
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

01008800 <_vector_table>:
 1008800:	c8 0f 00 21 21 9c 00 01 2d c3 00 01 f5 9b 00 01     ...!!...-.......
 1008810:	f5 9b 00 01 f5 9b 00 01 f5 9b 00 01 00 00 00 00     ................
	...
 100882c:	e9 98 00 01 f5 9b 00 01 00 00 00 00 91 98 00 01     ................
 100883c:	f5 9b 00 01                                         ....

01008840 <_irq_vector_table>:
 1008840:	69 99 00 01 69 99 00 01 69 99 00 01 69 99 00 01     i...i...i...i...
 1008850:	69 99 00 01 69 99 00 01 69 99 00 01 69 99 00 01     i...i...i...i...
 1008860:	69 99 00 01 69 99 00 01 69 99 00 01 69 99 00 01     i...i...i...i...
 1008870:	69 99 00 01 69 99 00 01 69 99 00 01 69 99 00 01     i...i...i...i...
 1008880:	69 99 00 01 69 99 00 01 69 99 00 01 69 99 00 01     i...i...i...i...
 1008890:	69 99 00 01 69 99 00 01 69 99 00 01 69 99 00 01     i...i...i...i...
 10088a0:	69 99 00 01 69 99 00 01 69 99 00 01 69 99 00 01     i...i...i...i...
 10088b0:	69 99 00 01 69 99 00 01                             i...i...

010088b8 <_vector_end>:
	...

01008a00 <m_firmware_info>:
 1008a00:	de e6 1e 28 4c bb ce 8f 02 35 00 00 3c 00 00 00     ...(L....5..<...
 1008a10:	12 45 00 00 01 00 00 00 00 88 00 01 00 88 00 01     .E..............
 1008a20:	ff ff 02 91 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

Disassembly of section text:

01008a3c <__aeabi_uldivmod>:
 1008a3c:	b953      	cbnz	r3, 1008a54 <__aeabi_uldivmod+0x18>
 1008a3e:	b94a      	cbnz	r2, 1008a54 <__aeabi_uldivmod+0x18>
 1008a40:	2900      	cmp	r1, #0
 1008a42:	bf08      	it	eq
 1008a44:	2800      	cmpeq	r0, #0
 1008a46:	bf1c      	itt	ne
 1008a48:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 1008a4c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 1008a50:	f000 b80c 	b.w	1008a6c <__aeabi_idiv0>
 1008a54:	f1ad 0c08 	sub.w	ip, sp, #8
 1008a58:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 1008a5c:	f000 f808 	bl	1008a70 <__udivmoddi4>
 1008a60:	f8dd e004 	ldr.w	lr, [sp, #4]
 1008a64:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 1008a68:	b004      	add	sp, #16
 1008a6a:	4770      	bx	lr

01008a6c <__aeabi_idiv0>:
 1008a6c:	4770      	bx	lr
 1008a6e:	bf00      	nop

01008a70 <__udivmoddi4>:
 1008a70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1008a74:	4686      	mov	lr, r0
 1008a76:	468c      	mov	ip, r1
 1008a78:	4608      	mov	r0, r1
 1008a7a:	9e08      	ldr	r6, [sp, #32]
 1008a7c:	4615      	mov	r5, r2
 1008a7e:	4674      	mov	r4, lr
 1008a80:	4619      	mov	r1, r3
 1008a82:	2b00      	cmp	r3, #0
 1008a84:	f040 80c1 	bne.w	1008c0a <__udivmoddi4+0x19a>
 1008a88:	4285      	cmp	r5, r0
 1008a8a:	fab2 f282 	clz	r2, r2
 1008a8e:	d945      	bls.n	1008b1c <__udivmoddi4+0xac>
 1008a90:	b14a      	cbz	r2, 1008aa6 <__udivmoddi4+0x36>
 1008a92:	f1c2 0320 	rsb	r3, r2, #32
 1008a96:	fa00 fc02 	lsl.w	ip, r0, r2
 1008a9a:	4095      	lsls	r5, r2
 1008a9c:	4094      	lsls	r4, r2
 1008a9e:	fa2e f303 	lsr.w	r3, lr, r3
 1008aa2:	ea43 0c0c 	orr.w	ip, r3, ip
 1008aa6:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 1008aaa:	b2a8      	uxth	r0, r5
 1008aac:	0c23      	lsrs	r3, r4, #16
 1008aae:	fbbc f8fe 	udiv	r8, ip, lr
 1008ab2:	fb0e cc18 	mls	ip, lr, r8, ip
 1008ab6:	fb08 f900 	mul.w	r9, r8, r0
 1008aba:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
 1008abe:	4599      	cmp	r9, r3
 1008ac0:	d928      	bls.n	1008b14 <__udivmoddi4+0xa4>
 1008ac2:	18eb      	adds	r3, r5, r3
 1008ac4:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
 1008ac8:	d204      	bcs.n	1008ad4 <__udivmoddi4+0x64>
 1008aca:	4599      	cmp	r9, r3
 1008acc:	d902      	bls.n	1008ad4 <__udivmoddi4+0x64>
 1008ace:	f1a8 0702 	sub.w	r7, r8, #2
 1008ad2:	442b      	add	r3, r5
 1008ad4:	eba3 0309 	sub.w	r3, r3, r9
 1008ad8:	b2a4      	uxth	r4, r4
 1008ada:	fbb3 fcfe 	udiv	ip, r3, lr
 1008ade:	fb0e 331c 	mls	r3, lr, ip, r3
 1008ae2:	fb0c f000 	mul.w	r0, ip, r0
 1008ae6:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 1008aea:	42a0      	cmp	r0, r4
 1008aec:	d914      	bls.n	1008b18 <__udivmoddi4+0xa8>
 1008aee:	192c      	adds	r4, r5, r4
 1008af0:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
 1008af4:	d204      	bcs.n	1008b00 <__udivmoddi4+0x90>
 1008af6:	42a0      	cmp	r0, r4
 1008af8:	d902      	bls.n	1008b00 <__udivmoddi4+0x90>
 1008afa:	f1ac 0302 	sub.w	r3, ip, #2
 1008afe:	442c      	add	r4, r5
 1008b00:	1a24      	subs	r4, r4, r0
 1008b02:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
 1008b06:	b11e      	cbz	r6, 1008b10 <__udivmoddi4+0xa0>
 1008b08:	40d4      	lsrs	r4, r2
 1008b0a:	2300      	movs	r3, #0
 1008b0c:	6034      	str	r4, [r6, #0]
 1008b0e:	6073      	str	r3, [r6, #4]
 1008b10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1008b14:	4647      	mov	r7, r8
 1008b16:	e7dd      	b.n	1008ad4 <__udivmoddi4+0x64>
 1008b18:	4663      	mov	r3, ip
 1008b1a:	e7f1      	b.n	1008b00 <__udivmoddi4+0x90>
 1008b1c:	bb92      	cbnz	r2, 1008b84 <__udivmoddi4+0x114>
 1008b1e:	1b43      	subs	r3, r0, r5
 1008b20:	2101      	movs	r1, #1
 1008b22:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 1008b26:	b2af      	uxth	r7, r5
 1008b28:	0c20      	lsrs	r0, r4, #16
 1008b2a:	fbb3 fcfe 	udiv	ip, r3, lr
 1008b2e:	fb0e 331c 	mls	r3, lr, ip, r3
 1008b32:	fb0c f807 	mul.w	r8, ip, r7
 1008b36:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 1008b3a:	4598      	cmp	r8, r3
 1008b3c:	d961      	bls.n	1008c02 <__udivmoddi4+0x192>
 1008b3e:	18eb      	adds	r3, r5, r3
 1008b40:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 1008b44:	d204      	bcs.n	1008b50 <__udivmoddi4+0xe0>
 1008b46:	4598      	cmp	r8, r3
 1008b48:	d902      	bls.n	1008b50 <__udivmoddi4+0xe0>
 1008b4a:	f1ac 0002 	sub.w	r0, ip, #2
 1008b4e:	442b      	add	r3, r5
 1008b50:	eba3 0308 	sub.w	r3, r3, r8
 1008b54:	b2a4      	uxth	r4, r4
 1008b56:	fbb3 fcfe 	udiv	ip, r3, lr
 1008b5a:	fb0e 331c 	mls	r3, lr, ip, r3
 1008b5e:	fb0c f707 	mul.w	r7, ip, r7
 1008b62:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 1008b66:	42a7      	cmp	r7, r4
 1008b68:	d94d      	bls.n	1008c06 <__udivmoddi4+0x196>
 1008b6a:	192c      	adds	r4, r5, r4
 1008b6c:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
 1008b70:	d204      	bcs.n	1008b7c <__udivmoddi4+0x10c>
 1008b72:	42a7      	cmp	r7, r4
 1008b74:	d902      	bls.n	1008b7c <__udivmoddi4+0x10c>
 1008b76:	f1ac 0302 	sub.w	r3, ip, #2
 1008b7a:	442c      	add	r4, r5
 1008b7c:	1be4      	subs	r4, r4, r7
 1008b7e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 1008b82:	e7c0      	b.n	1008b06 <__udivmoddi4+0x96>
 1008b84:	f1c2 0320 	rsb	r3, r2, #32
 1008b88:	4095      	lsls	r5, r2
 1008b8a:	4094      	lsls	r4, r2
 1008b8c:	fa20 f103 	lsr.w	r1, r0, r3
 1008b90:	fa2e f303 	lsr.w	r3, lr, r3
 1008b94:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 1008b98:	4090      	lsls	r0, r2
 1008b9a:	b2af      	uxth	r7, r5
 1008b9c:	4303      	orrs	r3, r0
 1008b9e:	fbb1 fcfe 	udiv	ip, r1, lr
 1008ba2:	fb0e 101c 	mls	r0, lr, ip, r1
 1008ba6:	0c19      	lsrs	r1, r3, #16
 1008ba8:	fb0c f807 	mul.w	r8, ip, r7
 1008bac:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 1008bb0:	4588      	cmp	r8, r1
 1008bb2:	d922      	bls.n	1008bfa <__udivmoddi4+0x18a>
 1008bb4:	1869      	adds	r1, r5, r1
 1008bb6:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 1008bba:	d204      	bcs.n	1008bc6 <__udivmoddi4+0x156>
 1008bbc:	4588      	cmp	r8, r1
 1008bbe:	d902      	bls.n	1008bc6 <__udivmoddi4+0x156>
 1008bc0:	f1ac 0002 	sub.w	r0, ip, #2
 1008bc4:	4429      	add	r1, r5
 1008bc6:	eba1 0108 	sub.w	r1, r1, r8
 1008bca:	b29b      	uxth	r3, r3
 1008bcc:	fbb1 fcfe 	udiv	ip, r1, lr
 1008bd0:	fb0e 111c 	mls	r1, lr, ip, r1
 1008bd4:	fb0c f707 	mul.w	r7, ip, r7
 1008bd8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 1008bdc:	429f      	cmp	r7, r3
 1008bde:	d90e      	bls.n	1008bfe <__udivmoddi4+0x18e>
 1008be0:	18eb      	adds	r3, r5, r3
 1008be2:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
 1008be6:	d204      	bcs.n	1008bf2 <__udivmoddi4+0x182>
 1008be8:	429f      	cmp	r7, r3
 1008bea:	d902      	bls.n	1008bf2 <__udivmoddi4+0x182>
 1008bec:	f1ac 0102 	sub.w	r1, ip, #2
 1008bf0:	442b      	add	r3, r5
 1008bf2:	1bdb      	subs	r3, r3, r7
 1008bf4:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 1008bf8:	e793      	b.n	1008b22 <__udivmoddi4+0xb2>
 1008bfa:	4660      	mov	r0, ip
 1008bfc:	e7e3      	b.n	1008bc6 <__udivmoddi4+0x156>
 1008bfe:	4661      	mov	r1, ip
 1008c00:	e7f7      	b.n	1008bf2 <__udivmoddi4+0x182>
 1008c02:	4660      	mov	r0, ip
 1008c04:	e7a4      	b.n	1008b50 <__udivmoddi4+0xe0>
 1008c06:	4663      	mov	r3, ip
 1008c08:	e7b8      	b.n	1008b7c <__udivmoddi4+0x10c>
 1008c0a:	4283      	cmp	r3, r0
 1008c0c:	d906      	bls.n	1008c1c <__udivmoddi4+0x1ac>
 1008c0e:	b916      	cbnz	r6, 1008c16 <__udivmoddi4+0x1a6>
 1008c10:	2100      	movs	r1, #0
 1008c12:	4608      	mov	r0, r1
 1008c14:	e77c      	b.n	1008b10 <__udivmoddi4+0xa0>
 1008c16:	e9c6 e000 	strd	lr, r0, [r6]
 1008c1a:	e7f9      	b.n	1008c10 <__udivmoddi4+0x1a0>
 1008c1c:	fab3 f783 	clz	r7, r3
 1008c20:	b98f      	cbnz	r7, 1008c46 <__udivmoddi4+0x1d6>
 1008c22:	4283      	cmp	r3, r0
 1008c24:	d301      	bcc.n	1008c2a <__udivmoddi4+0x1ba>
 1008c26:	4572      	cmp	r2, lr
 1008c28:	d808      	bhi.n	1008c3c <__udivmoddi4+0x1cc>
 1008c2a:	ebbe 0402 	subs.w	r4, lr, r2
 1008c2e:	eb60 0303 	sbc.w	r3, r0, r3
 1008c32:	2001      	movs	r0, #1
 1008c34:	469c      	mov	ip, r3
 1008c36:	b91e      	cbnz	r6, 1008c40 <__udivmoddi4+0x1d0>
 1008c38:	2100      	movs	r1, #0
 1008c3a:	e769      	b.n	1008b10 <__udivmoddi4+0xa0>
 1008c3c:	4638      	mov	r0, r7
 1008c3e:	e7fa      	b.n	1008c36 <__udivmoddi4+0x1c6>
 1008c40:	e9c6 4c00 	strd	r4, ip, [r6]
 1008c44:	e7f8      	b.n	1008c38 <__udivmoddi4+0x1c8>
 1008c46:	f1c7 0c20 	rsb	ip, r7, #32
 1008c4a:	40bb      	lsls	r3, r7
 1008c4c:	fa0e f507 	lsl.w	r5, lr, r7
 1008c50:	fa22 f40c 	lsr.w	r4, r2, ip
 1008c54:	fa2e f10c 	lsr.w	r1, lr, ip
 1008c58:	40ba      	lsls	r2, r7
 1008c5a:	431c      	orrs	r4, r3
 1008c5c:	fa20 f30c 	lsr.w	r3, r0, ip
 1008c60:	40b8      	lsls	r0, r7
 1008c62:	ea4f 4914 	mov.w	r9, r4, lsr #16
 1008c66:	4301      	orrs	r1, r0
 1008c68:	fa1f fe84 	uxth.w	lr, r4
 1008c6c:	fbb3 f8f9 	udiv	r8, r3, r9
 1008c70:	fb09 3018 	mls	r0, r9, r8, r3
 1008c74:	0c0b      	lsrs	r3, r1, #16
 1008c76:	fb08 fa0e 	mul.w	sl, r8, lr
 1008c7a:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 1008c7e:	459a      	cmp	sl, r3
 1008c80:	d940      	bls.n	1008d04 <__udivmoddi4+0x294>
 1008c82:	18e3      	adds	r3, r4, r3
 1008c84:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
 1008c88:	d204      	bcs.n	1008c94 <__udivmoddi4+0x224>
 1008c8a:	459a      	cmp	sl, r3
 1008c8c:	d902      	bls.n	1008c94 <__udivmoddi4+0x224>
 1008c8e:	f1a8 0002 	sub.w	r0, r8, #2
 1008c92:	4423      	add	r3, r4
 1008c94:	eba3 030a 	sub.w	r3, r3, sl
 1008c98:	b289      	uxth	r1, r1
 1008c9a:	fbb3 f8f9 	udiv	r8, r3, r9
 1008c9e:	fb09 3318 	mls	r3, r9, r8, r3
 1008ca2:	fb08 fe0e 	mul.w	lr, r8, lr
 1008ca6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 1008caa:	458e      	cmp	lr, r1
 1008cac:	d92c      	bls.n	1008d08 <__udivmoddi4+0x298>
 1008cae:	1861      	adds	r1, r4, r1
 1008cb0:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
 1008cb4:	d204      	bcs.n	1008cc0 <__udivmoddi4+0x250>
 1008cb6:	458e      	cmp	lr, r1
 1008cb8:	d902      	bls.n	1008cc0 <__udivmoddi4+0x250>
 1008cba:	f1a8 0302 	sub.w	r3, r8, #2
 1008cbe:	4421      	add	r1, r4
 1008cc0:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 1008cc4:	eba1 010e 	sub.w	r1, r1, lr
 1008cc8:	fba0 9802 	umull	r9, r8, r0, r2
 1008ccc:	4541      	cmp	r1, r8
 1008cce:	46ce      	mov	lr, r9
 1008cd0:	4643      	mov	r3, r8
 1008cd2:	d302      	bcc.n	1008cda <__udivmoddi4+0x26a>
 1008cd4:	d106      	bne.n	1008ce4 <__udivmoddi4+0x274>
 1008cd6:	454d      	cmp	r5, r9
 1008cd8:	d204      	bcs.n	1008ce4 <__udivmoddi4+0x274>
 1008cda:	3801      	subs	r0, #1
 1008cdc:	ebb9 0e02 	subs.w	lr, r9, r2
 1008ce0:	eb68 0304 	sbc.w	r3, r8, r4
 1008ce4:	2e00      	cmp	r6, #0
 1008ce6:	d0a7      	beq.n	1008c38 <__udivmoddi4+0x1c8>
 1008ce8:	ebb5 020e 	subs.w	r2, r5, lr
 1008cec:	eb61 0103 	sbc.w	r1, r1, r3
 1008cf0:	fa01 fc0c 	lsl.w	ip, r1, ip
 1008cf4:	fa22 f307 	lsr.w	r3, r2, r7
 1008cf8:	40f9      	lsrs	r1, r7
 1008cfa:	ea4c 0303 	orr.w	r3, ip, r3
 1008cfe:	e9c6 3100 	strd	r3, r1, [r6]
 1008d02:	e799      	b.n	1008c38 <__udivmoddi4+0x1c8>
 1008d04:	4640      	mov	r0, r8
 1008d06:	e7c5      	b.n	1008c94 <__udivmoddi4+0x224>
 1008d08:	4643      	mov	r3, r8
 1008d0a:	e7d9      	b.n	1008cc0 <__udivmoddi4+0x250>

01008d0c <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
 1008d0c:	4b01      	ldr	r3, [pc, #4]	; (1008d14 <char_out+0x8>)
 1008d0e:	681b      	ldr	r3, [r3, #0]
 1008d10:	4718      	bx	r3
 1008d12:	bf00      	nop
 1008d14:	21000000 	.word	0x21000000

01008d18 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
 1008d18:	b507      	push	{r0, r1, r2, lr}
 1008d1a:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
 1008d1c:	2100      	movs	r1, #0
 1008d1e:	4602      	mov	r2, r0
 1008d20:	9100      	str	r1, [sp, #0]
 1008d22:	4803      	ldr	r0, [pc, #12]	; (1008d30 <vprintk+0x18>)
 1008d24:	f000 f914 	bl	1008f50 <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
 1008d28:	b003      	add	sp, #12
 1008d2a:	f85d fb04 	ldr.w	pc, [sp], #4
 1008d2e:	bf00      	nop
 1008d30:	01008d0d 	.word	0x01008d0d

01008d34 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
 1008d34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1008d38:	8b05      	ldrh	r5, [r0, #24]
{
 1008d3a:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
 1008d3c:	0728      	lsls	r0, r5, #28
{
 1008d3e:	4690      	mov	r8, r2
	if (processing) {
 1008d40:	d411      	bmi.n	1008d66 <process_event+0x32>

	sys_slist_init(&clients);
	do {
		onoff_transition_fn transit = NULL;

		if (evt == EVT_RECHECK) {
 1008d42:	2902      	cmp	r1, #2
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1008d44:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
 1008d48:	f040 80cd 	bne.w	1008ee6 <process_event+0x1b2>
			evt = process_recheck(mgr);
 1008d4c:	4620      	mov	r0, r4
 1008d4e:	f003 f9ac 	bl	100c0aa <process_recheck>
		}

		if (evt == EVT_NOP) {
 1008d52:	b178      	cbz	r0, 1008d74 <process_event+0x40>
			break;
		}

		res = 0;
		if (evt == EVT_COMPLETE) {
 1008d54:	3801      	subs	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008d56:	8b21      	ldrh	r1, [r4, #24]
 1008d58:	2804      	cmp	r0, #4
 1008d5a:	d811      	bhi.n	1008d80 <process_event+0x4c>
 1008d5c:	e8df f000 	tbb	[pc, r0]
 1008d60:	856d10c3 	.word	0x856d10c3
 1008d64:	95          	.byte	0x95
 1008d65:	00          	.byte	0x00
		if (evt == EVT_COMPLETE) {
 1008d66:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
 1008d68:	bf0c      	ite	eq
 1008d6a:	f045 0510 	orreq.w	r5, r5, #16
			mgr->flags |= ONOFF_FLAG_RECHECK;
 1008d6e:	f045 0520 	orrne.w	r5, r5, #32
 1008d72:	8325      	strh	r5, [r4, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
 1008d74:	f388 8811 	msr	BASEPRI, r8
 1008d78:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
 1008d7c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1008d80:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
 1008d84:	45aa      	cmp	sl, r5
 1008d86:	f000 80a6 	beq.w	1008ed6 <process_event+0x1a2>
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
 1008d8a:	2700      	movs	r7, #0
 1008d8c:	46b9      	mov	r9, r7
 1008d8e:	463e      	mov	r6, r7
 1008d90:	68a3      	ldr	r3, [r4, #8]
 1008d92:	2b00      	cmp	r3, #0
 1008d94:	f000 80bd 	beq.w	1008f12 <process_event+0x1de>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
 1008d98:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
 1008d9c:	8321      	strh	r1, [r4, #24]
 1008d9e:	f388 8811 	msr	BASEPRI, r8
 1008da2:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
 1008da6:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
 1008da8:	2900      	cmp	r1, #0
 1008daa:	f000 80bb 	beq.w	1008f24 <process_event+0x1f0>
	return node->next;
 1008dae:	680d      	ldr	r5, [r1, #0]
 1008db0:	2900      	cmp	r1, #0
 1008db2:	f000 80b7 	beq.w	1008f24 <process_event+0x1f0>
		mon->callback(mgr, mon, state, res);
 1008db6:	4633      	mov	r3, r6
 1008db8:	4652      	mov	r2, sl
 1008dba:	4620      	mov	r0, r4
 1008dbc:	f8d1 8004 	ldr.w	r8, [r1, #4]
 1008dc0:	47c0      	blx	r8
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
 1008dc2:	2d00      	cmp	r5, #0
 1008dc4:	d076      	beq.n	1008eb4 <process_event+0x180>
 1008dc6:	682b      	ldr	r3, [r5, #0]
 1008dc8:	4629      	mov	r1, r5
 1008dca:	461d      	mov	r5, r3
 1008dcc:	e7f0      	b.n	1008db0 <process_event+0x7c>
 1008dce:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
 1008dd2:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
 1008dd4:	2a01      	cmp	r2, #1
 1008dd6:	d81b      	bhi.n	1008e10 <process_event+0xdc>
	list->head = NULL;
 1008dd8:	2200      	movs	r2, #0
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008dda:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
 1008dde:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
 1008de0:	6827      	ldr	r7, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008de2:	b289      	uxth	r1, r1
	list->tail = NULL;
 1008de4:	e9c4 2200 	strd	r2, r2, [r4]
		if (state == ONOFF_STATE_TO_ON) {
 1008de8:	d109      	bne.n	1008dfe <process_event+0xca>
 1008dea:	463b      	mov	r3, r7
 1008dec:	e003      	b.n	1008df6 <process_event+0xc2>
				mgr->refs += 1U;
 1008dee:	8b62      	ldrh	r2, [r4, #26]
 1008df0:	3201      	adds	r2, #1
 1008df2:	8362      	strh	r2, [r4, #26]
	return node->next;
 1008df4:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
 1008df6:	2b00      	cmp	r3, #0
 1008df8:	d1f9      	bne.n	1008dee <process_event+0xba>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008dfa:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
 1008dfe:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
 1008e00:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
 1008e02:	f003 f952 	bl	100c0aa <process_recheck>
 1008e06:	2800      	cmp	r0, #0
 1008e08:	d07b      	beq.n	1008f02 <process_event+0x1ce>
			mgr->flags |= ONOFF_FLAG_RECHECK;
 1008e0a:	f041 0120 	orr.w	r1, r1, #32
 1008e0e:	e077      	b.n	1008f00 <process_event+0x1cc>
	} else if (state == ONOFF_STATE_TO_OFF) {
 1008e10:	2b04      	cmp	r3, #4
 1008e12:	d10a      	bne.n	1008e2a <process_event+0xf6>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008e14:	f021 0107 	bic.w	r1, r1, #7
 1008e18:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
 1008e1a:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
 1008e1c:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
 1008e1e:	f003 f944 	bl	100c0aa <process_recheck>
 1008e22:	b110      	cbz	r0, 1008e2a <process_event+0xf6>
			mgr->flags |= ONOFF_FLAG_RECHECK;
 1008e24:	f041 0120 	orr.w	r1, r1, #32
 1008e28:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1008e2a:	8b21      	ldrh	r1, [r4, #24]
 1008e2c:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
 1008e30:	45aa      	cmp	sl, r5
 1008e32:	d050      	beq.n	1008ed6 <process_event+0x1a2>
 1008e34:	2700      	movs	r7, #0
		onoff_transition_fn transit = NULL;
 1008e36:	46b9      	mov	r9, r7
 1008e38:	e7aa      	b.n	1008d90 <process_event+0x5c>
			transit = mgr->transitions->start;
 1008e3a:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008e3c:	f021 0107 	bic.w	r1, r1, #7
 1008e40:	f041 0106 	orr.w	r1, r1, #6
				   && !sys_slist_is_empty(&mgr->monitors);
 1008e44:	2d06      	cmp	r5, #6
			transit = mgr->transitions->start;
 1008e46:	f8d3 9000 	ldr.w	r9, [r3]
	mgr->flags = (state & ONOFF_STATE_MASK)
 1008e4a:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
 1008e4c:	d12d      	bne.n	1008eaa <process_event+0x176>
		    || (transit != NULL)) {
 1008e4e:	f1b9 0f00 	cmp.w	r9, #0
 1008e52:	d040      	beq.n	1008ed6 <process_event+0x1a2>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
 1008e54:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
 1008e58:	8321      	strh	r1, [r4, #24]
 1008e5a:	f388 8811 	msr	BASEPRI, r8
 1008e5e:	f3bf 8f6f 	isb	sy
				transit(mgr, transition_complete);
 1008e62:	4620      	mov	r0, r4
 1008e64:	4939      	ldr	r1, [pc, #228]	; (1008f4c <process_event+0x218>)
 1008e66:	47c8      	blx	r9
 1008e68:	e029      	b.n	1008ebe <process_event+0x18a>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008e6a:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->stop;
 1008e6e:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008e70:	f041 0104 	orr.w	r1, r1, #4
 1008e74:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
 1008e76:	2d04      	cmp	r5, #4
			transit = mgr->transitions->stop;
 1008e78:	f8d3 9004 	ldr.w	r9, [r3, #4]
	mgr->flags = (state & ONOFF_STATE_MASK)
 1008e7c:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
 1008e7e:	d0e6      	beq.n	1008e4e <process_event+0x11a>
 1008e80:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1008e82:	f04f 0a04 	mov.w	sl, #4
		res = 0;
 1008e86:	463e      	mov	r6, r7
 1008e88:	e782      	b.n	1008d90 <process_event+0x5c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008e8a:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->reset;
 1008e8e:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008e90:	f041 0105 	orr.w	r1, r1, #5
 1008e94:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
 1008e96:	2d05      	cmp	r5, #5
			transit = mgr->transitions->reset;
 1008e98:	f8d3 9008 	ldr.w	r9, [r3, #8]
	mgr->flags = (state & ONOFF_STATE_MASK)
 1008e9c:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
 1008e9e:	d0d6      	beq.n	1008e4e <process_event+0x11a>
 1008ea0:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1008ea2:	f04f 0a05 	mov.w	sl, #5
		res = 0;
 1008ea6:	463e      	mov	r6, r7
 1008ea8:	e772      	b.n	1008d90 <process_event+0x5c>
				   && !sys_slist_is_empty(&mgr->monitors);
 1008eaa:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1008eac:	f04f 0a06 	mov.w	sl, #6
		res = 0;
 1008eb0:	463e      	mov	r6, r7
 1008eb2:	e76d      	b.n	1008d90 <process_event+0x5c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
 1008eb4:	462b      	mov	r3, r5
 1008eb6:	e787      	b.n	1008dc8 <process_event+0x94>
			if (transit != NULL) {
 1008eb8:	f1b9 0f00 	cmp.w	r9, #0
 1008ebc:	d1d1      	bne.n	1008e62 <process_event+0x12e>
	__asm__ volatile(
 1008ebe:	f04f 0320 	mov.w	r3, #32
 1008ec2:	f3ef 8811 	mrs	r8, BASEPRI
 1008ec6:	f383 8812 	msr	BASEPRI_MAX, r3
 1008eca:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
 1008ece:	8b23      	ldrh	r3, [r4, #24]
 1008ed0:	f023 0308 	bic.w	r3, r3, #8
 1008ed4:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
 1008ed6:	8b25      	ldrh	r5, [r4, #24]
 1008ed8:	06ea      	lsls	r2, r5, #27
 1008eda:	d52e      	bpl.n	1008f3a <process_event+0x206>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
 1008edc:	f025 0310 	bic.w	r3, r5, #16
 1008ee0:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
 1008ee2:	f005 0507 	and.w	r5, r5, #7
			res = mgr->last_res;
 1008ee6:	6966      	ldr	r6, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 1008ee8:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
 1008eea:	2e00      	cmp	r6, #0
 1008eec:	f6bf af6f 	bge.w	1008dce <process_event+0x9a>
	list->head = NULL;
 1008ef0:	2300      	movs	r3, #0
		*clients = mgr->clients;
 1008ef2:	6827      	ldr	r7, [r4, #0]
	list->tail = NULL;
 1008ef4:	e9c4 3300 	strd	r3, r3, [r4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
 1008ef8:	f021 0107 	bic.w	r1, r1, #7
 1008efc:	f041 0101 	orr.w	r1, r1, #1
			mgr->flags |= ONOFF_FLAG_RECHECK;
 1008f00:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
 1008f02:	8b21      	ldrh	r1, [r4, #24]
 1008f04:	f04f 0900 	mov.w	r9, #0
 1008f08:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
 1008f0c:	45aa      	cmp	sl, r5
 1008f0e:	f47f af3f 	bne.w	1008d90 <process_event+0x5c>
		    || !sys_slist_is_empty(&clients)
 1008f12:	2f00      	cmp	r7, #0
 1008f14:	d09b      	beq.n	1008e4e <process_event+0x11a>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
 1008f16:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
 1008f1a:	8321      	strh	r1, [r4, #24]
	__asm__ volatile(
 1008f1c:	f388 8811 	msr	BASEPRI, r8
 1008f20:	f3bf 8f6f 	isb	sy
			if (!sys_slist_is_empty(&clients)) {
 1008f24:	2f00      	cmp	r7, #0
 1008f26:	d0c7      	beq.n	1008eb8 <process_event+0x184>
	return node->next;
 1008f28:	683d      	ldr	r5, [r7, #0]
		notify_one(mgr, cli, state, res);
 1008f2a:	4639      	mov	r1, r7
 1008f2c:	4633      	mov	r3, r6
 1008f2e:	4652      	mov	r2, sl
 1008f30:	4620      	mov	r0, r4
 1008f32:	f003 f8e6 	bl	100c102 <notify_one>
	list->head = node;
 1008f36:	462f      	mov	r7, r5
	while (!sys_slist_is_empty(list)) {
 1008f38:	e7f4      	b.n	1008f24 <process_event+0x1f0>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
 1008f3a:	06ab      	lsls	r3, r5, #26
 1008f3c:	f57f af1a 	bpl.w	1008d74 <process_event+0x40>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
 1008f40:	f025 0320 	bic.w	r3, r5, #32
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
 1008f44:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
 1008f46:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
 1008f4a:	e6ff      	b.n	1008d4c <process_event+0x18>
 1008f4c:	0100c12f 	.word	0x0100c12f

01008f50 <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
 1008f50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1008f54:	4681      	mov	r9, r0
 1008f56:	468b      	mov	fp, r1
 1008f58:	4617      	mov	r7, r2
 1008f5a:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
 1008f5c:	2500      	movs	r5, #0
{
 1008f5e:	b095      	sub	sp, #84	; 0x54
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
 1008f60:	7838      	ldrb	r0, [r7, #0]
 1008f62:	b908      	cbnz	r0, 1008f68 <z_cbvprintf_impl+0x18>
			OUTC(' ');
			--width;
		}
	}

	return count;
 1008f64:	4628      	mov	r0, r5
 1008f66:	e357      	b.n	1009618 <z_cbvprintf_impl+0x6c8>
			OUTC(*fp++);
 1008f68:	1c7b      	adds	r3, r7, #1
		if (*fp != '%') {
 1008f6a:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
 1008f6c:	9303      	str	r3, [sp, #12]
		if (*fp != '%') {
 1008f6e:	d006      	beq.n	1008f7e <z_cbvprintf_impl+0x2e>
			OUTC('%');
 1008f70:	4659      	mov	r1, fp
 1008f72:	47c8      	blx	r9
 1008f74:	2800      	cmp	r0, #0
 1008f76:	f2c0 834f 	blt.w	1009618 <z_cbvprintf_impl+0x6c8>
 1008f7a:	3501      	adds	r5, #1
		if (bps == NULL) {
 1008f7c:	e1fb      	b.n	1009376 <z_cbvprintf_impl+0x426>
		} state = {
 1008f7e:	2218      	movs	r2, #24
 1008f80:	2100      	movs	r1, #0
 1008f82:	a80e      	add	r0, sp, #56	; 0x38
 1008f84:	f003 fa2e 	bl	100c3e4 <memset>
	if (*sp == '%') {
 1008f88:	787b      	ldrb	r3, [r7, #1]
 1008f8a:	2b25      	cmp	r3, #37	; 0x25
 1008f8c:	d07d      	beq.n	100908a <z_cbvprintf_impl+0x13a>
 1008f8e:	2300      	movs	r3, #0
 1008f90:	4698      	mov	r8, r3
 1008f92:	469e      	mov	lr, r3
 1008f94:	469c      	mov	ip, r3
 1008f96:	461e      	mov	r6, r3
 1008f98:	1c78      	adds	r0, r7, #1
 1008f9a:	4601      	mov	r1, r0
		switch (*sp) {
 1008f9c:	f810 2b01 	ldrb.w	r2, [r0], #1
 1008fa0:	2a2b      	cmp	r2, #43	; 0x2b
 1008fa2:	f000 80a1 	beq.w	10090e8 <z_cbvprintf_impl+0x198>
 1008fa6:	f200 8098 	bhi.w	10090da <z_cbvprintf_impl+0x18a>
 1008faa:	2a20      	cmp	r2, #32
 1008fac:	f000 809f 	beq.w	10090ee <z_cbvprintf_impl+0x19e>
 1008fb0:	2a23      	cmp	r2, #35	; 0x23
 1008fb2:	f000 809f 	beq.w	10090f4 <z_cbvprintf_impl+0x1a4>
 1008fb6:	b12b      	cbz	r3, 1008fc4 <z_cbvprintf_impl+0x74>
 1008fb8:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 1008fbc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 1008fc0:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 1008fc4:	f1b8 0f00 	cmp.w	r8, #0
 1008fc8:	d005      	beq.n	1008fd6 <z_cbvprintf_impl+0x86>
 1008fca:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 1008fce:	f043 0320 	orr.w	r3, r3, #32
 1008fd2:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 1008fd6:	f1be 0f00 	cmp.w	lr, #0
 1008fda:	d005      	beq.n	1008fe8 <z_cbvprintf_impl+0x98>
 1008fdc:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 1008fe0:	f043 0310 	orr.w	r3, r3, #16
 1008fe4:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 1008fe8:	f1bc 0f00 	cmp.w	ip, #0
 1008fec:	d005      	beq.n	1008ffa <z_cbvprintf_impl+0xaa>
 1008fee:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 1008ff2:	f043 0308 	orr.w	r3, r3, #8
 1008ff6:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
 1008ffa:	b12e      	cbz	r6, 1009008 <z_cbvprintf_impl+0xb8>
 1008ffc:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 1009000:	f043 0304 	orr.w	r3, r3, #4
 1009004:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (conv->flag_zero && conv->flag_dash) {
 1009008:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 100900c:	f003 0044 	and.w	r0, r3, #68	; 0x44
 1009010:	2844      	cmp	r0, #68	; 0x44
 1009012:	d103      	bne.n	100901c <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
 1009014:	f36f 1386 	bfc	r3, #6, #1
 1009018:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	conv->width_present = true;
 100901c:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
 1009020:	2a2a      	cmp	r2, #42	; 0x2a
	conv->width_present = true;
 1009022:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 1009026:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
 100902a:	d17f      	bne.n	100912c <z_cbvprintf_impl+0x1dc>
		conv->width_star = true;
 100902c:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
 1009030:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
 1009032:	f042 0201 	orr.w	r2, r2, #1
 1009036:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	conv->prec_present = (*sp == '.');
 100903a:	781a      	ldrb	r2, [r3, #0]
 100903c:	2a2e      	cmp	r2, #46	; 0x2e
 100903e:	bf0c      	ite	eq
 1009040:	2101      	moveq	r1, #1
 1009042:	2100      	movne	r1, #0
 1009044:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 1009048:	f361 0241 	bfi	r2, r1, #1, #1
 100904c:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	if (!conv->prec_present) {
 1009050:	d178      	bne.n	1009144 <z_cbvprintf_impl+0x1f4>
	if (*sp == '*') {
 1009052:	785a      	ldrb	r2, [r3, #1]
 1009054:	2a2a      	cmp	r2, #42	; 0x2a
 1009056:	d06e      	beq.n	1009136 <z_cbvprintf_impl+0x1e6>
	size_t val = 0;
 1009058:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
 100905a:	f04f 0c0a 	mov.w	ip, #10
	++sp;
 100905e:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
 1009060:	4619      	mov	r1, r3
 1009062:	f811 0b01 	ldrb.w	r0, [r1], #1
 1009066:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
 100906a:	2e09      	cmp	r6, #9
 100906c:	f240 8095 	bls.w	100919a <z_cbvprintf_impl+0x24a>
	conv->unsupported |= ((conv->prec_value < 0)
 1009070:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	conv->prec_value = prec;
 1009074:	9212      	str	r2, [sp, #72]	; 0x48
	conv->unsupported |= ((conv->prec_value < 0)
 1009076:	f3c1 0040 	ubfx	r0, r1, #1, #1
 100907a:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
 100907e:	460a      	mov	r2, r1
 1009080:	f360 0241 	bfi	r2, r0, #1, #1
 1009084:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
 1009088:	e05c      	b.n	1009144 <z_cbvprintf_impl+0x1f4>
		conv->specifier = *sp++;
 100908a:	1cba      	adds	r2, r7, #2
 100908c:	9203      	str	r2, [sp, #12]
 100908e:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->width_star) {
 1009092:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
 1009096:	07da      	lsls	r2, r3, #31
 1009098:	f140 812e 	bpl.w	10092f8 <z_cbvprintf_impl+0x3a8>
			width = va_arg(ap, int);
 100909c:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
 10090a0:	f1b8 0f00 	cmp.w	r8, #0
 10090a4:	da07      	bge.n	10090b6 <z_cbvprintf_impl+0x166>
				conv->flag_dash = true;
 10090a6:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				width = -width;
 10090aa:	f1c8 0800 	rsb	r8, r8, #0
				conv->flag_dash = true;
 10090ae:	f042 0204 	orr.w	r2, r2, #4
 10090b2:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
		if (conv->prec_star) {
 10090b6:	075e      	lsls	r6, r3, #29
 10090b8:	f140 8127 	bpl.w	100930a <z_cbvprintf_impl+0x3ba>
			int arg = va_arg(ap, int);
 10090bc:	f854 ab04 	ldr.w	sl, [r4], #4
			if (arg < 0) {
 10090c0:	f1ba 0f00 	cmp.w	sl, #0
 10090c4:	f280 8126 	bge.w	1009314 <z_cbvprintf_impl+0x3c4>
				conv->prec_present = false;
 10090c8:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
 10090cc:	f36f 0341 	bfc	r3, #1, #1
 10090d0:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
		int precision = -1;
 10090d4:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
 10090d8:	e11c      	b.n	1009314 <z_cbvprintf_impl+0x3c4>
		switch (*sp) {
 10090da:	2a2d      	cmp	r2, #45	; 0x2d
 10090dc:	d00d      	beq.n	10090fa <z_cbvprintf_impl+0x1aa>
 10090de:	2a30      	cmp	r2, #48	; 0x30
 10090e0:	f47f af69 	bne.w	1008fb6 <z_cbvprintf_impl+0x66>
 10090e4:	2301      	movs	r3, #1
	} while (loop);
 10090e6:	e758      	b.n	1008f9a <z_cbvprintf_impl+0x4a>
		switch (*sp) {
 10090e8:	f04f 0c01 	mov.w	ip, #1
 10090ec:	e755      	b.n	1008f9a <z_cbvprintf_impl+0x4a>
 10090ee:	f04f 0e01 	mov.w	lr, #1
 10090f2:	e752      	b.n	1008f9a <z_cbvprintf_impl+0x4a>
 10090f4:	f04f 0801 	mov.w	r8, #1
 10090f8:	e74f      	b.n	1008f9a <z_cbvprintf_impl+0x4a>
 10090fa:	2601      	movs	r6, #1
 10090fc:	e74d      	b.n	1008f9a <z_cbvprintf_impl+0x4a>
		val = 10U * val + *sp++ - '0';
 10090fe:	4603      	mov	r3, r0
 1009100:	fb0e 6202 	mla	r2, lr, r2, r6
 1009104:	3a30      	subs	r2, #48	; 0x30
 1009106:	4618      	mov	r0, r3
 1009108:	f810 6b01 	ldrb.w	r6, [r0], #1
 100910c:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
 1009110:	f1bc 0f09 	cmp.w	ip, #9
 1009114:	d9f3      	bls.n	10090fe <z_cbvprintf_impl+0x1ae>
	if (sp != wp) {
 1009116:	4299      	cmp	r1, r3
 1009118:	d08f      	beq.n	100903a <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
 100911a:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
		conv->width_value = width;
 100911e:	9211      	str	r2, [sp, #68]	; 0x44
				      || (width != (size_t)conv->width_value));
 1009120:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
 1009122:	f362 0141 	bfi	r1, r2, #1, #1
 1009126:	f88d 1040 	strb.w	r1, [sp, #64]	; 0x40
 100912a:	e786      	b.n	100903a <z_cbvprintf_impl+0xea>
 100912c:	460b      	mov	r3, r1
	size_t val = 0;
 100912e:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
 1009130:	f04f 0e0a 	mov.w	lr, #10
 1009134:	e7e7      	b.n	1009106 <z_cbvprintf_impl+0x1b6>
		conv->prec_star = true;
 1009136:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
 100913a:	3302      	adds	r3, #2
		conv->prec_star = true;
 100913c:	f042 0204 	orr.w	r2, r2, #4
 1009140:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	switch (*sp) {
 1009144:	781a      	ldrb	r2, [r3, #0]
 1009146:	2a6c      	cmp	r2, #108	; 0x6c
 1009148:	d047      	beq.n	10091da <z_cbvprintf_impl+0x28a>
 100914a:	d82b      	bhi.n	10091a4 <z_cbvprintf_impl+0x254>
 100914c:	2a68      	cmp	r2, #104	; 0x68
 100914e:	d031      	beq.n	10091b4 <z_cbvprintf_impl+0x264>
 1009150:	2a6a      	cmp	r2, #106	; 0x6a
 1009152:	d04b      	beq.n	10091ec <z_cbvprintf_impl+0x29c>
 1009154:	2a4c      	cmp	r2, #76	; 0x4c
 1009156:	d051      	beq.n	10091fc <z_cbvprintf_impl+0x2ac>
	conv->specifier = *sp++;
 1009158:	461a      	mov	r2, r3
 100915a:	f812 3b01 	ldrb.w	r3, [r2], #1
	switch (conv->specifier) {
 100915e:	2b78      	cmp	r3, #120	; 0x78
	conv->specifier = *sp++;
 1009160:	9203      	str	r2, [sp, #12]
 1009162:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->length_mod == LENGTH_UPPER_L) {
 1009166:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
	switch (conv->specifier) {
 100916a:	f200 80be 	bhi.w	10092ea <z_cbvprintf_impl+0x39a>
 100916e:	2b6d      	cmp	r3, #109	; 0x6d
 1009170:	d851      	bhi.n	1009216 <z_cbvprintf_impl+0x2c6>
 1009172:	2b69      	cmp	r3, #105	; 0x69
 1009174:	f200 80b9 	bhi.w	10092ea <z_cbvprintf_impl+0x39a>
 1009178:	2b57      	cmp	r3, #87	; 0x57
 100917a:	d867      	bhi.n	100924c <z_cbvprintf_impl+0x2fc>
 100917c:	2b41      	cmp	r3, #65	; 0x41
 100917e:	d003      	beq.n	1009188 <z_cbvprintf_impl+0x238>
 1009180:	3b45      	subs	r3, #69	; 0x45
 1009182:	2b02      	cmp	r3, #2
 1009184:	f200 80b1 	bhi.w	10092ea <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_FP;
 1009188:	2204      	movs	r2, #4
 100918a:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 100918e:	f362 0302 	bfi	r3, r2, #0, #3
 1009192:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
			unsupported = true;
 1009196:	2301      	movs	r3, #1
			break;
 1009198:	e073      	b.n	1009282 <z_cbvprintf_impl+0x332>
		val = 10U * val + *sp++ - '0';
 100919a:	fb0c 0202 	mla	r2, ip, r2, r0
 100919e:	460b      	mov	r3, r1
 10091a0:	3a30      	subs	r2, #48	; 0x30
 10091a2:	e75d      	b.n	1009060 <z_cbvprintf_impl+0x110>
	switch (*sp) {
 10091a4:	2a74      	cmp	r2, #116	; 0x74
 10091a6:	d025      	beq.n	10091f4 <z_cbvprintf_impl+0x2a4>
 10091a8:	2a7a      	cmp	r2, #122	; 0x7a
 10091aa:	d1d5      	bne.n	1009158 <z_cbvprintf_impl+0x208>
		conv->length_mod = LENGTH_Z;
 10091ac:	2106      	movs	r1, #6
 10091ae:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 10091b2:	e00c      	b.n	10091ce <z_cbvprintf_impl+0x27e>
		if (*++sp == 'h') {
 10091b4:	785a      	ldrb	r2, [r3, #1]
 10091b6:	2a68      	cmp	r2, #104	; 0x68
 10091b8:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 10091bc:	d106      	bne.n	10091cc <z_cbvprintf_impl+0x27c>
			conv->length_mod = LENGTH_HH;
 10091be:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
 10091c0:	f361 02c6 	bfi	r2, r1, #3, #4
 10091c4:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
			++sp;
 10091c8:	3302      	adds	r3, #2
 10091ca:	e7c5      	b.n	1009158 <z_cbvprintf_impl+0x208>
			conv->length_mod = LENGTH_H;
 10091cc:	2102      	movs	r1, #2
 10091ce:	f361 02c6 	bfi	r2, r1, #3, #4
 10091d2:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		if (*++sp == 'h') {
 10091d6:	3301      	adds	r3, #1
 10091d8:	e7be      	b.n	1009158 <z_cbvprintf_impl+0x208>
		if (*++sp == 'l') {
 10091da:	785a      	ldrb	r2, [r3, #1]
 10091dc:	2a6c      	cmp	r2, #108	; 0x6c
 10091de:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 10091e2:	d101      	bne.n	10091e8 <z_cbvprintf_impl+0x298>
			conv->length_mod = LENGTH_LL;
 10091e4:	2104      	movs	r1, #4
 10091e6:	e7eb      	b.n	10091c0 <z_cbvprintf_impl+0x270>
			conv->length_mod = LENGTH_L;
 10091e8:	2103      	movs	r1, #3
 10091ea:	e7f0      	b.n	10091ce <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_J;
 10091ec:	2105      	movs	r1, #5
 10091ee:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 10091f2:	e7ec      	b.n	10091ce <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_T;
 10091f4:	2107      	movs	r1, #7
 10091f6:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 10091fa:	e7e8      	b.n	10091ce <z_cbvprintf_impl+0x27e>
		conv->unsupported = true;
 10091fc:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 1009200:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
 1009204:	f022 0202 	bic.w	r2, r2, #2
 1009208:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 100920c:	f042 0202 	orr.w	r2, r2, #2
 1009210:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
		break;
 1009214:	e7df      	b.n	10091d6 <z_cbvprintf_impl+0x286>
	switch (conv->specifier) {
 1009216:	3b6e      	subs	r3, #110	; 0x6e
 1009218:	b2d9      	uxtb	r1, r3
 100921a:	2301      	movs	r3, #1
 100921c:	408b      	lsls	r3, r1
 100921e:	f240 4182 	movw	r1, #1154	; 0x482
 1009222:	420b      	tst	r3, r1
 1009224:	d137      	bne.n	1009296 <z_cbvprintf_impl+0x346>
 1009226:	f013 0f24 	tst.w	r3, #36	; 0x24
 100922a:	d151      	bne.n	10092d0 <z_cbvprintf_impl+0x380>
 100922c:	07d8      	lsls	r0, r3, #31
 100922e:	d55c      	bpl.n	10092ea <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_PTR;
 1009230:	2103      	movs	r1, #3
 1009232:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 1009236:	f361 0302 	bfi	r3, r1, #0, #3
 100923a:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
 100923e:	f002 0378 	and.w	r3, r2, #120	; 0x78
 1009242:	f1a3 0140 	sub.w	r1, r3, #64	; 0x40
 1009246:	424b      	negs	r3, r1
 1009248:	414b      	adcs	r3, r1
 100924a:	e01a      	b.n	1009282 <z_cbvprintf_impl+0x332>
 100924c:	2001      	movs	r0, #1
	switch (conv->specifier) {
 100924e:	f1a3 0158 	sub.w	r1, r3, #88	; 0x58
 1009252:	b2c9      	uxtb	r1, r1
 1009254:	fa00 f101 	lsl.w	r1, r0, r1
 1009258:	f411 4f62 	tst.w	r1, #57856	; 0xe200
 100925c:	d194      	bne.n	1009188 <z_cbvprintf_impl+0x238>
 100925e:	f640 0601 	movw	r6, #2049	; 0x801
 1009262:	4231      	tst	r1, r6
 1009264:	d11d      	bne.n	10092a2 <z_cbvprintf_impl+0x352>
 1009266:	f411 3f04 	tst.w	r1, #135168	; 0x21000
 100926a:	d03e      	beq.n	10092ea <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_SINT;
 100926c:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 1009270:	f360 0302 	bfi	r3, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
 1009274:	f002 0278 	and.w	r2, r2, #120	; 0x78
 1009278:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_SINT;
 100927a:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
 100927e:	d034      	beq.n	10092ea <z_cbvprintf_impl+0x39a>
	bool unsupported = false;
 1009280:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
 1009282:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
 1009286:	f3c2 0140 	ubfx	r1, r2, #1, #1
 100928a:	430b      	orrs	r3, r1
 100928c:	f363 0241 	bfi	r2, r3, #1, #1
 1009290:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
 1009294:	e6fd      	b.n	1009092 <z_cbvprintf_impl+0x142>
		conv->specifier_cat = SPECIFIER_UINT;
 1009296:	2102      	movs	r1, #2
 1009298:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 100929c:	f361 0302 	bfi	r3, r1, #0, #3
 10092a0:	e7e8      	b.n	1009274 <z_cbvprintf_impl+0x324>
 10092a2:	2002      	movs	r0, #2
 10092a4:	f89d 1042 	ldrb.w	r1, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
 10092a8:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
 10092ac:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
 10092b0:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
 10092b2:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
			conv->invalid = true;
 10092b6:	bf02      	ittt	eq
 10092b8:	f89d 1040 	ldrbeq.w	r1, [sp, #64]	; 0x40
 10092bc:	f041 0101 	orreq.w	r1, r1, #1
 10092c0:	f88d 1040 	strbeq.w	r1, [sp, #64]	; 0x40
		if (conv->specifier == 'c') {
 10092c4:	2b63      	cmp	r3, #99	; 0x63
 10092c6:	d1db      	bne.n	1009280 <z_cbvprintf_impl+0x330>
			unsupported = (conv->length_mod != LENGTH_NONE);
 10092c8:	1e13      	subs	r3, r2, #0
 10092ca:	bf18      	it	ne
 10092cc:	2301      	movne	r3, #1
 10092ce:	e7d8      	b.n	1009282 <z_cbvprintf_impl+0x332>
		conv->specifier_cat = SPECIFIER_PTR;
 10092d0:	2103      	movs	r1, #3
 10092d2:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
 10092d6:	f012 0f78 	tst.w	r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
 10092da:	f361 0302 	bfi	r3, r1, #0, #3
 10092de:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
 10092e2:	bf14      	ite	ne
 10092e4:	2301      	movne	r3, #1
 10092e6:	2300      	moveq	r3, #0
 10092e8:	e7cb      	b.n	1009282 <z_cbvprintf_impl+0x332>
		conv->invalid = true;
 10092ea:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 10092ee:	f043 0301 	orr.w	r3, r3, #1
 10092f2:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
		break;
 10092f6:	e7c3      	b.n	1009280 <z_cbvprintf_impl+0x330>
		} else if (conv->width_present) {
 10092f8:	f99d 2040 	ldrsb.w	r2, [sp, #64]	; 0x40
 10092fc:	2a00      	cmp	r2, #0
		int width = -1;
 10092fe:	bfac      	ite	ge
 1009300:	f04f 38ff 	movge.w	r8, #4294967295	; 0xffffffff
			width = conv->width_value;
 1009304:	f8dd 8044 	ldrlt.w	r8, [sp, #68]	; 0x44
 1009308:	e6d5      	b.n	10090b6 <z_cbvprintf_impl+0x166>
		} else if (conv->prec_present) {
 100930a:	0798      	lsls	r0, r3, #30
 100930c:	f57f aee2 	bpl.w	10090d4 <z_cbvprintf_impl+0x184>
			precision = conv->prec_value;
 1009310:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
		conv->pad0_value = 0;
 1009314:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
 1009316:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
			= (enum specifier_cat_enum)conv->specifier_cat;
 100931a:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
			= (enum length_mod_enum)conv->length_mod;
 100931e:	f89d 1041 	ldrb.w	r1, [sp, #65]	; 0x41
		enum specifier_cat_enum specifier_cat
 1009322:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
 1009326:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
 1009328:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
 100932c:	d133      	bne.n	1009396 <z_cbvprintf_impl+0x446>
			switch (length_mod) {
 100932e:	1ecb      	subs	r3, r1, #3
 1009330:	2b04      	cmp	r3, #4
 1009332:	d804      	bhi.n	100933e <z_cbvprintf_impl+0x3ee>
 1009334:	e8df f003 	tbb	[pc, r3]
 1009338:	21464621 	.word	0x21464621
 100933c:	21          	.byte	0x21
 100933d:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
 100933e:	6823      	ldr	r3, [r4, #0]
			if (length_mod == LENGTH_HH) {
 1009340:	2901      	cmp	r1, #1
				value->sint = va_arg(ap, int);
 1009342:	ea4f 72e3 	mov.w	r2, r3, asr #31
 1009346:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
 100934a:	d11c      	bne.n	1009386 <z_cbvprintf_impl+0x436>
				value->sint = (signed char)value->sint;
 100934c:	f99d 3038 	ldrsb.w	r3, [sp, #56]	; 0x38
 1009350:	17da      	asrs	r2, r3, #31
 1009352:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
				value->sint = va_arg(ap, int);
 1009356:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
 1009358:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
 100935c:	f013 0603 	ands.w	r6, r3, #3
 1009360:	d050      	beq.n	1009404 <z_cbvprintf_impl+0x4b4>
			OUTS(sp, fp);
 1009362:	463a      	mov	r2, r7
 1009364:	4659      	mov	r1, fp
 1009366:	4648      	mov	r0, r9
 1009368:	9b03      	ldr	r3, [sp, #12]
 100936a:	f002 ffbd 	bl	100c2e8 <outs>
 100936e:	2800      	cmp	r0, #0
 1009370:	f2c0 8152 	blt.w	1009618 <z_cbvprintf_impl+0x6c8>
 1009374:	4405      	add	r5, r0
			continue;
 1009376:	9f03      	ldr	r7, [sp, #12]
 1009378:	e5f2      	b.n	1008f60 <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
 100937a:	f854 3b04 	ldr.w	r3, [r4], #4
 100937e:	17da      	asrs	r2, r3, #31
				value->uint = (unsigned char)value->uint;
 1009380:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
 1009384:	e7e8      	b.n	1009358 <z_cbvprintf_impl+0x408>
			} else if (length_mod == LENGTH_H) {
 1009386:	2902      	cmp	r1, #2
 1009388:	d1e5      	bne.n	1009356 <z_cbvprintf_impl+0x406>
				value->sint = (short)value->sint;
 100938a:	b21a      	sxth	r2, r3
 100938c:	f343 33c0 	sbfx	r3, r3, #15, #1
 1009390:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 1009394:	e7df      	b.n	1009356 <z_cbvprintf_impl+0x406>
		} else if (specifier_cat == SPECIFIER_UINT) {
 1009396:	2b02      	cmp	r3, #2
 1009398:	d124      	bne.n	10093e4 <z_cbvprintf_impl+0x494>
			switch (length_mod) {
 100939a:	1ecb      	subs	r3, r1, #3
 100939c:	2b04      	cmp	r3, #4
 100939e:	d804      	bhi.n	10093aa <z_cbvprintf_impl+0x45a>
 10093a0:	e8df f003 	tbb	[pc, r3]
 10093a4:	18101018 	.word	0x18101018
 10093a8:	18          	.byte	0x18
 10093a9:	00          	.byte	0x00
			if (length_mod == LENGTH_HH) {
 10093aa:	2901      	cmp	r1, #1
 10093ac:	f04f 0200 	mov.w	r2, #0
				value->uint = va_arg(ap, unsigned int);
 10093b0:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
 10093b4:	d014      	beq.n	10093e0 <z_cbvprintf_impl+0x490>
			} else if (length_mod == LENGTH_H) {
 10093b6:	2902      	cmp	r1, #2
				value->uint = va_arg(ap, unsigned int);
 10093b8:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			} else if (length_mod == LENGTH_H) {
 10093bc:	d1cc      	bne.n	1009358 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned short)value->uint;
 10093be:	b29b      	uxth	r3, r3
			value->ptr = va_arg(ap, void *);
 10093c0:	930e      	str	r3, [sp, #56]	; 0x38
 10093c2:	e7c9      	b.n	1009358 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap,
 10093c4:	3407      	adds	r4, #7
 10093c6:	f024 0407 	bic.w	r4, r4, #7
				value->uint =
 10093ca:	e8f4 2302 	ldrd	r2, r3, [r4], #8
 10093ce:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
 10093d2:	e7c1      	b.n	1009358 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap, size_t);
 10093d4:	f854 3b04 	ldr.w	r3, [r4], #4
 10093d8:	930e      	str	r3, [sp, #56]	; 0x38
 10093da:	2300      	movs	r3, #0
 10093dc:	930f      	str	r3, [sp, #60]	; 0x3c
			} else if (length_mod == LENGTH_H) {
 10093de:	e7bb      	b.n	1009358 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned char)value->uint;
 10093e0:	b2db      	uxtb	r3, r3
 10093e2:	e7cd      	b.n	1009380 <z_cbvprintf_impl+0x430>
		} else if (specifier_cat == SPECIFIER_FP) {
 10093e4:	2b04      	cmp	r3, #4
 10093e6:	d108      	bne.n	10093fa <z_cbvprintf_impl+0x4aa>
					(sint_value_type)va_arg(ap, long long);
 10093e8:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
 10093ea:	f024 0407 	bic.w	r4, r4, #7
 10093ee:	e9d4 2300 	ldrd	r2, r3, [r4]
 10093f2:	3408      	adds	r4, #8
 10093f4:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 10093f8:	e7ae      	b.n	1009358 <z_cbvprintf_impl+0x408>
		} else if (specifier_cat == SPECIFIER_PTR) {
 10093fa:	2b03      	cmp	r3, #3
 10093fc:	d1ac      	bne.n	1009358 <z_cbvprintf_impl+0x408>
			value->ptr = va_arg(ap, void *);
 10093fe:	f854 3b04 	ldr.w	r3, [r4], #4
 1009402:	e7dd      	b.n	10093c0 <z_cbvprintf_impl+0x470>
		switch (conv->specifier) {
 1009404:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
 1009408:	2878      	cmp	r0, #120	; 0x78
 100940a:	d8b4      	bhi.n	1009376 <z_cbvprintf_impl+0x426>
 100940c:	2862      	cmp	r0, #98	; 0x62
 100940e:	d81c      	bhi.n	100944a <z_cbvprintf_impl+0x4fa>
 1009410:	2825      	cmp	r0, #37	; 0x25
 1009412:	f43f adad 	beq.w	1008f70 <z_cbvprintf_impl+0x20>
 1009416:	2858      	cmp	r0, #88	; 0x58
 1009418:	d1ad      	bne.n	1009376 <z_cbvprintf_impl+0x426>
			bps = encode_uint(value->uint, conv, buf, bpe);
 100941a:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 100941e:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 1009422:	9300      	str	r3, [sp, #0]
 1009424:	aa10      	add	r2, sp, #64	; 0x40
 1009426:	ab08      	add	r3, sp, #32
 1009428:	f002 ff18 	bl	100c25c <encode_uint>
			if (precision >= 0) {
 100942c:	f1ba 0f00 	cmp.w	sl, #0
			bps = encode_uint(value->uint, conv, buf, bpe);
 1009430:	4607      	mov	r7, r0
			if (precision >= 0) {
 1009432:	f280 8099 	bge.w	1009568 <z_cbvprintf_impl+0x618>
		if (bps == NULL) {
 1009436:	2f00      	cmp	r7, #0
 1009438:	d09d      	beq.n	1009376 <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
 100943a:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 100943e:	1bd8      	subs	r0, r3, r7
		if (sign != 0) {
 1009440:	2e00      	cmp	r6, #0
 1009442:	f000 80c0 	beq.w	10095c6 <z_cbvprintf_impl+0x676>
			nj_len += 1U;
 1009446:	3001      	adds	r0, #1
 1009448:	e0bd      	b.n	10095c6 <z_cbvprintf_impl+0x676>
		switch (conv->specifier) {
 100944a:	3863      	subs	r0, #99	; 0x63
 100944c:	2815      	cmp	r0, #21
 100944e:	d892      	bhi.n	1009376 <z_cbvprintf_impl+0x426>
 1009450:	a201      	add	r2, pc, #4	; (adr r2, 1009458 <z_cbvprintf_impl+0x508>)
 1009452:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
 1009456:	bf00      	nop
 1009458:	0100952d 	.word	0x0100952d
 100945c:	0100953f 	.word	0x0100953f
 1009460:	01009377 	.word	0x01009377
 1009464:	01009377 	.word	0x01009377
 1009468:	01009377 	.word	0x01009377
 100946c:	01009377 	.word	0x01009377
 1009470:	0100953f 	.word	0x0100953f
 1009474:	01009377 	.word	0x01009377
 1009478:	01009377 	.word	0x01009377
 100947c:	01009377 	.word	0x01009377
 1009480:	01009377 	.word	0x01009377
 1009484:	010095cb 	.word	0x010095cb
 1009488:	01009563 	.word	0x01009563
 100948c:	01009589 	.word	0x01009589
 1009490:	01009377 	.word	0x01009377
 1009494:	01009377 	.word	0x01009377
 1009498:	010094b1 	.word	0x010094b1
 100949c:	01009377 	.word	0x01009377
 10094a0:	01009563 	.word	0x01009563
 10094a4:	01009377 	.word	0x01009377
 10094a8:	01009377 	.word	0x01009377
 10094ac:	01009563 	.word	0x01009563
			if (precision >= 0) {
 10094b0:	f1ba 0f00 	cmp.w	sl, #0
			bps = (const char *)value->ptr;
 10094b4:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			if (precision >= 0) {
 10094b6:	db35      	blt.n	1009524 <z_cbvprintf_impl+0x5d4>
				len = strnlen(bps, precision);
 10094b8:	4651      	mov	r1, sl
 10094ba:	4638      	mov	r0, r7
 10094bc:	f002 ff6e 	bl	100c39c <strnlen>
			bpe = bps + len;
 10094c0:	eb07 0a00 	add.w	sl, r7, r0
		if (bps == NULL) {
 10094c4:	2f00      	cmp	r7, #0
 10094c6:	f43f af56 	beq.w	1009376 <z_cbvprintf_impl+0x426>
		char sign = 0;
 10094ca:	2600      	movs	r6, #0
		if (conv->altform_0c) {
 10094cc:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 10094d0:	f013 0210 	ands.w	r2, r3, #16
 10094d4:	9205      	str	r2, [sp, #20]
 10094d6:	f000 8092 	beq.w	10095fe <z_cbvprintf_impl+0x6ae>
			nj_len += 2U;
 10094da:	3002      	adds	r0, #2
		if (conv->pad_fp) {
 10094dc:	065b      	lsls	r3, r3, #25
		nj_len += conv->pad0_value;
 10094de:	9a11      	ldr	r2, [sp, #68]	; 0x44
			nj_len += conv->pad0_pre_exp;
 10094e0:	bf48      	it	mi
 10094e2:	9b12      	ldrmi	r3, [sp, #72]	; 0x48
		nj_len += conv->pad0_value;
 10094e4:	4410      	add	r0, r2
			nj_len += conv->pad0_pre_exp;
 10094e6:	bf48      	it	mi
 10094e8:	18c0      	addmi	r0, r0, r3
		if (width > 0) {
 10094ea:	f1b8 0f00 	cmp.w	r8, #0
		nj_len += conv->pad0_value;
 10094ee:	9204      	str	r2, [sp, #16]
		if (width > 0) {
 10094f0:	f340 809f 	ble.w	1009632 <z_cbvprintf_impl+0x6e2>
			if (!conv->flag_dash) {
 10094f4:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
			width -= (int)nj_len;
 10094f8:	eba8 0800 	sub.w	r8, r8, r0
			if (!conv->flag_dash) {
 10094fc:	f3c2 0380 	ubfx	r3, r2, #2, #1
 1009500:	0750      	lsls	r0, r2, #29
 1009502:	9306      	str	r3, [sp, #24]
 1009504:	f100 8095 	bmi.w	1009632 <z_cbvprintf_impl+0x6e2>
				if (conv->flag_zero) {
 1009508:	0651      	lsls	r1, r2, #25
 100950a:	f140 8088 	bpl.w	100961e <z_cbvprintf_impl+0x6ce>
					if (sign != 0) {
 100950e:	b13e      	cbz	r6, 1009520 <z_cbvprintf_impl+0x5d0>
						OUTC(sign);
 1009510:	4659      	mov	r1, fp
 1009512:	4630      	mov	r0, r6
 1009514:	47c8      	blx	r9
 1009516:	2800      	cmp	r0, #0
 1009518:	db7e      	blt.n	1009618 <z_cbvprintf_impl+0x6c8>
 100951a:	9b06      	ldr	r3, [sp, #24]
 100951c:	3501      	adds	r5, #1
 100951e:	461e      	mov	r6, r3
					pad = '0';
 1009520:	2230      	movs	r2, #48	; 0x30
 1009522:	e07d      	b.n	1009620 <z_cbvprintf_impl+0x6d0>
				len = strlen(bps);
 1009524:	4638      	mov	r0, r7
 1009526:	f002 ff32 	bl	100c38e <strlen>
 100952a:	e7c9      	b.n	10094c0 <z_cbvprintf_impl+0x570>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 100952c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
		char sign = 0;
 100952e:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
 1009530:	2001      	movs	r0, #1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 1009532:	f88d 3020 	strb.w	r3, [sp, #32]
			bps = buf;
 1009536:	af08      	add	r7, sp, #32
			bpe = buf + 1;
 1009538:	f10d 0a21 	add.w	sl, sp, #33	; 0x21
 100953c:	e7c6      	b.n	10094cc <z_cbvprintf_impl+0x57c>
			if (conv->flag_plus) {
 100953e:	0719      	lsls	r1, r3, #28
			} else if (conv->flag_space) {
 1009540:	bf5a      	itte	pl
 1009542:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
 1009546:	015e      	lslpl	r6, r3, #5
				sign = '+';
 1009548:	262b      	movmi	r6, #43	; 0x2b
			sint = value->sint;
 100954a:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
			if (sint < 0) {
 100954e:	2b00      	cmp	r3, #0
 1009550:	f6bf af63 	bge.w	100941a <z_cbvprintf_impl+0x4ca>
				value->uint = (uint_value_type)-sint;
 1009554:	4252      	negs	r2, r2
 1009556:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
 100955a:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
 100955c:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 1009560:	e75b      	b.n	100941a <z_cbvprintf_impl+0x4ca>
		switch (conv->specifier) {
 1009562:	2600      	movs	r6, #0
 1009564:	e759      	b.n	100941a <z_cbvprintf_impl+0x4ca>
		char sign = 0;
 1009566:	2600      	movs	r6, #0
				conv->flag_zero = false;
 1009568:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				size_t len = bpe - bps;
 100956c:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 1009570:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
 1009572:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
 1009576:	459a      	cmp	sl, r3
				conv->flag_zero = false;
 1009578:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				if (len < (size_t)precision) {
 100957c:	f67f af5b 	bls.w	1009436 <z_cbvprintf_impl+0x4e6>
					conv->pad0_value = precision - (int)len;
 1009580:	ebaa 0303 	sub.w	r3, sl, r3
 1009584:	9311      	str	r3, [sp, #68]	; 0x44
 1009586:	e756      	b.n	1009436 <z_cbvprintf_impl+0x4e6>
			if (value->ptr != NULL) {
 1009588:	980e      	ldr	r0, [sp, #56]	; 0x38
 100958a:	b390      	cbz	r0, 10095f2 <z_cbvprintf_impl+0x6a2>
				bps = encode_uint((uintptr_t)value->ptr, conv,
 100958c:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 1009590:	9300      	str	r3, [sp, #0]
 1009592:	2100      	movs	r1, #0
 1009594:	ab08      	add	r3, sp, #32
 1009596:	aa10      	add	r2, sp, #64	; 0x40
 1009598:	f002 fe60 	bl	100c25c <encode_uint>
				conv->altform_0c = true;
 100959c:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
 10095a0:	f1ba 0f00 	cmp.w	sl, #0
				conv->altform_0c = true;
 10095a4:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 10095a8:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
 10095ac:	f043 0310 	orr.w	r3, r3, #16
				bps = encode_uint((uintptr_t)value->ptr, conv,
 10095b0:	4607      	mov	r7, r0
				conv->altform_0c = true;
 10095b2:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
 10095b6:	dad6      	bge.n	1009566 <z_cbvprintf_impl+0x616>
		if (bps == NULL) {
 10095b8:	2800      	cmp	r0, #0
 10095ba:	f43f aedc 	beq.w	1009376 <z_cbvprintf_impl+0x426>
		char sign = 0;
 10095be:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
 10095c0:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 10095c4:	1a18      	subs	r0, r3, r0
		if (sign != 0) {
 10095c6:	469a      	mov	sl, r3
 10095c8:	e780      	b.n	10094cc <z_cbvprintf_impl+0x57c>
				store_count(conv, value->ptr, count);
 10095ca:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	switch ((enum length_mod_enum)conv->length_mod) {
 10095cc:	2907      	cmp	r1, #7
 10095ce:	f63f aed2 	bhi.w	1009376 <z_cbvprintf_impl+0x426>
 10095d2:	e8df f001 	tbb	[pc, r1]
 10095d6:	040c      	.short	0x040c
 10095d8:	08080c06 	.word	0x08080c06
 10095dc:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
 10095de:	701d      	strb	r5, [r3, #0]
		if (bps == NULL) {
 10095e0:	e6c9      	b.n	1009376 <z_cbvprintf_impl+0x426>
		*(short *)dp = (short)count;
 10095e2:	801d      	strh	r5, [r3, #0]
		if (bps == NULL) {
 10095e4:	e6c7      	b.n	1009376 <z_cbvprintf_impl+0x426>
		*(intmax_t *)dp = (intmax_t)count;
 10095e6:	17ea      	asrs	r2, r5, #31
 10095e8:	e9c3 5200 	strd	r5, r2, [r3]
		if (bps == NULL) {
 10095ec:	e6c3      	b.n	1009376 <z_cbvprintf_impl+0x426>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
 10095ee:	601d      	str	r5, [r3, #0]
		if (bps == NULL) {
 10095f0:	e6c1      	b.n	1009376 <z_cbvprintf_impl+0x426>
 10095f2:	4f2f      	ldr	r7, [pc, #188]	; (10096b0 <z_cbvprintf_impl+0x760>)
		char sign = 0;
 10095f4:	4606      	mov	r6, r0
			bpe = bps + 5;
 10095f6:	f107 0a05 	add.w	sl, r7, #5
		size_t nj_len = (bpe - bps);
 10095fa:	2005      	movs	r0, #5
 10095fc:	e766      	b.n	10094cc <z_cbvprintf_impl+0x57c>
		} else if (conv->altform_0) {
 10095fe:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
 1009600:	bf48      	it	mi
 1009602:	3001      	addmi	r0, #1
 1009604:	e76a      	b.n	10094dc <z_cbvprintf_impl+0x58c>
					OUTC(pad);
 1009606:	4610      	mov	r0, r2
 1009608:	9307      	str	r3, [sp, #28]
 100960a:	9206      	str	r2, [sp, #24]
 100960c:	4659      	mov	r1, fp
 100960e:	47c8      	blx	r9
 1009610:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 1009614:	2800      	cmp	r0, #0
 1009616:	da04      	bge.n	1009622 <z_cbvprintf_impl+0x6d2>
#undef OUTS
#undef OUTC
}
 1009618:	b015      	add	sp, #84	; 0x54
 100961a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
 100961e:	2220      	movs	r2, #32
					pad = '0';
 1009620:	4643      	mov	r3, r8
				while (width-- > 0) {
 1009622:	4619      	mov	r1, r3
 1009624:	2900      	cmp	r1, #0
 1009626:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 100962a:	dcec      	bgt.n	1009606 <z_cbvprintf_impl+0x6b6>
 100962c:	4445      	add	r5, r8
 100962e:	4698      	mov	r8, r3
 1009630:	1a6d      	subs	r5, r5, r1
		if (sign != 0) {
 1009632:	b12e      	cbz	r6, 1009640 <z_cbvprintf_impl+0x6f0>
			OUTC(sign);
 1009634:	4659      	mov	r1, fp
 1009636:	4630      	mov	r0, r6
 1009638:	47c8      	blx	r9
 100963a:	2800      	cmp	r0, #0
 100963c:	dbec      	blt.n	1009618 <z_cbvprintf_impl+0x6c8>
 100963e:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
 1009640:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 1009644:	06da      	lsls	r2, r3, #27
 1009646:	d401      	bmi.n	100964c <z_cbvprintf_impl+0x6fc>
 1009648:	071b      	lsls	r3, r3, #28
 100964a:	d505      	bpl.n	1009658 <z_cbvprintf_impl+0x708>
				OUTC('0');
 100964c:	4659      	mov	r1, fp
 100964e:	2030      	movs	r0, #48	; 0x30
 1009650:	47c8      	blx	r9
 1009652:	2800      	cmp	r0, #0
 1009654:	dbe0      	blt.n	1009618 <z_cbvprintf_impl+0x6c8>
 1009656:	3501      	adds	r5, #1
			if (conv->altform_0c) {
 1009658:	9b05      	ldr	r3, [sp, #20]
 100965a:	b133      	cbz	r3, 100966a <z_cbvprintf_impl+0x71a>
				OUTC(conv->specifier);
 100965c:	4659      	mov	r1, fp
 100965e:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
 1009662:	47c8      	blx	r9
 1009664:	2800      	cmp	r0, #0
 1009666:	dbd7      	blt.n	1009618 <z_cbvprintf_impl+0x6c8>
 1009668:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
 100966a:	9e04      	ldr	r6, [sp, #16]
 100966c:	442e      	add	r6, r5
 100966e:	e005      	b.n	100967c <z_cbvprintf_impl+0x72c>
				OUTC('0');
 1009670:	4659      	mov	r1, fp
 1009672:	2030      	movs	r0, #48	; 0x30
 1009674:	47c8      	blx	r9
 1009676:	2800      	cmp	r0, #0
 1009678:	dbce      	blt.n	1009618 <z_cbvprintf_impl+0x6c8>
 100967a:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
 100967c:	1b73      	subs	r3, r6, r5
 100967e:	2b00      	cmp	r3, #0
 1009680:	dcf6      	bgt.n	1009670 <z_cbvprintf_impl+0x720>
			OUTS(bps, bpe);
 1009682:	4653      	mov	r3, sl
 1009684:	463a      	mov	r2, r7
 1009686:	4659      	mov	r1, fp
 1009688:	4648      	mov	r0, r9
 100968a:	f002 fe2d 	bl	100c2e8 <outs>
 100968e:	2800      	cmp	r0, #0
 1009690:	dbc2      	blt.n	1009618 <z_cbvprintf_impl+0x6c8>
 1009692:	4405      	add	r5, r0
		while (width > 0) {
 1009694:	44a8      	add	r8, r5
 1009696:	eba8 0305 	sub.w	r3, r8, r5
 100969a:	2b00      	cmp	r3, #0
 100969c:	f77f ae6b 	ble.w	1009376 <z_cbvprintf_impl+0x426>
			OUTC(' ');
 10096a0:	4659      	mov	r1, fp
 10096a2:	2020      	movs	r0, #32
 10096a4:	47c8      	blx	r9
 10096a6:	2800      	cmp	r0, #0
 10096a8:	dbb6      	blt.n	1009618 <z_cbvprintf_impl+0x6c8>
 10096aa:	3501      	adds	r5, #1
			--width;
 10096ac:	e7f3      	b.n	1009696 <z_cbvprintf_impl+0x746>
 10096ae:	bf00      	nop
 10096b0:	0100cb65 	.word	0x0100cb65

010096b4 <nordicsemi_nrf53_init>:
	__asm__ volatile(
 10096b4:	f04f 0220 	mov.w	r2, #32
 10096b8:	f3ef 8311 	mrs	r3, BASEPRI
 10096bc:	f382 8812 	msr	BASEPRI_MAX, r2
 10096c0:	f3bf 8f6f 	isb	sy
        NRFX_CRITICAL_SECTION_EXIT();
    }
    else
#endif
    {
        p_reg->ICACHECNF = (uint32_t)config;
 10096c4:	2101      	movs	r1, #1
 10096c6:	4a04      	ldr	r2, [pc, #16]	; (10096d8 <nordicsemi_nrf53_init+0x24>)
 10096c8:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
 10096cc:	f383 8811 	msr	BASEPRI, r3
 10096d0:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
 10096d4:	2000      	movs	r0, #0
 10096d6:	4770      	bx	lr
 10096d8:	41080000 	.word	0x41080000

010096dc <z_arm_on_enter_cpu_idle>:
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
 10096dc:	2305      	movs	r3, #5
{
 10096de:	b570      	push	{r4, r5, r6, lr}
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
 10096e0:	4d14      	ldr	r5, [pc, #80]	; (1009734 <z_arm_on_enter_cpu_idle+0x58>)
 10096e2:	4e15      	ldr	r6, [pc, #84]	; (1009738 <z_arm_on_enter_cpu_idle+0x5c>)
 10096e4:	782c      	ldrb	r4, [r5, #0]
 10096e6:	3401      	adds	r4, #1
 10096e8:	fbb4 f3f3 	udiv	r3, r4, r3
 10096ec:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 10096f0:	1ae4      	subs	r4, r4, r3
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
 10096f2:	f002 ff6a 	bl	100c5ca <sys_clock_cycle_get_32>
	if (timestamps_filled &&
 10096f6:	4a11      	ldr	r2, [pc, #68]	; (100973c <z_arm_on_enter_cpu_idle+0x60>)
 10096f8:	7813      	ldrb	r3, [r2, #0]
 10096fa:	b123      	cbz	r3, 1009706 <z_arm_on_enter_cpu_idle+0x2a>
	    (now - timestamps[oldest]) < (window_cycles + 1)) {
 10096fc:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 1009700:	1ac0      	subs	r0, r0, r3
	if (timestamps_filled &&
 1009702:	2807      	cmp	r0, #7
 1009704:	d913      	bls.n	100972e <z_arm_on_enter_cpu_idle+0x52>
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1009706:	4b0e      	ldr	r3, [pc, #56]	; (1009740 <z_arm_on_enter_cpu_idle+0x64>)
 1009708:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
	if (nrf_power_event_check(NRF_POWER, NRF_POWER_EVENT_SLEEPENTER)) {
 100970c:	b141      	cbz	r1, 1009720 <z_arm_on_enter_cpu_idle+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100970e:	2100      	movs	r1, #0
 1009710:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
 1009714:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
 1009718:	702c      	strb	r4, [r5, #0]
		if (current == 0) {
 100971a:	b90c      	cbnz	r4, 1009720 <z_arm_on_enter_cpu_idle+0x44>
			timestamps_filled = true;
 100971c:	2301      	movs	r3, #1
 100971e:	7013      	strb	r3, [r2, #0]
	timestamps[current] = k_cycle_get_32();
 1009720:	782c      	ldrb	r4, [r5, #0]
 1009722:	f002 ff52 	bl	100c5ca <sys_clock_cycle_get_32>
 1009726:	f846 0024 	str.w	r0, [r6, r4, lsl #2]
	return true;
 100972a:	2001      	movs	r0, #1
}
 100972c:	bd70      	pop	{r4, r5, r6, pc}
		return false;
 100972e:	2000      	movs	r0, #0
 1009730:	e7fc      	b.n	100972c <z_arm_on_enter_cpu_idle+0x50>
 1009732:	bf00      	nop
 1009734:	210002bd 	.word	0x210002bd
 1009738:	210001d0 	.word	0x210001d0
 100973c:	210002bc 	.word	0x210002bc
 1009740:	41005000 	.word	0x41005000

01009744 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
 1009744:	b120      	cbz	r0, 1009750 <arch_busy_wait+0xc>
    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
 1009746:	4b03      	ldr	r3, [pc, #12]	; (1009754 <arch_busy_wait+0x10>)
 1009748:	0180      	lsls	r0, r0, #6
 100974a:	f043 0301 	orr.w	r3, r3, #1
 100974e:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
 1009750:	4770      	bx	lr
 1009752:	bf00      	nop
 1009754:	0100ca80 	.word	0x0100ca80

01009758 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
 1009758:	f001 b970 	b.w	100aa3c <SystemInit>

0100975c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
 100975c:	4901      	ldr	r1, [pc, #4]	; (1009764 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
 100975e:	2210      	movs	r2, #16
	str	r2, [r1]
 1009760:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
 1009762:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
 1009764:	e000ed10 	.word	0xe000ed10

01009768 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
 1009768:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
 100976a:	4040      	eors	r0, r0
	msr	BASEPRI, r0
 100976c:	f380 8811 	msr	BASEPRI, r0
	isb
 1009770:	f3bf 8f6f 	isb	sy
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
 1009774:	b501      	push	{r0, lr}
 1009776:	f7ff ffb1 	bl	10096dc <z_arm_on_enter_cpu_idle>
 100977a:	2800      	cmp	r0, #0
 100977c:	d006      	beq.n	100978c <_skip_0>
 100977e:	f3bf 8f4f 	dsb	sy
 1009782:	bf30      	wfi
 1009784:	bf00      	nop
 1009786:	bf00      	nop
 1009788:	bf00      	nop
 100978a:	bf00      	nop

0100978c <_skip_0>:
 100978c:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
 1009790:	b662      	cpsie	i
	isb
 1009792:	f3bf 8f6f 	isb	sy

	bx	lr
 1009796:	4770      	bx	lr

01009798 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
 1009798:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
 100979a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
 100979c:	f381 8811 	msr	BASEPRI, r1

	_sleep_if_allowed wfe
 10097a0:	b501      	push	{r0, lr}
 10097a2:	f7ff ff9b 	bl	10096dc <z_arm_on_enter_cpu_idle>
 10097a6:	2800      	cmp	r0, #0
 10097a8:	d006      	beq.n	10097b8 <_skip_1>
 10097aa:	f3bf 8f4f 	dsb	sy
 10097ae:	bf20      	wfe
 10097b0:	bf00      	nop
 10097b2:	bf00      	nop
 10097b4:	bf00      	nop
 10097b6:	bf00      	nop

010097b8 <_skip_1>:
 10097b8:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

	msr	BASEPRI, r0
 10097bc:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
 10097c0:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
 10097c2:	4770      	bx	lr

010097c4 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
 10097c4:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 10097c6:	2800      	cmp	r0, #0
 10097c8:	db07      	blt.n	10097da <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 10097ca:	2301      	movs	r3, #1
 10097cc:	0941      	lsrs	r1, r0, #5
 10097ce:	4a03      	ldr	r2, [pc, #12]	; (10097dc <arch_irq_enable+0x18>)
 10097d0:	f000 001f 	and.w	r0, r0, #31
 10097d4:	4083      	lsls	r3, r0
 10097d6:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 10097da:	4770      	bx	lr
 10097dc:	e000e100 	.word	0xe000e100

010097e0 <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
 10097e0:	4b05      	ldr	r3, [pc, #20]	; (10097f8 <arch_irq_is_enabled+0x18>)
 10097e2:	0942      	lsrs	r2, r0, #5
 10097e4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 10097e8:	2301      	movs	r3, #1
 10097ea:	f000 001f 	and.w	r0, r0, #31
 10097ee:	fa03 f000 	lsl.w	r0, r3, r0
}
 10097f2:	4010      	ands	r0, r2
 10097f4:	4770      	bx	lr
 10097f6:	bf00      	nop
 10097f8:	e000e100 	.word	0xe000e100

010097fc <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
 10097fc:	b240      	sxtb	r0, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 10097fe:	2800      	cmp	r0, #0
		prio += _IRQ_PRIO_OFFSET;
 1009800:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1009804:	bfac      	ite	ge
 1009806:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 100980a:	4b06      	ldrlt	r3, [pc, #24]	; (1009824 <z_arm_irq_priority_set+0x28>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 100980c:	ea4f 1141 	mov.w	r1, r1, lsl #5
 1009810:	b2c9      	uxtb	r1, r1
 1009812:	bfab      	itete	ge
 1009814:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1009818:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 100981c:	f880 1300 	strbge.w	r1, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1009820:	5419      	strblt	r1, [r3, r0]
}
 1009822:	4770      	bx	lr
 1009824:	e000ed14 	.word	0xe000ed14

01009828 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
 1009828:	bf30      	wfi
    b z_SysNmiOnReset
 100982a:	f7ff bffd 	b.w	1009828 <z_SysNmiOnReset>
 100982e:	bf00      	nop

01009830 <z_arm_prep_c>:
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
 1009830:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 1009832:	4b08      	ldr	r3, [pc, #32]	; (1009854 <z_arm_prep_c+0x24>)
 1009834:	4a08      	ldr	r2, [pc, #32]	; (1009858 <z_arm_prep_c+0x28>)
 1009836:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 100983a:	6093      	str	r3, [r2, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 100983c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1009840:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
 1009844:	f001 fe38 	bl	100b4b8 <z_bss_zero>
	z_data_copy();
 1009848:	f002 fab4 	bl	100bdb4 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
 100984c:	f000 f9dc 	bl	1009c08 <z_arm_interrupt_init>
	z_cstart();
 1009850:	f001 fe72 	bl	100b538 <z_cstart>
 1009854:	01008800 	.word	0x01008800
 1009858:	e000ed00 	.word	0xe000ed00

0100985c <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
 100985c:	4a09      	ldr	r2, [pc, #36]	; (1009884 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
 100985e:	490a      	ldr	r1, [pc, #40]	; (1009888 <arch_swap+0x2c>)
	_current->arch.basepri = key;
 1009860:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
 1009862:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
 1009864:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
 1009866:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 1009868:	4908      	ldr	r1, [pc, #32]	; (100988c <arch_swap+0x30>)
 100986a:	684b      	ldr	r3, [r1, #4]
 100986c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 1009870:	604b      	str	r3, [r1, #4]
 1009872:	2300      	movs	r3, #0
 1009874:	f383 8811 	msr	BASEPRI, r3
 1009878:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
 100987c:	6893      	ldr	r3, [r2, #8]
}
 100987e:	6f98      	ldr	r0, [r3, #120]	; 0x78
 1009880:	4770      	bx	lr
 1009882:	bf00      	nop
 1009884:	2100028c 	.word	0x2100028c
 1009888:	0100cb38 	.word	0x0100cb38
 100988c:	e000ed00 	.word	0xe000ed00

01009890 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
 1009890:	4913      	ldr	r1, [pc, #76]	; (10098e0 <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
 1009892:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
 1009894:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
 1009898:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
 100989a:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
 100989e:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 10098a2:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
 10098a4:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
 10098a8:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
 10098ac:	4f0d      	ldr	r7, [pc, #52]	; (10098e4 <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
 10098ae:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 10098b2:	694a      	ldr	r2, [r1, #20]

    str r2, [r1, #_kernel_offset_to_current]
 10098b4:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
 10098b6:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
 10098b8:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
 10098ba:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
 10098bc:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
 10098be:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
 10098c2:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
 10098c6:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
 10098ca:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
 10098ce:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
 10098d2:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
 10098d4:	f002 fd31 	bl	100c33a <configure_builtin_stack_guard>
    pop {r2, lr}
 10098d8:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
 10098dc:	4770      	bx	lr
 10098de:	0000      	.short	0x0000
    ldr r1, =_kernel
 10098e0:	2100028c 	.word	0x2100028c
    ldr v4, =_SCS_ICSR
 10098e4:	e000ed04 	.word	0xe000ed04

010098e8 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 10098e8:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
 10098ec:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 10098ee:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 10098f2:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 10098f6:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
 10098f8:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
 10098fc:	2902      	cmp	r1, #2
    beq _oops
 10098fe:	d0ff      	beq.n	1009900 <_oops>

01009900 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
 1009900:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
 1009902:	f002 fd0b 	bl	100c31c <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
 1009906:	bd01      	pop	{r0, pc}

01009908 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
 1009908:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
 100990c:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
 100990e:	490b      	ldr	r1, [pc, #44]	; (100993c <arch_new_thread+0x34>)
	iframe->a2 = (uint32_t)p1;
 1009910:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
 1009914:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
 1009916:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
 100991a:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
 100991e:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
 1009920:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
 1009924:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
 1009928:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 100992c:	f842 3c04 	str.w	r3, [r2, #-4]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
 1009930:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
 1009932:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
 1009934:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
 1009936:	6743      	str	r3, [r0, #116]	; 0x74
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
 1009938:	4770      	bx	lr
 100993a:	bf00      	nop
 100993c:	0100c097 	.word	0x0100c097

01009940 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
 1009940:	4b08      	ldr	r3, [pc, #32]	; (1009964 <arch_switch_to_main_thread+0x24>)
 1009942:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 1009944:	6e43      	ldr	r3, [r0, #100]	; 0x64
 1009946:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
 100994a:	4610      	mov	r0, r2
 100994c:	f381 8809 	msr	PSP, r1
 1009950:	2100      	movs	r1, #0
 1009952:	b663      	cpsie	if
 1009954:	f381 8811 	msr	BASEPRI, r1
 1009958:	f3bf 8f6f 	isb	sy
 100995c:	2200      	movs	r2, #0
 100995e:	2300      	movs	r3, #0
 1009960:	f002 fb99 	bl	100c096 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
 1009964:	2100028c 	.word	0x2100028c

01009968 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
 1009968:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
 100996a:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
 100996e:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
 1009972:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
 1009976:	4904      	ldr	r1, [pc, #16]	; (1009988 <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
 1009978:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
 100997a:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
 100997c:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
 100997e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
 1009982:	4902      	ldr	r1, [pc, #8]	; (100998c <_isr_wrapper+0x24>)
	bx r1
 1009984:	4708      	bx	r1
 1009986:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
 1009988:	0100c910 	.word	0x0100c910
	ldr r1, =z_arm_int_exit
 100998c:	01009991 	.word	0x01009991

01009990 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
 1009990:	4b04      	ldr	r3, [pc, #16]	; (10099a4 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
 1009992:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
 1009994:	6958      	ldr	r0, [r3, #20]
	cmp r0, r1
 1009996:	4288      	cmp	r0, r1
	beq _EXIT_EXC
 1009998:	d003      	beq.n	10099a2 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
 100999a:	4903      	ldr	r1, [pc, #12]	; (10099a8 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
 100999c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
 10099a0:	600a      	str	r2, [r1, #0]

010099a2 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
 10099a2:	4770      	bx	lr
	ldr r3, =_kernel
 10099a4:	2100028c 	.word	0x2100028c
	ldr r1, =_SCS_ICSR
 10099a8:	e000ed04 	.word	0xe000ed04

010099ac <usage_fault.constprop.0>:
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 10099ac:	4b15      	ldr	r3, [pc, #84]	; (1009a04 <usage_fault.constprop.0+0x58>)
 10099ae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
 10099b0:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
		reason = K_ERR_ARM_USAGE_DIV_0;
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 10099b4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
 10099b6:	bf14      	ite	ne
 10099b8:	201e      	movne	r0, #30
 10099ba:	201d      	moveq	r0, #29
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
 10099bc:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
		PR_FAULT_INFO("  Unaligned memory access");
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
 10099c0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
 10099c2:	bf18      	it	ne
 10099c4:	201f      	movne	r0, #31
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
 10099c6:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 10099ca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_STACK_CHK_FAIL;
 10099cc:	bf18      	it	ne
 10099ce:	2002      	movne	r0, #2
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
 10099d0:	f412 2f00 	tst.w	r2, #524288	; 0x80000
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 10099d4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
 10099d6:	bf18      	it	ne
 10099d8:	2021      	movne	r0, #33	; 0x21
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
 10099da:	f412 2f80 	tst.w	r2, #262144	; 0x40000
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 10099de:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
 10099e0:	bf18      	it	ne
 10099e2:	2022      	movne	r0, #34	; 0x22
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
 10099e4:	f412 3f00 	tst.w	r2, #131072	; 0x20000
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 10099e8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
 10099ea:	bf18      	it	ne
 10099ec:	2023      	movne	r0, #35	; 0x23
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
 10099ee:	f412 3f80 	tst.w	r2, #65536	; 0x10000
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 10099f2:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	return reason;
}
 10099f4:	bf18      	it	ne
 10099f6:	2024      	movne	r0, #36	; 0x24
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 10099f8:	ea6f 4202 	mvn.w	r2, r2, lsl #16
 10099fc:	ea6f 4212 	mvn.w	r2, r2, lsr #16
 1009a00:	629a      	str	r2, [r3, #40]	; 0x28
}
 1009a02:	4770      	bx	lr
 1009a04:	e000ed00 	.word	0xe000ed00

01009a08 <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
 1009a08:	b510      	push	{r4, lr}
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 1009a0a:	4b16      	ldr	r3, [pc, #88]	; (1009a64 <bus_fault.constprop.0+0x5c>)
 1009a0c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 1009a0e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
 1009a10:	f412 5f80 	tst.w	r2, #4096	; 0x1000
 1009a14:	bf14      	ite	ne
 1009a16:	2217      	movne	r2, #23
 1009a18:	2216      	moveq	r2, #22
		reason = K_ERR_ARM_BUS_UNSTACKING;
 1009a1a:	f414 6f00 	tst.w	r4, #2048	; 0x800
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 1009a1e:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_UNSTACKING;
 1009a20:	bf18      	it	ne
 1009a22:	2218      	movne	r2, #24
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 1009a24:	05a4      	lsls	r4, r4, #22
 1009a26:	d509      	bpl.n	1009a3c <bus_fault.constprop.0+0x34>
		STORE_xFAR(bfar, SCB->BFAR);
 1009a28:	6b9a      	ldr	r2, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 1009a2a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 1009a2c:	0412      	lsls	r2, r2, #16
 1009a2e:	d504      	bpl.n	1009a3a <bus_fault.constprop.0+0x32>
			if (from_hard_fault != 0) {
 1009a30:	b118      	cbz	r0, 1009a3a <bus_fault.constprop.0+0x32>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 1009a32:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 1009a34:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 1009a38:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
 1009a3a:	2219      	movs	r2, #25
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 1009a3c:	4b09      	ldr	r3, [pc, #36]	; (1009a64 <bus_fault.constprop.0+0x5c>)
 1009a3e:	6a98      	ldr	r0, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
 1009a40:	f410 6f80 	tst.w	r0, #1024	; 0x400
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 1009a44:	6a98      	ldr	r0, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
 1009a46:	bf18      	it	ne
 1009a48:	221a      	movne	r2, #26
		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
 1009a4a:	f410 7f80 	tst.w	r0, #256	; 0x100
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 1009a4e:	6a98      	ldr	r0, [r3, #40]	; 0x28
 1009a50:	f440 407f 	orr.w	r0, r0, #65280	; 0xff00
 1009a54:	6298      	str	r0, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
 1009a56:	f04f 0300 	mov.w	r3, #0
}
 1009a5a:	bf0c      	ite	eq
 1009a5c:	4610      	moveq	r0, r2
 1009a5e:	201b      	movne	r0, #27
	*recoverable = memory_fault_recoverable(esf, true);
 1009a60:	700b      	strb	r3, [r1, #0]
}
 1009a62:	bd10      	pop	{r4, pc}
 1009a64:	e000ed00 	.word	0xe000ed00

01009a68 <mem_manage_fault.constprop.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
 1009a68:	b510      	push	{r4, lr}
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 1009a6a:	4b15      	ldr	r3, [pc, #84]	; (1009ac0 <mem_manage_fault.constprop.0+0x58>)
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
 1009a6c:	4602      	mov	r2, r0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 1009a6e:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 1009a70:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
 1009a72:	f010 0f10 	tst.w	r0, #16
 1009a76:	bf14      	ite	ne
 1009a78:	2011      	movne	r0, #17
 1009a7a:	2010      	moveq	r0, #16
		reason = K_ERR_ARM_MEM_UNSTACKING;
 1009a7c:	f014 0f08 	tst.w	r4, #8
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 1009a80:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_UNSTACKING;
 1009a82:	bf18      	it	ne
 1009a84:	2012      	movne	r0, #18
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 1009a86:	07a4      	lsls	r4, r4, #30
 1009a88:	d509      	bpl.n	1009a9e <mem_manage_fault.constprop.0+0x36>
		uint32_t temp = SCB->MMFAR;
 1009a8a:	6b58      	ldr	r0, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 1009a8c:	6a98      	ldr	r0, [r3, #40]	; 0x28
 1009a8e:	0600      	lsls	r0, r0, #24
 1009a90:	d504      	bpl.n	1009a9c <mem_manage_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
 1009a92:	b11a      	cbz	r2, 1009a9c <mem_manage_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 1009a94:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 1009a96:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 1009a9a:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
 1009a9c:	2013      	movs	r0, #19
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 1009a9e:	4b08      	ldr	r3, [pc, #32]	; (1009ac0 <mem_manage_fault.constprop.0+0x58>)
 1009aa0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
 1009aa2:	f012 0f01 	tst.w	r2, #1
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 1009aa6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
 1009aa8:	bf18      	it	ne
 1009aaa:	2014      	movne	r0, #20
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 1009aac:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 1009aae:	bf58      	it	pl
 1009ab0:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 1009ab2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 1009ab4:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 1009ab8:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
 1009aba:	2300      	movs	r3, #0
 1009abc:	700b      	strb	r3, [r1, #0]
}
 1009abe:	bd10      	pop	{r4, pc}
 1009ac0:	e000ed00 	.word	0xe000ed00

01009ac4 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
 1009ac4:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 1009ac6:	4b44      	ldr	r3, [pc, #272]	; (1009bd8 <z_arm_fault+0x114>)
{
 1009ac8:	4606      	mov	r6, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 1009aca:	685b      	ldr	r3, [r3, #4]
 1009acc:	2500      	movs	r5, #0
{
 1009ace:	b08a      	sub	sp, #40	; 0x28
 1009ad0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 1009ad4:	f385 8811 	msr	BASEPRI, r5
 1009ad8:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 1009adc:	f002 407f 	and.w	r0, r2, #4278190080	; 0xff000000
 1009ae0:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
 1009ae4:	d111      	bne.n	1009b0a <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 1009ae6:	f002 000c 	and.w	r0, r2, #12
 1009aea:	2808      	cmp	r0, #8
 1009aec:	d00d      	beq.n	1009b0a <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
 1009aee:	0710      	lsls	r0, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
 1009af0:	bf4c      	ite	mi
 1009af2:	460e      	movmi	r6, r1
			*nested_exc = true;
 1009af4:	2501      	movpl	r5, #1
	*recoverable = false;
 1009af6:	2200      	movs	r2, #0
	switch (fault) {
 1009af8:	3b03      	subs	r3, #3
	*recoverable = false;
 1009afa:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
 1009afe:	2b03      	cmp	r3, #3
 1009b00:	d805      	bhi.n	1009b0e <z_arm_fault+0x4a>
 1009b02:	e8df f003 	tbb	[pc, r3]
 1009b06:	5c1e      	.short	0x5c1e
 1009b08:	5960      	.short	0x5960
		return NULL;
 1009b0a:	462e      	mov	r6, r5
 1009b0c:	e7f3      	b.n	1009af6 <z_arm_fault+0x32>
 1009b0e:	2400      	movs	r4, #0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
 1009b10:	f89d 3007 	ldrb.w	r3, [sp, #7]
 1009b14:	b99b      	cbnz	r3, 1009b3e <z_arm_fault+0x7a>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
 1009b16:	2220      	movs	r2, #32
 1009b18:	4631      	mov	r1, r6
 1009b1a:	a802      	add	r0, sp, #8
 1009b1c:	f002 fc57 	bl	100c3ce <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
 1009b20:	9b09      	ldr	r3, [sp, #36]	; 0x24
 1009b22:	2d00      	cmp	r5, #0
 1009b24:	d053      	beq.n	1009bce <z_arm_fault+0x10a>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 1009b26:	f3c3 0208 	ubfx	r2, r3, #0, #9
 1009b2a:	b922      	cbnz	r2, 1009b36 <z_arm_fault+0x72>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 1009b2c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 1009b30:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 1009b34:	9309      	str	r3, [sp, #36]	; 0x24

	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
		reason = K_ERR_CPU_EXCEPTION;
	}

	z_arm_fatal_error(reason, &esf_copy);
 1009b36:	4620      	mov	r0, r4
 1009b38:	a902      	add	r1, sp, #8
 1009b3a:	f002 fbed 	bl	100c318 <z_arm_fatal_error>
}
 1009b3e:	b00a      	add	sp, #40	; 0x28
 1009b40:	bd70      	pop	{r4, r5, r6, pc}
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 1009b42:	4b25      	ldr	r3, [pc, #148]	; (1009bd8 <z_arm_fault+0x114>)
 1009b44:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 1009b46:	0791      	lsls	r1, r2, #30
 1009b48:	d4e1      	bmi.n	1009b0e <z_arm_fault+0x4a>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 1009b4a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 1009b4c:	2a00      	cmp	r2, #0
 1009b4e:	dbde      	blt.n	1009b0e <z_arm_fault+0x4a>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 1009b50:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 1009b52:	0052      	lsls	r2, r2, #1
 1009b54:	d5db      	bpl.n	1009b0e <z_arm_fault+0x4a>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 1009b56:	695a      	ldr	r2, [r3, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
 1009b58:	69b1      	ldr	r1, [r6, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 1009b5a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 1009b5e:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 1009b60:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1009b64:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 1009b68:	695a      	ldr	r2, [r3, #20]
	uint16_t fault_insn = *(ret_addr - 1);
 1009b6a:	f831 1c02 	ldrh.w	r1, [r1, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 1009b6e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 1009b72:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 1009b74:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1009b78:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 1009b7c:	f64d 7202 	movw	r2, #57090	; 0xdf02
 1009b80:	4291      	cmp	r1, r2
 1009b82:	d009      	beq.n	1009b98 <z_arm_fault+0xd4>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 1009b84:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 1009b86:	b2d2      	uxtb	r2, r2
 1009b88:	b142      	cbz	r2, 1009b9c <z_arm_fault+0xd8>
			reason = mem_manage_fault(esf, 1, recoverable);
 1009b8a:	2001      	movs	r0, #1
 1009b8c:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
 1009b90:	f7ff ff6a 	bl	1009a68 <mem_manage_fault.constprop.0>
		reason = usage_fault(esf);
 1009b94:	4604      	mov	r4, r0
		break;
 1009b96:	e7bb      	b.n	1009b10 <z_arm_fault+0x4c>
			reason = esf->basic.r0;
 1009b98:	6834      	ldr	r4, [r6, #0]
 1009b9a:	e7b9      	b.n	1009b10 <z_arm_fault+0x4c>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 1009b9c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 1009b9e:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
 1009ba2:	d005      	beq.n	1009bb0 <z_arm_fault+0xec>
			reason = bus_fault(esf, 1, recoverable);
 1009ba4:	2001      	movs	r0, #1
 1009ba6:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
 1009baa:	f7ff ff2d 	bl	1009a08 <bus_fault.constprop.0>
 1009bae:	e7f1      	b.n	1009b94 <z_arm_fault+0xd0>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 1009bb0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 1009bb2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 1009bb6:	d3aa      	bcc.n	1009b0e <z_arm_fault+0x4a>
		reason = usage_fault(esf);
 1009bb8:	f7ff fef8 	bl	10099ac <usage_fault.constprop.0>
 1009bbc:	e7ea      	b.n	1009b94 <z_arm_fault+0xd0>
		reason = mem_manage_fault(esf, 0, recoverable);
 1009bbe:	2000      	movs	r0, #0
 1009bc0:	f10d 0107 	add.w	r1, sp, #7
 1009bc4:	e7e4      	b.n	1009b90 <z_arm_fault+0xcc>
		reason = bus_fault(esf, 0, recoverable);
 1009bc6:	2000      	movs	r0, #0
 1009bc8:	f10d 0107 	add.w	r1, sp, #7
 1009bcc:	e7ed      	b.n	1009baa <z_arm_fault+0xe6>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 1009bce:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 1009bd2:	f023 0301 	bic.w	r3, r3, #1
 1009bd6:	e7ad      	b.n	1009b34 <z_arm_fault+0x70>
 1009bd8:	e000ed00 	.word	0xe000ed00

01009bdc <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 1009bdc:	4b04      	ldr	r3, [pc, #16]	; (1009bf0 <z_arm_fault_init+0x14>)
 1009bde:	695a      	ldr	r2, [r3, #20]
 1009be0:	f042 0210 	orr.w	r2, r2, #16
 1009be4:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
 1009be6:	695a      	ldr	r2, [r3, #20]
 1009be8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 1009bec:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
 1009bee:	4770      	bx	lr
 1009bf0:	e000ed00 	.word	0xe000ed00

01009bf4 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
 1009bf4:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
 1009bf8:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
 1009bfc:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
 1009bfe:	4672      	mov	r2, lr
	bl z_arm_fault
 1009c00:	f7ff ff60 	bl	1009ac4 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
 1009c04:	bd01      	pop	{r0, pc}
 1009c06:	bf00      	nop

01009c08 <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
 1009c08:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1009c0a:	2120      	movs	r1, #32
 1009c0c:	4803      	ldr	r0, [pc, #12]	; (1009c1c <z_arm_interrupt_init+0x14>)
 1009c0e:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
 1009c10:	3301      	adds	r3, #1
 1009c12:	2b1e      	cmp	r3, #30
 1009c14:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
 1009c18:	d1f9      	bne.n	1009c0e <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
 1009c1a:	4770      	bx	lr
 1009c1c:	e000e100 	.word	0xe000e100

01009c20 <__start>:
    strb r0, [r1]
#endif /* CONFIG_DEBUG_THREAD_INFO */

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
 1009c20:	2000      	movs	r0, #0
    msr CONTROL, r0
 1009c22:	f380 8814 	msr	CONTROL, r0
    isb
 1009c26:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
 1009c2a:	2000      	movs	r0, #0
    msr MSPLIM, r0
 1009c2c:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
 1009c30:	f380 880b 	msr	PSPLIM, r0
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
 1009c34:	f7ff fd90 	bl	1009758 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
 1009c38:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
 1009c3a:	490e      	ldr	r1, [pc, #56]	; (1009c74 <__start+0x54>)
    str r0, [r1]
 1009c3c:	6008      	str	r0, [r1, #0]
    dsb
 1009c3e:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
 1009c42:	480d      	ldr	r0, [pc, #52]	; (1009c78 <__start+0x58>)
    msr msp, r0
 1009c44:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
 1009c48:	f000 f83e 	bl	1009cc8 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 1009c4c:	2020      	movs	r0, #32
    msr BASEPRI, r0
 1009c4e:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
 1009c52:	480a      	ldr	r0, [pc, #40]	; (1009c7c <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 1009c54:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
 1009c58:	1840      	adds	r0, r0, r1
    msr PSP, r0
 1009c5a:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
 1009c5e:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
 1009c62:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
 1009c64:	4308      	orrs	r0, r1
    msr CONTROL, r0
 1009c66:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
 1009c6a:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
 1009c6e:	f7ff fddf 	bl	1009830 <z_arm_prep_c>
 1009c72:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
 1009c74:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
 1009c78:	21000fc8 	.word	0x21000fc8
    ldr r0, =z_interrupt_stacks
 1009c7c:	210002c8 	.word	0x210002c8

01009c80 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
 1009c80:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 1009c84:	4905      	ldr	r1, [pc, #20]	; (1009c9c <sys_arch_reboot+0x1c>)
 1009c86:	4b06      	ldr	r3, [pc, #24]	; (1009ca0 <sys_arch_reboot+0x20>)
 1009c88:	68ca      	ldr	r2, [r1, #12]
 1009c8a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 1009c8e:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 1009c90:	60cb      	str	r3, [r1, #12]
 1009c92:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 1009c96:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 1009c98:	e7fd      	b.n	1009c96 <sys_arch_reboot+0x16>
 1009c9a:	bf00      	nop
 1009c9c:	e000ed00 	.word	0xe000ed00
 1009ca0:	05fa0004 	.word	0x05fa0004

01009ca4 <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
 1009ca4:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
 1009ca6:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
 1009ca8:	4906      	ldr	r1, [pc, #24]	; (1009cc4 <z_arm_clear_arm_mpu_config+0x20>)
 1009caa:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
	int num_regions =
 1009cae:	f3c2 2207 	ubfx	r2, r2, #8, #8
	for (i = 0; i < num_regions; i++) {
 1009cb2:	4293      	cmp	r3, r2
 1009cb4:	db00      	blt.n	1009cb8 <z_arm_clear_arm_mpu_config+0x14>
		ARM_MPU_ClrRegion(i);
	}
}
 1009cb6:	4770      	bx	lr
  mpu->RNR = rnr;
 1009cb8:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
  mpu->RLAR = 0U;
 1009cbc:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0
	for (i = 0; i < num_regions; i++) {
 1009cc0:	3301      	adds	r3, #1
 1009cc2:	e7f6      	b.n	1009cb2 <z_arm_clear_arm_mpu_config+0xe>
 1009cc4:	e000ed00 	.word	0xe000ed00

01009cc8 <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
 1009cc8:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
 1009cca:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 1009ccc:	2400      	movs	r4, #0
 1009cce:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
 1009cd2:	f7ff ffe7 	bl	1009ca4 <z_arm_clear_arm_mpu_config>
 1009cd6:	4623      	mov	r3, r4
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
 1009cd8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 1009cdc:	4a0c      	ldr	r2, [pc, #48]	; (1009d10 <z_arm_init_arch_hw_at_boot+0x48>)
 1009cde:	f103 0120 	add.w	r1, r3, #32
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
 1009ce2:	3301      	adds	r3, #1
 1009ce4:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
 1009ce6:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
 1009cea:	d1f8      	bne.n	1009cde <z_arm_init_arch_hw_at_boot+0x16>
 1009cec:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
 1009cee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 1009cf2:	4a07      	ldr	r2, [pc, #28]	; (1009d10 <z_arm_init_arch_hw_at_boot+0x48>)
 1009cf4:	f103 0160 	add.w	r1, r3, #96	; 0x60
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
 1009cf8:	3301      	adds	r3, #1
 1009cfa:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
 1009cfc:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
 1009d00:	d1f8      	bne.n	1009cf4 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
 1009d02:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
 1009d04:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1009d08:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
 1009d0c:	bd10      	pop	{r4, pc}
 1009d0e:	bf00      	nop
 1009d10:	e000e100 	.word	0xe000e100

01009d14 <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
 1009d14:	4b08      	ldr	r3, [pc, #32]	; (1009d38 <z_impl_k_thread_abort+0x24>)
 1009d16:	689b      	ldr	r3, [r3, #8]
 1009d18:	4283      	cmp	r3, r0
 1009d1a:	d10b      	bne.n	1009d34 <z_impl_k_thread_abort+0x20>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 1009d1c:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
 1009d20:	b143      	cbz	r3, 1009d34 <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 1009d22:	4b06      	ldr	r3, [pc, #24]	; (1009d3c <z_impl_k_thread_abort+0x28>)
 1009d24:	685a      	ldr	r2, [r3, #4]
 1009d26:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 1009d2a:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
 1009d2c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 1009d2e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 1009d32:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
 1009d34:	f001 bfde 	b.w	100bcf4 <z_thread_abort>
 1009d38:	2100028c 	.word	0x2100028c
 1009d3c:	e000ed00 	.word	0xe000ed00

01009d40 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
 1009d40:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	 * into account the unused SRAM area, as well.
	 */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_static_mpu_regions(static_regions,
 1009d42:	4c09      	ldr	r4, [pc, #36]	; (1009d68 <z_arm_configure_static_mpu_regions+0x28>)
 1009d44:	4a09      	ldr	r2, [pc, #36]	; (1009d6c <z_arm_configure_static_mpu_regions+0x2c>)
 1009d46:	4623      	mov	r3, r4
 1009d48:	2101      	movs	r1, #1
 1009d4a:	4809      	ldr	r0, [pc, #36]	; (1009d70 <z_arm_configure_static_mpu_regions+0x30>)
 1009d4c:	f000 f8ea 	bl	1009f24 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
 1009d50:	2300      	movs	r3, #0
 1009d52:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
 1009d54:	4b07      	ldr	r3, [pc, #28]	; (1009d74 <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 1009d56:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
 1009d58:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 1009d5a:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
 1009d5c:	9301      	str	r3, [sp, #4]
 1009d5e:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 1009d60:	f000 f8ea 	bl	1009f38 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
 1009d64:	b004      	add	sp, #16
 1009d66:	bd10      	pop	{r4, pc}
 1009d68:	21010000 	.word	0x21010000
 1009d6c:	21000000 	.word	0x21000000
 1009d70:	0100ca88 	.word	0x0100ca88
 1009d74:	21000090 	.word	0x21000090

01009d78 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
 1009d78:	b510      	push	{r4, lr}
	mpu_set_region(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
		| (region_conf->attr.rbar &
 1009d7a:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
 1009d7c:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
 1009d7e:	f004 021f 	and.w	r2, r4, #31
		(region_conf->base & MPU_RBAR_BASE_Msk)
 1009d82:	f023 031f 	bic.w	r3, r3, #31
		| (region_conf->attr.rbar &
 1009d86:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
 1009d88:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
 1009d8a:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
 1009d8c:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = rnr;
 1009d90:	4905      	ldr	r1, [pc, #20]	; (1009da8 <region_init+0x30>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
 1009d92:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
 1009d96:	f043 0301 	orr.w	r3, r3, #1
	MPU->RNR = rnr;
 1009d9a:	f8c1 0098 	str.w	r0, [r1, #152]	; 0x98
	MPU->RBAR = rbar;
 1009d9e:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
	MPU->RLAR = rlar;
 1009da2:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
 1009da6:	bd10      	pop	{r4, pc}
 1009da8:	e000ed00 	.word	0xe000ed00

01009dac <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
 1009dac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1009db0:	460f      	mov	r7, r1
 1009db2:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
 1009db4:	4606      	mov	r6, r0
 1009db6:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = rnr;
 1009dba:	4d4e      	ldr	r5, [pc, #312]	; (1009ef4 <mpu_configure_regions_and_partition.constprop.0+0x148>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
 1009dbc:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
 1009dbe:	45b8      	cmp	r8, r7
 1009dc0:	f280 8094 	bge.w	1009eec <mpu_configure_regions_and_partition.constprop.0+0x140>
		if (regions[i].size == 0U) {
 1009dc4:	f8d6 9004 	ldr.w	r9, [r6, #4]
 1009dc8:	f1b9 0f00 	cmp.w	r9, #0
 1009dcc:	d036      	beq.n	1009e3c <mpu_configure_regions_and_partition.constprop.0+0x90>
		&&
 1009dce:	f1b9 0f1f 	cmp.w	r9, #31
 1009dd2:	f240 8089 	bls.w	1009ee8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		&&
 1009dd6:	f019 0f1f 	tst.w	r9, #31
 1009dda:	f040 8085 	bne.w	1009ee8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		((part->start &
 1009dde:	f8d6 a000 	ldr.w	sl, [r6]
		&&
 1009de2:	f01a 0f1f 	tst.w	sl, #31
 1009de6:	d17f      	bne.n	1009ee8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
 1009de8:	4650      	mov	r0, sl
 1009dea:	f002 faaa 	bl	100c342 <arm_cmse_mpu_region_get>
 1009dee:	4683      	mov	fp, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 1009df0:	eb09 000a 	add.w	r0, r9, sl
 1009df4:	3801      	subs	r0, #1
 1009df6:	f002 faa4 	bl	100c342 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
 1009dfa:	4583      	cmp	fp, r0
 1009dfc:	d174      	bne.n	1009ee8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		 * inside which the new region will be configured.
		 */
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
 1009dfe:	f11b 0f16 	cmn.w	fp, #22
 1009e02:	d071      	beq.n	1009ee8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
 1009e04:	455c      	cmp	r4, fp
 1009e06:	dd6f      	ble.n	1009ee8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	MPU->RNR = rnr;
 1009e08:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
 1009e0c:	f8d5 109c 	ldr.w	r1, [r5, #156]	; 0x9c
	MPU->RNR = rnr;
 1009e10:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RLAR;
 1009e14:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	return mpu_get_rbar() & MPU_RBAR_BASE_Msk;
 1009e18:	f021 011f 	bic.w	r1, r1, #31
	return (mpu_get_rlar() & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
 1009e1c:	f043 0a1f 	orr.w	sl, r3, #31
		 * The new memory region is to be placed inside the underlying
		 * region, possibly splitting the underlying region into two.
		 */
		uint32_t u_reg_base = mpu_region_get_base(u_reg_index);
		uint32_t u_reg_last = mpu_region_get_last_addr(u_reg_index);
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
 1009e20:	e9d6 3200 	ldrd	r3, r2, [r6]
 1009e24:	441a      	add	r2, r3

		if ((regions[i].start == u_reg_base) &&
 1009e26:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
 1009e28:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
		if ((regions[i].start == u_reg_base) &&
 1009e2c:	d11e      	bne.n	1009e6c <mpu_configure_regions_and_partition.constprop.0+0xc0>
 1009e2e:	45ca      	cmp	sl, r9
 1009e30:	d108      	bne.n	1009e44 <mpu_configure_regions_and_partition.constprop.0+0x98>
			 * underlying region. In this case we simply
			 * update the partition attributes of the
			 * underlying region with those of the new
			 * region.
			 */
			mpu_configure_region(u_reg_index, &regions[i]);
 1009e32:	4631      	mov	r1, r6
 1009e34:	fa5f f08b 	uxtb.w	r0, fp
 1009e38:	f002 fa8c 	bl	100c354 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
 1009e3c:	f108 0801 	add.w	r8, r8, #1
 1009e40:	360c      	adds	r6, #12
 1009e42:	e7bc      	b.n	1009dbe <mpu_configure_regions_and_partition.constprop.0+0x12>
			 */
			mpu_region_set_base(u_reg_index,
				regions[i].start + regions[i].size);

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);
 1009e44:	4631      	mov	r1, r6
	MPU->RNR = rnr;
 1009e46:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
 1009e4a:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
		     | (base & MPU_RBAR_BASE_Msk));
 1009e4e:	f022 021f 	bic.w	r2, r2, #31
	mpu_set_rbar((mpu_get_rbar() & (~MPU_RBAR_BASE_Msk))
 1009e52:	f003 031f 	and.w	r3, r3, #31
		     | (base & MPU_RBAR_BASE_Msk));
 1009e56:	4313      	orrs	r3, r2
	MPU->RBAR = rbar;
 1009e58:	f8c5 309c 	str.w	r3, [r5, #156]	; 0x9c
				mpu_configure_region(reg_index, &regions[i]);
 1009e5c:	b2e0      	uxtb	r0, r4
			 */
			mpu_region_set_limit(u_reg_index,
				regions[i].start - 1);

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);
 1009e5e:	f002 fa79 	bl	100c354 <mpu_configure_region>

			if (reg_index == -EINVAL) {
 1009e62:	f110 0f16 	cmn.w	r0, #22
 1009e66:	d03f      	beq.n	1009ee8 <mpu_configure_regions_and_partition.constprop.0+0x13c>

			if (reg_index == -EINVAL) {
				return reg_index;
			}

			reg_index++;
 1009e68:	1c44      	adds	r4, r0, #1
 1009e6a:	e7e7      	b.n	1009e3c <mpu_configure_regions_and_partition.constprop.0+0x90>
	MPU->RNR = rnr;
 1009e6c:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RLAR;
 1009e70:	f8d5 20a0 	ldr.w	r2, [r5, #160]	; 0xa0
				regions[i].start - 1);
 1009e74:	3b01      	subs	r3, #1
		     | (limit & MPU_RLAR_LIMIT_Msk));
 1009e76:	f023 031f 	bic.w	r3, r3, #31
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
 1009e7a:	f002 021f 	and.w	r2, r2, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
 1009e7e:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
 1009e80:	45ca      	cmp	sl, r9
				mpu_configure_region(reg_index, &regions[i]);
 1009e82:	4631      	mov	r1, r6
				mpu_configure_region(reg_index, &regions[i]);
 1009e84:	b2e0      	uxtb	r0, r4
	MPU->RLAR = rlar;
 1009e86:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
		} else if (reg_last == u_reg_last) {
 1009e8a:	d0e8      	beq.n	1009e5e <mpu_configure_regions_and_partition.constprop.0+0xb2>
				mpu_configure_region(reg_index, &regions[i]);
 1009e8c:	f002 fa62 	bl	100c354 <mpu_configure_region>
			if (reg_index == -EINVAL) {
 1009e90:	f110 0f16 	cmn.w	r0, #22
 1009e94:	d028      	beq.n	1009ee8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	MPU->RNR = rnr;
 1009e96:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
 1009e9a:	f8d5 209c 	ldr.w	r2, [r5, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
 1009e9e:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
 1009ea2:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
	attr->rbar = mpu_get_rbar() &
 1009ea6:	f362 0304 	bfi	r3, r2, #0, #5
 1009eaa:	f88d 3008 	strb.w	r3, [sp, #8]
	return MPU->RLAR;
 1009eae:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
 1009eb2:	f89d 2008 	ldrb.w	r2, [sp, #8]
 1009eb6:	085b      	lsrs	r3, r3, #1
 1009eb8:	f363 1247 	bfi	r2, r3, #5, #3
 1009ebc:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
 1009ec0:	e9d6 3200 	ldrd	r3, r2, [r6]
 1009ec4:	4413      	add	r3, r2
 1009ec6:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
 1009ec8:	f023 031f 	bic.w	r3, r3, #31
			reg_index++;
 1009ecc:	1c41      	adds	r1, r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
 1009ece:	4453      	add	r3, sl
 1009ed0:	eba3 0309 	sub.w	r3, r3, r9
 1009ed4:	b2c8      	uxtb	r0, r1
 1009ed6:	f023 031f 	bic.w	r3, r3, #31

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
 1009eda:	2807      	cmp	r0, #7
			fill_region.attr.r_limit =
 1009edc:	9303      	str	r3, [sp, #12]
 1009ede:	d803      	bhi.n	1009ee8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
 1009ee0:	4669      	mov	r1, sp
 1009ee2:	f7ff ff49 	bl	1009d78 <region_init>
 1009ee6:	e7bf      	b.n	1009e68 <mpu_configure_regions_and_partition.constprop.0+0xbc>
			return -EINVAL;
 1009ee8:	f06f 0415 	mvn.w	r4, #21
		}
	}

	return reg_index;
}
 1009eec:	4620      	mov	r0, r4
 1009eee:	b005      	add	sp, #20
 1009ef0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1009ef4:	e000ed00 	.word	0xe000ed00

01009ef8 <arm_core_mpu_enable>:
	 * background region for privileged software access if desired.
	 */
#if defined(CONFIG_MPU_DISABLE_BACKGROUND_MAP)
	MPU->CTRL = MPU_CTRL_ENABLE_Msk;
#else
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
 1009ef8:	2205      	movs	r2, #5
 1009efa:	4b04      	ldr	r3, [pc, #16]	; (1009f0c <arm_core_mpu_enable+0x14>)
 1009efc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
 1009f00:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1009f04:	f3bf 8f6f 	isb	sy
#endif

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
 1009f08:	4770      	bx	lr
 1009f0a:	bf00      	nop
 1009f0c:	e000ed00 	.word	0xe000ed00

01009f10 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
 1009f10:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
 1009f14:	2200      	movs	r2, #0
 1009f16:	4b02      	ldr	r3, [pc, #8]	; (1009f20 <arm_core_mpu_disable+0x10>)
 1009f18:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
 1009f1c:	4770      	bx	lr
 1009f1e:	bf00      	nop
 1009f20:	e000ed00 	.word	0xe000ed00

01009f24 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	*static_regions, const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
 1009f24:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
 1009f26:	4c03      	ldr	r4, [pc, #12]	; (1009f34 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
 1009f28:	7822      	ldrb	r2, [r4, #0]
 1009f2a:	f7ff ff3f 	bl	1009dac <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
 1009f2e:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
 1009f30:	bd10      	pop	{r4, pc}
 1009f32:	bf00      	nop
 1009f34:	210002be 	.word	0x210002be

01009f38 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
 1009f38:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1009f3c:	4d29      	ldr	r5, [pc, #164]	; (1009fe4 <arm_core_mpu_mark_areas_for_dynamic_regions+0xac>)
 1009f3e:	468a      	mov	sl, r1

/* This internal function marks and stores the configuration of memory areas
 * where dynamic region programming is allowed. Return zero on success, or
 * -EINVAL on error.
 */
static int mpu_mark_areas_for_dynamic_regions(
 1009f40:	4606      	mov	r6, r0
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
 1009f42:	f04f 0800 	mov.w	r8, #0
 1009f46:	46ab      	mov	fp, r5
	MPU->RNR = rnr;
 1009f48:	4f27      	ldr	r7, [pc, #156]	; (1009fe8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb0>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
 1009f4a:	45d0      	cmp	r8, sl
 1009f4c:	da1b      	bge.n	1009f86 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
 1009f4e:	f8d6 9004 	ldr.w	r9, [r6, #4]
 1009f52:	f1b9 0f00 	cmp.w	r9, #0
 1009f56:	d03f      	beq.n	1009fd8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
 1009f58:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
 1009f5a:	4608      	mov	r0, r1
 1009f5c:	9101      	str	r1, [sp, #4]
 1009f5e:	f002 f9f0 	bl	100c342 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 1009f62:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
 1009f64:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 1009f66:	eb09 0001 	add.w	r0, r9, r1
 1009f6a:	3801      	subs	r0, #1
 1009f6c:	f002 f9e9 	bl	100c342 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
 1009f70:	4284      	cmp	r4, r0
 1009f72:	f04f 0214 	mov.w	r2, #20
 1009f76:	4b1d      	ldr	r3, [pc, #116]	; (1009fec <arm_core_mpu_mark_areas_for_dynamic_regions+0xb4>)
 1009f78:	d008      	beq.n	1009f8c <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
 1009f7a:	fb02 f308 	mul.w	r3, r2, r8
 1009f7e:	f06f 0215 	mvn.w	r2, #21
 1009f82:	f84b 2003 	str.w	r2, [fp, r3]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
 1009f86:	b003      	add	sp, #12
 1009f88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
 1009f8c:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
 1009f90:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
 1009f92:	d0f8      	beq.n	1009f86 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
 1009f94:	7819      	ldrb	r1, [r3, #0]
 1009f96:	42a1      	cmp	r1, r4
 1009f98:	ddf5      	ble.n	1009f86 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = mpu_get_rbar() &
 1009f9a:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = rnr;
 1009f9e:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
 1009fa2:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
	return MPU->RBAR;
 1009fa6:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
 1009faa:	f100 0108 	add.w	r1, r0, #8
 1009fae:	7b00      	ldrb	r0, [r0, #12]
 1009fb0:	f364 0004 	bfi	r0, r4, #0, #5
 1009fb4:	7108      	strb	r0, [r1, #4]
	return MPU->RLAR;
 1009fb6:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
 1009fba:	790c      	ldrb	r4, [r1, #4]
 1009fbc:	0840      	lsrs	r0, r0, #1
 1009fbe:	f360 1447 	bfi	r4, r0, #5, #3
 1009fc2:	710c      	strb	r4, [r1, #4]
	return MPU->RBAR;
 1009fc4:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
	region_conf->base = mpu_get_rbar() & MPU_RBAR_BASE_Msk;
 1009fc8:	f021 011f 	bic.w	r1, r1, #31
 1009fcc:	6069      	str	r1, [r5, #4]
	return MPU->RLAR;
 1009fce:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
	region_conf->attr.r_limit = mpu_get_rlar() & MPU_RLAR_LIMIT_Msk;
 1009fd2:	f021 011f 	bic.w	r1, r1, #31
 1009fd6:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
 1009fd8:	f108 0801 	add.w	r8, r8, #1
 1009fdc:	3514      	adds	r5, #20
 1009fde:	360c      	adds	r6, #12
 1009fe0:	e7b3      	b.n	1009f4a <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
 1009fe2:	bf00      	nop
 1009fe4:	210001e4 	.word	0x210001e4
 1009fe8:	e000ed00 	.word	0xe000ed00
 1009fec:	210002be 	.word	0x210002be

01009ff0 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
 1009ff0:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
 1009ff2:	4d0e      	ldr	r5, [pc, #56]	; (100a02c <z_arm_mpu_init+0x3c>)
 1009ff4:	682c      	ldr	r4, [r5, #0]
 1009ff6:	2c08      	cmp	r4, #8
 1009ff8:	d815      	bhi.n	100a026 <z_arm_mpu_init+0x36>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 1009ffa:	2000      	movs	r0, #0
	arm_core_mpu_disable();
 1009ffc:	f7ff ff88 	bl	1009f10 <arm_core_mpu_disable>
	MPU->MAIR0 = mair0;
 100a000:	4b0b      	ldr	r3, [pc, #44]	; (100a030 <z_arm_mpu_init+0x40>)
 100a002:	4a0c      	ldr	r2, [pc, #48]	; (100a034 <z_arm_mpu_init+0x44>)
 100a004:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 100a008:	4284      	cmp	r4, r0
 100a00a:	d105      	bne.n	100a018 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
 100a00c:	4b0a      	ldr	r3, [pc, #40]	; (100a038 <z_arm_mpu_init+0x48>)
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
 100a00e:	2000      	movs	r0, #0
	static_regions_num = mpu_config.num_regions;
 100a010:	701c      	strb	r4, [r3, #0]
	arm_core_mpu_enable();
 100a012:	f7ff ff71 	bl	1009ef8 <arm_core_mpu_enable>
}
 100a016:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
 100a018:	6869      	ldr	r1, [r5, #4]
 100a01a:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 100a01e:	f7ff feab 	bl	1009d78 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 100a022:	3001      	adds	r0, #1
 100a024:	e7f0      	b.n	100a008 <z_arm_mpu_init+0x18>
		return -1;
 100a026:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 100a02a:	e7f4      	b.n	100a016 <z_arm_mpu_init+0x26>
 100a02c:	0100ca94 	.word	0x0100ca94
 100a030:	e000ed00 	.word	0xe000ed00
 100a034:	0044ffaa 	.word	0x0044ffaa
 100a038:	210002be 	.word	0x210002be

0100a03c <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
 100a03c:	4b08      	ldr	r3, [pc, #32]	; (100a060 <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
 100a03e:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
 100a040:	1ac3      	subs	r3, r0, r3
{
 100a042:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
 100a044:	4907      	ldr	r1, [pc, #28]	; (100a064 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
 100a046:	109b      	asrs	r3, r3, #2
{
 100a048:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
 100a04a:	4359      	muls	r1, r3
 100a04c:	2240      	movs	r2, #64	; 0x40
 100a04e:	4806      	ldr	r0, [pc, #24]	; (100a068 <onoff_stop+0x2c>)
 100a050:	f002 f9ed 	bl	100c42e <stop>
	notify(mgr, res);
 100a054:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
 100a056:	4601      	mov	r1, r0
	notify(mgr, res);
 100a058:	4620      	mov	r0, r4
}
 100a05a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
 100a05e:	4718      	bx	r3
 100a060:	2100020c 	.word	0x2100020c
 100a064:	b6db6db7 	.word	0xb6db6db7
 100a068:	0100c8c8 	.word	0x0100c8c8

0100a06c <onoff_start>:
static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 100a06c:	2340      	movs	r3, #64	; 0x40
{
 100a06e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
 100a070:	4c0b      	ldr	r4, [pc, #44]	; (100a0a0 <onoff_start+0x34>)
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 100a072:	9300      	str	r3, [sp, #0]
	size_t offset = (size_t)(mgr - data->mgr);
 100a074:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 100a076:	460b      	mov	r3, r1
{
 100a078:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 100a07a:	490a      	ldr	r1, [pc, #40]	; (100a0a4 <onoff_start+0x38>)
	size_t offset = (size_t)(mgr - data->mgr);
 100a07c:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 100a07e:	4361      	muls	r1, r4
{
 100a080:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
 100a082:	4a09      	ldr	r2, [pc, #36]	; (100a0a8 <onoff_start+0x3c>)
 100a084:	4809      	ldr	r0, [pc, #36]	; (100a0ac <onoff_start+0x40>)
 100a086:	f002 f9ff 	bl	100c488 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
 100a08a:	1e01      	subs	r1, r0, #0
 100a08c:	da05      	bge.n	100a09a <onoff_start+0x2e>
		notify(mgr, err);
 100a08e:	4630      	mov	r0, r6
 100a090:	462b      	mov	r3, r5
	}
}
 100a092:	b002      	add	sp, #8
 100a094:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
 100a098:	4718      	bx	r3
}
 100a09a:	b002      	add	sp, #8
 100a09c:	bd70      	pop	{r4, r5, r6, pc}
 100a09e:	bf00      	nop
 100a0a0:	2100020c 	.word	0x2100020c
 100a0a4:	b6db6db7 	.word	0xb6db6db7
 100a0a8:	0100c4f5 	.word	0x0100c4f5
 100a0ac:	0100c8c8 	.word	0x0100c8c8

0100a0b0 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
 100a0b0:	b570      	push	{r4, r5, r6, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 100a0b2:	2200      	movs	r2, #0
 100a0b4:	2101      	movs	r1, #1
{
 100a0b6:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 100a0b8:	2005      	movs	r0, #5
 100a0ba:	f7ff fb9f 	bl	10097fc <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
 100a0be:	480f      	ldr	r0, [pc, #60]	; (100a0fc <clk_init+0x4c>)
 100a0c0:	f000 fdb6 	bl	100ac30 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
 100a0c4:	4b0e      	ldr	r3, [pc, #56]	; (100a100 <clk_init+0x50>)
 100a0c6:	4298      	cmp	r0, r3
 100a0c8:	d115      	bne.n	100a0f6 <clk_init+0x46>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
 100a0ca:	f000 fdc1 	bl	100ac50 <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
 100a0ce:	6926      	ldr	r6, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
 100a0d0:	490c      	ldr	r1, [pc, #48]	; (100a104 <clk_init+0x54>)
 100a0d2:	4630      	mov	r0, r6
 100a0d4:	f002 f839 	bl	100c14a <onoff_manager_init>
					 &transitions);
		if (err < 0) {
 100a0d8:	2800      	cmp	r0, #0
 100a0da:	db0b      	blt.n	100a0f4 <clk_init+0x44>
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
 100a0dc:	2501      	movs	r5, #1
 100a0de:	6435      	str	r5, [r6, #64]	; 0x40
	struct nrf_clock_control_data *data = dev->data;
 100a0e0:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
 100a0e2:	4908      	ldr	r1, [pc, #32]	; (100a104 <clk_init+0x54>)
 100a0e4:	f104 001c 	add.w	r0, r4, #28
 100a0e8:	f002 f82f 	bl	100c14a <onoff_manager_init>
		if (err < 0) {
 100a0ec:	2800      	cmp	r0, #0
 100a0ee:	db01      	blt.n	100a0f4 <clk_init+0x44>
	}

	return 0;
 100a0f0:	2000      	movs	r0, #0
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
 100a0f2:	64e5      	str	r5, [r4, #76]	; 0x4c
}
 100a0f4:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
 100a0f6:	f06f 0004 	mvn.w	r0, #4
 100a0fa:	e7fb      	b.n	100a0f4 <clk_init+0x44>
 100a0fc:	0100a13d 	.word	0x0100a13d
 100a100:	0bad0000 	.word	0x0bad0000
 100a104:	0100cabc 	.word	0x0100cabc

0100a108 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
 100a108:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
 100a10a:	230c      	movs	r3, #12
	sub_data->cb = NULL;
 100a10c:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
 100a10e:	434b      	muls	r3, r1
static void clkstarted_handle(const struct device *dev,
 100a110:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
 100a112:	4808      	ldr	r0, [pc, #32]	; (100a134 <clkstarted_handle.constprop.0+0x2c>)
 100a114:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
 100a116:	3340      	adds	r3, #64	; 0x40
 100a118:	4418      	add	r0, r3
	void *user_data = sub_data->user_data;
 100a11a:	e9d4 560e 	ldrd	r5, r6, [r4, #56]	; 0x38
	sub_data->cb = NULL;
 100a11e:	63a2      	str	r2, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
 100a120:	f002 f972 	bl	100c408 <set_on_state>
	if (callback) {
 100a124:	b12d      	cbz	r5, 100a132 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
 100a126:	4632      	mov	r2, r6
 100a128:	462b      	mov	r3, r5
}
 100a12a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
 100a12e:	4802      	ldr	r0, [pc, #8]	; (100a138 <clkstarted_handle.constprop.0+0x30>)
 100a130:	4718      	bx	r3
}
 100a132:	bd70      	pop	{r4, r5, r6, pc}
 100a134:	2100020c 	.word	0x2100020c
 100a138:	0100c8c8 	.word	0x0100c8c8

0100a13c <clock_event_handler>:
	switch (event) {
 100a13c:	b110      	cbz	r0, 100a144 <clock_event_handler+0x8>
 100a13e:	2801      	cmp	r0, #1
 100a140:	d004      	beq.n	100a14c <clock_event_handler+0x10>
 100a142:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
 100a144:	4b03      	ldr	r3, [pc, #12]	; (100a154 <clock_event_handler+0x18>)
 100a146:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 100a148:	075b      	lsls	r3, r3, #29
 100a14a:	d101      	bne.n	100a150 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
 100a14c:	f7ff bfdc 	b.w	100a108 <clkstarted_handle.constprop.0>
}
 100a150:	4770      	bx	lr
 100a152:	bf00      	nop
 100a154:	2100020c 	.word	0x2100020c

0100a158 <generic_hfclk_start>:
{
 100a158:	b508      	push	{r3, lr}
	__asm__ volatile(
 100a15a:	f04f 0320 	mov.w	r3, #32
 100a15e:	f3ef 8111 	mrs	r1, BASEPRI
 100a162:	f383 8812 	msr	BASEPRI_MAX, r3
 100a166:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
 100a16a:	4a11      	ldr	r2, [pc, #68]	; (100a1b0 <generic_hfclk_start+0x58>)
 100a16c:	6813      	ldr	r3, [r2, #0]
 100a16e:	f043 0002 	orr.w	r0, r3, #2
 100a172:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
 100a174:	07da      	lsls	r2, r3, #31
 100a176:	d408      	bmi.n	100a18a <generic_hfclk_start+0x32>
	__asm__ volatile(
 100a178:	f381 8811 	msr	BASEPRI, r1
 100a17c:	f3bf 8f6f 	isb	sy
}
 100a180:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
 100a184:	2001      	movs	r0, #1
 100a186:	f000 bd75 	b.w	100ac74 <nrfx_clock_start>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
 100a18a:	4b0a      	ldr	r3, [pc, #40]	; (100a1b4 <generic_hfclk_start+0x5c>)
 100a18c:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 100a190:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
 100a194:	07d3      	lsls	r3, r2, #31
 100a196:	d5ef      	bpl.n	100a178 <generic_hfclk_start+0x20>
			set_on_state(get_hf_flags());
 100a198:	4807      	ldr	r0, [pc, #28]	; (100a1b8 <generic_hfclk_start+0x60>)
 100a19a:	f002 f935 	bl	100c408 <set_on_state>
 100a19e:	f381 8811 	msr	BASEPRI, r1
 100a1a2:	f3bf 8f6f 	isb	sy
}
 100a1a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
 100a1aa:	2000      	movs	r0, #0
 100a1ac:	f7ff bfac 	b.w	100a108 <clkstarted_handle.constprop.0>
 100a1b0:	2100025c 	.word	0x2100025c
 100a1b4:	41005000 	.word	0x41005000
 100a1b8:	2100024c 	.word	0x2100024c

0100a1bc <api_blocking_start>:
{
 100a1bc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
 100a1be:	2200      	movs	r2, #0
 100a1c0:	2301      	movs	r3, #1
 100a1c2:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
 100a1c6:	466b      	mov	r3, sp
 100a1c8:	4a08      	ldr	r2, [pc, #32]	; (100a1ec <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
 100a1ca:	f8cd d000 	str.w	sp, [sp]
 100a1ce:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
 100a1d2:	f002 f988 	bl	100c4e6 <api_start>
	if (err < 0) {
 100a1d6:	2800      	cmp	r0, #0
 100a1d8:	db05      	blt.n	100a1e6 <api_blocking_start+0x2a>
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke3(parm0.x, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
 100a1da:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 100a1de:	2300      	movs	r3, #0
 100a1e0:	4668      	mov	r0, sp
 100a1e2:	f001 fac3 	bl	100b76c <z_impl_k_sem_take>
}
 100a1e6:	b005      	add	sp, #20
 100a1e8:	f85d fb04 	ldr.w	pc, [sp], #4
 100a1ec:	0100c513 	.word	0x0100c513

0100a1f0 <generic_hfclk_stop>:
{
 100a1f0:	b510      	push	{r4, lr}
	__asm__ volatile(
 100a1f2:	f04f 0320 	mov.w	r3, #32
 100a1f6:	f3ef 8411 	mrs	r4, BASEPRI
 100a1fa:	f383 8812 	msr	BASEPRI_MAX, r3
 100a1fe:	f3bf 8f6f 	isb	sy
	hfclk_users &= ~HF_USER_GENERIC;
 100a202:	4a07      	ldr	r2, [pc, #28]	; (100a220 <generic_hfclk_stop+0x30>)
 100a204:	6813      	ldr	r3, [r2, #0]
 100a206:	f023 0102 	bic.w	r1, r3, #2
	if (!(hfclk_users & HF_USER_BT)) {
 100a20a:	07db      	lsls	r3, r3, #31
	hfclk_users &= ~HF_USER_GENERIC;
 100a20c:	6011      	str	r1, [r2, #0]
	if (!(hfclk_users & HF_USER_BT)) {
 100a20e:	d402      	bmi.n	100a216 <generic_hfclk_stop+0x26>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
 100a210:	2001      	movs	r0, #1
 100a212:	f002 f9f0 	bl	100c5f6 <nrfx_clock_stop>
	__asm__ volatile(
 100a216:	f384 8811 	msr	BASEPRI, r4
 100a21a:	f3bf 8f6f 	isb	sy
}
 100a21e:	bd10      	pop	{r4, pc}
 100a220:	2100025c 	.word	0x2100025c

0100a224 <z_nrf_clock_control_lf_on>:
{
 100a224:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 100a228:	2201      	movs	r2, #1
 100a22a:	4607      	mov	r7, r0
 100a22c:	4935      	ldr	r1, [pc, #212]	; (100a304 <z_nrf_clock_control_lf_on+0xe0>)
 100a22e:	e8d1 3fef 	ldaex	r3, [r1]
 100a232:	e8c1 2fe0 	stlex	r0, r2, [r1]
 100a236:	2800      	cmp	r0, #0
 100a238:	d1f9      	bne.n	100a22e <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
 100a23a:	b933      	cbnz	r3, 100a24a <z_nrf_clock_control_lf_on+0x26>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
 100a23c:	4932      	ldr	r1, [pc, #200]	; (100a308 <z_nrf_clock_control_lf_on+0xe4>)
		err = onoff_request(mgr, &cli);
 100a23e:	4833      	ldr	r0, [pc, #204]	; (100a30c <z_nrf_clock_control_lf_on+0xe8>)
 100a240:	604b      	str	r3, [r1, #4]
 100a242:	60cb      	str	r3, [r1, #12]
 100a244:	608a      	str	r2, [r1, #8]
 100a246:	f001 ff93 	bl	100c170 <onoff_request>
	switch (start_mode) {
 100a24a:	1e7b      	subs	r3, r7, #1
 100a24c:	2b01      	cmp	r3, #1
 100a24e:	d828      	bhi.n	100a2a2 <z_nrf_clock_control_lf_on+0x7e>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
 100a250:	2f01      	cmp	r7, #1
 100a252:	d106      	bne.n	100a262 <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
 100a254:	4b2e      	ldr	r3, [pc, #184]	; (100a310 <z_nrf_clock_control_lf_on+0xec>)
 100a256:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
 100a25a:	f003 0303 	and.w	r3, r3, #3
 100a25e:	2b02      	cmp	r3, #2
 100a260:	d01f      	beq.n	100a2a2 <z_nrf_clock_control_lf_on+0x7e>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
 100a262:	f002 fa41 	bl	100c6e8 <k_is_in_isr>
 100a266:	4605      	mov	r5, r0
 100a268:	b9e8      	cbnz	r0, 100a2a6 <z_nrf_clock_control_lf_on+0x82>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
 100a26a:	4b2a      	ldr	r3, [pc, #168]	; (100a314 <z_nrf_clock_control_lf_on+0xf0>)
 100a26c:	781b      	ldrb	r3, [r3, #0]
 100a26e:	b1d3      	cbz	r3, 100a2a6 <z_nrf_clock_control_lf_on+0x82>
    p_reg->INTENCLR = mask;
 100a270:	2202      	movs	r2, #2
	int key = isr_mode ? irq_lock() : 0;
 100a272:	4606      	mov	r6, r0
 100a274:	4b26      	ldr	r3, [pc, #152]	; (100a310 <z_nrf_clock_control_lf_on+0xec>)
 100a276:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 100a27a:	4c25      	ldr	r4, [pc, #148]	; (100a310 <z_nrf_clock_control_lf_on+0xec>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 100a27c:	f8df 8098 	ldr.w	r8, [pc, #152]	; 100a318 <z_nrf_clock_control_lf_on+0xf4>
 100a280:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 100a284:	f8d4 2418 	ldr.w	r2, [r4, #1048]	; 0x418
 100a288:	03d2      	lsls	r2, r2, #15
 100a28a:	d516      	bpl.n	100a2ba <z_nrf_clock_control_lf_on+0x96>
	while (!(nrfx_clock_is_running(d, (void *)&type)
 100a28c:	f003 0303 	and.w	r3, r3, #3
 100a290:	2b02      	cmp	r3, #2
 100a292:	d001      	beq.n	100a298 <z_nrf_clock_control_lf_on+0x74>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
 100a294:	2f01      	cmp	r7, #1
 100a296:	d110      	bne.n	100a2ba <z_nrf_clock_control_lf_on+0x96>
	if (isr_mode) {
 100a298:	b375      	cbz	r5, 100a2f8 <z_nrf_clock_control_lf_on+0xd4>
 100a29a:	f386 8811 	msr	BASEPRI, r6
 100a29e:	f3bf 8f6f 	isb	sy
}
 100a2a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm__ volatile(
 100a2a6:	f04f 0320 	mov.w	r3, #32
 100a2aa:	f3ef 8611 	mrs	r6, BASEPRI
 100a2ae:	f383 8812 	msr	BASEPRI_MAX, r3
 100a2b2:	f3bf 8f6f 	isb	sy
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
 100a2b6:	2501      	movs	r5, #1
 100a2b8:	e7df      	b.n	100a27a <z_nrf_clock_control_lf_on+0x56>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
 100a2ba:	b1c5      	cbz	r5, 100a2ee <z_nrf_clock_control_lf_on+0xca>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
 100a2bc:	4630      	mov	r0, r6
 100a2be:	f7ff fa6b 	bl	1009798 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
 100a2c2:	f8d4 3518 	ldr.w	r3, [r4, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
 100a2c6:	b2db      	uxtb	r3, r3
 100a2c8:	2b01      	cmp	r3, #1
 100a2ca:	d1d9      	bne.n	100a280 <z_nrf_clock_control_lf_on+0x5c>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 100a2cc:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
 100a2d0:	2a00      	cmp	r2, #0
 100a2d2:	d0d5      	beq.n	100a280 <z_nrf_clock_control_lf_on+0x5c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100a2d4:	2200      	movs	r2, #0
 100a2d6:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
 100a2da:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
 100a2de:	2202      	movs	r2, #2
 100a2e0:	f8c4 2518 	str.w	r2, [r4, #1304]	; 0x518
 100a2e4:	2220      	movs	r2, #32
 100a2e6:	f8c8 2180 	str.w	r2, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 100a2ea:	60a3      	str	r3, [r4, #8]
}
 100a2ec:	e7c8      	b.n	100a280 <z_nrf_clock_control_lf_on+0x5c>
	return z_impl_k_sleep(timeout);
 100a2ee:	2100      	movs	r1, #0
 100a2f0:	2021      	movs	r0, #33	; 0x21
 100a2f2:	f001 fcdf 	bl	100bcb4 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
 100a2f6:	e7e4      	b.n	100a2c2 <z_nrf_clock_control_lf_on+0x9e>
    p_reg->INTENSET = mask;
 100a2f8:	2202      	movs	r2, #2
 100a2fa:	4b05      	ldr	r3, [pc, #20]	; (100a310 <z_nrf_clock_control_lf_on+0xec>)
 100a2fc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
 100a300:	e7cf      	b.n	100a2a2 <z_nrf_clock_control_lf_on+0x7e>
 100a302:	bf00      	nop
 100a304:	21000208 	.word	0x21000208
 100a308:	210001f8 	.word	0x210001f8
 100a30c:	21000228 	.word	0x21000228
 100a310:	41005000 	.word	0x41005000
 100a314:	210002bf 	.word	0x210002bf
 100a318:	e000e100 	.word	0xe000e100

0100a31c <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
 100a31c:	b530      	push	{r4, r5, lr}
	return port->config;
 100a31e:	6840      	ldr	r0, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
 100a320:	f001 041f 	and.w	r4, r1, #31
 100a324:	7b05      	ldrb	r5, [r0, #12]
	nrfx_err_t err;
	uint8_t ch;

	if (mode == GPIO_INT_MODE_DISABLED) {
 100a326:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
{
 100a32a:	b085      	sub	sp, #20
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
 100a32c:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
 100a330:	d105      	bne.n	100a33e <gpio_nrfx_pin_interrupt_configure+0x22>
		nrfx_gpiote_trigger_disable(abs_pin);
 100a332:	4620      	mov	r0, r4
 100a334:	f000 ff56 	bl	100b1e4 <nrfx_gpiote_trigger_disable>

		return 0;
 100a338:	2000      	movs	r0, #0
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
}
 100a33a:	b005      	add	sp, #20
 100a33c:	bd30      	pop	{r4, r5, pc}
	nrfx_gpiote_trigger_config_t trigger_config = {
 100a33e:	2500      	movs	r5, #0
	if (mode == GPIO_INT_MODE_LEVEL) {
 100a340:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
	nrfx_gpiote_trigger_config_t trigger_config = {
 100a344:	e9cd 5502 	strd	r5, r5, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
 100a348:	d114      	bne.n	100a374 <gpio_nrfx_pin_interrupt_configure+0x58>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
 100a34a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
	nrfx_gpiote_trigger_config_t trigger_config = {
 100a34e:	bf0c      	ite	eq
 100a350:	2304      	moveq	r3, #4
 100a352:	2305      	movne	r3, #5
 100a354:	f88d 3008 	strb.w	r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
 100a358:	2300      	movs	r3, #0
 100a35a:	4620      	mov	r0, r4
 100a35c:	4619      	mov	r1, r3
 100a35e:	aa02      	add	r2, sp, #8
 100a360:	f000 fd7c 	bl	100ae5c <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
 100a364:	4b1f      	ldr	r3, [pc, #124]	; (100a3e4 <gpio_nrfx_pin_interrupt_configure+0xc8>)
 100a366:	4298      	cmp	r0, r3
 100a368:	d138      	bne.n	100a3dc <gpio_nrfx_pin_interrupt_configure+0xc0>
	nrfx_gpiote_trigger_enable(abs_pin, true);
 100a36a:	2101      	movs	r1, #1
 100a36c:	4620      	mov	r0, r4
 100a36e:	f000 fef3 	bl	100b158 <nrfx_gpiote_trigger_enable>
	return 0;
 100a372:	e7e1      	b.n	100a338 <gpio_nrfx_pin_interrupt_configure+0x1c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
 100a374:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
 100a378:	d025      	beq.n	100a3c6 <gpio_nrfx_pin_interrupt_configure+0xaa>
 100a37a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 100a37e:	bf14      	ite	ne
 100a380:	2301      	movne	r3, #1
 100a382:	2302      	moveq	r3, #2
	nrfx_gpiote_trigger_config_t trigger_config = {
 100a384:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
 100a388:	6883      	ldr	r3, [r0, #8]
 100a38a:	40cb      	lsrs	r3, r1
 100a38c:	07d9      	lsls	r1, r3, #31
 100a38e:	d4e3      	bmi.n	100a358 <gpio_nrfx_pin_interrupt_configure+0x3c>
 100a390:	f1b2 7fa0 	cmp.w	r2, #20971520	; 0x1400000
 100a394:	d1e0      	bne.n	100a358 <gpio_nrfx_pin_interrupt_configure+0x3c>
        /* FALLTHROUGH */
        case 0: return NRF_P0;
#endif
#if defined(P1_FEATURE_PINS_PRESENT)
        /* FALLTHROUGH */
        case 1: return NRF_P1;
 100a396:	4a14      	ldr	r2, [pc, #80]	; (100a3e8 <gpio_nrfx_pin_interrupt_configure+0xcc>)
 100a398:	4814      	ldr	r0, [pc, #80]	; (100a3ec <gpio_nrfx_pin_interrupt_configure+0xd0>)
NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;

    return pin_number >> 5;
 100a39a:	0961      	lsrs	r1, r4, #5
        case 1: return NRF_P1;
 100a39c:	2901      	cmp	r1, #1
 100a39e:	bf08      	it	eq
 100a3a0:	4602      	moveq	r2, r0
    *p_pin = pin_number & 0x1F;
 100a3a2:	f004 031f 	and.w	r3, r4, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
 100a3a6:	3380      	adds	r3, #128	; 0x80
 100a3a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
 100a3ac:	07db      	lsls	r3, r3, #31
 100a3ae:	d4d3      	bmi.n	100a358 <gpio_nrfx_pin_interrupt_configure+0x3c>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
 100a3b0:	f10d 0507 	add.w	r5, sp, #7
 100a3b4:	4629      	mov	r1, r5
 100a3b6:	4620      	mov	r0, r4
 100a3b8:	f000 fe7a 	bl	100b0b0 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
 100a3bc:	4b0c      	ldr	r3, [pc, #48]	; (100a3f0 <gpio_nrfx_pin_interrupt_configure+0xd4>)
 100a3be:	4298      	cmp	r0, r3
 100a3c0:	d003      	beq.n	100a3ca <gpio_nrfx_pin_interrupt_configure+0xae>
		trigger_config.p_in_channel = &ch;
 100a3c2:	9503      	str	r5, [sp, #12]
 100a3c4:	e7c8      	b.n	100a358 <gpio_nrfx_pin_interrupt_configure+0x3c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
 100a3c6:	2303      	movs	r3, #3
 100a3c8:	e7dc      	b.n	100a384 <gpio_nrfx_pin_interrupt_configure+0x68>
			err = nrfx_gpiote_channel_alloc(&ch);
 100a3ca:	4628      	mov	r0, r5
 100a3cc:	f000 febe 	bl	100b14c <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
 100a3d0:	4b04      	ldr	r3, [pc, #16]	; (100a3e4 <gpio_nrfx_pin_interrupt_configure+0xc8>)
 100a3d2:	4298      	cmp	r0, r3
 100a3d4:	d0f5      	beq.n	100a3c2 <gpio_nrfx_pin_interrupt_configure+0xa6>
				return -ENOMEM;
 100a3d6:	f06f 000b 	mvn.w	r0, #11
 100a3da:	e7ae      	b.n	100a33a <gpio_nrfx_pin_interrupt_configure+0x1e>
		return -EINVAL;
 100a3dc:	f06f 0015 	mvn.w	r0, #21
 100a3e0:	e7ab      	b.n	100a33a <gpio_nrfx_pin_interrupt_configure+0x1e>
 100a3e2:	bf00      	nop
 100a3e4:	0bad0000 	.word	0x0bad0000
 100a3e8:	418c0500 	.word	0x418c0500
 100a3ec:	418c0800 	.word	0x418c0800
 100a3f0:	0bad0004 	.word	0x0bad0004

0100a3f4 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
 100a3f4:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
 100a3f6:	f000 fe99 	bl	100b12c <nrfx_gpiote_is_init>
 100a3fa:	4604      	mov	r4, r0
 100a3fc:	b968      	cbnz	r0, 100a41a <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
 100a3fe:	f000 fe6d 	bl	100b0dc <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
 100a402:	4b08      	ldr	r3, [pc, #32]	; (100a424 <gpio_nrfx_init+0x30>)
 100a404:	4298      	cmp	r0, r3
 100a406:	d10a      	bne.n	100a41e <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
 100a408:	4621      	mov	r1, r4
 100a40a:	4807      	ldr	r0, [pc, #28]	; (100a428 <gpio_nrfx_init+0x34>)
 100a40c:	f000 fe4a 	bl	100b0a4 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
 100a410:	4622      	mov	r2, r4
 100a412:	2105      	movs	r1, #5
 100a414:	200a      	movs	r0, #10
 100a416:	f7ff f9f1 	bl	10097fc <z_arm_irq_priority_set>
		return 0;
 100a41a:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
 100a41c:	bd10      	pop	{r4, pc}
		return -EIO;
 100a41e:	f06f 0004 	mvn.w	r0, #4
 100a422:	e7fb      	b.n	100a41c <gpio_nrfx_init+0x28>
 100a424:	0bad0000 	.word	0x0bad0000
 100a428:	0100a42d 	.word	0x0100a42d

0100a42c <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
 100a42c:	0942      	lsrs	r2, r0, #5
{
 100a42e:	4603      	mov	r3, r0
 100a430:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
 100a432:	d002      	beq.n	100a43a <nrfx_gpio_handler+0xe>
 100a434:	2a01      	cmp	r2, #1
 100a436:	d017      	beq.n	100a468 <nrfx_gpio_handler+0x3c>
}
 100a438:	bd70      	pop	{r4, r5, r6, pc}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
 100a43a:	4e0d      	ldr	r6, [pc, #52]	; (100a470 <nrfx_gpio_handler+0x44>)
	gpio_fire_callbacks(list, port, BIT(pin));
 100a43c:	6932      	ldr	r2, [r6, #16]
 100a43e:	6851      	ldr	r1, [r2, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 100a440:	2900      	cmp	r1, #0
 100a442:	d0f9      	beq.n	100a438 <nrfx_gpio_handler+0xc>
 100a444:	2501      	movs	r5, #1
    *p_pin = pin_number & 0x1F;
 100a446:	f003 031f 	and.w	r3, r3, #31
	return node->next;
 100a44a:	680c      	ldr	r4, [r1, #0]
 100a44c:	409d      	lsls	r5, r3
 100a44e:	2900      	cmp	r1, #0
 100a450:	d0f2      	beq.n	100a438 <nrfx_gpio_handler+0xc>
		if (cb->pin_mask & pins) {
 100a452:	688a      	ldr	r2, [r1, #8]
 100a454:	402a      	ands	r2, r5
 100a456:	d002      	beq.n	100a45e <nrfx_gpio_handler+0x32>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
 100a458:	4630      	mov	r0, r6
 100a45a:	684b      	ldr	r3, [r1, #4]
 100a45c:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 100a45e:	b12c      	cbz	r4, 100a46c <nrfx_gpio_handler+0x40>
 100a460:	6823      	ldr	r3, [r4, #0]
 100a462:	4621      	mov	r1, r4
 100a464:	461c      	mov	r4, r3
 100a466:	e7f2      	b.n	100a44e <nrfx_gpio_handler+0x22>
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
 100a468:	4e02      	ldr	r6, [pc, #8]	; (100a474 <nrfx_gpio_handler+0x48>)
 100a46a:	e7e7      	b.n	100a43c <nrfx_gpio_handler+0x10>
 100a46c:	4623      	mov	r3, r4
 100a46e:	e7f8      	b.n	100a462 <nrfx_gpio_handler+0x36>
 100a470:	0100c8f8 	.word	0x0100c8f8
 100a474:	0100c8e0 	.word	0x0100c8e0

0100a478 <gpio_nrfx_pin_configure>:
{
 100a478:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return port->config;
 100a47c:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 100a47e:	f001 051f 	and.w	r5, r1, #31
 100a482:	7b3b      	ldrb	r3, [r7, #12]
{
 100a484:	4614      	mov	r4, r2
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 100a486:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
{
 100a48a:	460e      	mov	r6, r1
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
 100a48c:	4628      	mov	r0, r5
 100a48e:	f10d 0103 	add.w	r1, sp, #3
 100a492:	f000 fe0d 	bl	100b0b0 <nrfx_gpiote_channel_get>
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
 100a496:	f414 3f40 	tst.w	r4, #196608	; 0x30000
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
 100a49a:	4680      	mov	r8, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
 100a49c:	d10b      	bne.n	100a4b6 <gpio_nrfx_pin_configure+0x3e>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
 100a49e:	4628      	mov	r0, r5
 100a4a0:	f000 fec8 	bl	100b234 <nrfx_gpiote_pin_uninit>
		if (free_ch) {
 100a4a4:	4b3c      	ldr	r3, [pc, #240]	; (100a598 <gpio_nrfx_pin_configure+0x120>)
 100a4a6:	4598      	cmp	r8, r3
 100a4a8:	d103      	bne.n	100a4b2 <gpio_nrfx_pin_configure+0x3a>
			err = nrfx_gpiote_channel_free(ch);
 100a4aa:	f89d 0003 	ldrb.w	r0, [sp, #3]
 100a4ae:	f000 fe47 	bl	100b140 <nrfx_gpiote_channel_free>
		return 0;
 100a4b2:	2000      	movs	r0, #0
 100a4b4:	e00c      	b.n	100a4d0 <gpio_nrfx_pin_configure+0x58>
	nrfx_gpiote_trigger_config_t trigger_config = {
 100a4b6:	2300      	movs	r3, #0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
 100a4b8:	4628      	mov	r0, r5
 100a4ba:	4619      	mov	r1, r3
 100a4bc:	aa02      	add	r2, sp, #8
	nrfx_gpiote_trigger_config_t trigger_config = {
 100a4be:	e9cd 3302 	strd	r3, r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
 100a4c2:	f000 fccb 	bl	100ae5c <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
 100a4c6:	4b34      	ldr	r3, [pc, #208]	; (100a598 <gpio_nrfx_pin_configure+0x120>)
 100a4c8:	4298      	cmp	r0, r3
 100a4ca:	d004      	beq.n	100a4d6 <gpio_nrfx_pin_configure+0x5e>
		return NRF_GPIO_PIN_PULLUP;
 100a4cc:	f06f 0015 	mvn.w	r0, #21
}
 100a4d0:	b004      	add	sp, #16
 100a4d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (free_ch) {
 100a4d6:	4580      	cmp	r8, r0
 100a4d8:	d103      	bne.n	100a4e2 <gpio_nrfx_pin_configure+0x6a>
		err = nrfx_gpiote_channel_free(ch);
 100a4da:	f89d 0003 	ldrb.w	r0, [sp, #3]
 100a4de:	f000 fe2f 	bl	100b140 <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
 100a4e2:	03a3      	lsls	r3, r4, #14
 100a4e4:	d549      	bpl.n	100a57a <gpio_nrfx_pin_configure+0x102>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
 100a4e6:	f240 3306 	movw	r3, #774	; 0x306
 100a4ea:	4023      	ands	r3, r4
 100a4ec:	f5b3 7f83 	cmp.w	r3, #262	; 0x106
 100a4f0:	d019      	beq.n	100a526 <gpio_nrfx_pin_configure+0xae>
 100a4f2:	d80c      	bhi.n	100a50e <gpio_nrfx_pin_configure+0x96>
 100a4f4:	2b06      	cmp	r3, #6
 100a4f6:	d017      	beq.n	100a528 <gpio_nrfx_pin_configure+0xb0>
 100a4f8:	d804      	bhi.n	100a504 <gpio_nrfx_pin_configure+0x8c>
 100a4fa:	b1ab      	cbz	r3, 100a528 <gpio_nrfx_pin_configure+0xb0>
 100a4fc:	2b02      	cmp	r3, #2
 100a4fe:	d1e5      	bne.n	100a4cc <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0S1;
 100a500:	2304      	movs	r3, #4
 100a502:	e011      	b.n	100a528 <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
 100a504:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 100a508:	d1e0      	bne.n	100a4cc <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_H0S1;
 100a50a:	2301      	movs	r3, #1
 100a50c:	e00c      	b.n	100a528 <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
 100a50e:	f240 2202 	movw	r2, #514	; 0x202
 100a512:	4293      	cmp	r3, r2
 100a514:	d026      	beq.n	100a564 <gpio_nrfx_pin_configure+0xec>
 100a516:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 100a51a:	d025      	beq.n	100a568 <gpio_nrfx_pin_configure+0xf0>
 100a51c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 100a520:	d1d4      	bne.n	100a4cc <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_S0H1;
 100a522:	2302      	movs	r3, #2
 100a524:	e000      	b.n	100a528 <gpio_nrfx_pin_configure+0xb0>
		*drive = NRF_GPIO_PIN_H0D1;
 100a526:	2307      	movs	r3, #7
		nrfx_gpiote_output_config_t output_config = {
 100a528:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
 100a52c:	f484 3380 	eor.w	r3, r4, #65536	; 0x10000
 100a530:	f3c3 4300 	ubfx	r3, r3, #16, #1
	if (flags & GPIO_PULL_UP) {
 100a534:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
 100a536:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
 100a53a:	bf4c      	ite	mi
 100a53c:	2303      	movmi	r3, #3
	} else if (flags & GPIO_PULL_DOWN) {
 100a53e:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
 100a542:	0321      	lsls	r1, r4, #12
		nrfx_gpiote_output_config_t output_config = {
 100a544:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
 100a548:	d510      	bpl.n	100a56c <gpio_nrfx_pin_configure+0xf4>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
 100a54a:	2301      	movs	r3, #1
 100a54c:	687a      	ldr	r2, [r7, #4]
 100a54e:	40b3      	lsls	r3, r6
    p_reg->OUTSET = set_mask;
 100a550:	6093      	str	r3, [r2, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
 100a552:	2200      	movs	r2, #0
 100a554:	4628      	mov	r0, r5
 100a556:	a901      	add	r1, sp, #4
 100a558:	f000 fd30 	bl	100afbc <nrfx_gpiote_output_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
 100a55c:	4b0e      	ldr	r3, [pc, #56]	; (100a598 <gpio_nrfx_pin_configure+0x120>)
 100a55e:	4298      	cmp	r0, r3
 100a560:	d0a7      	beq.n	100a4b2 <gpio_nrfx_pin_configure+0x3a>
 100a562:	e7b3      	b.n	100a4cc <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0H1;
 100a564:	2305      	movs	r3, #5
 100a566:	e7df      	b.n	100a528 <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
 100a568:	2303      	movs	r3, #3
 100a56a:	e7dd      	b.n	100a528 <gpio_nrfx_pin_configure+0xb0>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
 100a56c:	0362      	lsls	r2, r4, #13
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
 100a56e:	bf41      	itttt	mi
 100a570:	2301      	movmi	r3, #1
 100a572:	687a      	ldrmi	r2, [r7, #4]
 100a574:	40b3      	lslmi	r3, r6
    p_reg->OUTCLR = clr_mask;
 100a576:	60d3      	strmi	r3, [r2, #12]
}
 100a578:	e7eb      	b.n	100a552 <gpio_nrfx_pin_configure+0xda>
	if (flags & GPIO_PULL_UP) {
 100a57a:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
 100a57c:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
 100a580:	bf4c      	ite	mi
 100a582:	2403      	movmi	r4, #3
	} else if (flags & GPIO_PULL_DOWN) {
 100a584:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
 100a588:	461a      	mov	r2, r3
 100a58a:	4628      	mov	r0, r5
 100a58c:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
 100a58e:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
 100a592:	f000 fc63 	bl	100ae5c <nrfx_gpiote_input_configure>
 100a596:	e7e1      	b.n	100a55c <gpio_nrfx_pin_configure+0xe4>
 100a598:	0bad0000 	.word	0x0bad0000

0100a59c <compare_int_lock>:
#endif
}

static bool compare_int_lock(int32_t chan)
{
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
 100a59c:	2301      	movs	r3, #1
 100a59e:	4083      	lsls	r3, r0
{
 100a5a0:	b570      	push	{r4, r5, r6, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
 100a5a2:	43dc      	mvns	r4, r3
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 100a5a4:	4a0b      	ldr	r2, [pc, #44]	; (100a5d4 <compare_int_lock+0x38>)
 100a5a6:	e8d2 1fef 	ldaex	r1, [r2]
 100a5aa:	ea01 0504 	and.w	r5, r1, r4
 100a5ae:	e8c2 5fe6 	stlex	r6, r5, [r2]
 100a5b2:	2e00      	cmp	r6, #0
 100a5b4:	d1f7      	bne.n	100a5a6 <compare_int_lock+0xa>

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
 100a5b6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 100a5ba:	4082      	lsls	r2, r0
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_int_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
 100a5bc:	4806      	ldr	r0, [pc, #24]	; (100a5d8 <compare_int_lock+0x3c>)
 100a5be:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
 100a5c2:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
 100a5c6:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
 100a5ca:	420b      	tst	r3, r1
}
 100a5cc:	bf14      	ite	ne
 100a5ce:	2001      	movne	r0, #1
 100a5d0:	2000      	moveq	r0, #0
 100a5d2:	bd70      	pop	{r4, r5, r6, pc}
 100a5d4:	2100027c 	.word	0x2100027c
 100a5d8:	41016000 	.word	0x41016000

0100a5dc <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
 100a5dc:	b470      	push	{r4, r5, r6}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint32_t dticks = (uint32_t)(expire_time - last_count) / CYC_PER_TICK;
 100a5de:	490e      	ldr	r1, [pc, #56]	; (100a618 <sys_clock_timeout_handler+0x3c>)
	return absolute_time & COUNTER_MAX;
 100a5e0:	f022 467f 	bic.w	r6, r2, #4278190080	; 0xff000000
	uint32_t dticks = (uint32_t)(expire_time - last_count) / CYC_PER_TICK;
 100a5e4:	e9d1 3400 	ldrd	r3, r4, [r1]
 100a5e8:	1ad0      	subs	r0, r2, r3

	last_count += dticks * CYC_PER_TICK;
 100a5ea:	18c3      	adds	r3, r0, r3
 100a5ec:	f144 0400 	adc.w	r4, r4, #0
 100a5f0:	e9c1 3400 	strd	r3, r4, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
 100a5f4:	f5a6 1300 	sub.w	r3, r6, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
 100a5f8:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 100a5fc:	d209      	bcs.n	100a612 <sys_clock_timeout_handler+0x36>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
 100a5fe:	4b07      	ldr	r3, [pc, #28]	; (100a61c <sys_clock_timeout_handler+0x40>)
 100a600:	681b      	ldr	r3, [r3, #0]
 100a602:	0a1a      	lsrs	r2, r3, #8
 100a604:	061b      	lsls	r3, r3, #24
 100a606:	199c      	adds	r4, r3, r6
 100a608:	4b05      	ldr	r3, [pc, #20]	; (100a620 <sys_clock_timeout_handler+0x44>)
 100a60a:	f142 0500 	adc.w	r5, r2, #0
 100a60e:	e9c3 4500 	strd	r4, r5, [r3]
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(dticks);
}
 100a612:	bc70      	pop	{r4, r5, r6}
	sys_clock_announce(dticks);
 100a614:	f001 bca4 	b.w	100bf60 <sys_clock_announce>
 100a618:	210000a0 	.word	0x210000a0
 100a61c:	21000280 	.word	0x21000280
 100a620:	210000a8 	.word	0x210000a8

0100a624 <compare_int_unlock>:
	if (key) {
 100a624:	b1d9      	cbz	r1, 100a65e <compare_int_unlock+0x3a>
		atomic_or(&int_mask, BIT(chan));
 100a626:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 100a628:	4a0d      	ldr	r2, [pc, #52]	; (100a660 <compare_int_unlock+0x3c>)
 100a62a:	4083      	lsls	r3, r0
 100a62c:	e8d2 cfef 	ldaex	ip, [r2]
 100a630:	ea4c 0c03 	orr.w	ip, ip, r3
 100a634:	e8c2 cfe1 	stlex	r1, ip, [r2]
 100a638:	2900      	cmp	r1, #0
 100a63a:	d1f7      	bne.n	100a62c <compare_int_unlock+0x8>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
 100a63c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
 100a640:	4a08      	ldr	r2, [pc, #32]	; (100a664 <compare_int_unlock+0x40>)
 100a642:	4083      	lsls	r3, r0
 100a644:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 100a648:	4b07      	ldr	r3, [pc, #28]	; (100a668 <compare_int_unlock+0x44>)
 100a64a:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
 100a64e:	40c3      	lsrs	r3, r0
 100a650:	07db      	lsls	r3, r3, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 100a652:	bf42      	ittt	mi
 100a654:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
 100a658:	4b04      	ldrmi	r3, [pc, #16]	; (100a66c <compare_int_unlock+0x48>)
 100a65a:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
 100a65e:	4770      	bx	lr
 100a660:	2100027c 	.word	0x2100027c
 100a664:	41016000 	.word	0x41016000
 100a668:	21000278 	.word	0x21000278
 100a66c:	e000e100 	.word	0xe000e100

0100a670 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
 100a670:	4b0d      	ldr	r3, [pc, #52]	; (100a6a8 <z_nrf_rtc_timer_read+0x38>)
 100a672:	6818      	ldr	r0, [r3, #0]
 100a674:	0a01      	lsrs	r1, r0, #8
 100a676:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
 100a678:	f3bf 8f5f 	dmb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
 100a67c:	4b0b      	ldr	r3, [pc, #44]	; (100a6ac <z_nrf_rtc_timer_read+0x3c>)
 100a67e:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
 100a682:	1818      	adds	r0, r3, r0
 100a684:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
 100a688:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 100a68c:	d20a      	bcs.n	100a6a4 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
 100a68e:	4b08      	ldr	r3, [pc, #32]	; (100a6b0 <z_nrf_rtc_timer_read+0x40>)
 100a690:	e9d3 2300 	ldrd	r2, r3, [r3]
 100a694:	4290      	cmp	r0, r2
 100a696:	eb71 0303 	sbcs.w	r3, r1, r3
 100a69a:	d203      	bcs.n	100a6a4 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
 100a69c:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
 100a6a0:	f141 0100 	adc.w	r1, r1, #0
}
 100a6a4:	4770      	bx	lr
 100a6a6:	bf00      	nop
 100a6a8:	21000280 	.word	0x21000280
 100a6ac:	41016000 	.word	0x41016000
 100a6b0:	210000a8 	.word	0x210000a8

0100a6b4 <compare_set>:
{
 100a6b4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100a6b8:	4616      	mov	r6, r2
 100a6ba:	461f      	mov	r7, r3
 100a6bc:	4604      	mov	r4, r0
	key = compare_int_lock(chan);
 100a6be:	f7ff ff6d 	bl	100a59c <compare_int_lock>
 100a6c2:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
 100a6c4:	f7ff ffd4 	bl	100a670 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
 100a6c8:	42b0      	cmp	r0, r6
 100a6ca:	eb71 0307 	sbcs.w	r3, r1, r7
 100a6ce:	d250      	bcs.n	100a772 <compare_set+0xbe>
		if (target_time - curr_time > COUNTER_HALF_SPAN) {
 100a6d0:	4b38      	ldr	r3, [pc, #224]	; (100a7b4 <compare_set+0x100>)
 100a6d2:	1a30      	subs	r0, r6, r0
 100a6d4:	eb67 0101 	sbc.w	r1, r7, r1
 100a6d8:	4298      	cmp	r0, r3
 100a6da:	f171 0100 	sbcs.w	r1, r1, #0
 100a6de:	d265      	bcs.n	100a7ac <compare_set+0xf8>
		if (target_time != cc_data[chan].target_time) {
 100a6e0:	4b35      	ldr	r3, [pc, #212]	; (100a7b8 <compare_set+0x104>)
 100a6e2:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 100a6e6:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 100a6ea:	429f      	cmp	r7, r3
 100a6ec:	bf08      	it	eq
 100a6ee:	4296      	cmpeq	r6, r2
 100a6f0:	d049      	beq.n	100a786 <compare_set+0xd2>
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
 100a6f2:	f44f 3980 	mov.w	r9, #65536	; 0x10000
    p_reg->EVTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
 100a6f6:	4931      	ldr	r1, [pc, #196]	; (100a7bc <compare_set+0x108>)
 100a6f8:	fa09 f904 	lsl.w	r9, r9, r4
	event_clear(chan);
 100a6fc:	4620      	mov	r0, r4
	return absolute_time & COUNTER_MAX;
 100a6fe:	f026 4b7f 	bic.w	fp, r6, #4278190080	; 0xff000000
 100a702:	f8c1 9348 	str.w	r9, [r1, #840]	; 0x348
	event_clear(chan);
 100a706:	f001 ff54 	bl	100c5b2 <event_clear>
	uint32_t cc_inc = MIN_CYCLES_FROM_NOW;
 100a70a:	f04f 0a03 	mov.w	sl, #3
	uint32_t cc_val = req_cc;
 100a70e:	4658      	mov	r0, fp
	return nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
 100a710:	f104 0550 	add.w	r5, r4, #80	; 0x50
 100a714:	00ad      	lsls	r5, r5, #2
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 100a716:	b2ad      	uxth	r5, r5
 100a718:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    p_reg->CC[ch] = cc_val;
 100a71c:	f504 73a8 	add.w	r3, r4, #336	; 0x150
		if (counter_sub(cc_val, now + MIN_CYCLES_FROM_NOW) >
 100a720:	4a27      	ldr	r2, [pc, #156]	; (100a7c0 <compare_set+0x10c>)
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 100a722:	f505 35b0 	add.w	r5, r5, #90112	; 0x16000
    p_reg->CC[ch] = cc_val;
 100a726:	9301      	str	r3, [sp, #4]
 100a728:	f8dd c004 	ldr.w	ip, [sp, #4]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
 100a72c:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
 100a730:	f841 302c 	str.w	r3, [r1, ip, lsl #2]
    p_reg->EVTENSET = mask;
 100a734:	f8c1 9344 	str.w	r9, [r1, #836]	; 0x344
     return p_reg->COUNTER;
 100a738:	f8d1 8504 	ldr.w	r8, [r1, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
 100a73c:	eba0 0008 	sub.w	r0, r0, r8
 100a740:	3803      	subs	r0, #3
 100a742:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		if (counter_sub(cc_val, now + MIN_CYCLES_FROM_NOW) >
 100a746:	4290      	cmp	r0, r2
 100a748:	d91d      	bls.n	100a786 <compare_set+0xd2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 100a74a:	6828      	ldr	r0, [r5, #0]
			if (event_check(chan)) {
 100a74c:	b160      	cbz	r0, 100a768 <compare_set+0xb4>
     return p_reg->COUNTER;
 100a74e:	f8d1 8504 	ldr.w	r8, [r1, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
 100a752:	eba8 000b 	sub.w	r0, r8, fp
 100a756:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
				if (counter_sub(now, req_cc) > COUNTER_HALF_SPAN) {
 100a75a:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 100a75e:	d912      	bls.n	100a786 <compare_set+0xd2>
					event_clear(chan);
 100a760:	4620      	mov	r0, r4
 100a762:	f001 ff26 	bl	100c5b2 <event_clear>
 100a766:	4a16      	ldr	r2, [pc, #88]	; (100a7c0 <compare_set+0x10c>)
			cc_val = now + cc_inc;
 100a768:	eb0a 0008 	add.w	r0, sl, r8
			cc_inc++;
 100a76c:	f10a 0a01 	add.w	sl, sl, #1
	for (;;) {
 100a770:	e7da      	b.n	100a728 <compare_set+0x74>
		atomic_or(&force_isr_mask, BIT(chan));
 100a772:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 100a774:	4a13      	ldr	r2, [pc, #76]	; (100a7c4 <compare_set+0x110>)
 100a776:	40a3      	lsls	r3, r4
 100a778:	e8d2 0fef 	ldaex	r0, [r2]
 100a77c:	4318      	orrs	r0, r3
 100a77e:	e8c2 0fe1 	stlex	r1, r0, [r2]
 100a782:	2900      	cmp	r1, #0
 100a784:	d1f8      	bne.n	100a778 <compare_set+0xc4>
	return ret;
 100a786:	2500      	movs	r5, #0
	cc_data[chan].target_time = target_time;
 100a788:	490b      	ldr	r1, [pc, #44]	; (100a7b8 <compare_set+0x104>)
	cc_data[chan].callback = handler;
 100a78a:	980c      	ldr	r0, [sp, #48]	; 0x30
	cc_data[chan].target_time = target_time;
 100a78c:	0123      	lsls	r3, r4, #4
 100a78e:	eb01 1204 	add.w	r2, r1, r4, lsl #4
	cc_data[chan].callback = handler;
 100a792:	50c8      	str	r0, [r1, r3]
	cc_data[chan].target_time = target_time;
 100a794:	e9c2 6702 	strd	r6, r7, [r2, #8]
	cc_data[chan].user_context = user_data;
 100a798:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 100a79a:	6053      	str	r3, [r2, #4]
	compare_int_unlock(chan, key);
 100a79c:	4620      	mov	r0, r4
 100a79e:	9900      	ldr	r1, [sp, #0]
 100a7a0:	f7ff ff40 	bl	100a624 <compare_int_unlock>
}
 100a7a4:	4628      	mov	r0, r5
 100a7a6:	b003      	add	sp, #12
 100a7a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return -EINVAL;
 100a7ac:	f06f 0515 	mvn.w	r5, #21
 100a7b0:	e7f4      	b.n	100a79c <compare_set+0xe8>
 100a7b2:	bf00      	nop
 100a7b4:	00800001 	.word	0x00800001
 100a7b8:	21000090 	.word	0x21000090
 100a7bc:	41016000 	.word	0x41016000
 100a7c0:	007ffffd 	.word	0x007ffffd
 100a7c4:	21000278 	.word	0x21000278

0100a7c8 <sys_clock_driver_init>:
	int_event_disable_rtc();
	NVIC_ClearPendingIRQ(RTC_IRQn);
}

static int sys_clock_driver_init(void)
{
 100a7c8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
 100a7ca:	2500      	movs	r5, #0
	int_event_disable_rtc();

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
 100a7cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 100a7d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    p_reg->INTENCLR = mask;
 100a7d4:	4c18      	ldr	r4, [pc, #96]	; (100a838 <sys_clock_driver_init+0x70>)
 100a7d6:	4b19      	ldr	r3, [pc, #100]	; (100a83c <sys_clock_driver_init+0x74>)
    p_reg->INTENSET = mask;
 100a7d8:	2602      	movs	r6, #2
    p_reg->INTENCLR = mask;
 100a7da:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    p_reg->EVTENCLR = mask;
 100a7de:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
 100a7e2:	4b17      	ldr	r3, [pc, #92]	; (100a840 <sys_clock_driver_init+0x78>)
    p_reg->PRESCALER = val;
 100a7e4:	f8c4 5508 	str.w	r5, [r4, #1288]	; 0x508
 100a7e8:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
 100a7ec:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 100a7f0:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 100a7f4:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
 100a7f8:	4b12      	ldr	r3, [pc, #72]	; (100a844 <sys_clock_driver_init+0x7c>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
 100a7fa:	2101      	movs	r1, #1
 100a7fc:	f8c4 6304 	str.w	r6, [r4, #772]	; 0x304
 100a800:	2016      	movs	r0, #22
 100a802:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
 100a806:	462a      	mov	r2, r5
 100a808:	f7fe fff8 	bl	10097fc <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
 100a80c:	2016      	movs	r0, #22
 100a80e:	f7fe ffd9 	bl	10097c4 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
 100a812:	2301      	movs	r3, #1

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
 100a814:	4a0c      	ldr	r2, [pc, #48]	; (100a848 <sys_clock_driver_init+0x80>)
 100a816:	60a3      	str	r3, [r4, #8]
 100a818:	6023      	str	r3, [r4, #0]
 100a81a:	6013      	str	r3, [r2, #0]
	}

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		MAX_CYCLES : CYC_PER_TICK;

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
 100a81c:	4b0b      	ldr	r3, [pc, #44]	; (100a84c <sys_clock_driver_init+0x84>)
 100a81e:	4a0c      	ldr	r2, [pc, #48]	; (100a850 <sys_clock_driver_init+0x88>)
 100a820:	9300      	str	r3, [sp, #0]
 100a822:	4628      	mov	r0, r5
 100a824:	2300      	movs	r3, #0
 100a826:	9501      	str	r5, [sp, #4]
 100a828:	f7ff ff44 	bl	100a6b4 <compare_set>

	z_nrf_clock_control_lf_on(mode);
 100a82c:	4630      	mov	r0, r6
 100a82e:	f7ff fcf9 	bl	100a224 <z_nrf_clock_control_lf_on>

	return 0;
}
 100a832:	4628      	mov	r0, r5
 100a834:	b002      	add	sp, #8
 100a836:	bd70      	pop	{r4, r5, r6, pc}
 100a838:	41016000 	.word	0x41016000
 100a83c:	000f0003 	.word	0x000f0003
 100a840:	21000090 	.word	0x21000090
 100a844:	e000e100 	.word	0xe000e100
 100a848:	2100027c 	.word	0x2100027c
 100a84c:	0100a5dd 	.word	0x0100a5dd
 100a850:	007fffff 	.word	0x007fffff

0100a854 <rtc_nrf_isr>:
{
 100a854:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    return p_reg->INTENSET & mask;
 100a858:	4b2e      	ldr	r3, [pc, #184]	; (100a914 <rtc_nrf_isr+0xc0>)
 100a85a:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
 100a85e:	0790      	lsls	r0, r2, #30
 100a860:	d50b      	bpl.n	100a87a <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 100a862:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 100a866:	b142      	cbz	r2, 100a87a <rtc_nrf_isr+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 100a868:	2200      	movs	r2, #0
 100a86a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		overflow_cnt++;
 100a86e:	4a2a      	ldr	r2, [pc, #168]	; (100a918 <rtc_nrf_isr+0xc4>)
 100a870:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 100a874:	6813      	ldr	r3, [r2, #0]
 100a876:	3301      	adds	r3, #1
 100a878:	6013      	str	r3, [r2, #0]
    return p_reg->INTENSET & mask;
 100a87a:	4a26      	ldr	r2, [pc, #152]	; (100a914 <rtc_nrf_isr+0xc0>)
 100a87c:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
 100a880:	03d9      	lsls	r1, r3, #15
 100a882:	d527      	bpl.n	100a8d4 <rtc_nrf_isr+0x80>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 100a884:	4b25      	ldr	r3, [pc, #148]	; (100a91c <rtc_nrf_isr+0xc8>)
 100a886:	e8d3 1fef 	ldaex	r1, [r3]
 100a88a:	f021 0001 	bic.w	r0, r1, #1
 100a88e:	e8c3 0fe4 	stlex	r4, r0, [r3]
 100a892:	2c00      	cmp	r4, #0
 100a894:	d1f7      	bne.n	100a886 <rtc_nrf_isr+0x32>
		if ((atomic_and(&force_isr_mask, ~BIT(chan)) & BIT(chan)) ||
 100a896:	07cb      	lsls	r3, r1, #31
 100a898:	d402      	bmi.n	100a8a0 <rtc_nrf_isr+0x4c>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 100a89a:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
 100a89e:	b1cb      	cbz	r3, 100a8d4 <rtc_nrf_isr+0x80>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 100a8a0:	2500      	movs	r5, #0
 100a8a2:	4c1c      	ldr	r4, [pc, #112]	; (100a914 <rtc_nrf_isr+0xc0>)
 100a8a4:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
 100a8a8:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		curr_time = z_nrf_rtc_timer_read();
 100a8ac:	f7ff fee0 	bl	100a670 <z_nrf_rtc_timer_read>
 100a8b0:	f04f 0320 	mov.w	r3, #32
 100a8b4:	f3ef 8211 	mrs	r2, BASEPRI
 100a8b8:	f383 8812 	msr	BASEPRI_MAX, r3
 100a8bc:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
 100a8c0:	4b17      	ldr	r3, [pc, #92]	; (100a920 <rtc_nrf_isr+0xcc>)
 100a8c2:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
		if (curr_time >= expire_time) {
 100a8c6:	42b0      	cmp	r0, r6
 100a8c8:	41b9      	sbcs	r1, r7
 100a8ca:	d206      	bcs.n	100a8da <rtc_nrf_isr+0x86>
	__asm__ volatile(
 100a8cc:	f382 8811 	msr	BASEPRI, r2
 100a8d0:	f3bf 8f6f 	isb	sy
}
 100a8d4:	b003      	add	sp, #12
 100a8d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			cc_data[chan].target_time = TARGET_TIME_INVALID;
 100a8da:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
			user_context = cc_data[chan].user_context;
 100a8de:	e9d3 1000 	ldrd	r1, r0, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
 100a8e2:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			cc_data[chan].callback = NULL;
 100a8e6:	601d      	str	r5, [r3, #0]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
 100a8e8:	e9c3 8902 	strd	r8, r9, [r3, #8]
    p_reg->EVTENCLR = mask;
 100a8ec:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 100a8f0:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 100a8f4:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
 100a8f8:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
 100a8fc:	f382 8811 	msr	BASEPRI, r2
 100a900:	f3bf 8f6f 	isb	sy
		if (handler) {
 100a904:	2900      	cmp	r1, #0
 100a906:	d0e5      	beq.n	100a8d4 <rtc_nrf_isr+0x80>
			handler(chan, expire_time, user_context);
 100a908:	9000      	str	r0, [sp, #0]
 100a90a:	4632      	mov	r2, r6
 100a90c:	463b      	mov	r3, r7
 100a90e:	4628      	mov	r0, r5
 100a910:	4788      	blx	r1
 100a912:	e7df      	b.n	100a8d4 <rtc_nrf_isr+0x80>
 100a914:	41016000 	.word	0x41016000
 100a918:	21000280 	.word	0x21000280
 100a91c:	21000278 	.word	0x21000278
 100a920:	21000090 	.word	0x21000090

0100a924 <sys_clock_set_timeout>:
	if (ticks == K_TICKS_FOREVER) {
 100a924:	1c43      	adds	r3, r0, #1
{
 100a926:	b513      	push	{r0, r1, r4, lr}
	if (ticks == K_TICKS_FOREVER) {
 100a928:	d021      	beq.n	100a96e <sys_clock_set_timeout+0x4a>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
 100a92a:	2801      	cmp	r0, #1
 100a92c:	dd21      	ble.n	100a972 <sys_clock_set_timeout+0x4e>
 100a92e:	4a12      	ldr	r2, [pc, #72]	; (100a978 <sys_clock_set_timeout+0x54>)
 100a930:	4b12      	ldr	r3, [pc, #72]	; (100a97c <sys_clock_set_timeout+0x58>)
 100a932:	4290      	cmp	r0, r2
 100a934:	bfd4      	ite	le
 100a936:	4604      	movle	r4, r0
 100a938:	461c      	movgt	r4, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
 100a93a:	f7ff fe99 	bl	100a670 <z_nrf_rtc_timer_read>
 100a93e:	4b10      	ldr	r3, [pc, #64]	; (100a980 <sys_clock_set_timeout+0x5c>)
	if (cyc > MAX_CYCLES) {
 100a940:	490e      	ldr	r1, [pc, #56]	; (100a97c <sys_clock_set_timeout+0x58>)
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
 100a942:	e9d3 2300 	ldrd	r2, r3, [r3]
 100a946:	1a80      	subs	r0, r0, r2
		cyc = 0;
 100a948:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 100a94c:	bf28      	it	cs
 100a94e:	2400      	movcs	r4, #0
	cyc += unannounced;
 100a950:	4404      	add	r4, r0
	if (cyc > MAX_CYCLES) {
 100a952:	428c      	cmp	r4, r1
 100a954:	bf28      	it	cs
 100a956:	460c      	movcs	r4, r1
	uint64_t target_time = cyc + last_count;
 100a958:	2000      	movs	r0, #0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
 100a95a:	490a      	ldr	r1, [pc, #40]	; (100a984 <sys_clock_set_timeout+0x60>)
	uint64_t target_time = cyc + last_count;
 100a95c:	18a2      	adds	r2, r4, r2
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
 100a95e:	9001      	str	r0, [sp, #4]
 100a960:	9100      	str	r1, [sp, #0]
 100a962:	f143 0300 	adc.w	r3, r3, #0
 100a966:	f7ff fea5 	bl	100a6b4 <compare_set>
}
 100a96a:	b002      	add	sp, #8
 100a96c:	bd10      	pop	{r4, pc}
		cyc = MAX_TICKS * CYC_PER_TICK;
 100a96e:	4c03      	ldr	r4, [pc, #12]	; (100a97c <sys_clock_set_timeout+0x58>)
 100a970:	e7e3      	b.n	100a93a <sys_clock_set_timeout+0x16>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
 100a972:	2401      	movs	r4, #1
 100a974:	e7e1      	b.n	100a93a <sys_clock_set_timeout+0x16>
 100a976:	bf00      	nop
 100a978:	007ffffe 	.word	0x007ffffe
 100a97c:	007fffff 	.word	0x007fffff
 100a980:	210000a0 	.word	0x210000a0
 100a984:	0100a5dd 	.word	0x0100a5dd

0100a988 <sys_clock_elapsed>:
{
 100a988:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
 100a98a:	f7ff fe71 	bl	100a670 <z_nrf_rtc_timer_read>
 100a98e:	4b02      	ldr	r3, [pc, #8]	; (100a998 <sys_clock_elapsed+0x10>)
 100a990:	681b      	ldr	r3, [r3, #0]
}
 100a992:	1ac0      	subs	r0, r0, r3
 100a994:	bd08      	pop	{r3, pc}
 100a996:	bf00      	nop
 100a998:	210000a0 	.word	0x210000a0

0100a99c <check_ext_api_requests>:
	}
};
#endif

static int check_ext_api_requests(void)
{
 100a99c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const struct fw_info_ext_api_request *ext_api_req =
			skip_ext_apis(&m_firmware_info);
 100a9a0:	4822      	ldr	r0, [pc, #136]	; (100aa2c <check_ext_api_requests+0x90>)
{
 100a9a2:	b085      	sub	sp, #20
			skip_ext_apis(&m_firmware_info);
 100a9a4:	f001 fe19 	bl	100c5da <skip_ext_apis>

	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 100a9a8:	2500      	movs	r5, #0
			skip_ext_apis(&m_firmware_info);
 100a9aa:	4604      	mov	r4, r0
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 100a9ac:	4b1f      	ldr	r3, [pc, #124]	; (100aa2c <check_ext_api_requests+0x90>)
 */
static inline const struct fw_info_ext_api *fw_info_ext_api_check(
							uint32_t ext_api_addr)
{
	const struct fw_info_ext_api *ext_api;
	const uint32_t ext_api_magic[] = {EXT_API_MAGIC};
 100a9ae:	4e20      	ldr	r6, [pc, #128]	; (100aa30 <check_ext_api_requests+0x94>)
 100a9b0:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
			/* EXT_API hard requirement not met. */
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
			k_panic();
		} else {
			/* EXT_API soft requirement not met. */
			printk("WARNING: Optional EXT_API request not "
 100a9b4:	f8df 907c 	ldr.w	r9, [pc, #124]	; 100aa34 <check_ext_api_requests+0x98>
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 100a9b8:	45a8      	cmp	r8, r5
 100a9ba:	d803      	bhi.n	100a9c4 <check_ext_api_requests+0x28>
		}
		ADVANCE_EXT_API_REQ(ext_api_req);
	}

	return 0;
}
 100a9bc:	2000      	movs	r0, #0
 100a9be:	b005      	add	sp, #20
 100a9c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fw_info_ext_api_check((uint32_t)*(ext_api_req->ext_api))
 100a9c4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 100a9c6:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 100a9ca:	681f      	ldr	r7, [r3, #0]
 100a9cc:	ab01      	add	r3, sp, #4
 100a9ce:	e883 0007 	stmia.w	r3, {r0, r1, r2}

	ext_api = (const struct fw_info_ext_api *)(ext_api_addr);
	if (memcmp(ext_api->magic, ext_api_magic, CONFIG_FW_INFO_MAGIC_LEN)
 100a9d2:	220c      	movs	r2, #12
 100a9d4:	4619      	mov	r1, r3
 100a9d6:	4638      	mov	r0, r7
 100a9d8:	f001 fce9 	bl	100c3ae <memcmp>
 100a9dc:	b988      	cbnz	r0, 100aa02 <check_ext_api_requests+0x66>
 100a9de:	b187      	cbz	r7, 100aa02 <check_ext_api_requests+0x66>
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
 100a9e0:	6a63      	ldr	r3, [r4, #36]	; 0x24
	const uint32_t req_id = ext_api_req->request.ext_api_id;
 100a9e2:	6921      	ldr	r1, [r4, #16]
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
 100a9e4:	681b      	ldr	r3, [r3, #0]
	return ((ext_api->ext_api_id == req_id)
 100a9e6:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
 100a9e8:	4291      	cmp	r1, r2
 100a9ea:	d10a      	bne.n	100aa02 <check_ext_api_requests+0x66>
		&&  (ext_api->ext_api_version >= req_min_version)
 100a9ec:	699a      	ldr	r2, [r3, #24]
	const uint32_t req_min_version = ext_api_req->request.ext_api_version;
 100a9ee:	69a1      	ldr	r1, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
 100a9f0:	4291      	cmp	r1, r2
 100a9f2:	d806      	bhi.n	100aa02 <check_ext_api_requests+0x66>
	const uint32_t req_max_version = ext_api_req->ext_api_max_version;
 100a9f4:	69e1      	ldr	r1, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
 100a9f6:	4291      	cmp	r1, r2
 100a9f8:	d903      	bls.n	100aa02 <check_ext_api_requests+0x66>
	const uint32_t req_flags = ext_api_req->request.ext_api_flags;
 100a9fa:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
 100a9fc:	695b      	ldr	r3, [r3, #20]
 100a9fe:	439a      	bics	r2, r3
 100aa00:	d00a      	beq.n	100aa18 <check_ext_api_requests+0x7c>
		} else if (ext_api_req->required) {
 100aa02:	6a27      	ldr	r7, [r4, #32]
 100aa04:	b167      	cbz	r7, 100aa20 <check_ext_api_requests+0x84>
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
 100aa06:	480c      	ldr	r0, [pc, #48]	; (100aa38 <check_ext_api_requests+0x9c>)
 100aa08:	f001 fb38 	bl	100c07c <printk>
			k_panic();
 100aa0c:	4040      	eors	r0, r0
 100aa0e:	f380 8811 	msr	BASEPRI, r0
 100aa12:	f04f 0004 	mov.w	r0, #4
 100aa16:	df02      	svc	2
		ADVANCE_EXT_API_REQ(ext_api_req);
 100aa18:	68e3      	ldr	r3, [r4, #12]
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 100aa1a:	3501      	adds	r5, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
 100aa1c:	441c      	add	r4, r3
	for (uint32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
 100aa1e:	e7cb      	b.n	100a9b8 <check_ext_api_requests+0x1c>
			printk("WARNING: Optional EXT_API request not "
 100aa20:	4648      	mov	r0, r9
 100aa22:	f001 fb2b 	bl	100c07c <printk>
			*ext_api_req->ext_api = NULL;
 100aa26:	6a63      	ldr	r3, [r4, #36]	; 0x24
 100aa28:	601f      	str	r7, [r3, #0]
 100aa2a:	e7f5      	b.n	100aa18 <check_ext_api_requests+0x7c>
 100aa2c:	01008a00 	.word	0x01008a00
 100aa30:	0100ca60 	.word	0x0100ca60
 100aa34:	0100cbf0 	.word	0x0100cbf0
 100aa38:	0100cbc7 	.word	0x0100cbc7

0100aa3c <SystemInit>:
void SystemInit(void)
{
    /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim
     until one ADDR is not initialized. */
    uint32_t index = 0;
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
 100aa3c:	2200      	movs	r2, #0
 100aa3e:	00d3      	lsls	r3, r2, #3
 100aa40:	f103 73ff 	add.w	r3, r3, #33423360	; 0x1fe0000
 100aa44:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 100aa48:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
 100aa4c:	3101      	adds	r1, #1
 100aa4e:	d007      	beq.n	100aa60 <SystemInit+0x24>
        #if defined ( __ICCARM__ )
            /* IAR will complain about the order of volatile pointer accesses. */
            #pragma diag_suppress=Pa082
        #endif
        *((volatile uint32_t *)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 100aa50:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
 100aa54:	3201      	adds	r2, #1
        *((volatile uint32_t *)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 100aa56:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
 100aa5a:	2a20      	cmp	r2, #32
        *((volatile uint32_t *)NRF_FICR_NS->TRIMCNF[index].ADDR) = NRF_FICR_NS->TRIMCNF[index].DATA;
 100aa5c:	600b      	str	r3, [r1, #0]
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != 0xFFFFFFFFul; index++){
 100aa5e:	d1ee      	bne.n	100aa3e <SystemInit+0x2>
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
                #endif
            #elif defined(NRF_NETWORK)
                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
 100aa60:	4b22      	ldr	r3, [pc, #136]	; (100aaec <SystemInit+0xb0>)
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
 100aa62:	e9d3 324c 	ldrd	r3, r2, [r3, #304]	; 0x130
 100aa66:	2b07      	cmp	r3, #7
 100aa68:	d126      	bne.n	100aab8 <SystemInit+0x7c>
                {
                    switch(var2)
 100aa6a:	3a02      	subs	r2, #2
 100aa6c:	2a03      	cmp	r2, #3
 100aa6e:	4b20      	ldr	r3, [pc, #128]	; (100aaf0 <SystemInit+0xb4>)
 100aa70:	d928      	bls.n	100aac4 <SystemInit+0x88>

    /* Workaround for Errata 55 "Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf53_errata_55())
    {
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk){
 100aa72:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 100aa76:	07d1      	lsls	r1, r2, #31
 100aa78:	d432      	bmi.n	100aae0 <SystemInit+0xa4>
                #else
                    uint32_t var1 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000130ul));
                    uint32_t var2 = *((volatile uint32_t *)((uint32_t)NRF_FICR_S + 0x00000134ul));
                #endif
            #elif defined(NRF_NETWORK)
                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
 100aa7a:	4b1c      	ldr	r3, [pc, #112]	; (100aaec <SystemInit+0xb0>)
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)\
             || defined (NRF_NETWORK)
                if (var1 == 0x07)
 100aa7c:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
 100aa80:	2a07      	cmp	r2, #7
 100aa82:	d119      	bne.n	100aab8 <SystemInit+0x7c>
                {
                    switch(var2)
 100aa84:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
 100aa88:	3b02      	subs	r3, #2
 100aa8a:	2b03      	cmp	r3, #3
 100aa8c:	d802      	bhi.n	100aa94 <SystemInit+0x58>
            NRF_RESET_NS->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
        }
    }

    if (nrf53_errata_160())
 100aa8e:	4a19      	ldr	r2, [pc, #100]	; (100aaf4 <SystemInit+0xb8>)
 100aa90:	5cd3      	ldrb	r3, [r2, r3]
 100aa92:	b18b      	cbz	r3, 100aab8 <SystemInit+0x7c>
    {
        *((volatile uint32_t *)0x41002118) = 0x7Ful;
 100aa94:	237f      	movs	r3, #127	; 0x7f
 100aa96:	4a18      	ldr	r2, [pc, #96]	; (100aaf8 <SystemInit+0xbc>)
        *((volatile uint32_t *)0x41080E04) = 0x0ul;
 100aa98:	4918      	ldr	r1, [pc, #96]	; (100aafc <SystemInit+0xc0>)
        *((volatile uint32_t *)0x41002118) = 0x7Ful;
 100aa9a:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
        *((volatile uint32_t *)0x41080E04) = 0x0ul;
 100aa9e:	2300      	movs	r3, #0
 100aaa0:	f8c1 3e04 	str.w	r3, [r1, #3588]	; 0xe04
        *((volatile uint32_t *)0x41080E08) = 0x0ul;
 100aaa4:	f8c1 3e08 	str.w	r3, [r1, #3592]	; 0xe08
        *((volatile uint32_t *)0x41002124) = 0x0ul;
 100aaa8:	f8c2 3124 	str.w	r3, [r2, #292]	; 0x124
        *((volatile uint32_t *)0x4100212C) = 0x0ul;
 100aaac:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c
        *((volatile uint32_t *)0x41101110) = 0x0ul;
 100aab0:	f502 227f 	add.w	r2, r2, #1044480	; 0xff000
 100aab4:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
                /* Do nothing, allow user code to handle APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load APPROTECT soft branch from UICR.
               If UICR->APPROTECT is disabled, CTRLAP->APPROTECT will be disabled. */
            NRF_CTRLAP_NS->APPROTECT.DISABLE = NRF_UICR_NS->APPROTECT;
 100aab8:	4b11      	ldr	r3, [pc, #68]	; (100ab00 <SystemInit+0xc4>)
 100aaba:	681a      	ldr	r2, [r3, #0]
 100aabc:	4b11      	ldr	r3, [pc, #68]	; (100ab04 <SystemInit+0xc8>)
 100aabe:	f8c3 2544 	str.w	r2, [r3, #1348]	; 0x544
    }

    /* Handle fw-branch APPROTECT setup. */
    nrf53_handle_approtect();
}
 100aac2:	4770      	bx	lr
    if (nrf53_errata_49())
 100aac4:	4910      	ldr	r1, [pc, #64]	; (100ab08 <SystemInit+0xcc>)
 100aac6:	5c8a      	ldrb	r2, [r1, r2]
 100aac8:	2a00      	cmp	r2, #0
 100aaca:	d0d2      	beq.n	100aa72 <SystemInit+0x36>
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
 100aacc:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 100aad0:	07d2      	lsls	r2, r2, #31
 100aad2:	d5ce      	bpl.n	100aa72 <SystemInit+0x36>
            NRF_POWER_NS->EVENTS_SLEEPENTER = 0;
 100aad4:	2200      	movs	r2, #0
 100aad6:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
            NRF_POWER_NS->EVENTS_SLEEPEXIT = 0;
 100aada:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
                if (var1 == 0x07)
 100aade:	e7c8      	b.n	100aa72 <SystemInit+0x36>
            NRF_RESET_NS->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
 100aae0:	f06f 0201 	mvn.w	r2, #1
 100aae4:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
 100aae8:	e7c7      	b.n	100aa7a <SystemInit+0x3e>
 100aaea:	bf00      	nop
 100aaec:	01ff0000 	.word	0x01ff0000
 100aaf0:	41005000 	.word	0x41005000
 100aaf4:	0100cc23 	.word	0x0100cc23
 100aaf8:	41002000 	.word	0x41002000
 100aafc:	41080000 	.word	0x41080000
 100ab00:	01ff8000 	.word	0x01ff8000
 100ab04:	41006000 	.word	0x41006000
 100ab08:	0100cc27 	.word	0x0100cc27

0100ab0c <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
 100ab0c:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
 100ab0e:	2501      	movs	r5, #1
        prev_mask = *p_mask;
 100ab10:	6802      	ldr	r2, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
 100ab12:	fab2 f382 	clz	r3, r2
 100ab16:	f1c3 031f 	rsb	r3, r3, #31
 100ab1a:	b2db      	uxtb	r3, r3
        new_mask = prev_mask & ~NRFX_BIT(idx);
 100ab1c:	fa05 f403 	lsl.w	r4, r5, r3
 100ab20:	ea22 0404 	bic.w	r4, r2, r4
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 100ab24:	e8d0 6fef 	ldaex	r6, [r0]
 100ab28:	4296      	cmp	r6, r2
 100ab2a:	d104      	bne.n	100ab36 <nrfx_flag32_alloc+0x2a>
 100ab2c:	e8c0 4fec 	stlex	ip, r4, [r0]
 100ab30:	f1bc 0f00 	cmp.w	ip, #0
 100ab34:	d1f6      	bne.n	100ab24 <nrfx_flag32_alloc+0x18>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
 100ab36:	d1eb      	bne.n	100ab10 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
}
 100ab38:	4801      	ldr	r0, [pc, #4]	; (100ab40 <nrfx_flag32_alloc+0x34>)
    *p_flag = idx;
 100ab3a:	700b      	strb	r3, [r1, #0]
}
 100ab3c:	bd70      	pop	{r4, r5, r6, pc}
 100ab3e:	bf00      	nop
 100ab40:	0bad0000 	.word	0x0bad0000

0100ab44 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
 100ab44:	b510      	push	{r4, lr}
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
 100ab46:	6803      	ldr	r3, [r0, #0]
 100ab48:	40cb      	lsrs	r3, r1
 100ab4a:	07db      	lsls	r3, r3, #31
 100ab4c:	d410      	bmi.n	100ab70 <nrfx_flag32_free+0x2c>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
 100ab4e:	2301      	movs	r3, #1
 100ab50:	408b      	lsls	r3, r1
        prev_mask = *p_mask;
 100ab52:	6802      	ldr	r2, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
 100ab54:	ea43 0102 	orr.w	r1, r3, r2
 100ab58:	e8d0 4fef 	ldaex	r4, [r0]
 100ab5c:	4294      	cmp	r4, r2
 100ab5e:	d104      	bne.n	100ab6a <nrfx_flag32_free+0x26>
 100ab60:	e8c0 1fec 	stlex	ip, r1, [r0]
 100ab64:	f1bc 0f00 	cmp.w	ip, #0
 100ab68:	d1f6      	bne.n	100ab58 <nrfx_flag32_free+0x14>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
 100ab6a:	d1f2      	bne.n	100ab52 <nrfx_flag32_free+0xe>

    return NRFX_SUCCESS;
 100ab6c:	4801      	ldr	r0, [pc, #4]	; (100ab74 <nrfx_flag32_free+0x30>)
}
 100ab6e:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
 100ab70:	4801      	ldr	r0, [pc, #4]	; (100ab78 <nrfx_flag32_free+0x34>)
 100ab72:	e7fc      	b.n	100ab6e <nrfx_flag32_free+0x2a>
 100ab74:	0bad0000 	.word	0x0bad0000
 100ab78:	0bad0004 	.word	0x0bad0004

0100ab7c <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
 100ab7c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    switch (domain)
 100ab7e:	4604      	mov	r4, r0
 100ab80:	b118      	cbz	r0, 100ab8a <clock_stop+0xe>
 100ab82:	2801      	cmp	r0, #1
 100ab84:	d01e      	beq.n	100abc4 <clock_stop+0x48>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
 100ab86:	b003      	add	sp, #12
 100ab88:	bdf0      	pop	{r4, r5, r6, r7, pc}
    p_reg->INTENCLR = mask;
 100ab8a:	2202      	movs	r2, #2
 100ab8c:	4b27      	ldr	r3, [pc, #156]	; (100ac2c <clock_stop+0xb0>)
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
 100ab8e:	4607      	mov	r7, r0
 100ab90:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100ab94:	f8c3 0104 	str.w	r0, [r3, #260]	; 0x104
 100ab98:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 100ab9c:	2201      	movs	r2, #1
 100ab9e:	60da      	str	r2, [r3, #12]
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
 100aba0:	2301      	movs	r3, #1
 100aba2:	f242 7510 	movw	r5, #10000	; 0x2710
 100aba6:	4e21      	ldr	r6, [pc, #132]	; (100ac2c <clock_stop+0xb0>)
 100aba8:	f88d 3007 	strb.w	r3, [sp, #7]
    switch (domain)
 100abac:	b1b4      	cbz	r4, 100abdc <clock_stop+0x60>
 100abae:	2c01      	cmp	r4, #1
 100abb0:	d1e9      	bne.n	100ab86 <clock_stop+0xa>
            if (p_clk_src != NULL)
 100abb2:	b387      	cbz	r7, 100ac16 <clock_stop+0x9a>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
 100abb4:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
 100abb8:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
 100abbc:	703b      	strb	r3, [r7, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 100abbe:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
 100abc2:	e013      	b.n	100abec <clock_stop+0x70>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100abc4:	2200      	movs	r2, #0
    p_reg->INTENCLR = mask;
 100abc6:	4b19      	ldr	r3, [pc, #100]	; (100ac2c <clock_stop+0xb0>)
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
 100abc8:	f10d 0707 	add.w	r7, sp, #7
 100abcc:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100abd0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 100abd4:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 100abd8:	6058      	str	r0, [r3, #4]
 100abda:	e7e1      	b.n	100aba0 <clock_stop+0x24>
            if (p_clk_src != NULL)
 100abdc:	b18f      	cbz	r7, 100ac02 <clock_stop+0x86>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 100abde:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
 100abe2:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
 100abe6:	703b      	strb	r3, [r7, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 100abe8:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 100abec:	03da      	lsls	r2, r3, #15
 100abee:	d5ca      	bpl.n	100ab86 <clock_stop+0xa>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
 100abf0:	f89d 0007 	ldrb.w	r0, [sp, #7]
 100abf4:	2801      	cmp	r0, #1
 100abf6:	d1c6      	bne.n	100ab86 <clock_stop+0xa>
 100abf8:	f001 fcfb 	bl	100c5f2 <nrfx_busy_wait>
 100abfc:	3d01      	subs	r5, #1
 100abfe:	d1d5      	bne.n	100abac <clock_stop+0x30>
 100ac00:	e7c1      	b.n	100ab86 <clock_stop+0xa>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 100ac02:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
 100ac06:	03d9      	lsls	r1, r3, #15
 100ac08:	d5bd      	bpl.n	100ab86 <clock_stop+0xa>
 100ac0a:	2001      	movs	r0, #1
 100ac0c:	f001 fcf1 	bl	100c5f2 <nrfx_busy_wait>
 100ac10:	3d01      	subs	r5, #1
 100ac12:	d1f6      	bne.n	100ac02 <clock_stop+0x86>
 100ac14:	e7b7      	b.n	100ab86 <clock_stop+0xa>
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
 100ac16:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
 100ac1a:	03db      	lsls	r3, r3, #15
 100ac1c:	d5b3      	bpl.n	100ab86 <clock_stop+0xa>
 100ac1e:	2001      	movs	r0, #1
 100ac20:	f001 fce7 	bl	100c5f2 <nrfx_busy_wait>
 100ac24:	3d01      	subs	r5, #1
 100ac26:	d1f6      	bne.n	100ac16 <clock_stop+0x9a>
 100ac28:	e7ad      	b.n	100ab86 <clock_stop+0xa>
 100ac2a:	bf00      	nop
 100ac2c:	41005000 	.word	0x41005000

0100ac30 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
 100ac30:	4b04      	ldr	r3, [pc, #16]	; (100ac44 <nrfx_clock_init+0x14>)
 100ac32:	791a      	ldrb	r2, [r3, #4]
 100ac34:	b922      	cbnz	r2, 100ac40 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
 100ac36:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
 100ac38:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
 100ac3a:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
 100ac3c:	4802      	ldr	r0, [pc, #8]	; (100ac48 <nrfx_clock_init+0x18>)
 100ac3e:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
 100ac40:	4802      	ldr	r0, [pc, #8]	; (100ac4c <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
 100ac42:	4770      	bx	lr
 100ac44:	21000284 	.word	0x21000284
 100ac48:	0bad0000 	.word	0x0bad0000
 100ac4c:	0bad000c 	.word	0x0bad000c

0100ac50 <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
 100ac50:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
 100ac52:	2005      	movs	r0, #5
 100ac54:	f7fe fdc4 	bl	10097e0 <arch_irq_is_enabled>
 100ac58:	b910      	cbnz	r0, 100ac60 <nrfx_clock_enable+0x10>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
 100ac5a:	2005      	movs	r0, #5
 100ac5c:	f7fe fdb2 	bl	10097c4 <arch_irq_enable>
    p_reg->LFCLKSRC = (uint32_t)(source);
 100ac60:	2201      	movs	r2, #1
 100ac62:	4b03      	ldr	r3, [pc, #12]	; (100ac70 <nrfx_clock_enable+0x20>)
 100ac64:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}

#if NRF_CLOCK_HAS_HFCLKSRC
NRF_STATIC_INLINE void nrf_clock_hf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLKSRC = (uint32_t)(source);
 100ac68:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
#endif

    NRFX_LOG_INFO("Module enabled.");
}
 100ac6c:	bd08      	pop	{r3, pc}
 100ac6e:	bf00      	nop
 100ac70:	41005000 	.word	0x41005000

0100ac74 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
 100ac74:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
 100ac76:	b110      	cbz	r0, 100ac7e <nrfx_clock_start+0xa>
 100ac78:	2801      	cmp	r0, #1
 100ac7a:	d02e      	beq.n	100acda <nrfx_clock_start+0x66>
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
 100ac7c:	bd08      	pop	{r3, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 100ac7e:	4a1c      	ldr	r2, [pc, #112]	; (100acf0 <nrfx_clock_start+0x7c>)
 100ac80:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 100ac84:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
 100ac88:	03c9      	lsls	r1, r1, #15
 100ac8a:	d40e      	bmi.n	100acaa <nrfx_clock_start+0x36>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
 100ac8c:	f8d2 3414 	ldr.w	r3, [r2, #1044]	; 0x414
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
 100ac90:	07db      	lsls	r3, r3, #31
 100ac92:	d513      	bpl.n	100acbc <nrfx_clock_start+0x48>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
 100ac94:	f8d2 341c 	ldr.w	r3, [r2, #1052]	; 0x41c
 100ac98:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
 100ac9c:	3b01      	subs	r3, #1
 100ac9e:	2b01      	cmp	r3, #1
 100aca0:	d809      	bhi.n	100acb6 <nrfx_clock_start+0x42>
    p_reg->INTENSET = mask;
 100aca2:	2302      	movs	r3, #2
 100aca4:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
                        break;
 100aca8:	e7e8      	b.n	100ac7c <nrfx_clock_start+0x8>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 100acaa:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
 100acae:	2b02      	cmp	r3, #2
 100acb0:	d005      	beq.n	100acbe <nrfx_clock_start+0x4a>
 100acb2:	2b01      	cmp	r3, #1
 100acb4:	d002      	beq.n	100acbc <nrfx_clock_start+0x48>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
 100acb6:	2000      	movs	r0, #0
 100acb8:	f7ff ff60 	bl	100ab7c <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
 100acbc:	2301      	movs	r3, #1
    p_reg->LFCLKSRC = (uint32_t)(source);
 100acbe:	4a0c      	ldr	r2, [pc, #48]	; (100acf0 <nrfx_clock_start+0x7c>)
 100acc0:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100acc4:	2300      	movs	r3, #0
 100acc6:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
 100acca:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    p_reg->INTENSET = mask;
 100acce:	2302      	movs	r3, #2
 100acd0:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 100acd4:	2301      	movs	r3, #1
 100acd6:	6093      	str	r3, [r2, #8]
}
 100acd8:	e7d0      	b.n	100ac7c <nrfx_clock_start+0x8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100acda:	2200      	movs	r2, #0
 100acdc:	4b04      	ldr	r3, [pc, #16]	; (100acf0 <nrfx_clock_start+0x7c>)
 100acde:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 100ace2:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
 100ace6:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 100acea:	6018      	str	r0, [r3, #0]
}
 100acec:	e7c6      	b.n	100ac7c <nrfx_clock_start+0x8>
 100acee:	bf00      	nop
 100acf0:	41005000 	.word	0x41005000

0100acf4 <nrfx_power_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
 100acf4:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 100acf6:	4b17      	ldr	r3, [pc, #92]	; (100ad54 <nrfx_power_clock_irq_handler+0x60>)
 100acf8:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
 100acfc:	b152      	cbz	r2, 100ad14 <nrfx_power_clock_irq_handler+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100acfe:	2000      	movs	r0, #0
 100ad00:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
 100ad04:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
 100ad08:	2201      	movs	r2, #1
 100ad0a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
 100ad0e:	4b12      	ldr	r3, [pc, #72]	; (100ad58 <nrfx_power_clock_irq_handler+0x64>)
 100ad10:	681b      	ldr	r3, [r3, #0]
 100ad12:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 100ad14:	4b0f      	ldr	r3, [pc, #60]	; (100ad54 <nrfx_power_clock_irq_handler+0x60>)
 100ad16:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
 100ad1a:	b18a      	cbz	r2, 100ad40 <nrfx_power_clock_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100ad1c:	2200      	movs	r2, #0
 100ad1e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
 100ad22:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
 100ad26:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
 100ad2a:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
 100ad2e:	f002 0203 	and.w	r2, r2, #3
 100ad32:	2a01      	cmp	r2, #1
 100ad34:	f04f 0102 	mov.w	r1, #2
 100ad38:	d103      	bne.n	100ad42 <nrfx_power_clock_irq_handler+0x4e>
    p_reg->LFCLKSRC = (uint32_t)(source);
 100ad3a:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 100ad3e:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
 100ad40:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
 100ad42:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
 100ad46:	4b04      	ldr	r3, [pc, #16]	; (100ad58 <nrfx_power_clock_irq_handler+0x64>)
 100ad48:	2001      	movs	r0, #1
}
 100ad4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
 100ad4e:	681b      	ldr	r3, [r3, #0]
 100ad50:	4718      	bx	r3
 100ad52:	bf00      	nop
 100ad54:	41005000 	.word	0x41005000
 100ad58:	21000284 	.word	0x21000284

0100ad5c <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
 100ad5c:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
 100ad5e:	f003 021f 	and.w	r2, r3, #31
 100ad62:	6002      	str	r2, [r0, #0]
}
 100ad64:	4a03      	ldr	r2, [pc, #12]	; (100ad74 <nrf_gpio_pin_port_decode+0x18>)
 100ad66:	4804      	ldr	r0, [pc, #16]	; (100ad78 <nrf_gpio_pin_port_decode+0x1c>)
    return pin_number >> 5;
 100ad68:	095b      	lsrs	r3, r3, #5
}
 100ad6a:	2b01      	cmp	r3, #1
 100ad6c:	bf18      	it	ne
 100ad6e:	4610      	movne	r0, r2
 100ad70:	4770      	bx	lr
 100ad72:	bf00      	nop
 100ad74:	418c0500 	.word	0x418c0500
 100ad78:	418c0800 	.word	0x418c0800

0100ad7c <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
 100ad7c:	4b03      	ldr	r3, [pc, #12]	; (100ad8c <pin_in_use_by_te+0x10>)
 100ad7e:	3008      	adds	r0, #8
 100ad80:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
 100ad84:	f3c0 1040 	ubfx	r0, r0, #5, #1
 100ad88:	4770      	bx	lr
 100ad8a:	bf00      	nop
 100ad8c:	21000004 	.word	0x21000004

0100ad90 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
 100ad90:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
 100ad92:	4c0d      	ldr	r4, [pc, #52]	; (100adc8 <call_handler+0x38>)
 100ad94:	f100 0308 	add.w	r3, r0, #8
 100ad98:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
 100ad9c:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
 100ad9e:	05da      	lsls	r2, r3, #23
{
 100ada0:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
 100ada2:	d507      	bpl.n	100adb4 <call_handler+0x24>
 100ada4:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
 100ada8:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
 100adac:	6852      	ldr	r2, [r2, #4]
 100adae:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
 100adb2:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
 100adb4:	68a3      	ldr	r3, [r4, #8]
 100adb6:	b12b      	cbz	r3, 100adc4 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
 100adb8:	4631      	mov	r1, r6
 100adba:	4628      	mov	r0, r5
 100adbc:	68e2      	ldr	r2, [r4, #12]
    }
}
 100adbe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
 100adc2:	4718      	bx	r3
}
 100adc4:	bd70      	pop	{r4, r5, r6, pc}
 100adc6:	bf00      	nop
 100adc8:	21000004 	.word	0x21000004

0100adcc <release_handler>:
{
 100adcc:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
 100adce:	4a12      	ldr	r2, [pc, #72]	; (100ae18 <release_handler+0x4c>)
 100add0:	3008      	adds	r0, #8
 100add2:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
 100add6:	05d9      	lsls	r1, r3, #23
 100add8:	d51b      	bpl.n	100ae12 <release_handler+0x46>
 100adda:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
 100adde:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 100ade2:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
 100ade6:	2000      	movs	r0, #0
 100ade8:	f102 040e 	add.w	r4, r2, #14
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
 100adec:	f834 3f02 	ldrh.w	r3, [r4, #2]!
 100adf0:	f413 7f80 	tst.w	r3, #256	; 0x100
 100adf4:	d003      	beq.n	100adfe <release_handler+0x32>
 100adf6:	f3c3 2343 	ubfx	r3, r3, #9, #4
 100adfa:	4299      	cmp	r1, r3
 100adfc:	d009      	beq.n	100ae12 <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
 100adfe:	3001      	adds	r0, #1
 100ae00:	2830      	cmp	r0, #48	; 0x30
 100ae02:	d1f3      	bne.n	100adec <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
 100ae04:	2300      	movs	r3, #0
 100ae06:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
 100ae0a:	4804      	ldr	r0, [pc, #16]	; (100ae1c <release_handler+0x50>)
}
 100ae0c:	bc10      	pop	{r4}
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
 100ae0e:	f7ff be99 	b.w	100ab44 <nrfx_flag32_free>
}
 100ae12:	bc10      	pop	{r4}
 100ae14:	4770      	bx	lr
 100ae16:	bf00      	nop
 100ae18:	21000004 	.word	0x21000004
 100ae1c:	21000078 	.word	0x21000078

0100ae20 <pin_handler_trigger_uninit>:
{
 100ae20:	b538      	push	{r3, r4, r5, lr}
 100ae22:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
 100ae24:	f7ff ffaa 	bl	100ad7c <pin_in_use_by_te>
 100ae28:	4c0b      	ldr	r4, [pc, #44]	; (100ae58 <pin_handler_trigger_uninit+0x38>)
 100ae2a:	f102 0508 	add.w	r5, r2, #8
 100ae2e:	b160      	cbz	r0, 100ae4a <pin_handler_trigger_uninit+0x2a>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
 100ae30:	2100      	movs	r1, #0
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 100ae32:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
 100ae36:	0b5b      	lsrs	r3, r3, #13
 100ae38:	009b      	lsls	r3, r3, #2
 100ae3a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 100ae3e:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
 100ae42:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
#if defined(NRF53_SERIES) || defined(NRF91_SERIES)
    p_reg->CONFIG[idx] = 0;
 100ae46:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
    release_handler(pin);
 100ae4a:	4610      	mov	r0, r2
 100ae4c:	f7ff ffbe 	bl	100adcc <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
 100ae50:	2300      	movs	r3, #0
 100ae52:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
 100ae56:	bd38      	pop	{r3, r4, r5, pc}
 100ae58:	21000004 	.word	0x21000004

0100ae5c <nrfx_gpiote_input_configure>:
{
 100ae5c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 100ae60:	4604      	mov	r4, r0
 100ae62:	4690      	mov	r8, r2
 100ae64:	461d      	mov	r5, r3
    if (p_input_config)
 100ae66:	b301      	cbz	r1, 100aeaa <nrfx_gpiote_input_configure+0x4e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
 100ae68:	4e50      	ldr	r6, [pc, #320]	; (100afac <nrfx_gpiote_input_configure+0x150>)
 100ae6a:	f100 0708 	add.w	r7, r0, #8
    return pin_is_output(pin) && pin_in_use_by_te(pin);
 100ae6e:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
 100ae72:	079b      	lsls	r3, r3, #30
 100ae74:	d502      	bpl.n	100ae7c <nrfx_gpiote_input_configure+0x20>
 100ae76:	f7ff ff81 	bl	100ad7c <pin_in_use_by_te>
 100ae7a:	bb28      	cbnz	r0, 100aec8 <nrfx_gpiote_input_configure+0x6c>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
 100ae7c:	2300      	movs	r3, #0
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
 100ae7e:	4620      	mov	r0, r4
 100ae80:	e9cd 3300 	strd	r3, r3, [sp]
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
 100ae84:	f88d 300e 	strb.w	r3, [sp, #14]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
 100ae88:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
 100ae8c:	f10d 020f 	add.w	r2, sp, #15
 100ae90:	460b      	mov	r3, r1
 100ae92:	f10d 010e 	add.w	r1, sp, #14
 100ae96:	f001 fbb0 	bl	100c5fa <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
 100ae9a:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
 100ae9e:	f023 0302 	bic.w	r3, r3, #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
 100aea2:	f043 0301 	orr.w	r3, r3, #1
 100aea6:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_trigger_config)
 100aeaa:	f1b8 0f00 	cmp.w	r8, #0
 100aeae:	d02d      	beq.n	100af0c <nrfx_gpiote_input_configure+0xb0>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
 100aeb0:	4e3e      	ldr	r6, [pc, #248]	; (100afac <nrfx_gpiote_input_configure+0x150>)
 100aeb2:	f104 0708 	add.w	r7, r4, #8
 100aeb6:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
 100aeba:	f898 0000 	ldrb.w	r0, [r8]
        if (pin_is_output(pin))
 100aebe:	0799      	lsls	r1, r3, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
 100aec0:	f8d8 2004 	ldr.w	r2, [r8, #4]
        if (pin_is_output(pin))
 100aec4:	d502      	bpl.n	100aecc <nrfx_gpiote_input_configure+0x70>
            if (use_evt)
 100aec6:	b1ca      	cbz	r2, 100aefc <nrfx_gpiote_input_configure+0xa0>
            return NRFX_ERROR_INVALID_PARAM;
 100aec8:	4839      	ldr	r0, [pc, #228]	; (100afb0 <nrfx_gpiote_input_configure+0x154>)
 100aeca:	e021      	b.n	100af10 <nrfx_gpiote_input_configure+0xb4>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
 100aecc:	f023 0320 	bic.w	r3, r3, #32
 100aed0:	04db      	lsls	r3, r3, #19
 100aed2:	0cdb      	lsrs	r3, r3, #19
 100aed4:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
            if (use_evt)
 100aed8:	b182      	cbz	r2, 100aefc <nrfx_gpiote_input_configure+0xa0>
                if (!edge)
 100aeda:	2803      	cmp	r0, #3
 100aedc:	d8f4      	bhi.n	100aec8 <nrfx_gpiote_input_configure+0x6c>
                uint8_t ch = *p_trigger_config->p_in_channel;
 100aede:	f8d8 2004 	ldr.w	r2, [r8, #4]
 100aee2:	f892 c000 	ldrb.w	ip, [r2]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
 100aee6:	ea4f 028c 	mov.w	r2, ip, lsl #2
 100aeea:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
 100aeee:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
 100aef2:	b980      	cbnz	r0, 100af16 <nrfx_gpiote_input_configure+0xba>
    p_reg->CONFIG[idx] = 0;
 100aef4:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
 100aef8:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
 100aefc:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
 100af00:	f023 031c 	bic.w	r3, r3, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
 100af04:	ea43 0380 	orr.w	r3, r3, r0, lsl #2
 100af08:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_handler_config)
 100af0c:	bb1d      	cbnz	r5, 100af56 <nrfx_gpiote_input_configure+0xfa>
        err = NRFX_SUCCESS;
 100af0e:	4829      	ldr	r0, [pc, #164]	; (100afb4 <nrfx_gpiote_input_configure+0x158>)
}
 100af10:	b004      	add	sp, #16
 100af12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
 100af16:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
 100af1a:	ea43 334c 	orr.w	r3, r3, ip, lsl #13
 100af1e:	f021 0103 	bic.w	r1, r1, #3
 100af22:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
 100af26:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
 100af2a:	f043 0320 	orr.w	r3, r3, #32
 100af2e:	f421 314f 	bic.w	r1, r1, #211968	; 0x33c00
 100af32:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 100af36:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 100af3a:	0221      	lsls	r1, r4, #8
 100af3c:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
 100af40:	f401 517c 	and.w	r1, r1, #16128	; 0x3f00
 100af44:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 100af48:	ea41 010e 	orr.w	r1, r1, lr
 100af4c:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
 100af50:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
 100af54:	e7d2      	b.n	100aefc <nrfx_gpiote_input_configure+0xa0>
    release_handler(pin);
 100af56:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
 100af58:	e9d5 6700 	ldrd	r6, r7, [r5]
    release_handler(pin);
 100af5c:	f7ff ff36 	bl	100adcc <release_handler>
    if (!handler)
 100af60:	2e00      	cmp	r6, #0
 100af62:	d0d4      	beq.n	100af0e <nrfx_gpiote_input_configure+0xb2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
 100af64:	4d11      	ldr	r5, [pc, #68]	; (100afac <nrfx_gpiote_input_configure+0x150>)
 100af66:	e9d5 2300 	ldrd	r2, r3, [r5]
 100af6a:	4296      	cmp	r6, r2
 100af6c:	d101      	bne.n	100af72 <nrfx_gpiote_input_configure+0x116>
 100af6e:	429f      	cmp	r7, r3
 100af70:	d019      	beq.n	100afa6 <nrfx_gpiote_input_configure+0x14a>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
 100af72:	4811      	ldr	r0, [pc, #68]	; (100afb8 <nrfx_gpiote_input_configure+0x15c>)
 100af74:	f10d 010f 	add.w	r1, sp, #15
 100af78:	f7ff fdc8 	bl	100ab0c <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
 100af7c:	4b0d      	ldr	r3, [pc, #52]	; (100afb4 <nrfx_gpiote_input_configure+0x158>)
 100af7e:	4298      	cmp	r0, r3
 100af80:	d1c6      	bne.n	100af10 <nrfx_gpiote_input_configure+0xb4>
        handler_id = (int32_t)id;
 100af82:	f89d 200f 	ldrb.w	r2, [sp, #15]
    m_cb.handlers[handler_id].p_context = p_context;
 100af86:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
 100af8a:	f104 0008 	add.w	r0, r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
 100af8e:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
 100af90:	f835 3010 	ldrh.w	r3, [r5, r0, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
 100af94:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
 100af98:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
 100af9c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 100afa0:	f825 3010 	strh.w	r3, [r5, r0, lsl #1]
    return NRFX_SUCCESS;
 100afa4:	e7b3      	b.n	100af0e <nrfx_gpiote_input_configure+0xb2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
 100afa6:	2200      	movs	r2, #0
 100afa8:	e7ed      	b.n	100af86 <nrfx_gpiote_input_configure+0x12a>
 100afaa:	bf00      	nop
 100afac:	21000004 	.word	0x21000004
 100afb0:	0bad0004 	.word	0x0bad0004
 100afb4:	0bad0000 	.word	0x0bad0000
 100afb8:	21000078 	.word	0x21000078

0100afbc <nrfx_gpiote_output_configure>:
{
 100afbc:	b5f0      	push	{r4, r5, r6, r7, lr}
 100afbe:	4604      	mov	r4, r0
 100afc0:	4616      	mov	r6, r2
 100afc2:	b085      	sub	sp, #20
    if (p_config)
 100afc4:	b319      	cbz	r1, 100b00e <nrfx_gpiote_output_configure+0x52>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
 100afc6:	4d34      	ldr	r5, [pc, #208]	; (100b098 <nrfx_gpiote_output_configure+0xdc>)
 100afc8:	f100 0708 	add.w	r7, r0, #8
 100afcc:	f835 2017 	ldrh.w	r2, [r5, r7, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
 100afd0:	0793      	lsls	r3, r2, #30
 100afd2:	d403      	bmi.n	100afdc <nrfx_gpiote_output_configure+0x20>
 100afd4:	f7ff fed2 	bl	100ad7c <pin_in_use_by_te>
 100afd8:	2800      	cmp	r0, #0
 100afda:	d15a      	bne.n	100b092 <nrfx_gpiote_output_configure+0xd6>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
 100afdc:	f012 0f1c 	tst.w	r2, #28
 100afe0:	d002      	beq.n	100afe8 <nrfx_gpiote_output_configure+0x2c>
 100afe2:	784b      	ldrb	r3, [r1, #1]
 100afe4:	2b01      	cmp	r3, #1
 100afe6:	d054      	beq.n	100b092 <nrfx_gpiote_output_configure+0xd6>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
 100afe8:	2301      	movs	r3, #1
 100afea:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
 100afee:	2300      	movs	r3, #0
 100aff0:	1c4a      	adds	r2, r1, #1
 100aff2:	e9cd 1300 	strd	r1, r3, [sp]
 100aff6:	4620      	mov	r0, r4
 100aff8:	1c8b      	adds	r3, r1, #2
 100affa:	f10d 010f 	add.w	r1, sp, #15
 100affe:	f001 fafc 	bl	100c5fa <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
 100b002:	f835 3017 	ldrh.w	r3, [r5, r7, lsl #1]
 100b006:	f043 0303 	orr.w	r3, r3, #3
 100b00a:	f825 3017 	strh.w	r3, [r5, r7, lsl #1]
    if (p_task_config)
 100b00e:	b916      	cbnz	r6, 100b016 <nrfx_gpiote_output_configure+0x5a>
    return NRFX_SUCCESS;
 100b010:	4822      	ldr	r0, [pc, #136]	; (100b09c <nrfx_gpiote_output_configure+0xe0>)
}
 100b012:	b005      	add	sp, #20
 100b014:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
 100b016:	4a20      	ldr	r2, [pc, #128]	; (100b098 <nrfx_gpiote_output_configure+0xdc>)
 100b018:	f104 0708 	add.w	r7, r4, #8
 100b01c:	f832 0017 	ldrh.w	r0, [r2, r7, lsl #1]
        if (pin_is_input(pin))
 100b020:	0783      	lsls	r3, r0, #30
 100b022:	d536      	bpl.n	100b092 <nrfx_gpiote_output_configure+0xd6>
    p_reg->CONFIG[idx] = 0;
 100b024:	2300      	movs	r3, #0
        uint32_t ch = p_task_config->task_ch;
 100b026:	f896 c000 	ldrb.w	ip, [r6]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
 100b02a:	f020 0020 	bic.w	r0, r0, #32
 100b02e:	ea4f 018c 	mov.w	r1, ip, lsl #2
 100b032:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
 100b036:	04c0      	lsls	r0, r0, #19
 100b038:	f501 4120 	add.w	r1, r1, #40960	; 0xa000
 100b03c:	0cc0      	lsrs	r0, r0, #19
 100b03e:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
 100b042:	f822 0017 	strh.w	r0, [r2, r7, lsl #1]
    p_reg->CONFIG[idx] = 0;
 100b046:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
 100b04a:	7875      	ldrb	r5, [r6, #1]
 100b04c:	2d00      	cmp	r5, #0
 100b04e:	d0df      	beq.n	100b010 <nrfx_gpiote_output_configure+0x54>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
 100b050:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
                                      p_task_config->init_val);
 100b054:	78b6      	ldrb	r6, [r6, #2]
 100b056:	f423 1399 	bic.w	r3, r3, #1253376	; 0x132000
 100b05a:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 100b05e:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 100b062:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
 100b066:	0223      	lsls	r3, r4, #8
 100b068:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
 100b06c:	042d      	lsls	r5, r5, #16
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 100b06e:	ea43 030e 	orr.w	r3, r3, lr
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
 100b072:	f405 3540 	and.w	r5, r5, #196608	; 0x30000
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
 100b076:	0534      	lsls	r4, r6, #20
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 100b078:	432b      	orrs	r3, r5
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
 100b07a:	f404 1480 	and.w	r4, r4, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
 100b07e:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 100b082:	4323      	orrs	r3, r4
 100b084:	f040 0020 	orr.w	r0, r0, #32
 100b088:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
 100b08c:	f822 0017 	strh.w	r0, [r2, r7, lsl #1]
 100b090:	e7be      	b.n	100b010 <nrfx_gpiote_output_configure+0x54>
{
 100b092:	4803      	ldr	r0, [pc, #12]	; (100b0a0 <nrfx_gpiote_output_configure+0xe4>)
 100b094:	e7bd      	b.n	100b012 <nrfx_gpiote_output_configure+0x56>
 100b096:	bf00      	nop
 100b098:	21000004 	.word	0x21000004
 100b09c:	0bad0000 	.word	0x0bad0000
 100b0a0:	0bad0004 	.word	0x0bad0004

0100b0a4 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
 100b0a4:	4b01      	ldr	r3, [pc, #4]	; (100b0ac <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
 100b0a6:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
 100b0aa:	4770      	bx	lr
 100b0ac:	21000004 	.word	0x21000004

0100b0b0 <nrfx_gpiote_channel_get>:
{
 100b0b0:	b508      	push	{r3, lr}
 100b0b2:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
 100b0b4:	f7ff fe62 	bl	100ad7c <pin_in_use_by_te>
 100b0b8:	b138      	cbz	r0, 100b0ca <nrfx_gpiote_channel_get+0x1a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 100b0ba:	4b05      	ldr	r3, [pc, #20]	; (100b0d0 <nrfx_gpiote_channel_get+0x20>)
 100b0bc:	3208      	adds	r2, #8
 100b0be:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
        return NRFX_SUCCESS;
 100b0c2:	4804      	ldr	r0, [pc, #16]	; (100b0d4 <nrfx_gpiote_channel_get+0x24>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 100b0c4:	0b5b      	lsrs	r3, r3, #13
 100b0c6:	700b      	strb	r3, [r1, #0]
}
 100b0c8:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
 100b0ca:	4803      	ldr	r0, [pc, #12]	; (100b0d8 <nrfx_gpiote_channel_get+0x28>)
 100b0cc:	e7fc      	b.n	100b0c8 <nrfx_gpiote_channel_get+0x18>
 100b0ce:	bf00      	nop
 100b0d0:	21000004 	.word	0x21000004
 100b0d4:	0bad0000 	.word	0x0bad0000
 100b0d8:	0bad0004 	.word	0x0bad0004

0100b0dc <nrfx_gpiote_init>:
{
 100b0dc:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 100b0de:	4c0f      	ldr	r4, [pc, #60]	; (100b11c <nrfx_gpiote_init+0x40>)
 100b0e0:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
 100b0e4:	b9bd      	cbnz	r5, 100b116 <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
 100b0e6:	2260      	movs	r2, #96	; 0x60
 100b0e8:	4629      	mov	r1, r5
 100b0ea:	f104 0010 	add.w	r0, r4, #16
 100b0ee:	f001 f979 	bl	100c3e4 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
 100b0f2:	200a      	movs	r0, #10
 100b0f4:	f7fe fb66 	bl	10097c4 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 100b0f8:	4b09      	ldr	r3, [pc, #36]	; (100b120 <nrfx_gpiote_init+0x44>)
    return err_code;
 100b0fa:	480a      	ldr	r0, [pc, #40]	; (100b124 <nrfx_gpiote_init+0x48>)
 100b0fc:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
 100b100:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
 100b104:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 100b108:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
 100b10c:	2301      	movs	r3, #1
 100b10e:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
 100b112:	6763      	str	r3, [r4, #116]	; 0x74
}
 100b114:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
 100b116:	4804      	ldr	r0, [pc, #16]	; (100b128 <nrfx_gpiote_init+0x4c>)
 100b118:	e7fc      	b.n	100b114 <nrfx_gpiote_init+0x38>
 100b11a:	bf00      	nop
 100b11c:	21000004 	.word	0x21000004
 100b120:	4100a000 	.word	0x4100a000
 100b124:	0bad0000 	.word	0x0bad0000
 100b128:	0bad0005 	.word	0x0bad0005

0100b12c <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
 100b12c:	4b03      	ldr	r3, [pc, #12]	; (100b13c <nrfx_gpiote_is_init+0x10>)
 100b12e:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
 100b132:	3800      	subs	r0, #0
 100b134:	bf18      	it	ne
 100b136:	2001      	movne	r0, #1
 100b138:	4770      	bx	lr
 100b13a:	bf00      	nop
 100b13c:	21000004 	.word	0x21000004

0100b140 <nrfx_gpiote_channel_free>:
{
 100b140:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
 100b142:	4801      	ldr	r0, [pc, #4]	; (100b148 <nrfx_gpiote_channel_free+0x8>)
 100b144:	f7ff bcfe 	b.w	100ab44 <nrfx_flag32_free>
 100b148:	21000074 	.word	0x21000074

0100b14c <nrfx_gpiote_channel_alloc>:
{
 100b14c:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
 100b14e:	4801      	ldr	r0, [pc, #4]	; (100b154 <nrfx_gpiote_channel_alloc+0x8>)
 100b150:	f7ff bcdc 	b.w	100ab0c <nrfx_flag32_alloc>
 100b154:	21000074 	.word	0x21000074

0100b158 <nrfx_gpiote_trigger_enable>:
{
 100b158:	b537      	push	{r0, r1, r2, r4, r5, lr}
 100b15a:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
 100b15c:	f7ff fe0e 	bl	100ad7c <pin_in_use_by_te>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
 100b160:	4b1e      	ldr	r3, [pc, #120]	; (100b1dc <nrfx_gpiote_trigger_enable+0x84>)
 100b162:	f104 0208 	add.w	r2, r4, #8
 100b166:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
 100b16a:	b1e8      	cbz	r0, 100b1a8 <nrfx_gpiote_trigger_enable+0x50>
 100b16c:	f013 0502 	ands.w	r5, r3, #2
 100b170:	d11a      	bne.n	100b1a8 <nrfx_gpiote_trigger_enable+0x50>
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 100b172:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
 100b174:	009a      	lsls	r2, r3, #2
    return ((uint32_t)p_reg + event);
 100b176:	f102 4082 	add.w	r0, r2, #1090519040	; 0x41000000
 100b17a:	f500 4021 	add.w	r0, r0, #41216	; 0xa100
 100b17e:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 100b182:	6005      	str	r5, [r0, #0]
 100b184:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
 100b188:	6800      	ldr	r0, [r0, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
 100b18a:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
 100b18e:	f040 0001 	orr.w	r0, r0, #1
 100b192:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
 100b196:	b129      	cbz	r1, 100b1a4 <nrfx_gpiote_trigger_enable+0x4c>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
 100b198:	2201      	movs	r2, #1
 100b19a:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
 100b19e:	4a10      	ldr	r2, [pc, #64]	; (100b1e0 <nrfx_gpiote_trigger_enable+0x88>)
 100b1a0:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
 100b1a4:	b003      	add	sp, #12
 100b1a6:	bd30      	pop	{r4, r5, pc}
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
 100b1a8:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
 100b1ac:	2b04      	cmp	r3, #4
 100b1ae:	d011      	beq.n	100b1d4 <nrfx_gpiote_trigger_enable+0x7c>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
 100b1b0:	2b05      	cmp	r3, #5
 100b1b2:	d011      	beq.n	100b1d8 <nrfx_gpiote_trigger_enable+0x80>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 100b1b4:	a801      	add	r0, sp, #4
 100b1b6:	9401      	str	r4, [sp, #4]
 100b1b8:	f7ff fdd0 	bl	100ad5c <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
 100b1bc:	9b01      	ldr	r3, [sp, #4]
    return p_reg->IN;
 100b1be:	6901      	ldr	r1, [r0, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
 100b1c0:	40d9      	lsrs	r1, r3
 100b1c2:	f001 0101 	and.w	r1, r1, #1
 100b1c6:	3102      	adds	r1, #2
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
 100b1c8:	4620      	mov	r0, r4
}
 100b1ca:	b003      	add	sp, #12
 100b1cc:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
 100b1d0:	f001 ba5c 	b.w	100c68c <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
 100b1d4:	2103      	movs	r1, #3
 100b1d6:	e7f7      	b.n	100b1c8 <nrfx_gpiote_trigger_enable+0x70>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
 100b1d8:	2102      	movs	r1, #2
 100b1da:	e7f5      	b.n	100b1c8 <nrfx_gpiote_trigger_enable+0x70>
 100b1dc:	21000004 	.word	0x21000004
 100b1e0:	4100a000 	.word	0x4100a000

0100b1e4 <nrfx_gpiote_trigger_disable>:
{
 100b1e4:	b508      	push	{r3, lr}
 100b1e6:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
 100b1e8:	f7ff fdc8 	bl	100ad7c <pin_in_use_by_te>
 100b1ec:	b1c0      	cbz	r0, 100b220 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
 100b1ee:	4b0f      	ldr	r3, [pc, #60]	; (100b22c <nrfx_gpiote_trigger_disable+0x48>)
 100b1f0:	f102 0108 	add.w	r1, r2, #8
 100b1f4:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
 100b1f8:	0799      	lsls	r1, r3, #30
 100b1fa:	d411      	bmi.n	100b220 <nrfx_gpiote_trigger_disable+0x3c>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
 100b1fc:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
 100b1fe:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
 100b200:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
 100b202:	490b      	ldr	r1, [pc, #44]	; (100b230 <nrfx_gpiote_trigger_disable+0x4c>)
 100b204:	009b      	lsls	r3, r3, #2
 100b206:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 100b20a:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
 100b20e:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
 100b212:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
 100b216:	f022 0203 	bic.w	r2, r2, #3
 100b21a:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
 100b21e:	bd08      	pop	{r3, pc}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
 100b220:	2100      	movs	r1, #0
}
 100b222:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
 100b226:	4610      	mov	r0, r2
 100b228:	f001 ba30 	b.w	100c68c <nrf_gpio_cfg_sense_set>
 100b22c:	21000004 	.word	0x21000004
 100b230:	4100a000 	.word	0x4100a000

0100b234 <nrfx_gpiote_pin_uninit>:
{
 100b234:	b513      	push	{r0, r1, r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
 100b236:	4b10      	ldr	r3, [pc, #64]	; (100b278 <nrfx_gpiote_pin_uninit+0x44>)
 100b238:	f100 0208 	add.w	r2, r0, #8
 100b23c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
 100b240:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
 100b242:	07db      	lsls	r3, r3, #31
 100b244:	d516      	bpl.n	100b274 <nrfx_gpiote_pin_uninit+0x40>
    nrfx_gpiote_trigger_disable(pin);
 100b246:	f7ff ffcd 	bl	100b1e4 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
 100b24a:	4620      	mov	r0, r4
 100b24c:	f7ff fde8 	bl	100ae20 <pin_handler_trigger_uninit>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 100b250:	a801      	add	r0, sp, #4
 100b252:	9401      	str	r4, [sp, #4]
 100b254:	f7ff fd82 	bl	100ad5c <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
 100b258:	9b01      	ldr	r3, [sp, #4]
 100b25a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 100b25e:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 100b262:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
 100b266:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
 100b26a:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    nrf_gpio_cfg(
 100b26e:	4803      	ldr	r0, [pc, #12]	; (100b27c <nrfx_gpiote_pin_uninit+0x48>)
}
 100b270:	b002      	add	sp, #8
 100b272:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
 100b274:	4802      	ldr	r0, [pc, #8]	; (100b280 <nrfx_gpiote_pin_uninit+0x4c>)
 100b276:	e7fb      	b.n	100b270 <nrfx_gpiote_pin_uninit+0x3c>
 100b278:	21000004 	.word	0x21000004
 100b27c:	0bad0000 	.word	0x0bad0000
 100b280:	0bad0004 	.word	0x0bad0004

0100b284 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
 100b284:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
 100b288:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
 100b28a:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 100b28c:	4634      	mov	r4, r6
{
 100b28e:	4b65      	ldr	r3, [pc, #404]	; (100b424 <nrfx_gpiote_irq_handler+0x1a0>)
    return p_reg->INTENSET & mask;
 100b290:	4865      	ldr	r0, [pc, #404]	; (100b428 <nrfx_gpiote_irq_handler+0x1a4>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
 100b292:	4966      	ldr	r1, [pc, #408]	; (100b42c <nrfx_gpiote_irq_handler+0x1a8>)
{
 100b294:	b087      	sub	sp, #28
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 100b296:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
 100b298:	b135      	cbz	r5, 100b2a8 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
 100b29a:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
 100b29e:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 100b2a0:	bf1e      	ittt	ne
 100b2a2:	601c      	strne	r4, [r3, #0]
 100b2a4:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
 100b2a6:	4316      	orrne	r6, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
 100b2a8:	3304      	adds	r3, #4
 100b2aa:	428b      	cmp	r3, r1
        }
        mask <<= 1;
 100b2ac:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
 100b2b0:	d1f1      	bne.n	100b296 <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 100b2b2:	4b5d      	ldr	r3, [pc, #372]	; (100b428 <nrfx_gpiote_irq_handler+0x1a4>)
 100b2b4:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
 100b2b8:	2b00      	cmp	r3, #0
 100b2ba:	f000 8096 	beq.w	100b3ea <nrfx_gpiote_irq_handler+0x166>
        *p_masks = gpio_regs[i]->LATCH;
 100b2be:	f8df 9170 	ldr.w	r9, [pc, #368]	; 100b430 <nrfx_gpiote_irq_handler+0x1ac>
 100b2c2:	f8df 8170 	ldr.w	r8, [pc, #368]	; 100b434 <nrfx_gpiote_irq_handler+0x1b0>
 100b2c6:	f8d9 3020 	ldr.w	r3, [r9, #32]
 100b2ca:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
 100b2cc:	f8c9 3020 	str.w	r3, [r9, #32]
        *p_masks = gpio_regs[i]->LATCH;
 100b2d0:	f8d8 3020 	ldr.w	r3, [r8, #32]
 100b2d4:	9305      	str	r3, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
 100b2d6:	f8c8 3020 	str.w	r3, [r8, #32]
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
 100b2da:	f04f 0a00 	mov.w	sl, #0
            while (latch[i])
 100b2de:	f10d 0b10 	add.w	fp, sp, #16
 100b2e2:	ea4f 134a 	mov.w	r3, sl, lsl #5
 100b2e6:	9300      	str	r3, [sp, #0]
 100b2e8:	e048      	b.n	100b37c <nrfx_gpiote_irq_handler+0xf8>
                uint32_t pin = NRF_CTZ(latch[i]);
 100b2ea:	fa94 f4a4 	rbit	r4, r4
 100b2ee:	fab4 f484 	clz	r4, r4
                pin += 32 * i;
 100b2f2:	9b00      	ldr	r3, [sp, #0]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
 100b2f4:	4a50      	ldr	r2, [pc, #320]	; (100b438 <nrfx_gpiote_irq_handler+0x1b4>)
                pin += 32 * i;
 100b2f6:	441c      	add	r4, r3
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
 100b2f8:	f104 0308 	add.w	r3, r4, #8
 100b2fc:	f832 7013 	ldrh.w	r7, [r2, r3, lsl #1]
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
 100b300:	2301      	movs	r3, #1
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
 100b302:	08e0      	lsrs	r0, r4, #3
    bit = BITMASK_RELBIT_GET(bit);
 100b304:	f004 0207 	and.w	r2, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
 100b308:	fa03 f202 	lsl.w	r2, r3, r2
 100b30c:	f81b 3000 	ldrb.w	r3, [fp, r0]
 100b310:	9403      	str	r4, [sp, #12]
 100b312:	ea23 0302 	bic.w	r3, r3, r2
 100b316:	f80b 3000 	strb.w	r3, [fp, r0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 100b31a:	a803      	add	r0, sp, #12
 100b31c:	f7ff fd1e 	bl	100ad5c <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
 100b320:	9b03      	ldr	r3, [sp, #12]
 100b322:	08b9      	lsrs	r1, r7, #2
 100b324:	3380      	adds	r3, #128	; 0x80
 100b326:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 100b32a:	f3c7 0582 	ubfx	r5, r7, #2, #3
    if (is_level(trigger))
 100b32e:	074a      	lsls	r2, r1, #29
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
 100b330:	462f      	mov	r7, r5
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
 100b332:	f3c3 4301 	ubfx	r3, r3, #16, #2
    if (is_level(trigger))
 100b336:	d52b      	bpl.n	100b390 <nrfx_gpiote_irq_handler+0x10c>
        call_handler(pin, trigger);
 100b338:	4620      	mov	r0, r4
 100b33a:	4639      	mov	r1, r7
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
 100b33c:	b2dd      	uxtb	r5, r3
 100b33e:	f7ff fd27 	bl	100ad90 <call_handler>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 100b342:	a803      	add	r0, sp, #12
 100b344:	9403      	str	r4, [sp, #12]
 100b346:	f7ff fd09 	bl	100ad5c <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
 100b34a:	9b03      	ldr	r3, [sp, #12]
 100b34c:	3380      	adds	r3, #128	; 0x80
 100b34e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
        if (nrf_gpio_pin_sense_get(pin) == sense)
 100b352:	f3c3 4301 	ubfx	r3, r3, #16, #2
 100b356:	429d      	cmp	r5, r3
 100b358:	d107      	bne.n	100b36a <nrfx_gpiote_irq_handler+0xe6>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
 100b35a:	2100      	movs	r1, #0
 100b35c:	4620      	mov	r0, r4
 100b35e:	f001 f995 	bl	100c68c <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
 100b362:	4629      	mov	r1, r5
 100b364:	4620      	mov	r0, r4
 100b366:	f001 f991 	bl	100c68c <nrf_gpio_cfg_sense_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 100b36a:	a803      	add	r0, sp, #12
 100b36c:	9403      	str	r4, [sp, #12]
 100b36e:	f7ff fcf5 	bl	100ad5c <nrf_gpio_pin_port_decode>
    reg->LATCH = (1 << pin_number);
 100b372:	2201      	movs	r2, #1
 100b374:	9b03      	ldr	r3, [sp, #12]
 100b376:	fa02 f303 	lsl.w	r3, r2, r3
 100b37a:	6203      	str	r3, [r0, #32]
            while (latch[i])
 100b37c:	f85b 402a 	ldr.w	r4, [fp, sl, lsl #2]
 100b380:	2c00      	cmp	r4, #0
 100b382:	d1b2      	bne.n	100b2ea <nrfx_gpiote_irq_handler+0x66>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
 100b384:	f1ba 0f00 	cmp.w	sl, #0
 100b388:	d11d      	bne.n	100b3c6 <nrfx_gpiote_irq_handler+0x142>
 100b38a:	f04f 0a01 	mov.w	sl, #1
 100b38e:	e7a8      	b.n	100b2e2 <nrfx_gpiote_irq_handler+0x5e>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
 100b390:	2b02      	cmp	r3, #2
 100b392:	d10c      	bne.n	100b3ae <nrfx_gpiote_irq_handler+0x12a>
        nrf_gpio_cfg_sense_set(pin, next_sense);
 100b394:	2103      	movs	r1, #3
 100b396:	4620      	mov	r0, r4
 100b398:	f001 f978 	bl	100c68c <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
 100b39c:	f005 0305 	and.w	r3, r5, #5
 100b3a0:	2b01      	cmp	r3, #1
 100b3a2:	d1e2      	bne.n	100b36a <nrfx_gpiote_irq_handler+0xe6>
            call_handler(pin, trigger);
 100b3a4:	4639      	mov	r1, r7
 100b3a6:	4620      	mov	r0, r4
 100b3a8:	f7ff fcf2 	bl	100ad90 <call_handler>
 100b3ac:	e7dd      	b.n	100b36a <nrfx_gpiote_irq_handler+0xe6>
        nrf_gpio_cfg_sense_set(pin, next_sense);
 100b3ae:	2102      	movs	r1, #2
 100b3b0:	4620      	mov	r0, r4
 100b3b2:	9301      	str	r3, [sp, #4]
 100b3b4:	f001 f96a 	bl	100c68c <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
 100b3b8:	2d03      	cmp	r5, #3
 100b3ba:	d0f3      	beq.n	100b3a4 <nrfx_gpiote_irq_handler+0x120>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
 100b3bc:	9b01      	ldr	r3, [sp, #4]
 100b3be:	2b03      	cmp	r3, #3
 100b3c0:	d1d3      	bne.n	100b36a <nrfx_gpiote_irq_handler+0xe6>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
 100b3c2:	2d02      	cmp	r5, #2
 100b3c4:	e7ed      	b.n	100b3a2 <nrfx_gpiote_irq_handler+0x11e>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 100b3c6:	4b18      	ldr	r3, [pc, #96]	; (100b428 <nrfx_gpiote_irq_handler+0x1a4>)
 100b3c8:	f8c3 417c 	str.w	r4, [r3, #380]	; 0x17c
 100b3cc:	f8d3 317c 	ldr.w	r3, [r3, #380]	; 0x17c
        *p_masks = gpio_regs[i]->LATCH;
 100b3d0:	f8d9 3020 	ldr.w	r3, [r9, #32]
 100b3d4:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
 100b3d6:	f8c9 3020 	str.w	r3, [r9, #32]
        *p_masks = gpio_regs[i]->LATCH;
 100b3da:	f8d8 2020 	ldr.w	r2, [r8, #32]
        if (latch[port_idx])
 100b3de:	4313      	orrs	r3, r2
 100b3e0:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
 100b3e2:	f8c8 2020 	str.w	r2, [r8, #32]
 100b3e6:	f47f af78 	bne.w	100b2da <nrfx_gpiote_irq_handler+0x56>
        mask &= ~NRFX_BIT(ch);
 100b3ea:	2401      	movs	r4, #1
    while (mask)
 100b3ec:	b916      	cbnz	r6, 100b3f4 <nrfx_gpiote_irq_handler+0x170>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
 100b3ee:	b007      	add	sp, #28
 100b3f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        uint32_t ch = NRF_CTZ(mask);
 100b3f4:	fa96 f3a6 	rbit	r3, r6
 100b3f8:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
 100b3fc:	fa04 f203 	lsl.w	r2, r4, r3
 100b400:	009b      	lsls	r3, r3, #2
 100b402:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 100b406:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
 100b40a:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
 100b40e:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
 100b412:	f3c0 2005 	ubfx	r0, r0, #8, #6
 100b416:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
 100b41a:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
 100b41e:	f7ff fcb7 	bl	100ad90 <call_handler>
 100b422:	e7e3      	b.n	100b3ec <nrfx_gpiote_irq_handler+0x168>
 100b424:	4100a100 	.word	0x4100a100
 100b428:	4100a000 	.word	0x4100a000
 100b42c:	4100a120 	.word	0x4100a120
 100b430:	418c0500 	.word	0x418c0500
 100b434:	418c0800 	.word	0x418c0800
 100b438:	21000004 	.word	0x21000004

0100b43c <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 100b43c:	4b10      	ldr	r3, [pc, #64]	; (100b480 <z_sys_init_run_level+0x44>)
{
 100b43e:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 100b440:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
 100b444:	3001      	adds	r0, #1
 100b446:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 100b44a:	42a6      	cmp	r6, r4
 100b44c:	d800      	bhi.n	100b450 <z_sys_init_run_level+0x14>
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
 100b44e:	bd70      	pop	{r4, r5, r6, pc}
			int rc = entry->init_fn.dev(dev);
 100b450:	e9d4 3500 	ldrd	r3, r5, [r4]
		if (dev != NULL) {
 100b454:	b18d      	cbz	r5, 100b47a <z_sys_init_run_level+0x3e>
			int rc = entry->init_fn.dev(dev);
 100b456:	4628      	mov	r0, r5
 100b458:	4798      	blx	r3
			if (rc != 0) {
 100b45a:	b138      	cbz	r0, 100b46c <z_sys_init_run_level+0x30>
				if (rc < 0) {
 100b45c:	2800      	cmp	r0, #0
 100b45e:	bfb8      	it	lt
 100b460:	4240      	neglt	r0, r0
				if (rc > UINT8_MAX) {
 100b462:	28ff      	cmp	r0, #255	; 0xff
 100b464:	bfa8      	it	ge
 100b466:	20ff      	movge	r0, #255	; 0xff
				dev->state->init_res = rc;
 100b468:	68eb      	ldr	r3, [r5, #12]
 100b46a:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
 100b46c:	68ea      	ldr	r2, [r5, #12]
 100b46e:	7853      	ldrb	r3, [r2, #1]
 100b470:	f043 0301 	orr.w	r3, r3, #1
 100b474:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 100b476:	3408      	adds	r4, #8
 100b478:	e7e7      	b.n	100b44a <z_sys_init_run_level+0xe>
			(void)entry->init_fn.sys();
 100b47a:	4798      	blx	r3
 100b47c:	e7fb      	b.n	100b476 <z_sys_init_run_level+0x3a>
 100b47e:	bf00      	nop
 100b480:	0100cb3c 	.word	0x0100cb3c

0100b484 <bg_thread_main>:
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
 100b484:	2201      	movs	r2, #1
{
 100b486:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
 100b488:	4b09      	ldr	r3, [pc, #36]	; (100b4b0 <bg_thread_main+0x2c>)

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 100b48a:	2003      	movs	r0, #3
	z_sys_post_kernel = true;
 100b48c:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 100b48e:	f7ff ffd5 	bl	100b43c <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
 100b492:	f000 fde9 	bl	100c068 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 100b496:	2004      	movs	r0, #4
 100b498:	f7ff ffd0 	bl	100b43c <z_sys_init_run_level>

	z_init_static_threads();
 100b49c:	f000 f8ea 	bl	100b674 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
 100b4a0:	f000 fde8 	bl	100c074 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 100b4a4:	4a03      	ldr	r2, [pc, #12]	; (100b4b4 <bg_thread_main+0x30>)
 100b4a6:	7b13      	ldrb	r3, [r2, #12]
 100b4a8:	f023 0301 	bic.w	r3, r3, #1
 100b4ac:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 100b4ae:	bd08      	pop	{r3, pc}
 100b4b0:	210002bf 	.word	0x210002bf
 100b4b4:	21000130 	.word	0x21000130

0100b4b8 <z_bss_zero>:
{
 100b4b8:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 100b4ba:	4803      	ldr	r0, [pc, #12]	; (100b4c8 <z_bss_zero+0x10>)
 100b4bc:	4a03      	ldr	r2, [pc, #12]	; (100b4cc <z_bss_zero+0x14>)
 100b4be:	2100      	movs	r1, #0
 100b4c0:	1a12      	subs	r2, r2, r0
 100b4c2:	f001 f90d 	bl	100c6e0 <z_early_memset>
}
 100b4c6:	bd08      	pop	{r3, pc}
 100b4c8:	21000090 	.word	0x21000090
 100b4cc:	210002c4 	.word	0x210002c4

0100b4d0 <z_init_cpu>:

#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
 100b4d0:	2300      	movs	r3, #0
 100b4d2:	2201      	movs	r2, #1
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
 100b4d4:	b570      	push	{r4, r5, r6, lr}
 100b4d6:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
 100b4d8:	e9cd 2304 	strd	r2, r3, [sp, #16]
 100b4dc:	220f      	movs	r2, #15
 100b4de:	9301      	str	r3, [sp, #4]
 100b4e0:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 100b4e4:	2314      	movs	r3, #20
 100b4e6:	4d0f      	ldr	r5, [pc, #60]	; (100b524 <z_init_cpu+0x54>)
	struct k_thread *thread = &z_idle_threads[i];
 100b4e8:	4e0f      	ldr	r6, [pc, #60]	; (100b528 <z_init_cpu+0x58>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 100b4ea:	fb03 5500 	mla	r5, r3, r0, r5
	z_setup_new_thread(thread, stack,
 100b4ee:	490f      	ldr	r1, [pc, #60]	; (100b52c <z_init_cpu+0x5c>)
	struct k_thread *thread = &z_idle_threads[i];
 100b4f0:	eb06 16c0 	add.w	r6, r6, r0, lsl #7
{
 100b4f4:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
 100b4f6:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 100b4fa:	f44f 7280 	mov.w	r2, #256	; 0x100
 100b4fe:	4630      	mov	r0, r6
 100b500:	4b0b      	ldr	r3, [pc, #44]	; (100b530 <z_init_cpu+0x60>)
 100b502:	9500      	str	r5, [sp, #0]
 100b504:	f000 f886 	bl	100b614 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 100b508:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
 100b50a:	742c      	strb	r4, [r5, #16]
 100b50c:	f023 0304 	bic.w	r3, r3, #4
 100b510:	7373      	strb	r3, [r6, #13]
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 100b512:	4b08      	ldr	r3, [pc, #32]	; (100b534 <z_init_cpu+0x64>)
 100b514:	3401      	adds	r4, #1
 100b516:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 100b51a:	60ee      	str	r6, [r5, #12]
	_kernel.cpus[id].irq_stack =
 100b51c:	606b      	str	r3, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
 100b51e:	b006      	add	sp, #24
 100b520:	bd70      	pop	{r4, r5, r6, pc}
 100b522:	bf00      	nop
 100b524:	2100028c 	.word	0x2100028c
 100b528:	210000b0 	.word	0x210000b0
 100b52c:	21000ac8 	.word	0x21000ac8
 100b530:	0100c6f5 	.word	0x0100c6f5
 100b534:	210002c8 	.word	0x210002c8

0100b538 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
 100b538:	b580      	push	{r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
 100b53a:	2000      	movs	r0, #0
{
 100b53c:	b0a6      	sub	sp, #152	; 0x98
	z_sys_init_run_level(INIT_LEVEL_EARLY);
 100b53e:	f7ff ff7d 	bl	100b43c <z_sys_init_run_level>
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 100b542:	4b2d      	ldr	r3, [pc, #180]	; (100b5f8 <z_cstart+0xc0>)
	uint32_t msp =
 100b544:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 100b548:	f382 8808 	msr	MSP, r2
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 100b54c:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 100b550:	2400      	movs	r4, #0
 100b552:	23e0      	movs	r3, #224	; 0xe0
 100b554:	4d29      	ldr	r5, [pc, #164]	; (100b5fc <z_cstart+0xc4>)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
 100b556:	4e2a      	ldr	r6, [pc, #168]	; (100b600 <z_cstart+0xc8>)
 100b558:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
 100b55c:	77ec      	strb	r4, [r5, #31]
 100b55e:	762c      	strb	r4, [r5, #24]
 100b560:	766c      	strb	r4, [r5, #25]
 100b562:	76ac      	strb	r4, [r5, #26]
 100b564:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 100b568:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 100b56a:	4f26      	ldr	r7, [pc, #152]	; (100b604 <z_cstart+0xcc>)
 100b56c:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 100b570:	626b      	str	r3, [r5, #36]	; 0x24
 100b572:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
 100b576:	f7fe fb31 	bl	1009bdc <z_arm_fault_init>
	z_arm_cpu_idle_init();
 100b57a:	f7fe f8ef 	bl	100975c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 100b57e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 100b582:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
 100b584:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
 100b586:	f7fe fd33 	bl	1009ff0 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
 100b58a:	f7fe fbd9 	bl	1009d40 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
 100b58e:	f240 1301 	movw	r3, #257	; 0x101
 100b592:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
 100b596:	ab06      	add	r3, sp, #24
 100b598:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
 100b59a:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	dummy_thread->resource_pool = NULL;
 100b59e:	9422      	str	r4, [sp, #136]	; 0x88
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
 100b5a0:	f001 f974 	bl	100c88c <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 100b5a4:	2001      	movs	r0, #1
 100b5a6:	f7ff ff49 	bl	100b43c <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 100b5aa:	2002      	movs	r0, #2
	_kernel.ready_q.cache = &z_main_thread;
 100b5ac:	4d16      	ldr	r5, [pc, #88]	; (100b608 <z_cstart+0xd0>)
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 100b5ae:	f7ff ff45 	bl	100b43c <z_sys_init_run_level>
	z_sched_init();
 100b5b2:	f000 faf5 	bl	100bba0 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 100b5b6:	4b15      	ldr	r3, [pc, #84]	; (100b60c <z_cstart+0xd4>)
	_kernel.ready_q.cache = &z_main_thread;
 100b5b8:	6175      	str	r5, [r6, #20]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 100b5ba:	9305      	str	r3, [sp, #20]
 100b5bc:	2301      	movs	r3, #1
 100b5be:	4914      	ldr	r1, [pc, #80]	; (100b610 <z_cstart+0xd8>)
 100b5c0:	f44f 6280 	mov.w	r2, #1024	; 0x400
 100b5c4:	e9cd 4303 	strd	r4, r3, [sp, #12]
 100b5c8:	4628      	mov	r0, r5
 100b5ca:	463b      	mov	r3, r7
 100b5cc:	e9cd 4401 	strd	r4, r4, [sp, #4]
 100b5d0:	9400      	str	r4, [sp, #0]
 100b5d2:	f000 f81f 	bl	100b614 <z_setup_new_thread>
 100b5d6:	4606      	mov	r6, r0
 100b5d8:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
 100b5da:	4628      	mov	r0, r5
 100b5dc:	f022 0204 	bic.w	r2, r2, #4
 100b5e0:	736a      	strb	r2, [r5, #13]
 100b5e2:	f001 f8cd 	bl	100c780 <z_ready_thread>
	z_init_cpu(0);
 100b5e6:	4620      	mov	r0, r4
 100b5e8:	f7ff ff72 	bl	100b4d0 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 100b5ec:	463a      	mov	r2, r7
 100b5ee:	4631      	mov	r1, r6
 100b5f0:	4628      	mov	r0, r5
 100b5f2:	f7fe f9a5 	bl	1009940 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 100b5f6:	bf00      	nop
 100b5f8:	210002c8 	.word	0x210002c8
 100b5fc:	e000ed00 	.word	0xe000ed00
 100b600:	2100028c 	.word	0x2100028c
 100b604:	0100b485 	.word	0x0100b485
 100b608:	21000130 	.word	0x21000130
 100b60c:	0100cc42 	.word	0x0100cc42
 100b610:	21000bc8 	.word	0x21000bc8

0100b614 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
 100b614:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
 100b618:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
 100b61a:	f100 0558 	add.w	r5, r0, #88	; 0x58
 100b61e:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
 100b620:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
 100b622:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
 100b626:	2500      	movs	r5, #0
{
 100b628:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
 100b62a:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
 100b62c:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
 100b62e:	e9c0 5506 	strd	r5, r5, [r0, #24]
 100b632:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 100b634:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 100b636:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 100b638:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
 100b63c:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
 100b640:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
 100b642:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
 100b644:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 100b646:	9202      	str	r2, [sp, #8]
 100b648:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
 100b64a:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 100b64e:	9201      	str	r2, [sp, #4]
 100b650:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 100b652:	9200      	str	r2, [sp, #0]
 100b654:	4642      	mov	r2, r8
 100b656:	f7fe f957 	bl	1009908 <arch_new_thread>
	if (!_current) {
 100b65a:	4b05      	ldr	r3, [pc, #20]	; (100b670 <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
 100b65c:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
 100b65e:	689b      	ldr	r3, [r3, #8]
 100b660:	b103      	cbz	r3, 100b664 <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
 100b662:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
 100b664:	4640      	mov	r0, r8
 100b666:	6723      	str	r3, [r4, #112]	; 0x70
 100b668:	b004      	add	sp, #16
 100b66a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100b66e:	bf00      	nop
 100b670:	2100028c 	.word	0x2100028c

0100b674 <z_init_static_threads>:
{
 100b674:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100b678:	4c29      	ldr	r4, [pc, #164]	; (100b720 <z_init_static_threads+0xac>)
	_FOREACH_STATIC_THREAD(thread_data) {
 100b67a:	4d2a      	ldr	r5, [pc, #168]	; (100b724 <z_init_static_threads+0xb0>)
{
 100b67c:	b087      	sub	sp, #28
 100b67e:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
 100b680:	42ae      	cmp	r6, r5
 100b682:	f104 042c 	add.w	r4, r4, #44	; 0x2c
 100b686:	d30f      	bcc.n	100b6a8 <z_init_static_threads+0x34>
	k_sched_lock();
 100b688:	f000 fa5a 	bl	100bb40 <k_sched_lock>
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
 100b68c:	f44f 4600 	mov.w	r6, #32768	; 0x8000
 100b690:	f240 37e7 	movw	r7, #999	; 0x3e7
	_FOREACH_STATIC_THREAD(thread_data) {
 100b694:	4c22      	ldr	r4, [pc, #136]	; (100b720 <z_init_static_threads+0xac>)

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 100b696:	f8df 9090 	ldr.w	r9, [pc, #144]	; 100b728 <z_init_static_threads+0xb4>
 100b69a:	42ac      	cmp	r4, r5
 100b69c:	d320      	bcc.n	100b6e0 <z_init_static_threads+0x6c>
}
 100b69e:	b007      	add	sp, #28
 100b6a0:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
 100b6a4:	f000 ba60 	b.w	100bb68 <k_sched_unlock>
		z_setup_new_thread(
 100b6a8:	f854 3c04 	ldr.w	r3, [r4, #-4]
 100b6ac:	9305      	str	r3, [sp, #20]
 100b6ae:	f854 3c0c 	ldr.w	r3, [r4, #-12]
 100b6b2:	9304      	str	r3, [sp, #16]
 100b6b4:	f854 3c10 	ldr.w	r3, [r4, #-16]
 100b6b8:	9303      	str	r3, [sp, #12]
 100b6ba:	f854 3c14 	ldr.w	r3, [r4, #-20]
 100b6be:	9302      	str	r3, [sp, #8]
 100b6c0:	f854 3c18 	ldr.w	r3, [r4, #-24]
 100b6c4:	9301      	str	r3, [sp, #4]
 100b6c6:	f854 3c1c 	ldr.w	r3, [r4, #-28]
 100b6ca:	9300      	str	r3, [sp, #0]
 100b6cc:	e954 2309 	ldrd	r2, r3, [r4, #-36]	; 0x24
 100b6d0:	e954 010b 	ldrd	r0, r1, [r4, #-44]	; 0x2c
 100b6d4:	f7ff ff9e 	bl	100b614 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 100b6d8:	f854 3c2c 	ldr.w	r3, [r4, #-44]
 100b6dc:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
 100b6de:	e7ce      	b.n	100b67e <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
 100b6e0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 100b6e2:	1c5a      	adds	r2, r3, #1
 100b6e4:	d00d      	beq.n	100b702 <z_init_static_threads+0x8e>
 100b6e6:	2100      	movs	r1, #0
 100b6e8:	4638      	mov	r0, r7
					    K_MSEC(thread_data->init_delay));
 100b6ea:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 100b6ee:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 100b6f2:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
 100b6f6:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 100b6fa:	d104      	bne.n	100b706 <z_init_static_threads+0x92>
	z_sched_start(thread);
 100b6fc:	4640      	mov	r0, r8
 100b6fe:	f000 f9cf 	bl	100baa0 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
 100b702:	342c      	adds	r4, #44	; 0x2c
 100b704:	e7c9      	b.n	100b69a <z_init_static_threads+0x26>
 100b706:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 100b70a:	2300      	movs	r3, #0
 100b70c:	f7fd f996 	bl	1008a3c <__aeabi_uldivmod>
 100b710:	4602      	mov	r2, r0
 100b712:	460b      	mov	r3, r1
 100b714:	f108 0018 	add.w	r0, r8, #24
 100b718:	4649      	mov	r1, r9
 100b71a:	f000 fbab 	bl	100be74 <z_add_timeout>
 100b71e:	e7f0      	b.n	100b702 <z_init_static_threads+0x8e>
 100b720:	0100ca00 	.word	0x0100ca00
 100b724:	0100ca00 	.word	0x0100ca00
 100b728:	0100c7e5 	.word	0x0100c7e5

0100b72c <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
 100b72c:	b538      	push	{r3, r4, r5, lr}
 100b72e:	4604      	mov	r4, r0
	__asm__ volatile(
 100b730:	f04f 0320 	mov.w	r3, #32
 100b734:	f3ef 8511 	mrs	r5, BASEPRI
 100b738:	f383 8812 	msr	BASEPRI_MAX, r3
 100b73c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
 100b740:	f001 f854 	bl	100c7ec <z_unpend_first_thread>

	if (thread != NULL) {
 100b744:	b148      	cbz	r0, 100b75a <z_impl_k_sem_give+0x2e>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
 100b746:	2200      	movs	r2, #0
 100b748:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
 100b74a:	f001 f819 	bl	100c780 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
 100b74e:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
 100b750:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
 100b754:	4804      	ldr	r0, [pc, #16]	; (100b768 <z_impl_k_sem_give+0x3c>)
 100b756:	f000 b991 	b.w	100ba7c <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 100b75a:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 100b75e:	429a      	cmp	r2, r3
 100b760:	bf18      	it	ne
 100b762:	3301      	addne	r3, #1
 100b764:	60a3      	str	r3, [r4, #8]
}
 100b766:	e7f2      	b.n	100b74e <z_impl_k_sem_give+0x22>
 100b768:	210002c0 	.word	0x210002c0

0100b76c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
 100b76c:	b513      	push	{r0, r1, r4, lr}
 100b76e:	f04f 0420 	mov.w	r4, #32
 100b772:	f3ef 8111 	mrs	r1, BASEPRI
 100b776:	f384 8812 	msr	BASEPRI_MAX, r4
 100b77a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
 100b77e:	6884      	ldr	r4, [r0, #8]
 100b780:	b144      	cbz	r4, 100b794 <z_impl_k_sem_take+0x28>
		sem->count--;
 100b782:	3c01      	subs	r4, #1
 100b784:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
 100b786:	f381 8811 	msr	BASEPRI, r1
 100b78a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
 100b78e:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
 100b790:	b002      	add	sp, #8
 100b792:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 100b794:	ea52 0403 	orrs.w	r4, r2, r3
 100b798:	d106      	bne.n	100b7a8 <z_impl_k_sem_take+0x3c>
 100b79a:	f381 8811 	msr	BASEPRI, r1
 100b79e:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
 100b7a2:	f06f 000f 	mvn.w	r0, #15
 100b7a6:	e7f3      	b.n	100b790 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 100b7a8:	e9cd 2300 	strd	r2, r3, [sp]
 100b7ac:	4602      	mov	r2, r0
 100b7ae:	4802      	ldr	r0, [pc, #8]	; (100b7b8 <z_impl_k_sem_take+0x4c>)
 100b7b0:	f000 f946 	bl	100ba40 <z_pend_curr>
	return ret;
 100b7b4:	e7ec      	b.n	100b790 <z_impl_k_sem_take+0x24>
 100b7b6:	bf00      	nop
 100b7b8:	210002c0 	.word	0x210002c0

0100b7bc <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
 100b7bc:	89c3      	ldrh	r3, [r0, #14]
 100b7be:	2b7f      	cmp	r3, #127	; 0x7f
 100b7c0:	d812      	bhi.n	100b7e8 <sliceable+0x2c>
	int ret = slice_ticks;
 100b7c2:	4b0a      	ldr	r3, [pc, #40]	; (100b7ec <sliceable+0x30>)
 100b7c4:	681b      	ldr	r3, [r3, #0]
		&& slice_time(thread) != 0
 100b7c6:	b163      	cbz	r3, 100b7e2 <sliceable+0x26>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 100b7c8:	4b09      	ldr	r3, [pc, #36]	; (100b7f0 <sliceable+0x34>)
 100b7ca:	f990 200e 	ldrsb.w	r2, [r0, #14]
 100b7ce:	681b      	ldr	r3, [r3, #0]
 100b7d0:	429a      	cmp	r2, r3
 100b7d2:	db09      	blt.n	100b7e8 <sliceable+0x2c>
		&& !z_is_thread_prevented_from_running(thread)
 100b7d4:	7b43      	ldrb	r3, [r0, #13]
 100b7d6:	06db      	lsls	r3, r3, #27
 100b7d8:	d106      	bne.n	100b7e8 <sliceable+0x2c>
		&& !z_is_idle_thread_object(thread);
 100b7da:	4b06      	ldr	r3, [pc, #24]	; (100b7f4 <sliceable+0x38>)
 100b7dc:	1ac3      	subs	r3, r0, r3
 100b7de:	bf18      	it	ne
 100b7e0:	2301      	movne	r3, #1
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
 100b7e2:	f003 0001 	and.w	r0, r3, #1
 100b7e6:	4770      	bx	lr
		&& !z_is_idle_thread_object(thread);
 100b7e8:	2300      	movs	r3, #0
 100b7ea:	e7fa      	b.n	100b7e2 <sliceable+0x26>
 100b7ec:	210002b4 	.word	0x210002b4
 100b7f0:	210002b0 	.word	0x210002b0
 100b7f4:	210000b0 	.word	0x210000b0

0100b7f8 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);

	slice_expired[cpu] = true;
 100b7f8:	2201      	movs	r2, #1
	int cpu = ARRAY_INDEX(slice_timeouts, t);
 100b7fa:	4b04      	ldr	r3, [pc, #16]	; (100b80c <slice_timeout+0x14>)
 100b7fc:	1ac0      	subs	r0, r0, r3
 100b7fe:	4b04      	ldr	r3, [pc, #16]	; (100b810 <slice_timeout+0x18>)
 100b800:	10c0      	asrs	r0, r0, #3
 100b802:	4358      	muls	r0, r3
	slice_expired[cpu] = true;
 100b804:	4b03      	ldr	r3, [pc, #12]	; (100b814 <slice_timeout+0x1c>)
 100b806:	541a      	strb	r2, [r3, r0]
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
 100b808:	4770      	bx	lr
 100b80a:	bf00      	nop
 100b80c:	210001b0 	.word	0x210001b0
 100b810:	aaaaaaab 	.word	0xaaaaaaab
 100b814:	210002c0 	.word	0x210002c0

0100b818 <z_reset_time_slice>:

void z_reset_time_slice(struct k_thread *curr)
{
 100b818:	b570      	push	{r4, r5, r6, lr}
	int cpu = _current_cpu->id;
 100b81a:	4b0e      	ldr	r3, [pc, #56]	; (100b854 <z_reset_time_slice+0x3c>)

	z_abort_timeout(&slice_timeouts[cpu]);
 100b81c:	4c0e      	ldr	r4, [pc, #56]	; (100b858 <z_reset_time_slice+0x40>)
	int cpu = _current_cpu->id;
 100b81e:	7c1e      	ldrb	r6, [r3, #16]
	z_abort_timeout(&slice_timeouts[cpu]);
 100b820:	2318      	movs	r3, #24
 100b822:	fb03 4406 	mla	r4, r3, r6, r4
{
 100b826:	4605      	mov	r5, r0
	z_abort_timeout(&slice_timeouts[cpu]);
 100b828:	4620      	mov	r0, r4
 100b82a:	f001 f811 	bl	100c850 <z_abort_timeout>
	slice_expired[cpu] = false;
 100b82e:	2200      	movs	r2, #0
 100b830:	4b0a      	ldr	r3, [pc, #40]	; (100b85c <z_reset_time_slice+0x44>)
	if (sliceable(curr)) {
 100b832:	4628      	mov	r0, r5
	slice_expired[cpu] = false;
 100b834:	559a      	strb	r2, [r3, r6]
	if (sliceable(curr)) {
 100b836:	f7ff ffc1 	bl	100b7bc <sliceable>
 100b83a:	b148      	cbz	r0, 100b850 <z_reset_time_slice+0x38>
	int ret = slice_ticks;
 100b83c:	4b08      	ldr	r3, [pc, #32]	; (100b860 <z_reset_time_slice+0x48>)
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 100b83e:	4620      	mov	r0, r4
			      K_TICKS(slice_time(curr) - 1));
	}
}
 100b840:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			      K_TICKS(slice_time(curr) - 1));
 100b844:	681a      	ldr	r2, [r3, #0]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 100b846:	4907      	ldr	r1, [pc, #28]	; (100b864 <z_reset_time_slice+0x4c>)
			      K_TICKS(slice_time(curr) - 1));
 100b848:	3a01      	subs	r2, #1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 100b84a:	17d3      	asrs	r3, r2, #31
 100b84c:	f000 bb12 	b.w	100be74 <z_add_timeout>
}
 100b850:	bd70      	pop	{r4, r5, r6, pc}
 100b852:	bf00      	nop
 100b854:	2100028c 	.word	0x2100028c
 100b858:	210001b0 	.word	0x210001b0
 100b85c:	210002c0 	.word	0x210002c0
 100b860:	210002b4 	.word	0x210002b4
 100b864:	0100b7f9 	.word	0x0100b7f9

0100b868 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
 100b868:	b538      	push	{r3, r4, r5, lr}
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
 100b86a:	4d0d      	ldr	r5, [pc, #52]	; (100b8a0 <update_cache+0x38>)
 100b86c:	462b      	mov	r3, r5
 100b86e:	f853 4f18 	ldr.w	r4, [r3, #24]!
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100b872:	429c      	cmp	r4, r3
 100b874:	d000      	beq.n	100b878 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 100b876:	b904      	cbnz	r4, 100b87a <update_cache+0x12>
 100b878:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
 100b87a:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
 100b87c:	b938      	cbnz	r0, 100b88e <update_cache+0x26>
	if (z_is_thread_prevented_from_running(_current)) {
 100b87e:	7b5a      	ldrb	r2, [r3, #13]
 100b880:	06d2      	lsls	r2, r2, #27
 100b882:	d104      	bne.n	100b88e <update_cache+0x26>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 100b884:	69a2      	ldr	r2, [r4, #24]
 100b886:	b912      	cbnz	r2, 100b88e <update_cache+0x26>
	if (is_preempt(_current) || is_metairq(thread)) {
 100b888:	89da      	ldrh	r2, [r3, #14]
 100b88a:	2a7f      	cmp	r2, #127	; 0x7f
 100b88c:	d805      	bhi.n	100b89a <update_cache+0x32>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
 100b88e:	429c      	cmp	r4, r3
 100b890:	d002      	beq.n	100b898 <update_cache+0x30>
			z_reset_time_slice(thread);
 100b892:	4620      	mov	r0, r4
 100b894:	f7ff ffc0 	bl	100b818 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
 100b898:	4623      	mov	r3, r4
 100b89a:	616b      	str	r3, [r5, #20]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
 100b89c:	bd38      	pop	{r3, r4, r5, pc}
 100b89e:	bf00      	nop
 100b8a0:	2100028c 	.word	0x2100028c

0100b8a4 <move_thread_to_end_of_prio_q>:
{
 100b8a4:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
 100b8a6:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
 100b8aa:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
 100b8ac:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
 100b8ae:	7b43      	ldrb	r3, [r0, #13]
 100b8b0:	da04      	bge.n	100b8bc <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 100b8b2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 100b8b6:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
 100b8b8:	f000 ff28 	bl	100c70c <sys_dlist_remove>
	return list->head == list;
 100b8bc:	4a15      	ldr	r2, [pc, #84]	; (100b914 <move_thread_to_end_of_prio_q+0x70>)
	thread->base.thread_state |= _THREAD_QUEUED;
 100b8be:	7b4b      	ldrb	r3, [r1, #13]
 100b8c0:	4610      	mov	r0, r2
 100b8c2:	f063 037f 	orn	r3, r3, #127	; 0x7f
 100b8c6:	734b      	strb	r3, [r1, #13]
 100b8c8:	f850 3f18 	ldr.w	r3, [r0, #24]!
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
 100b8cc:	69d4      	ldr	r4, [r2, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100b8ce:	4283      	cmp	r3, r0
 100b8d0:	bf08      	it	eq
 100b8d2:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 100b8d4:	b923      	cbnz	r3, 100b8e0 <move_thread_to_end_of_prio_q+0x3c>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
 100b8d6:	e9c1 0400 	strd	r0, r4, [r1]

	tail->next = node;
 100b8da:	6021      	str	r1, [r4, #0]
	list->tail = node;
 100b8dc:	61d1      	str	r1, [r2, #28]
}
 100b8de:	e00c      	b.n	100b8fa <move_thread_to_end_of_prio_q+0x56>
	int32_t b1 = thread_1->base.prio;
 100b8e0:	f991 500e 	ldrsb.w	r5, [r1, #14]
	int32_t b2 = thread_2->base.prio;
 100b8e4:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
 100b8e8:	42b5      	cmp	r5, r6
 100b8ea:	d00e      	beq.n	100b90a <move_thread_to_end_of_prio_q+0x66>
		if (z_sched_prio_cmp(thread, t) > 0) {
 100b8ec:	42ae      	cmp	r6, r5
 100b8ee:	dd0c      	ble.n	100b90a <move_thread_to_end_of_prio_q+0x66>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
 100b8f0:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
 100b8f2:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
 100b8f6:	6001      	str	r1, [r0, #0]
	successor->prev = node;
 100b8f8:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
 100b8fa:	6890      	ldr	r0, [r2, #8]
}
 100b8fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
 100b900:	1a43      	subs	r3, r0, r1
 100b902:	4258      	negs	r0, r3
 100b904:	4158      	adcs	r0, r3
 100b906:	f7ff bfaf 	b.w	100b868 <update_cache>
	return (node == list->tail) ? NULL : node->next;
 100b90a:	429c      	cmp	r4, r3
 100b90c:	d0e3      	beq.n	100b8d6 <move_thread_to_end_of_prio_q+0x32>
 100b90e:	681b      	ldr	r3, [r3, #0]
 100b910:	e7e0      	b.n	100b8d4 <move_thread_to_end_of_prio_q+0x30>
 100b912:	bf00      	nop
 100b914:	2100028c 	.word	0x2100028c

0100b918 <ready_thread>:
{
 100b918:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 100b91a:	f990 300d 	ldrsb.w	r3, [r0, #13]
 100b91e:	7b42      	ldrb	r2, [r0, #13]
 100b920:	2b00      	cmp	r3, #0
 100b922:	db29      	blt.n	100b978 <ready_thread+0x60>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 100b924:	06d3      	lsls	r3, r2, #27
 100b926:	d127      	bne.n	100b978 <ready_thread+0x60>
	return node->next != NULL;
 100b928:	6983      	ldr	r3, [r0, #24]
 100b92a:	bb2b      	cbnz	r3, 100b978 <ready_thread+0x60>
	return list->head == list;
 100b92c:	4913      	ldr	r1, [pc, #76]	; (100b97c <ready_thread+0x64>)
	thread->base.thread_state |= _THREAD_QUEUED;
 100b92e:	f062 027f 	orn	r2, r2, #127	; 0x7f
 100b932:	7342      	strb	r2, [r0, #13]
 100b934:	460a      	mov	r2, r1
 100b936:	f852 4f18 	ldr.w	r4, [r2, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100b93a:	4294      	cmp	r4, r2
 100b93c:	bf18      	it	ne
 100b93e:	4623      	movne	r3, r4
	return (node == list->tail) ? NULL : node->next;
 100b940:	69cc      	ldr	r4, [r1, #28]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 100b942:	b923      	cbnz	r3, 100b94e <ready_thread+0x36>
	node->prev = tail;
 100b944:	e9c0 2400 	strd	r2, r4, [r0]
	tail->next = node;
 100b948:	6020      	str	r0, [r4, #0]
	list->tail = node;
 100b94a:	61c8      	str	r0, [r1, #28]
}
 100b94c:	e00c      	b.n	100b968 <ready_thread+0x50>
	int32_t b1 = thread_1->base.prio;
 100b94e:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
 100b952:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
 100b956:	42b5      	cmp	r5, r6
 100b958:	d00a      	beq.n	100b970 <ready_thread+0x58>
		if (z_sched_prio_cmp(thread, t) > 0) {
 100b95a:	42ae      	cmp	r6, r5
 100b95c:	dd08      	ble.n	100b970 <ready_thread+0x58>
	sys_dnode_t *const prev = successor->prev;
 100b95e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
 100b960:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
 100b964:	6010      	str	r0, [r2, #0]
	successor->prev = node;
 100b966:	6058      	str	r0, [r3, #4]
		update_cache(0);
 100b968:	2000      	movs	r0, #0
}
 100b96a:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
 100b96c:	f7ff bf7c 	b.w	100b868 <update_cache>
	return (node == list->tail) ? NULL : node->next;
 100b970:	42a3      	cmp	r3, r4
 100b972:	d0e7      	beq.n	100b944 <ready_thread+0x2c>
 100b974:	681b      	ldr	r3, [r3, #0]
 100b976:	e7e4      	b.n	100b942 <ready_thread+0x2a>
}
 100b978:	bc70      	pop	{r4, r5, r6}
 100b97a:	4770      	bx	lr
 100b97c:	2100028c 	.word	0x2100028c

0100b980 <unready_thread>:
{
 100b980:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
 100b982:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
 100b986:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
 100b988:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
 100b98a:	7b43      	ldrb	r3, [r0, #13]
 100b98c:	da04      	bge.n	100b998 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 100b98e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 100b992:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
 100b994:	f000 feba 	bl	100c70c <sys_dlist_remove>
	update_cache(thread == _current);
 100b998:	4b04      	ldr	r3, [pc, #16]	; (100b9ac <unready_thread+0x2c>)
 100b99a:	6898      	ldr	r0, [r3, #8]
 100b99c:	1a43      	subs	r3, r0, r1
 100b99e:	4258      	negs	r0, r3
 100b9a0:	4158      	adcs	r0, r3
}
 100b9a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
 100b9a6:	f7ff bf5f 	b.w	100b868 <update_cache>
 100b9aa:	bf00      	nop
 100b9ac:	2100028c 	.word	0x2100028c

0100b9b0 <pend_locked>:
{
 100b9b0:	b570      	push	{r4, r5, r6, lr}
 100b9b2:	4615      	mov	r5, r2
 100b9b4:	461c      	mov	r4, r3
 100b9b6:	4606      	mov	r6, r0
	add_to_waitq_locked(thread, wait_q);
 100b9b8:	f000 feba 	bl	100c730 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 100b9bc:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 100b9c0:	bf08      	it	eq
 100b9c2:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
 100b9c6:	d008      	beq.n	100b9da <pend_locked+0x2a>
 100b9c8:	462a      	mov	r2, r5
 100b9ca:	4623      	mov	r3, r4
 100b9cc:	f106 0018 	add.w	r0, r6, #24
 100b9d0:	4902      	ldr	r1, [pc, #8]	; (100b9dc <pend_locked+0x2c>)
}
 100b9d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 100b9d6:	f000 ba4d 	b.w	100be74 <z_add_timeout>
 100b9da:	bd70      	pop	{r4, r5, r6, pc}
 100b9dc:	0100c7e5 	.word	0x0100c7e5

0100b9e0 <z_time_slice>:
{
 100b9e0:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
 100b9e2:	f04f 0320 	mov.w	r3, #32
 100b9e6:	f3ef 8511 	mrs	r5, BASEPRI
 100b9ea:	f383 8812 	msr	BASEPRI_MAX, r3
 100b9ee:	f3bf 8f6f 	isb	sy
	struct k_thread *curr = _current;
 100b9f2:	4b10      	ldr	r3, [pc, #64]	; (100ba34 <z_time_slice+0x54>)
	if (pending_current == curr) {
 100b9f4:	4a10      	ldr	r2, [pc, #64]	; (100ba38 <z_time_slice+0x58>)
	struct k_thread *curr = _current;
 100b9f6:	689c      	ldr	r4, [r3, #8]
	if (pending_current == curr) {
 100b9f8:	6810      	ldr	r0, [r2, #0]
 100b9fa:	42a0      	cmp	r0, r4
 100b9fc:	d106      	bne.n	100ba0c <z_time_slice+0x2c>
		z_reset_time_slice(curr);
 100b9fe:	f7ff ff0b 	bl	100b818 <z_reset_time_slice>
	__asm__ volatile(
 100ba02:	f385 8811 	msr	BASEPRI, r5
 100ba06:	f3bf 8f6f 	isb	sy
}
 100ba0a:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
 100ba0c:	2100      	movs	r1, #0
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
 100ba0e:	7c1b      	ldrb	r3, [r3, #16]
	pending_current = NULL;
 100ba10:	6011      	str	r1, [r2, #0]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
 100ba12:	4a0a      	ldr	r2, [pc, #40]	; (100ba3c <z_time_slice+0x5c>)
 100ba14:	5cd3      	ldrb	r3, [r2, r3]
 100ba16:	2b00      	cmp	r3, #0
 100ba18:	d0f3      	beq.n	100ba02 <z_time_slice+0x22>
 100ba1a:	4620      	mov	r0, r4
 100ba1c:	f7ff fece 	bl	100b7bc <sliceable>
 100ba20:	2800      	cmp	r0, #0
 100ba22:	d0ee      	beq.n	100ba02 <z_time_slice+0x22>
		if (!z_is_thread_prevented_from_running(curr)) {
 100ba24:	7b63      	ldrb	r3, [r4, #13]
 100ba26:	06db      	lsls	r3, r3, #27
 100ba28:	d102      	bne.n	100ba30 <z_time_slice+0x50>
			move_thread_to_end_of_prio_q(curr);
 100ba2a:	4620      	mov	r0, r4
 100ba2c:	f7ff ff3a 	bl	100b8a4 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
 100ba30:	4620      	mov	r0, r4
 100ba32:	e7e4      	b.n	100b9fe <z_time_slice+0x1e>
 100ba34:	2100028c 	.word	0x2100028c
 100ba38:	210002ac 	.word	0x210002ac
 100ba3c:	210002c0 	.word	0x210002c0

0100ba40 <z_pend_curr>:
{
 100ba40:	b570      	push	{r4, r5, r6, lr}
	pending_current = _current;
 100ba42:	480c      	ldr	r0, [pc, #48]	; (100ba74 <z_pend_curr+0x34>)
 100ba44:	4d0c      	ldr	r5, [pc, #48]	; (100ba78 <z_pend_curr+0x38>)
 100ba46:	6886      	ldr	r6, [r0, #8]
{
 100ba48:	460c      	mov	r4, r1
	pending_current = _current;
 100ba4a:	602e      	str	r6, [r5, #0]
{
 100ba4c:	4611      	mov	r1, r2
 100ba4e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
	__asm__ volatile(
 100ba52:	f04f 0620 	mov.w	r6, #32
 100ba56:	f3ef 8511 	mrs	r5, BASEPRI
 100ba5a:	f386 8812 	msr	BASEPRI_MAX, r6
 100ba5e:	f3bf 8f6f 	isb	sy
	pend_locked(_current, wait_q, timeout);
 100ba62:	6880      	ldr	r0, [r0, #8]
 100ba64:	f7ff ffa4 	bl	100b9b0 <pend_locked>
	ret = arch_swap(key);
 100ba68:	4620      	mov	r0, r4
}
 100ba6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 100ba6e:	f7fd bef5 	b.w	100985c <arch_swap>
 100ba72:	bf00      	nop
 100ba74:	2100028c 	.word	0x2100028c
 100ba78:	210002ac 	.word	0x210002ac

0100ba7c <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
 100ba7c:	b949      	cbnz	r1, 100ba92 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 100ba7e:	f3ef 8005 	mrs	r0, IPSR
 100ba82:	b930      	cbnz	r0, 100ba92 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
 100ba84:	4b05      	ldr	r3, [pc, #20]	; (100ba9c <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
 100ba86:	695a      	ldr	r2, [r3, #20]
 100ba88:	689b      	ldr	r3, [r3, #8]
 100ba8a:	429a      	cmp	r2, r3
 100ba8c:	d001      	beq.n	100ba92 <z_reschedule+0x16>
 100ba8e:	f7fd bee5 	b.w	100985c <arch_swap>
	__asm__ volatile(
 100ba92:	f381 8811 	msr	BASEPRI, r1
 100ba96:	f3bf 8f6f 	isb	sy
}
 100ba9a:	4770      	bx	lr
 100ba9c:	2100028c 	.word	0x2100028c

0100baa0 <z_sched_start>:
{
 100baa0:	b510      	push	{r4, lr}
	__asm__ volatile(
 100baa2:	f04f 0220 	mov.w	r2, #32
 100baa6:	f3ef 8411 	mrs	r4, BASEPRI
 100baaa:	f382 8812 	msr	BASEPRI_MAX, r2
 100baae:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
 100bab2:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
 100bab4:	0751      	lsls	r1, r2, #29
 100bab6:	d404      	bmi.n	100bac2 <z_sched_start+0x22>
	__asm__ volatile(
 100bab8:	f384 8811 	msr	BASEPRI, r4
 100babc:	f3bf 8f6f 	isb	sy
}
 100bac0:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
 100bac2:	f022 0204 	bic.w	r2, r2, #4
 100bac6:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
 100bac8:	f7ff ff26 	bl	100b918 <ready_thread>
	z_reschedule(&sched_spinlock, key);
 100bacc:	4621      	mov	r1, r4
}
 100bace:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
 100bad2:	4801      	ldr	r0, [pc, #4]	; (100bad8 <z_sched_start+0x38>)
 100bad4:	f7ff bfd2 	b.w	100ba7c <z_reschedule>
 100bad8:	210002c1 	.word	0x210002c1

0100badc <z_impl_k_thread_suspend>:
{
 100badc:	b570      	push	{r4, r5, r6, lr}
 100bade:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 100bae0:	3018      	adds	r0, #24
 100bae2:	f000 feb5 	bl	100c850 <z_abort_timeout>
	__asm__ volatile(
 100bae6:	f04f 0320 	mov.w	r3, #32
 100baea:	f3ef 8611 	mrs	r6, BASEPRI
 100baee:	f383 8812 	msr	BASEPRI_MAX, r3
 100baf2:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
 100baf6:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
 100bafa:	7b63      	ldrb	r3, [r4, #13]
 100bafc:	2a00      	cmp	r2, #0
 100bafe:	da05      	bge.n	100bb0c <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 100bb00:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
 100bb04:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
 100bb06:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
 100bb08:	f000 fe00 	bl	100c70c <sys_dlist_remove>
		update_cache(thread == _current);
 100bb0c:	4d0b      	ldr	r5, [pc, #44]	; (100bb3c <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
 100bb0e:	7b63      	ldrb	r3, [r4, #13]
 100bb10:	68a8      	ldr	r0, [r5, #8]
 100bb12:	f043 0310 	orr.w	r3, r3, #16
 100bb16:	7363      	strb	r3, [r4, #13]
 100bb18:	1b03      	subs	r3, r0, r4
 100bb1a:	4258      	negs	r0, r3
 100bb1c:	4158      	adcs	r0, r3
 100bb1e:	f7ff fea3 	bl	100b868 <update_cache>
	__asm__ volatile(
 100bb22:	f386 8811 	msr	BASEPRI, r6
 100bb26:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
 100bb2a:	68ab      	ldr	r3, [r5, #8]
 100bb2c:	42a3      	cmp	r3, r4
 100bb2e:	d103      	bne.n	100bb38 <z_impl_k_thread_suspend+0x5c>
}
 100bb30:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
 100bb34:	f000 be82 	b.w	100c83c <z_reschedule_unlocked>
}
 100bb38:	bd70      	pop	{r4, r5, r6, pc}
 100bb3a:	bf00      	nop
 100bb3c:	2100028c 	.word	0x2100028c

0100bb40 <k_sched_lock>:
	__asm__ volatile(
 100bb40:	f04f 0320 	mov.w	r3, #32
 100bb44:	f3ef 8111 	mrs	r1, BASEPRI
 100bb48:	f383 8812 	msr	BASEPRI_MAX, r3
 100bb4c:	f3bf 8f6f 	isb	sy
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
 100bb50:	4b04      	ldr	r3, [pc, #16]	; (100bb64 <k_sched_lock+0x24>)
 100bb52:	689a      	ldr	r2, [r3, #8]
 100bb54:	7bd3      	ldrb	r3, [r2, #15]
 100bb56:	3b01      	subs	r3, #1
 100bb58:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
 100bb5a:	f381 8811 	msr	BASEPRI, r1
 100bb5e:	f3bf 8f6f 	isb	sy
}
 100bb62:	4770      	bx	lr
 100bb64:	2100028c 	.word	0x2100028c

0100bb68 <k_sched_unlock>:
{
 100bb68:	b510      	push	{r4, lr}
	__asm__ volatile(
 100bb6a:	f04f 0320 	mov.w	r3, #32
 100bb6e:	f3ef 8411 	mrs	r4, BASEPRI
 100bb72:	f383 8812 	msr	BASEPRI_MAX, r3
 100bb76:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
 100bb7a:	4b08      	ldr	r3, [pc, #32]	; (100bb9c <k_sched_unlock+0x34>)
		update_cache(0);
 100bb7c:	2000      	movs	r0, #0
		++_current->base.sched_locked;
 100bb7e:	689a      	ldr	r2, [r3, #8]
 100bb80:	7bd3      	ldrb	r3, [r2, #15]
 100bb82:	3301      	adds	r3, #1
 100bb84:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
 100bb86:	f7ff fe6f 	bl	100b868 <update_cache>
	__asm__ volatile(
 100bb8a:	f384 8811 	msr	BASEPRI, r4
 100bb8e:	f3bf 8f6f 	isb	sy
}
 100bb92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
 100bb96:	f000 be51 	b.w	100c83c <z_reschedule_unlocked>
 100bb9a:	bf00      	nop
 100bb9c:	2100028c 	.word	0x2100028c

0100bba0 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
 100bba0:	4b02      	ldr	r3, [pc, #8]	; (100bbac <z_sched_init+0xc>)
 100bba2:	f103 0218 	add.w	r2, r3, #24
	list->tail = (sys_dnode_t *)list;
 100bba6:	e9c3 2206 	strd	r2, r2, [r3, #24]
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
 100bbaa:	4770      	bx	lr
 100bbac:	2100028c 	.word	0x2100028c

0100bbb0 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
 100bbb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
 100bbb2:	f04f 0320 	mov.w	r3, #32
 100bbb6:	f3ef 8511 	mrs	r5, BASEPRI
 100bbba:	f383 8812 	msr	BASEPRI_MAX, r3
 100bbbe:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
 100bbc2:	4919      	ldr	r1, [pc, #100]	; (100bc28 <z_impl_k_yield+0x78>)
 100bbc4:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
 100bbc6:	7b43      	ldrb	r3, [r0, #13]
 100bbc8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 100bbcc:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
 100bbce:	f000 fd9d 	bl	100c70c <sys_dlist_remove>
	return list->head == list;
 100bbd2:	4608      	mov	r0, r1
	}
	queue_thread(_current);
 100bbd4:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
 100bbd6:	7b5a      	ldrb	r2, [r3, #13]
 100bbd8:	f062 027f 	orn	r2, r2, #127	; 0x7f
 100bbdc:	735a      	strb	r2, [r3, #13]
 100bbde:	f850 2f18 	ldr.w	r2, [r0, #24]!
	return (node == list->tail) ? NULL : node->next;
 100bbe2:	69cc      	ldr	r4, [r1, #28]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100bbe4:	4282      	cmp	r2, r0
 100bbe6:	bf08      	it	eq
 100bbe8:	2200      	moveq	r2, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 100bbea:	b922      	cbnz	r2, 100bbf6 <z_impl_k_yield+0x46>
	node->prev = tail;
 100bbec:	e9c3 0400 	strd	r0, r4, [r3]
	tail->next = node;
 100bbf0:	6023      	str	r3, [r4, #0]
	list->tail = node;
 100bbf2:	61cb      	str	r3, [r1, #28]
}
 100bbf4:	e00c      	b.n	100bc10 <z_impl_k_yield+0x60>
	int32_t b1 = thread_1->base.prio;
 100bbf6:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
 100bbfa:	f992 700e 	ldrsb.w	r7, [r2, #14]
	if (b1 != b2) {
 100bbfe:	42be      	cmp	r6, r7
 100bc00:	d00e      	beq.n	100bc20 <z_impl_k_yield+0x70>
		if (z_sched_prio_cmp(thread, t) > 0) {
 100bc02:	42b7      	cmp	r7, r6
 100bc04:	dd0c      	ble.n	100bc20 <z_impl_k_yield+0x70>
	sys_dnode_t *const prev = successor->prev;
 100bc06:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
 100bc08:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
 100bc0c:	600b      	str	r3, [r1, #0]
	successor->prev = node;
 100bc0e:	6053      	str	r3, [r2, #4]
	update_cache(1);
 100bc10:	2001      	movs	r0, #1
 100bc12:	f7ff fe29 	bl	100b868 <update_cache>
 100bc16:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
 100bc18:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 100bc1c:	f7fd be1e 	b.w	100985c <arch_swap>
	return (node == list->tail) ? NULL : node->next;
 100bc20:	42a2      	cmp	r2, r4
 100bc22:	d0e3      	beq.n	100bbec <z_impl_k_yield+0x3c>
 100bc24:	6812      	ldr	r2, [r2, #0]
 100bc26:	e7e0      	b.n	100bbea <z_impl_k_yield+0x3a>
 100bc28:	2100028c 	.word	0x2100028c

0100bc2c <z_tick_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
 100bc2c:	ea50 0301 	orrs.w	r3, r0, r1
{
 100bc30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100bc34:	4605      	mov	r5, r0
 100bc36:	460e      	mov	r6, r1
	if (ticks == 0) {
 100bc38:	d103      	bne.n	100bc42 <z_tick_sleep+0x16>
	z_impl_k_yield();
 100bc3a:	f7ff ffb9 	bl	100bbb0 <z_impl_k_yield>
		k_yield();
		return 0;
 100bc3e:	2000      	movs	r0, #0
 100bc40:	e02c      	b.n	100bc9c <z_tick_sleep+0x70>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
 100bc42:	1c83      	adds	r3, r0, #2
 100bc44:	f171 33ff 	sbcs.w	r3, r1, #4294967295	; 0xffffffff
 100bc48:	db2a      	blt.n	100bca0 <z_tick_sleep+0x74>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 100bc4a:	f000 fe17 	bl	100c87c <sys_clock_tick_get_32>
 100bc4e:	182c      	adds	r4, r5, r0
 100bc50:	f04f 0320 	mov.w	r3, #32
 100bc54:	f3ef 8811 	mrs	r8, BASEPRI
 100bc58:	f383 8812 	msr	BASEPRI_MAX, r3
 100bc5c:	f3bf 8f6f 	isb	sy
	}

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
 100bc60:	4f11      	ldr	r7, [pc, #68]	; (100bca8 <z_tick_sleep+0x7c>)
 100bc62:	4b12      	ldr	r3, [pc, #72]	; (100bcac <z_tick_sleep+0x80>)
 100bc64:	68b8      	ldr	r0, [r7, #8]
 100bc66:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
 100bc68:	f7ff fe8a 	bl	100b980 <unready_thread>
	z_add_thread_timeout(_current, timeout);
 100bc6c:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 100bc6e:	4910      	ldr	r1, [pc, #64]	; (100bcb0 <z_tick_sleep+0x84>)
 100bc70:	462a      	mov	r2, r5
 100bc72:	4633      	mov	r3, r6
 100bc74:	3018      	adds	r0, #24
 100bc76:	f000 f8fd 	bl	100be74 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
 100bc7a:	68ba      	ldr	r2, [r7, #8]
 100bc7c:	4640      	mov	r0, r8
	thread->base.thread_state |= _THREAD_SUSPENDED;
 100bc7e:	7b53      	ldrb	r3, [r2, #13]
 100bc80:	f043 0310 	orr.w	r3, r3, #16
 100bc84:	7353      	strb	r3, [r2, #13]
 100bc86:	f7fd fde9 	bl	100985c <arch_swap>

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
 100bc8a:	f000 fdf7 	bl	100c87c <sys_clock_tick_get_32>
 100bc8e:	1a20      	subs	r0, r4, r0
 100bc90:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
 100bc94:	2801      	cmp	r0, #1
 100bc96:	f173 0300 	sbcs.w	r3, r3, #0
 100bc9a:	dbd0      	blt.n	100bc3e <z_tick_sleep+0x12>
		return ticks;
	}
#endif

	return 0;
}
 100bc9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 100bca0:	f06f 0401 	mvn.w	r4, #1
 100bca4:	1a24      	subs	r4, r4, r0
 100bca6:	e7d3      	b.n	100bc50 <z_tick_sleep+0x24>
 100bca8:	2100028c 	.word	0x2100028c
 100bcac:	210002ac 	.word	0x210002ac
 100bcb0:	0100c7e5 	.word	0x0100c7e5

0100bcb4 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 100bcb4:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
 100bcb8:	bf08      	it	eq
 100bcba:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
 100bcbe:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 100bcc0:	d106      	bne.n	100bcd0 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
 100bcc2:	4b08      	ldr	r3, [pc, #32]	; (100bce4 <z_impl_k_sleep+0x30>)
 100bcc4:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
 100bcc6:	f7ff ff09 	bl	100badc <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
 100bcca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
 100bcce:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
 100bcd0:	f7ff ffac 	bl	100bc2c <z_tick_sleep>
 100bcd4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 100bcd8:	fb80 0303 	smull	r0, r3, r0, r3
 100bcdc:	0bc0      	lsrs	r0, r0, #15
 100bcde:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
 100bce2:	e7f4      	b.n	100bcce <z_impl_k_sleep+0x1a>
 100bce4:	2100028c 	.word	0x2100028c

0100bce8 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
 100bce8:	4b01      	ldr	r3, [pc, #4]	; (100bcf0 <z_impl_z_current_get+0x8>)
 100bcea:	6898      	ldr	r0, [r3, #8]
 100bcec:	4770      	bx	lr
 100bcee:	bf00      	nop
 100bcf0:	2100028c 	.word	0x2100028c

0100bcf4 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
 100bcf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100bcf8:	4604      	mov	r4, r0
 100bcfa:	f04f 0320 	mov.w	r3, #32
 100bcfe:	f3ef 8611 	mrs	r6, BASEPRI
 100bd02:	f383 8812 	msr	BASEPRI_MAX, r3
 100bd06:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
 100bd0a:	7b03      	ldrb	r3, [r0, #12]
 100bd0c:	07d9      	lsls	r1, r3, #31
 100bd0e:	d50b      	bpl.n	100bd28 <z_thread_abort+0x34>
	__asm__ volatile(
 100bd10:	f386 8811 	msr	BASEPRI, r6
 100bd14:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
 100bd18:	4040      	eors	r0, r0
 100bd1a:	f380 8811 	msr	BASEPRI, r0
 100bd1e:	f04f 0004 	mov.w	r0, #4
 100bd22:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
 100bd24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 100bd28:	7b43      	ldrb	r3, [r0, #13]
 100bd2a:	071a      	lsls	r2, r3, #28
 100bd2c:	d504      	bpl.n	100bd38 <z_thread_abort+0x44>
 100bd2e:	f386 8811 	msr	BASEPRI, r6
 100bd32:	f3bf 8f6f 	isb	sy
 100bd36:	e7f5      	b.n	100bd24 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 100bd38:	f023 0220 	bic.w	r2, r3, #32
 100bd3c:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
 100bd40:	09d2      	lsrs	r2, r2, #7
 100bd42:	d120      	bne.n	100bd86 <z_thread_abort+0x92>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 100bd44:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
 100bd46:	68a3      	ldr	r3, [r4, #8]
 100bd48:	b113      	cbz	r3, 100bd50 <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
 100bd4a:	4620      	mov	r0, r4
 100bd4c:	f000 fce6 	bl	100c71c <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
 100bd50:	f104 0018 	add.w	r0, r4, #24
 100bd54:	f000 fd7c 	bl	100c850 <z_abort_timeout>
 100bd58:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 100bd5c:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
 100bd60:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100bd62:	42bd      	cmp	r5, r7
 100bd64:	d000      	beq.n	100bd68 <z_thread_abort+0x74>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 100bd66:	b9b5      	cbnz	r5, 100bd96 <z_thread_abort+0xa2>
		update_cache(1);
 100bd68:	2001      	movs	r0, #1
 100bd6a:	f7ff fd7d 	bl	100b868 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
 100bd6e:	4b10      	ldr	r3, [pc, #64]	; (100bdb0 <z_thread_abort+0xbc>)
 100bd70:	689b      	ldr	r3, [r3, #8]
 100bd72:	42a3      	cmp	r3, r4
 100bd74:	d1db      	bne.n	100bd2e <z_thread_abort+0x3a>
 100bd76:	f3ef 8305 	mrs	r3, IPSR
 100bd7a:	2b00      	cmp	r3, #0
 100bd7c:	d1d7      	bne.n	100bd2e <z_thread_abort+0x3a>
 100bd7e:	4630      	mov	r0, r6
 100bd80:	f7fd fd6c 	bl	100985c <arch_swap>
	return ret;
 100bd84:	e7d3      	b.n	100bd2e <z_thread_abort+0x3a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 100bd86:	f003 035f 	and.w	r3, r3, #95	; 0x5f
 100bd8a:	f043 0308 	orr.w	r3, r3, #8
 100bd8e:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
 100bd90:	f000 fcbc 	bl	100c70c <sys_dlist_remove>
}
 100bd94:	e7d7      	b.n	100bd46 <z_thread_abort+0x52>
		unpend_thread_no_timeout(thread);
 100bd96:	4628      	mov	r0, r5
 100bd98:	f000 fcc0 	bl	100c71c <unpend_thread_no_timeout>
 100bd9c:	f105 0018 	add.w	r0, r5, #24
 100bda0:	f000 fd56 	bl	100c850 <z_abort_timeout>
		ready_thread(thread);
 100bda4:	4628      	mov	r0, r5
 100bda6:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
 100bdaa:	f7ff fdb5 	bl	100b918 <ready_thread>
 100bdae:	e7d7      	b.n	100bd60 <z_thread_abort+0x6c>
 100bdb0:	2100028c 	.word	0x2100028c

0100bdb4 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
 100bdb4:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
 100bdb6:	4806      	ldr	r0, [pc, #24]	; (100bdd0 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 100bdb8:	4a06      	ldr	r2, [pc, #24]	; (100bdd4 <z_data_copy+0x20>)
 100bdba:	4907      	ldr	r1, [pc, #28]	; (100bdd8 <z_data_copy+0x24>)
 100bdbc:	1a12      	subs	r2, r2, r0
 100bdbe:	f000 fc91 	bl	100c6e4 <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
 100bdc2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
 100bdc6:	4a05      	ldr	r2, [pc, #20]	; (100bddc <z_data_copy+0x28>)
 100bdc8:	4905      	ldr	r1, [pc, #20]	; (100bde0 <z_data_copy+0x2c>)
 100bdca:	4806      	ldr	r0, [pc, #24]	; (100bde4 <z_data_copy+0x30>)
 100bdcc:	f000 bc8a 	b.w	100c6e4 <z_early_memcpy>
 100bdd0:	21000000 	.word	0x21000000
 100bdd4:	2100008e 	.word	0x2100008e
 100bdd8:	0100cc80 	.word	0x0100cc80
 100bddc:	00000000 	.word	0x00000000
 100bde0:	0100cc80 	.word	0x0100cc80
 100bde4:	21000000 	.word	0x21000000

0100bde8 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 100bde8:	4b03      	ldr	r3, [pc, #12]	; (100bdf8 <elapsed+0x10>)
 100bdea:	681b      	ldr	r3, [r3, #0]
 100bdec:	b90b      	cbnz	r3, 100bdf2 <elapsed+0xa>
 100bdee:	f7fe bdcb 	b.w	100a988 <sys_clock_elapsed>
}
 100bdf2:	2000      	movs	r0, #0
 100bdf4:	4770      	bx	lr
 100bdf6:	bf00      	nop
 100bdf8:	210002b8 	.word	0x210002b8

0100bdfc <next_timeout>:

static int32_t next_timeout(void)
{
 100bdfc:	b510      	push	{r4, lr}
	return list->head == list;
 100bdfe:	4b0e      	ldr	r3, [pc, #56]	; (100be38 <next_timeout+0x3c>)
 100be00:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100be02:	429c      	cmp	r4, r3
 100be04:	d104      	bne.n	100be10 <next_timeout+0x14>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
 100be06:	f7ff ffef 	bl	100bde8 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
 100be0a:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
 100be0e:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
 100be10:	f7ff ffea 	bl	100bde8 <elapsed>
	if ((to == NULL) ||
 100be14:	2c00      	cmp	r4, #0
 100be16:	d0f8      	beq.n	100be0a <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 100be18:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 100be1c:	1a1b      	subs	r3, r3, r0
 100be1e:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
 100be22:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 100be26:	f172 0100 	sbcs.w	r1, r2, #0
 100be2a:	daee      	bge.n	100be0a <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
 100be2c:	2a00      	cmp	r2, #0
 100be2e:	bfac      	ite	ge
 100be30:	4618      	movge	r0, r3
 100be32:	2000      	movlt	r0, #0
	return ret;
 100be34:	e7eb      	b.n	100be0e <next_timeout+0x12>
 100be36:	bf00      	nop
 100be38:	21000080 	.word	0x21000080

0100be3c <remove_timeout>:
{
 100be3c:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 100be3e:	b170      	cbz	r0, 100be5e <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
 100be40:	4b0b      	ldr	r3, [pc, #44]	; (100be70 <remove_timeout+0x34>)
 100be42:	685b      	ldr	r3, [r3, #4]
 100be44:	4298      	cmp	r0, r3
 100be46:	d00a      	beq.n	100be5e <remove_timeout+0x22>
 100be48:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
 100be4a:	b143      	cbz	r3, 100be5e <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
 100be4c:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
 100be50:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
 100be54:	1912      	adds	r2, r2, r4
 100be56:	eb41 0105 	adc.w	r1, r1, r5
 100be5a:	e9c3 2104 	strd	r2, r1, [r3, #16]
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
 100be5e:	e9d0 3200 	ldrd	r3, r2, [r0]

	prev->next = next;
 100be62:	6013      	str	r3, [r2, #0]
	next->prev = prev;
 100be64:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 100be66:	2300      	movs	r3, #0
	node->prev = NULL;
 100be68:	e9c0 3300 	strd	r3, r3, [r0]
}
 100be6c:	bd30      	pop	{r4, r5, pc}
 100be6e:	bf00      	nop
 100be70:	21000080 	.word	0x21000080

0100be74 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 100be74:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 100be78:	bf08      	it	eq
 100be7a:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
 100be7e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100be80:	4604      	mov	r4, r0
 100be82:	461d      	mov	r5, r3
 100be84:	4616      	mov	r6, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 100be86:	d05c      	beq.n	100bf42 <z_add_timeout+0xce>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
 100be88:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
 100be8a:	f04f 0320 	mov.w	r3, #32
 100be8e:	f3ef 8711 	mrs	r7, BASEPRI
 100be92:	f383 8812 	msr	BASEPRI_MAX, r3
 100be96:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 100be9a:	3201      	adds	r2, #1
 100be9c:	f175 33ff 	sbcs.w	r3, r5, #4294967295	; 0xffffffff
 100bea0:	da24      	bge.n	100beec <z_add_timeout+0x78>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 100bea2:	f06f 0301 	mvn.w	r3, #1
 100bea6:	492c      	ldr	r1, [pc, #176]	; (100bf58 <z_add_timeout+0xe4>)
 100bea8:	e9d1 2000 	ldrd	r2, r0, [r1]
 100beac:	1a9b      	subs	r3, r3, r2
 100beae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 100beb2:	eb62 0000 	sbc.w	r0, r2, r0
 100beb6:	1b9e      	subs	r6, r3, r6
 100beb8:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
 100bebc:	2e01      	cmp	r6, #1
 100bebe:	f170 0300 	sbcs.w	r3, r0, #0
 100bec2:	da01      	bge.n	100bec8 <z_add_timeout+0x54>
 100bec4:	2601      	movs	r6, #1
 100bec6:	2000      	movs	r0, #0
 100bec8:	e9c4 6004 	strd	r6, r0, [r4, #16]
	return list->head == list;
 100becc:	4e23      	ldr	r6, [pc, #140]	; (100bf5c <z_add_timeout+0xe8>)
 100bece:	f8d6 c000 	ldr.w	ip, [r6]
	return (node == list->tail) ? NULL : node->next;
 100bed2:	6875      	ldr	r5, [r6, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100bed4:	45b4      	cmp	ip, r6
 100bed6:	bf08      	it	eq
 100bed8:	f04f 0c00 	moveq.w	ip, #0
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
 100bedc:	f1bc 0f00 	cmp.w	ip, #0
 100bee0:	d10d      	bne.n	100befe <z_add_timeout+0x8a>
	node->prev = tail;
 100bee2:	e9c4 6500 	strd	r6, r5, [r4]
	tail->next = node;
 100bee6:	602c      	str	r4, [r5, #0]
	list->tail = node;
 100bee8:	6074      	str	r4, [r6, #4]
}
 100beea:	e01c      	b.n	100bf26 <z_add_timeout+0xb2>
			to->dticks = timeout.ticks + 1 + elapsed();
 100beec:	f7ff ff7c 	bl	100bde8 <elapsed>
 100bef0:	3601      	adds	r6, #1
 100bef2:	f145 0500 	adc.w	r5, r5, #0
 100bef6:	1836      	adds	r6, r6, r0
 100bef8:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
 100befc:	e7e4      	b.n	100bec8 <z_add_timeout+0x54>
			if (t->dticks > to->dticks) {
 100befe:	e9dc 2004 	ldrd	r2, r0, [ip, #16]
 100bf02:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
 100bf06:	4293      	cmp	r3, r2
 100bf08:	eb71 0e00 	sbcs.w	lr, r1, r0
 100bf0c:	da1a      	bge.n	100bf44 <z_add_timeout+0xd0>
				t->dticks -= to->dticks;
 100bf0e:	1ad2      	subs	r2, r2, r3
	sys_dnode_t *const prev = successor->prev;
 100bf10:	f8dc 3004 	ldr.w	r3, [ip, #4]
 100bf14:	eb60 0001 	sbc.w	r0, r0, r1
 100bf18:	e9cc 2004 	strd	r2, r0, [ip, #16]
	node->next = successor;
 100bf1c:	e9c4 c300 	strd	ip, r3, [r4]
	prev->next = node;
 100bf20:	601c      	str	r4, [r3, #0]
	successor->prev = node;
 100bf22:	f8cc 4004 	str.w	r4, [ip, #4]
	return list->head == list;
 100bf26:	6833      	ldr	r3, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100bf28:	42b3      	cmp	r3, r6
 100bf2a:	d006      	beq.n	100bf3a <z_add_timeout+0xc6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
 100bf2c:	429c      	cmp	r4, r3
 100bf2e:	d104      	bne.n	100bf3a <z_add_timeout+0xc6>
			sys_clock_set_timeout(next_timeout(), false);
 100bf30:	f7ff ff64 	bl	100bdfc <next_timeout>
 100bf34:	2100      	movs	r1, #0
 100bf36:	f7fe fcf5 	bl	100a924 <sys_clock_set_timeout>
	__asm__ volatile(
 100bf3a:	f387 8811 	msr	BASEPRI, r7
 100bf3e:	f3bf 8f6f 	isb	sy
		}
	}
}
 100bf42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			to->dticks -= t->dticks;
 100bf44:	1a9b      	subs	r3, r3, r2
 100bf46:	eb61 0100 	sbc.w	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
 100bf4a:	45ac      	cmp	ip, r5
 100bf4c:	e9c4 3104 	strd	r3, r1, [r4, #16]
 100bf50:	d0c7      	beq.n	100bee2 <z_add_timeout+0x6e>
 100bf52:	f8dc c000 	ldr.w	ip, [ip]
 100bf56:	e7c1      	b.n	100bedc <z_add_timeout+0x68>
 100bf58:	210001c8 	.word	0x210001c8
 100bf5c:	21000080 	.word	0x21000080

0100bf60 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
 100bf60:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__asm__ volatile(
 100bf64:	f04f 0320 	mov.w	r3, #32
 100bf68:	f3ef 8c11 	mrs	ip, BASEPRI
 100bf6c:	f383 8812 	msr	BASEPRI_MAX, r3
 100bf70:	f3bf 8f6f 	isb	sy
	return list->head == list;
 100bf74:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 100c028 <sys_clock_announce+0xc8>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
 100bf78:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 100c02c <sys_clock_announce+0xcc>
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
		t->dticks = 0;
 100bf7c:	2400      	movs	r4, #0
	announce_remaining = ticks;
 100bf7e:	f8c9 0000 	str.w	r0, [r9]
 100bf82:	f8da 0000 	ldr.w	r0, [sl]
		t->dticks = 0;
 100bf86:	2500      	movs	r5, #0
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100bf88:	4550      	cmp	r0, sl
 100bf8a:	bf08      	it	eq
 100bf8c:	2000      	moveq	r0, #0
		curr_tick += dt;
 100bf8e:	4f28      	ldr	r7, [pc, #160]	; (100c030 <sys_clock_announce+0xd0>)
 100bf90:	46e0      	mov	r8, ip
 100bf92:	e9d7 2100 	ldrd	r2, r1, [r7]
	     (t != NULL) && (t->dticks <= announce_remaining);
 100bf96:	f8d9 3000 	ldr.w	r3, [r9]
 100bf9a:	b380      	cbz	r0, 100bffe <sys_clock_announce+0x9e>
 100bf9c:	e9d0 6c04 	ldrd	r6, ip, [r0, #16]
 100bfa0:	ea4f 7ee3 	mov.w	lr, r3, asr #31
 100bfa4:	42b3      	cmp	r3, r6
 100bfa6:	eb7e 0b0c 	sbcs.w	fp, lr, ip
 100bfaa:	da05      	bge.n	100bfb8 <sys_clock_announce+0x58>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
 100bfac:	1af6      	subs	r6, r6, r3
 100bfae:	eb6c 040e 	sbc.w	r4, ip, lr
 100bfb2:	e9c0 6404 	strd	r6, r4, [r0, #16]
 100bfb6:	e022      	b.n	100bffe <sys_clock_announce+0x9e>
		curr_tick += dt;
 100bfb8:	18b2      	adds	r2, r6, r2
 100bfba:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
		t->dticks = 0;
 100bfbe:	e9c0 4504 	strd	r4, r5, [r0, #16]
		curr_tick += dt;
 100bfc2:	e9c7 2100 	strd	r2, r1, [r7]
		remove_timeout(t);
 100bfc6:	f7ff ff39 	bl	100be3c <remove_timeout>
	__asm__ volatile(
 100bfca:	f388 8811 	msr	BASEPRI, r8
 100bfce:	f3bf 8f6f 	isb	sy
		t->fn(t);
 100bfd2:	6883      	ldr	r3, [r0, #8]
 100bfd4:	4798      	blx	r3
	__asm__ volatile(
 100bfd6:	f04f 0320 	mov.w	r3, #32
 100bfda:	f3ef 8811 	mrs	r8, BASEPRI
 100bfde:	f383 8812 	msr	BASEPRI_MAX, r3
 100bfe2:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
 100bfe6:	f8d9 3000 	ldr.w	r3, [r9]
	return list->head == list;
 100bfea:	f8da 0000 	ldr.w	r0, [sl]
 100bfee:	1b9b      	subs	r3, r3, r6
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100bff0:	4550      	cmp	r0, sl
	k.key = arch_irq_lock();
 100bff2:	46c4      	mov	ip, r8
 100bff4:	f8c9 3000 	str.w	r3, [r9]
 100bff8:	d1ca      	bne.n	100bf90 <sys_clock_announce+0x30>
		curr_tick += dt;
 100bffa:	e9d7 2100 	ldrd	r2, r1, [r7]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
 100bffe:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
 100c000:	189a      	adds	r2, r3, r2
 100c002:	eb41 73e3 	adc.w	r3, r1, r3, asr #31
 100c006:	e9c7 2300 	strd	r2, r3, [r7]
	announce_remaining = 0;
 100c00a:	f8c9 4000 	str.w	r4, [r9]

	sys_clock_set_timeout(next_timeout(), false);
 100c00e:	f7ff fef5 	bl	100bdfc <next_timeout>
 100c012:	4621      	mov	r1, r4
 100c014:	f7fe fc86 	bl	100a924 <sys_clock_set_timeout>
	__asm__ volatile(
 100c018:	f388 8811 	msr	BASEPRI, r8
 100c01c:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
 100c020:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_time_slice();
 100c024:	f7ff bcdc 	b.w	100b9e0 <z_time_slice>
 100c028:	21000080 	.word	0x21000080
 100c02c:	210002b8 	.word	0x210002b8
 100c030:	210001c8 	.word	0x210001c8

0100c034 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
 100c034:	b510      	push	{r4, lr}
	__asm__ volatile(
 100c036:	f04f 0320 	mov.w	r3, #32
 100c03a:	f3ef 8411 	mrs	r4, BASEPRI
 100c03e:	f383 8812 	msr	BASEPRI_MAX, r3
 100c042:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
 100c046:	f7ff fecf 	bl	100bde8 <elapsed>
 100c04a:	4603      	mov	r3, r0
 100c04c:	4a05      	ldr	r2, [pc, #20]	; (100c064 <sys_clock_tick_get+0x30>)
 100c04e:	e9d2 0100 	ldrd	r0, r1, [r2]
 100c052:	1818      	adds	r0, r3, r0
 100c054:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
	__asm__ volatile(
 100c058:	f384 8811 	msr	BASEPRI, r4
 100c05c:	f3bf 8f6f 	isb	sy
	}
	return t;
}
 100c060:	bd10      	pop	{r4, pc}
 100c062:	bf00      	nop
 100c064:	210001c8 	.word	0x210001c8

0100c068 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
 100c068:	4801      	ldr	r0, [pc, #4]	; (100c070 <boot_banner+0x8>)
 100c06a:	f000 b807 	b.w	100c07c <printk>
 100c06e:	bf00      	nop
 100c070:	0100cc4a 	.word	0x0100cc4a

0100c074 <main>:
#include <zephyr/kernel.h>

int main(void)
{
	return 0; /* Dummy application. Unused main */
}
 100c074:	2000      	movs	r0, #0
 100c076:	4770      	bx	lr

0100c078 <arch_printk_char_out>:
}
 100c078:	2000      	movs	r0, #0
 100c07a:	4770      	bx	lr

0100c07c <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
 100c07c:	b40f      	push	{r0, r1, r2, r3}
 100c07e:	b507      	push	{r0, r1, r2, lr}
 100c080:	a904      	add	r1, sp, #16
 100c082:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
 100c086:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
 100c088:	f7fc fe46 	bl	1008d18 <vprintk>

	va_end(ap);
}
 100c08c:	b003      	add	sp, #12
 100c08e:	f85d eb04 	ldr.w	lr, [sp], #4
 100c092:	b004      	add	sp, #16
 100c094:	4770      	bx	lr

0100c096 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 100c096:	4604      	mov	r4, r0
 100c098:	b508      	push	{r3, lr}
 100c09a:	4608      	mov	r0, r1
 100c09c:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
 100c09e:	461a      	mov	r2, r3
 100c0a0:	47a0      	blx	r4
	return z_impl_z_current_get();
 100c0a2:	f7ff fe21 	bl	100bce8 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
 100c0a6:	f7fd fe35 	bl	1009d14 <z_impl_k_thread_abort>

0100c0aa <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
 100c0aa:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
 100c0ac:	f013 0307 	ands.w	r3, r3, #7
 100c0b0:	d105      	bne.n	100c0be <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
 100c0b2:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
 100c0b4:	2b00      	cmp	r3, #0
 100c0b6:	bf0c      	ite	eq
 100c0b8:	2000      	moveq	r0, #0
 100c0ba:	2003      	movne	r0, #3
 100c0bc:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
 100c0be:	2b02      	cmp	r3, #2
 100c0c0:	d105      	bne.n	100c0ce <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
 100c0c2:	8b40      	ldrh	r0, [r0, #26]
 100c0c4:	fab0 f080 	clz	r0, r0
 100c0c8:	0940      	lsrs	r0, r0, #5
 100c0ca:	0080      	lsls	r0, r0, #2
 100c0cc:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
 100c0ce:	2b01      	cmp	r3, #1
 100c0d0:	d105      	bne.n	100c0de <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
 100c0d2:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
 100c0d4:	2b00      	cmp	r3, #0
 100c0d6:	bf0c      	ite	eq
 100c0d8:	2000      	moveq	r0, #0
 100c0da:	2005      	movne	r0, #5
 100c0dc:	4770      	bx	lr
	int evt = EVT_NOP;
 100c0de:	2000      	movs	r0, #0
}
 100c0e0:	4770      	bx	lr

0100c0e2 <validate_args>:
{
 100c0e2:	b510      	push	{r4, lr}
 100c0e4:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
 100c0e6:	b100      	cbz	r0, 100c0ea <validate_args+0x8>
 100c0e8:	b911      	cbnz	r1, 100c0f0 <validate_args+0xe>
		return -EINVAL;
 100c0ea:	f06f 0015 	mvn.w	r0, #21
}
 100c0ee:	bd10      	pop	{r4, pc}
	int rv = sys_notify_validate(&cli->notify);
 100c0f0:	1d08      	adds	r0, r1, #4
 100c0f2:	f000 f895 	bl	100c220 <sys_notify_validate>
	if ((rv == 0)
 100c0f6:	2800      	cmp	r0, #0
 100c0f8:	d1f9      	bne.n	100c0ee <validate_args+0xc>
	    && ((cli->notify.flags
 100c0fa:	68a3      	ldr	r3, [r4, #8]
 100c0fc:	2b03      	cmp	r3, #3
 100c0fe:	d9f6      	bls.n	100c0ee <validate_args+0xc>
 100c100:	e7f3      	b.n	100c0ea <validate_args+0x8>

0100c102 <notify_one>:
{
 100c102:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100c106:	460d      	mov	r5, r1
 100c108:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
 100c10a:	4619      	mov	r1, r3
 100c10c:	1d28      	adds	r0, r5, #4
{
 100c10e:	4690      	mov	r8, r2
 100c110:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
 100c112:	f000 f896 	bl	100c242 <sys_notify_finalize>
	if (cb) {
 100c116:	4604      	mov	r4, r0
 100c118:	b138      	cbz	r0, 100c12a <notify_one+0x28>
		cb(mgr, cli, state, res);
 100c11a:	4633      	mov	r3, r6
 100c11c:	4642      	mov	r2, r8
 100c11e:	4629      	mov	r1, r5
 100c120:	4638      	mov	r0, r7
 100c122:	46a4      	mov	ip, r4
}
 100c124:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
 100c128:	4760      	bx	ip
}
 100c12a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0100c12e <transition_complete>:
{
 100c12e:	b410      	push	{r4}
	__asm__ volatile(
 100c130:	f04f 0420 	mov.w	r4, #32
 100c134:	f3ef 8211 	mrs	r2, BASEPRI
 100c138:	f384 8812 	msr	BASEPRI_MAX, r4
 100c13c:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
 100c140:	6141      	str	r1, [r0, #20]
}
 100c142:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
 100c144:	2101      	movs	r1, #1
 100c146:	f7fc bdf5 	b.w	1008d34 <process_event>

0100c14a <onoff_manager_init>:
{
 100c14a:	b538      	push	{r3, r4, r5, lr}
 100c14c:	460c      	mov	r4, r1
	if ((mgr == NULL)
 100c14e:	4605      	mov	r5, r0
 100c150:	b158      	cbz	r0, 100c16a <onoff_manager_init+0x20>
	    || (transitions == NULL)
 100c152:	b151      	cbz	r1, 100c16a <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
 100c154:	680b      	ldr	r3, [r1, #0]
 100c156:	b143      	cbz	r3, 100c16a <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
 100c158:	684b      	ldr	r3, [r1, #4]
 100c15a:	b133      	cbz	r3, 100c16a <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
 100c15c:	221c      	movs	r2, #28
 100c15e:	2100      	movs	r1, #0
 100c160:	f000 f940 	bl	100c3e4 <memset>
	return 0;
 100c164:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
 100c166:	612c      	str	r4, [r5, #16]
}
 100c168:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
 100c16a:	f06f 0015 	mvn.w	r0, #21
 100c16e:	e7fb      	b.n	100c168 <onoff_manager_init+0x1e>

0100c170 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
 100c170:	b570      	push	{r4, r5, r6, lr}
 100c172:	4605      	mov	r5, r0
 100c174:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
 100c176:	f7ff ffb4 	bl	100c0e2 <validate_args>

	if (rv < 0) {
 100c17a:	1e04      	subs	r4, r0, #0
 100c17c:	db15      	blt.n	100c1aa <onoff_request+0x3a>
 100c17e:	f04f 0320 	mov.w	r3, #32
 100c182:	f3ef 8211 	mrs	r2, BASEPRI
 100c186:	f383 8812 	msr	BASEPRI_MAX, r3
 100c18a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
 100c18e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100c192:	8b6b      	ldrh	r3, [r5, #26]
 100c194:	8b2c      	ldrh	r4, [r5, #24]
 100c196:	428b      	cmp	r3, r1
 100c198:	f004 0407 	and.w	r4, r4, #7
 100c19c:	d107      	bne.n	100c1ae <onoff_request+0x3e>
	__asm__ volatile(
 100c19e:	f382 8811 	msr	BASEPRI, r2
 100c1a2:	f3bf 8f6f 	isb	sy
		rv = -EAGAIN;
 100c1a6:	f06f 040a 	mvn.w	r4, #10
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
 100c1aa:	4620      	mov	r0, r4
 100c1ac:	bd70      	pop	{r4, r5, r6, pc}
	if (state == ONOFF_STATE_ON) {
 100c1ae:	2c02      	cmp	r4, #2
 100c1b0:	d10c      	bne.n	100c1cc <onoff_request+0x5c>
		mgr->refs += 1U;
 100c1b2:	3301      	adds	r3, #1
 100c1b4:	836b      	strh	r3, [r5, #26]
 100c1b6:	f382 8811 	msr	BASEPRI, r2
 100c1ba:	f3bf 8f6f 	isb	sy
			notify_one(mgr, cli, state, 0);
 100c1be:	2300      	movs	r3, #0
 100c1c0:	4622      	mov	r2, r4
 100c1c2:	4631      	mov	r1, r6
 100c1c4:	4628      	mov	r0, r5
 100c1c6:	f7ff ff9c 	bl	100c102 <notify_one>
 100c1ca:	e7ee      	b.n	100c1aa <onoff_request+0x3a>
	} else if ((state == ONOFF_STATE_OFF)
 100c1cc:	2c06      	cmp	r4, #6
 100c1ce:	d814      	bhi.n	100c1fa <onoff_request+0x8a>
 100c1d0:	e8df f004 	tbb	[pc, r4]
 100c1d4:	13131304 	.word	0x13131304
 100c1d8:	1a04      	.short	0x1a04
 100c1da:	04          	.byte	0x04
 100c1db:	00          	.byte	0x00
	parent->next = child;
 100c1dc:	2300      	movs	r3, #0
 100c1de:	6033      	str	r3, [r6, #0]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
 100c1e0:	686b      	ldr	r3, [r5, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
 100c1e2:	b93b      	cbnz	r3, 100c1f4 <onoff_request+0x84>
	list->head = node;
 100c1e4:	e9c5 6600 	strd	r6, r6, [r5]
	if (start) {
 100c1e8:	b9ac      	cbnz	r4, 100c216 <onoff_request+0xa6>
		process_event(mgr, EVT_RECHECK, key);
 100c1ea:	2102      	movs	r1, #2
 100c1ec:	4628      	mov	r0, r5
 100c1ee:	f7fc fda1 	bl	1008d34 <process_event>
 100c1f2:	e7da      	b.n	100c1aa <onoff_request+0x3a>
	parent->next = child;
 100c1f4:	601e      	str	r6, [r3, #0]
	list->tail = node;
 100c1f6:	606e      	str	r6, [r5, #4]
}
 100c1f8:	e7f6      	b.n	100c1e8 <onoff_request+0x78>
 100c1fa:	f382 8811 	msr	BASEPRI, r2
 100c1fe:	f3bf 8f6f 	isb	sy
		rv = -EIO;
 100c202:	f06f 0404 	mvn.w	r4, #4
 100c206:	e7d0      	b.n	100c1aa <onoff_request+0x3a>
 100c208:	f382 8811 	msr	BASEPRI, r2
 100c20c:	f3bf 8f6f 	isb	sy
 100c210:	f06f 0485 	mvn.w	r4, #133	; 0x85
 100c214:	e7c9      	b.n	100c1aa <onoff_request+0x3a>
 100c216:	f382 8811 	msr	BASEPRI, r2
 100c21a:	f3bf 8f6f 	isb	sy
		if (notify) {
 100c21e:	e7c4      	b.n	100c1aa <onoff_request+0x3a>

0100c220 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
 100c220:	4603      	mov	r3, r0
 100c222:	b158      	cbz	r0, 100c23c <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
 100c224:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
 100c226:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
 100c22a:	2a01      	cmp	r2, #1
 100c22c:	d003      	beq.n	100c236 <sys_notify_validate+0x16>
 100c22e:	2a03      	cmp	r2, #3
 100c230:	d104      	bne.n	100c23c <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
 100c232:	6802      	ldr	r2, [r0, #0]
 100c234:	b112      	cbz	r2, 100c23c <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
 100c236:	2000      	movs	r0, #0
 100c238:	6098      	str	r0, [r3, #8]
 100c23a:	4770      	bx	lr
 100c23c:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
 100c240:	4770      	bx	lr

0100c242 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
 100c242:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
 100c244:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
 100c246:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
 100c24a:	2a03      	cmp	r2, #3
 100c24c:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
 100c250:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
 100c252:	bf14      	ite	ne
 100c254:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
 100c256:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
 100c258:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
 100c25a:	4770      	bx	lr

0100c25c <encode_uint>:
{
 100c25c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100c260:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier) != 0;
 100c262:	78d3      	ldrb	r3, [r2, #3]
{
 100c264:	4680      	mov	r8, r0
	switch (specifier) {
 100c266:	2b6f      	cmp	r3, #111	; 0x6f
{
 100c268:	460f      	mov	r7, r1
 100c26a:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
 100c26c:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
 100c270:	d029      	beq.n	100c2c6 <encode_uint+0x6a>
 100c272:	d824      	bhi.n	100c2be <encode_uint+0x62>
		return 10;
 100c274:	2b58      	cmp	r3, #88	; 0x58
 100c276:	bf0c      	ite	eq
 100c278:	2610      	moveq	r6, #16
 100c27a:	260a      	movne	r6, #10
	char *bp = bps + (bpe - bps);
 100c27c:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
 100c280:	4632      	mov	r2, r6
 100c282:	2300      	movs	r3, #0
 100c284:	4640      	mov	r0, r8
 100c286:	4639      	mov	r1, r7
 100c288:	f7fc fbd8 	bl	1008a3c <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
 100c28c:	2a09      	cmp	r2, #9
 100c28e:	b2d4      	uxtb	r4, r2
 100c290:	d81e      	bhi.n	100c2d0 <encode_uint+0x74>
 100c292:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
 100c294:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
 100c296:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
 100c298:	f177 0700 	sbcs.w	r7, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
 100c29c:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
 100c2a0:	d301      	bcc.n	100c2a6 <encode_uint+0x4a>
 100c2a2:	45d1      	cmp	r9, sl
 100c2a4:	d811      	bhi.n	100c2ca <encode_uint+0x6e>
	if (conv->flag_hash) {
 100c2a6:	782b      	ldrb	r3, [r5, #0]
 100c2a8:	069b      	lsls	r3, r3, #26
 100c2aa:	d505      	bpl.n	100c2b8 <encode_uint+0x5c>
		if (radix == 8) {
 100c2ac:	2e08      	cmp	r6, #8
 100c2ae:	d115      	bne.n	100c2dc <encode_uint+0x80>
			conv->altform_0 = true;
 100c2b0:	78ab      	ldrb	r3, [r5, #2]
 100c2b2:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
 100c2b6:	70ab      	strb	r3, [r5, #2]
}
 100c2b8:	4648      	mov	r0, r9
 100c2ba:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
 100c2be:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 10;
 100c2c2:	2b70      	cmp	r3, #112	; 0x70
 100c2c4:	e7d7      	b.n	100c276 <encode_uint+0x1a>
	switch (specifier) {
 100c2c6:	2608      	movs	r6, #8
 100c2c8:	e7d8      	b.n	100c27c <encode_uint+0x20>
		value /= radix;
 100c2ca:	4680      	mov	r8, r0
 100c2cc:	460f      	mov	r7, r1
 100c2ce:	e7d7      	b.n	100c280 <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
 100c2d0:	f1bb 0f19 	cmp.w	fp, #25
 100c2d4:	bf94      	ite	ls
 100c2d6:	3437      	addls	r4, #55	; 0x37
 100c2d8:	3457      	addhi	r4, #87	; 0x57
 100c2da:	e7db      	b.n	100c294 <encode_uint+0x38>
		} else if (radix == 16) {
 100c2dc:	2e10      	cmp	r6, #16
 100c2de:	d1eb      	bne.n	100c2b8 <encode_uint+0x5c>
			conv->altform_0c = true;
 100c2e0:	78ab      	ldrb	r3, [r5, #2]
 100c2e2:	f043 0310 	orr.w	r3, r3, #16
 100c2e6:	e7e6      	b.n	100c2b6 <encode_uint+0x5a>

0100c2e8 <outs>:
{
 100c2e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100c2ec:	4607      	mov	r7, r0
 100c2ee:	4688      	mov	r8, r1
 100c2f0:	4615      	mov	r5, r2
 100c2f2:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 100c2f4:	4614      	mov	r4, r2
 100c2f6:	42b4      	cmp	r4, r6
 100c2f8:	d305      	bcc.n	100c306 <outs+0x1e>
 100c2fa:	b10e      	cbz	r6, 100c300 <outs+0x18>
	return (int)count;
 100c2fc:	1b60      	subs	r0, r4, r5
 100c2fe:	e008      	b.n	100c312 <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 100c300:	7823      	ldrb	r3, [r4, #0]
 100c302:	2b00      	cmp	r3, #0
 100c304:	d0fa      	beq.n	100c2fc <outs+0x14>
		int rc = out((int)*sp++, ctx);
 100c306:	4641      	mov	r1, r8
 100c308:	f814 0b01 	ldrb.w	r0, [r4], #1
 100c30c:	47b8      	blx	r7
		if (rc < 0) {
 100c30e:	2800      	cmp	r0, #0
 100c310:	daf1      	bge.n	100c2f6 <outs+0xe>
}
 100c312:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0100c316 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_STRIP_PATHS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_WARN_DEPRECATED, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_ENFORCE_ZEPHYR_STDINT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
 100c316:	4770      	bx	lr

0100c318 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
 100c318:	f000 b9c7 	b.w	100c6aa <z_fatal_error>

0100c31c <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
 100c31c:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
 100c31e:	6800      	ldr	r0, [r0, #0]
 100c320:	f000 b9c3 	b.w	100c6aa <z_fatal_error>

0100c324 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 100c324:	2100      	movs	r1, #0
 100c326:	2001      	movs	r0, #1
 100c328:	f7ff bff6 	b.w	100c318 <z_arm_fatal_error>

0100c32c <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
 100c32c:	b508      	push	{r3, lr}
	handler();
 100c32e:	f7fd fa7b 	bl	1009828 <z_SysNmiOnReset>
	z_arm_int_exit();
}
 100c332:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
 100c336:	f7fd bb2b 	b.w	1009990 <z_arm_exc_exit>

0100c33a <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 100c33a:	6e43      	ldr	r3, [r0, #100]	; 0x64
 100c33c:	f383 880b 	msr	PSPLIM, r3
}
 100c340:	4770      	bx	lr

0100c342 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
 100c342:	e840 f300 	tt	r3, r0
int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
		return addr_info.flags.mpu_region;
 100c346:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 100c34a:	b2d8      	uxtb	r0, r3
	}

	return -EINVAL;
}
 100c34c:	bf08      	it	eq
 100c34e:	f06f 0015 	mvneq.w	r0, #21
 100c352:	4770      	bx	lr

0100c354 <mpu_configure_region>:
{
 100c354:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	p_attr->rbar = attr->rbar &
 100c356:	890a      	ldrh	r2, [r1, #8]
 100c358:	894e      	ldrh	r6, [r1, #10]
	region_conf.base = new_region->start;
 100c35a:	680b      	ldr	r3, [r1, #0]
		&new_region->attr, new_region->start, new_region->size);
 100c35c:	684d      	ldr	r5, [r1, #4]
 100c35e:	f002 021f 	and.w	r2, r2, #31
 100c362:	ea42 1246 	orr.w	r2, r2, r6, lsl #5
	region_conf.base = new_region->start;
 100c366:	9300      	str	r3, [sp, #0]
 100c368:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
 100c36c:	f023 031f 	bic.w	r3, r3, #31
 100c370:	1e6a      	subs	r2, r5, #1
 100c372:	4413      	add	r3, r2
 100c374:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1U)) {
 100c378:	2807      	cmp	r0, #7
 100c37a:	9303      	str	r3, [sp, #12]
 100c37c:	d804      	bhi.n	100c388 <mpu_configure_region+0x34>
	region_init(index, region_conf);
 100c37e:	4669      	mov	r1, sp
 100c380:	f7fd fcfa 	bl	1009d78 <region_init>
}
 100c384:	b004      	add	sp, #16
 100c386:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
 100c388:	f06f 0015 	mvn.w	r0, #21
	return region_allocate_and_init(index,
 100c38c:	e7fa      	b.n	100c384 <mpu_configure_region+0x30>

0100c38e <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
 100c38e:	4603      	mov	r3, r0
	size_t n = 0;
 100c390:	2000      	movs	r0, #0

	while (*s != '\0') {
 100c392:	5c1a      	ldrb	r2, [r3, r0]
 100c394:	b902      	cbnz	r2, 100c398 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
 100c396:	4770      	bx	lr
		n++;
 100c398:	3001      	adds	r0, #1
 100c39a:	e7fa      	b.n	100c392 <strlen+0x4>

0100c39c <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
 100c39c:	4603      	mov	r3, r0
	size_t n = 0;
 100c39e:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
 100c3a0:	5c1a      	ldrb	r2, [r3, r0]
 100c3a2:	b10a      	cbz	r2, 100c3a8 <strnlen+0xc>
 100c3a4:	4288      	cmp	r0, r1
 100c3a6:	d100      	bne.n	100c3aa <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
 100c3a8:	4770      	bx	lr
		n++;
 100c3aa:	3001      	adds	r0, #1
 100c3ac:	e7f8      	b.n	100c3a0 <strnlen+0x4>

0100c3ae <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
 100c3ae:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
 100c3b0:	b15a      	cbz	r2, 100c3ca <memcmp+0x1c>
 100c3b2:	3901      	subs	r1, #1
 100c3b4:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
 100c3b6:	f810 2b01 	ldrb.w	r2, [r0], #1
 100c3ba:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 100c3be:	42a0      	cmp	r0, r4
 100c3c0:	d001      	beq.n	100c3c6 <memcmp+0x18>
 100c3c2:	429a      	cmp	r2, r3
 100c3c4:	d0f7      	beq.n	100c3b6 <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
 100c3c6:	1ad0      	subs	r0, r2, r3
}
 100c3c8:	bd10      	pop	{r4, pc}
		return 0;
 100c3ca:	4610      	mov	r0, r2
 100c3cc:	e7fc      	b.n	100c3c8 <memcmp+0x1a>

0100c3ce <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
 100c3ce:	b510      	push	{r4, lr}
 100c3d0:	1e43      	subs	r3, r0, #1
 100c3d2:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
 100c3d4:	4291      	cmp	r1, r2
 100c3d6:	d100      	bne.n	100c3da <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
 100c3d8:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
 100c3da:	f811 4b01 	ldrb.w	r4, [r1], #1
 100c3de:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
 100c3e2:	e7f7      	b.n	100c3d4 <memcpy+0x6>

0100c3e4 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
 100c3e4:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
 100c3e6:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
 100c3e8:	4402      	add	r2, r0
 100c3ea:	4293      	cmp	r3, r2
 100c3ec:	d100      	bne.n	100c3f0 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
 100c3ee:	4770      	bx	lr
		*(d_byte++) = c_byte;
 100c3f0:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
 100c3f4:	e7f9      	b.n	100c3ea <memset+0x6>

0100c3f6 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
 100c3f6:	220c      	movs	r2, #12
 100c3f8:	6903      	ldr	r3, [r0, #16]
 100c3fa:	b2c9      	uxtb	r1, r1
 100c3fc:	fb01 3302 	mla	r3, r1, r2, r3
 100c400:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 100c402:	f000 0007 	and.w	r0, r0, #7
 100c406:	4770      	bx	lr

0100c408 <set_on_state>:
	__asm__ volatile(
 100c408:	f04f 0320 	mov.w	r3, #32
 100c40c:	f3ef 8211 	mrs	r2, BASEPRI
 100c410:	f383 8812 	msr	BASEPRI_MAX, r3
 100c414:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
 100c418:	6803      	ldr	r3, [r0, #0]
 100c41a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100c41e:	f043 0302 	orr.w	r3, r3, #2
 100c422:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
 100c424:	f382 8811 	msr	BASEPRI, r2
 100c428:	f3bf 8f6f 	isb	sy
}
 100c42c:	4770      	bx	lr

0100c42e <stop>:
{
 100c42e:	b570      	push	{r4, r5, r6, lr}
 100c430:	b2c9      	uxtb	r1, r1
	struct nrf_clock_control_data *data = dev->data;
 100c432:	6903      	ldr	r3, [r0, #16]
	__asm__ volatile(
 100c434:	f04f 0420 	mov.w	r4, #32
 100c438:	f3ef 8511 	mrs	r5, BASEPRI
 100c43c:	f384 8812 	msr	BASEPRI_MAX, r4
 100c440:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
 100c444:	260c      	movs	r6, #12
 100c446:	fb06 3401 	mla	r4, r6, r1, r3
 100c44a:	6c24      	ldr	r4, [r4, #64]	; 0x40
	if ((current_ctx != 0) && (current_ctx != ctx)) {
 100c44c:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
 100c450:	d008      	beq.n	100c464 <stop+0x36>
 100c452:	42a2      	cmp	r2, r4
 100c454:	d006      	beq.n	100c464 <stop+0x36>
	__asm__ volatile(
 100c456:	f385 8811 	msr	BASEPRI, r5
 100c45a:	f3bf 8f6f 	isb	sy
		err = -EPERM;
 100c45e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 100c462:	bd70      	pop	{r4, r5, r6, pc}
		*flags = CLOCK_CONTROL_STATUS_OFF;
 100c464:	2201      	movs	r2, #1
 100c466:	fb06 3301 	mla	r3, r6, r1, r3
 100c46a:	641a      	str	r2, [r3, #64]	; 0x40
 100c46c:	f385 8811 	msr	BASEPRI, r5
 100c470:	f3bf 8f6f 	isb	sy
	get_sub_config(dev, type)->stop();
 100c474:	6843      	ldr	r3, [r0, #4]
 100c476:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 100c47a:	685b      	ldr	r3, [r3, #4]
 100c47c:	4798      	blx	r3
	return 0;
 100c47e:	2000      	movs	r0, #0
 100c480:	e7ef      	b.n	100c462 <stop+0x34>

0100c482 <api_stop>:
	return stop(dev, subsys, CTX_API);
 100c482:	2280      	movs	r2, #128	; 0x80
 100c484:	f7ff bfd3 	b.w	100c42e <stop>

0100c488 <async_start>:
{
 100c488:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100c48a:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
 100c48c:	6904      	ldr	r4, [r0, #16]
	return &data->subsys[type];
 100c48e:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
 100c490:	f04f 0520 	mov.w	r5, #32
 100c494:	f3ef 8611 	mrs	r6, BASEPRI
 100c498:	f385 8812 	msr	BASEPRI_MAX, r5
 100c49c:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
 100c4a0:	250c      	movs	r5, #12
 100c4a2:	fb05 4401 	mla	r4, r5, r1, r4
 100c4a6:	6c25      	ldr	r5, [r4, #64]	; 0x40
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
 100c4a8:	f005 0c07 	and.w	ip, r5, #7
 100c4ac:	f1bc 0f01 	cmp.w	ip, #1
 100c4b0:	d10c      	bne.n	100c4cc <async_start+0x44>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
 100c4b2:	6427      	str	r7, [r4, #64]	; 0x40
	__asm__ volatile(
 100c4b4:	f386 8811 	msr	BASEPRI, r6
 100c4b8:	f3bf 8f6f 	isb	sy
	subdata->user_data = user_data;
 100c4bc:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
 100c4c0:	6843      	ldr	r3, [r0, #4]
 100c4c2:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
 100c4c6:	4798      	blx	r3
	return 0;
 100c4c8:	2000      	movs	r0, #0
}
 100c4ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
 100c4cc:	f005 05c0 	and.w	r5, r5, #192	; 0xc0
	} else if (current_ctx != ctx) {
 100c4d0:	42af      	cmp	r7, r5
 100c4d2:	f386 8811 	msr	BASEPRI, r6
 100c4d6:	f3bf 8f6f 	isb	sy
		err = -EALREADY;
 100c4da:	bf0c      	ite	eq
 100c4dc:	f06f 0077 	mvneq.w	r0, #119	; 0x77
		err = -EPERM;
 100c4e0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 100c4e4:	e7f1      	b.n	100c4ca <async_start+0x42>

0100c4e6 <api_start>:
{
 100c4e6:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
 100c4e8:	2480      	movs	r4, #128	; 0x80
 100c4ea:	9400      	str	r4, [sp, #0]
 100c4ec:	f7ff ffcc 	bl	100c488 <async_start>
}
 100c4f0:	b002      	add	sp, #8
 100c4f2:	bd10      	pop	{r4, pc}

0100c4f4 <onoff_started_callback>:
{
 100c4f4:	b410      	push	{r4}
	notify(mgr, 0);
 100c4f6:	241c      	movs	r4, #28
	return &data->mgr[type];
 100c4f8:	6900      	ldr	r0, [r0, #16]
 100c4fa:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
 100c4fc:	fb03 0004 	mla	r0, r3, r4, r0
 100c500:	2100      	movs	r1, #0
}
 100c502:	bc10      	pop	{r4}
	notify(mgr, 0);
 100c504:	4710      	bx	r2

0100c506 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
 100c506:	2000      	movs	r0, #0
 100c508:	f7fe bbb4 	b.w	100ac74 <nrfx_clock_start>

0100c50c <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
 100c50c:	2000      	movs	r0, #0
 100c50e:	f000 b872 	b.w	100c5f6 <nrfx_clock_stop>

0100c512 <blocking_start_callback>:
{
 100c512:	4610      	mov	r0, r2
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
 100c514:	f7ff b90a 	b.w	100b72c <z_impl_k_sem_give>

0100c518 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 100c518:	6843      	ldr	r3, [r0, #4]
}
 100c51a:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 100c51c:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
 100c51e:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
 100c520:	600b      	str	r3, [r1, #0]
}
 100c522:	4770      	bx	lr

0100c524 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 100c524:	6843      	ldr	r3, [r0, #4]
	const uint32_t set_mask = value & mask;
 100c526:	ea02 0001 	and.w	r0, r2, r1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 100c52a:	685b      	ldr	r3, [r3, #4]
	const uint32_t clear_mask = (~set_mask) & mask;
 100c52c:	ea21 0102 	bic.w	r1, r1, r2
    p_reg->OUTSET = set_mask;
 100c530:	6098      	str	r0, [r3, #8]
}
 100c532:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
 100c534:	60d9      	str	r1, [r3, #12]
 100c536:	4770      	bx	lr

0100c538 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 100c538:	6843      	ldr	r3, [r0, #4]
}
 100c53a:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 100c53c:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
 100c53e:	6099      	str	r1, [r3, #8]
}
 100c540:	4770      	bx	lr

0100c542 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 100c542:	6843      	ldr	r3, [r0, #4]
}
 100c544:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 100c546:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
 100c548:	60d9      	str	r1, [r3, #12]
}
 100c54a:	4770      	bx	lr

0100c54c <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 100c54c:	6843      	ldr	r3, [r0, #4]
 100c54e:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
 100c550:	6853      	ldr	r3, [r2, #4]
	const uint32_t set_mask = value & mask;
 100c552:	ea21 0003 	bic.w	r0, r1, r3
	const uint32_t clear_mask = (~value) & mask;
 100c556:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
 100c558:	6090      	str	r0, [r2, #8]
}
 100c55a:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
 100c55c:	60d3      	str	r3, [r2, #12]
 100c55e:	4770      	bx	lr

0100c560 <gpio_nrfx_manage_callback>:
{
 100c560:	b510      	push	{r4, lr}
	return port->data;
 100c562:	6903      	ldr	r3, [r0, #16]
	return list->head;
 100c564:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
 100c566:	b1f8      	cbz	r0, 100c5a8 <gpio_nrfx_manage_callback+0x48>
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 100c568:	4288      	cmp	r0, r1
 100c56a:	d119      	bne.n	100c5a0 <gpio_nrfx_manage_callback+0x40>
Z_GENLIST_REMOVE(slist, snode)
 100c56c:	689c      	ldr	r4, [r3, #8]
	return node->next;
 100c56e:	6808      	ldr	r0, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
 100c570:	42a1      	cmp	r1, r4
	list->head = node;
 100c572:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
 100c574:	d100      	bne.n	100c578 <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
 100c576:	6098      	str	r0, [r3, #8]
	parent->next = child;
 100c578:	2000      	movs	r0, #0
 100c57a:	6008      	str	r0, [r1, #0]
	if (set) {
 100c57c:	b12a      	cbz	r2, 100c58a <gpio_nrfx_manage_callback+0x2a>
	return list->head;
 100c57e:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
 100c580:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
 100c582:	689a      	ldr	r2, [r3, #8]
	list->head = node;
 100c584:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
 100c586:	b902      	cbnz	r2, 100c58a <gpio_nrfx_manage_callback+0x2a>
	list->tail = node;
 100c588:	6099      	str	r1, [r3, #8]
	return 0;
 100c58a:	2000      	movs	r0, #0
	return gpio_manage_callback(&get_port_data(port)->callbacks,
 100c58c:	e010      	b.n	100c5b0 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 100c58e:	4281      	cmp	r1, r0
 100c590:	d106      	bne.n	100c5a0 <gpio_nrfx_manage_callback+0x40>
	return node->next;
 100c592:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
 100c594:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
 100c596:	6898      	ldr	r0, [r3, #8]
 100c598:	4281      	cmp	r1, r0
 100c59a:	d1ed      	bne.n	100c578 <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
 100c59c:	609c      	str	r4, [r3, #8]
}
 100c59e:	e7eb      	b.n	100c578 <gpio_nrfx_manage_callback+0x18>
	return node->next;
 100c5a0:	4604      	mov	r4, r0
 100c5a2:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 100c5a4:	2800      	cmp	r0, #0
 100c5a6:	d1f2      	bne.n	100c58e <gpio_nrfx_manage_callback+0x2e>
			if (!set) {
 100c5a8:	2a00      	cmp	r2, #0
 100c5aa:	d1e8      	bne.n	100c57e <gpio_nrfx_manage_callback+0x1e>
				return -EINVAL;
 100c5ac:	f06f 0015 	mvn.w	r0, #21
}
 100c5b0:	bd10      	pop	{r4, pc}

0100c5b2 <event_clear>:
 100c5b2:	2200      	movs	r2, #0
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
 100c5b4:	f100 0350 	add.w	r3, r0, #80	; 0x50
 100c5b8:	009b      	lsls	r3, r3, #2
 100c5ba:	b29b      	uxth	r3, r3
 100c5bc:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 100c5c0:	f503 33b0 	add.w	r3, r3, #90112	; 0x16000
 100c5c4:	601a      	str	r2, [r3, #0]
 100c5c6:	681b      	ldr	r3, [r3, #0]
}
 100c5c8:	4770      	bx	lr

0100c5ca <sys_clock_cycle_get_32>:
{
 100c5ca:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
 100c5cc:	f7fe f850 	bl	100a670 <z_nrf_rtc_timer_read>
}
 100c5d0:	bd08      	pop	{r3, pc}

0100c5d2 <k_sys_fatal_error_handler>:

	LOG_PANIC();

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
		sys_arch_reboot(0);
 100c5d2:	2000      	movs	r0, #0
{
 100c5d4:	b508      	push	{r3, lr}
		sys_arch_reboot(0);
 100c5d6:	f7fd fb53 	bl	1009c80 <sys_arch_reboot>

0100c5da <skip_ext_apis>:
{
 100c5da:	4603      	mov	r3, r0
	for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 100c5dc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 100c5de:	2300      	movs	r3, #0
	const struct fw_info_ext_api *ext_api = &fw_info->ext_apis[0];
 100c5e0:	303c      	adds	r0, #60	; 0x3c
	for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 100c5e2:	429a      	cmp	r2, r3
 100c5e4:	d100      	bne.n	100c5e8 <skip_ext_apis+0xe>
}
 100c5e6:	4770      	bx	lr
		ADVANCE_EXT_API(ext_api);
 100c5e8:	68c1      	ldr	r1, [r0, #12]
	for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 100c5ea:	3301      	adds	r3, #1
		ADVANCE_EXT_API(ext_api);
 100c5ec:	4408      	add	r0, r1
	for (uint32_t j = 0; j < fw_info->ext_api_num; j++) {
 100c5ee:	e7f8      	b.n	100c5e2 <skip_ext_apis+0x8>

0100c5f0 <nrfx_isr>:
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
 100c5f0:	4700      	bx	r0

0100c5f2 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
 100c5f2:	f000 b947 	b.w	100c884 <z_impl_k_busy_wait>

0100c5f6 <nrfx_clock_stop>:
    clock_stop(domain);
 100c5f6:	f7fe bac1 	b.w	100ab7c <clock_stop>

0100c5fa <nrf_gpio_reconfigure>:
{
 100c5fa:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 100c5fc:	4616      	mov	r6, r2
 100c5fe:	e9dd 4708 	ldrd	r4, r7, [sp, #32]
 100c602:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 100c604:	a801      	add	r0, sp, #4
{
 100c606:	461d      	mov	r5, r3
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
 100c608:	f7fe fba8 	bl	100ad5c <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
 100c60c:	9b01      	ldr	r3, [sp, #4]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
 100c60e:	f1b6 0c00 	subs.w	ip, r6, #0
 100c612:	bf18      	it	ne
 100c614:	f04f 0c01 	movne.w	ip, #1
 100c618:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
 100c61c:	1e0b      	subs	r3, r1, #0
 100c61e:	bf18      	it	ne
 100c620:	2301      	movne	r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
 100c622:	2d00      	cmp	r5, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
 100c624:	ea43 034c 	orr.w	r3, r3, ip, lsl #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
 100c628:	bf14      	ite	ne
 100c62a:	f04f 0c0c 	movne.w	ip, #12
 100c62e:	f04f 0c00 	moveq.w	ip, #0
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
 100c632:	2c00      	cmp	r4, #0
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
 100c634:	ea43 030c 	orr.w	r3, r3, ip
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
 100c638:	bf14      	ite	ne
 100c63a:	f44f 6c70 	movne.w	ip, #3840	; 0xf00
 100c63e:	f04f 0c00 	moveq.w	ip, #0
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
 100c642:	2f00      	cmp	r7, #0
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
 100c644:	ea43 030c 	orr.w	r3, r3, ip
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
 100c648:	bf14      	ite	ne
 100c64a:	f44f 3c40 	movne.w	ip, #196608	; 0x30000
 100c64e:	f04f 0c00 	moveq.w	ip, #0
    uint32_t cnf = reg->PIN_CNF[pin_number];
 100c652:	f8d0 2200 	ldr.w	r2, [r0, #512]	; 0x200
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
 100c656:	ea43 030c 	orr.w	r3, r3, ip
    cnf &= ~to_update;
 100c65a:	ea22 0303 	bic.w	r3, r2, r3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
 100c65e:	b101      	cbz	r1, 100c662 <nrf_gpio_reconfigure+0x68>
 100c660:	7809      	ldrb	r1, [r1, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
 100c662:	b10e      	cbz	r6, 100c668 <nrf_gpio_reconfigure+0x6e>
 100c664:	7836      	ldrb	r6, [r6, #0]
 100c666:	0076      	lsls	r6, r6, #1
 100c668:	4319      	orrs	r1, r3
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
 100c66a:	b10d      	cbz	r5, 100c670 <nrf_gpio_reconfigure+0x76>
 100c66c:	782d      	ldrb	r5, [r5, #0]
 100c66e:	00ad      	lsls	r5, r5, #2
 100c670:	4331      	orrs	r1, r6
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
 100c672:	b10c      	cbz	r4, 100c678 <nrf_gpio_reconfigure+0x7e>
 100c674:	7824      	ldrb	r4, [r4, #0]
 100c676:	0224      	lsls	r4, r4, #8
 100c678:	4329      	orrs	r1, r5
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
 100c67a:	b10f      	cbz	r7, 100c680 <nrf_gpio_reconfigure+0x86>
 100c67c:	783f      	ldrb	r7, [r7, #0]
 100c67e:	043f      	lsls	r7, r7, #16
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
 100c680:	430c      	orrs	r4, r1
 100c682:	433c      	orrs	r4, r7
    reg->PIN_CNF[pin_number] = cnf;
 100c684:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
}
 100c688:	b003      	add	sp, #12
 100c68a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0100c68c <nrf_gpio_cfg_sense_set>:
{
 100c68c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
 100c68e:	f10d 030f 	add.w	r3, sp, #15
 100c692:	9301      	str	r3, [sp, #4]
 100c694:	2300      	movs	r3, #0
{
 100c696:	f88d 100f 	strb.w	r1, [sp, #15]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
 100c69a:	461a      	mov	r2, r3
 100c69c:	4619      	mov	r1, r3
 100c69e:	9300      	str	r3, [sp, #0]
 100c6a0:	f7ff ffab 	bl	100c5fa <nrf_gpio_reconfigure>
}
 100c6a4:	b005      	add	sp, #20
 100c6a6:	f85d fb04 	ldr.w	pc, [sp], #4

0100c6aa <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 100c6aa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100c6ac:	4605      	mov	r5, r0
 100c6ae:	460e      	mov	r6, r1
	__asm__ volatile(
 100c6b0:	f04f 0320 	mov.w	r3, #32
 100c6b4:	f3ef 8711 	mrs	r7, BASEPRI
 100c6b8:	f383 8812 	msr	BASEPRI_MAX, r3
 100c6bc:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
 100c6c0:	f7ff fb12 	bl	100bce8 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
 100c6c4:	4631      	mov	r1, r6
 100c6c6:	4604      	mov	r4, r0
 100c6c8:	4628      	mov	r0, r5
 100c6ca:	f7ff ff82 	bl	100c5d2 <k_sys_fatal_error_handler>
	__asm__ volatile(
 100c6ce:	f387 8811 	msr	BASEPRI, r7
 100c6d2:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
 100c6d6:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
 100c6d8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 100c6dc:	f7fd bb1a 	b.w	1009d14 <z_impl_k_thread_abort>

0100c6e0 <z_early_memset>:
	(void) memset(dst, c, n);
 100c6e0:	f7ff be80 	b.w	100c3e4 <memset>

0100c6e4 <z_early_memcpy>:
	(void) memcpy(dst, src, n);
 100c6e4:	f7ff be73 	b.w	100c3ce <memcpy>

0100c6e8 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 100c6e8:	f3ef 8005 	mrs	r0, IPSR
}
 100c6ec:	3800      	subs	r0, #0
 100c6ee:	bf18      	it	ne
 100c6f0:	2001      	movne	r0, #1
 100c6f2:	4770      	bx	lr

0100c6f4 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
 100c6f4:	b508      	push	{r3, lr}
	__asm__ volatile(
 100c6f6:	f04f 0220 	mov.w	r2, #32
 100c6fa:	f3ef 8311 	mrs	r3, BASEPRI
 100c6fe:	f382 8812 	msr	BASEPRI_MAX, r2
 100c702:	f3bf 8f6f 	isb	sy
	arch_cpu_idle();
 100c706:	f7fd f82f 	bl	1009768 <arch_cpu_idle>
 100c70a:	e7f4      	b.n	100c6f6 <idle+0x2>

0100c70c <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
 100c70c:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
 100c710:	6013      	str	r3, [r2, #0]
	next->prev = prev;
 100c712:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 100c714:	2300      	movs	r3, #0
	node->prev = NULL;
 100c716:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
 100c71a:	4770      	bx	lr

0100c71c <unpend_thread_no_timeout>:
{
 100c71c:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
 100c71e:	f7ff fff5 	bl	100c70c <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 100c722:	7b43      	ldrb	r3, [r0, #13]
 100c724:	f023 0302 	bic.w	r3, r3, #2
 100c728:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
 100c72a:	2300      	movs	r3, #0
 100c72c:	6083      	str	r3, [r0, #8]
}
 100c72e:	bd08      	pop	{r3, pc}

0100c730 <add_to_waitq_locked>:
{
 100c730:	b538      	push	{r3, r4, r5, lr}
 100c732:	4604      	mov	r4, r0
 100c734:	460d      	mov	r5, r1
	unready_thread(thread);
 100c736:	f7ff f923 	bl	100b980 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
 100c73a:	7b63      	ldrb	r3, [r4, #13]
 100c73c:	f043 0302 	orr.w	r3, r3, #2
 100c740:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
 100c742:	b1e5      	cbz	r5, 100c77e <add_to_waitq_locked+0x4e>
		thread->base.pended_on = wait_q;
 100c744:	60a5      	str	r5, [r4, #8]
	return list->head == list;
 100c746:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100c748:	429d      	cmp	r5, r3
 100c74a:	d109      	bne.n	100c760 <add_to_waitq_locked+0x30>
	sys_dnode_t *const tail = list->tail;
 100c74c:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
 100c74e:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
 100c752:	601c      	str	r4, [r3, #0]
	list->tail = node;
 100c754:	606c      	str	r4, [r5, #4]
}
 100c756:	e012      	b.n	100c77e <add_to_waitq_locked+0x4e>
	return (node == list->tail) ? NULL : node->next;
 100c758:	686a      	ldr	r2, [r5, #4]
 100c75a:	4293      	cmp	r3, r2
 100c75c:	d0f6      	beq.n	100c74c <add_to_waitq_locked+0x1c>
 100c75e:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 100c760:	2b00      	cmp	r3, #0
 100c762:	d0f3      	beq.n	100c74c <add_to_waitq_locked+0x1c>
	int32_t b1 = thread_1->base.prio;
 100c764:	f994 200e 	ldrsb.w	r2, [r4, #14]
	int32_t b2 = thread_2->base.prio;
 100c768:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
 100c76c:	428a      	cmp	r2, r1
 100c76e:	d0f3      	beq.n	100c758 <add_to_waitq_locked+0x28>
		if (z_sched_prio_cmp(thread, t) > 0) {
 100c770:	4291      	cmp	r1, r2
 100c772:	ddf1      	ble.n	100c758 <add_to_waitq_locked+0x28>
	sys_dnode_t *const prev = successor->prev;
 100c774:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
 100c776:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
 100c77a:	6014      	str	r4, [r2, #0]
	successor->prev = node;
 100c77c:	605c      	str	r4, [r3, #4]
}
 100c77e:	bd38      	pop	{r3, r4, r5, pc}

0100c780 <z_ready_thread>:
{
 100c780:	b510      	push	{r4, lr}
 100c782:	f04f 0320 	mov.w	r3, #32
 100c786:	f3ef 8411 	mrs	r4, BASEPRI
 100c78a:	f383 8812 	msr	BASEPRI_MAX, r3
 100c78e:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
 100c792:	f7ff f8c1 	bl	100b918 <ready_thread>
	__asm__ volatile(
 100c796:	f384 8811 	msr	BASEPRI, r4
 100c79a:	f3bf 8f6f 	isb	sy
}
 100c79e:	bd10      	pop	{r4, pc}

0100c7a0 <z_sched_wake_thread>:
{
 100c7a0:	b538      	push	{r3, r4, r5, lr}
 100c7a2:	4604      	mov	r4, r0
	__asm__ volatile(
 100c7a4:	f04f 0320 	mov.w	r3, #32
 100c7a8:	f3ef 8511 	mrs	r5, BASEPRI
 100c7ac:	f383 8812 	msr	BASEPRI_MAX, r3
 100c7b0:	f3bf 8f6f 	isb	sy
		if (!killed) {
 100c7b4:	7b43      	ldrb	r3, [r0, #13]
 100c7b6:	f013 0f28 	tst.w	r3, #40	; 0x28
 100c7ba:	d10b      	bne.n	100c7d4 <z_sched_wake_thread+0x34>
			if (thread->base.pended_on != NULL) {
 100c7bc:	6883      	ldr	r3, [r0, #8]
 100c7be:	b10b      	cbz	r3, 100c7c4 <z_sched_wake_thread+0x24>
				unpend_thread_no_timeout(thread);
 100c7c0:	f7ff ffac 	bl	100c71c <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
 100c7c4:	7b63      	ldrb	r3, [r4, #13]
			if (is_timeout) {
 100c7c6:	b951      	cbnz	r1, 100c7de <z_sched_wake_thread+0x3e>
 100c7c8:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
			ready_thread(thread);
 100c7cc:	4620      	mov	r0, r4
 100c7ce:	7363      	strb	r3, [r4, #13]
 100c7d0:	f7ff f8a2 	bl	100b918 <ready_thread>
	__asm__ volatile(
 100c7d4:	f385 8811 	msr	BASEPRI, r5
 100c7d8:	f3bf 8f6f 	isb	sy
}
 100c7dc:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 100c7de:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
}
 100c7e2:	e7f3      	b.n	100c7cc <z_sched_wake_thread+0x2c>

0100c7e4 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
 100c7e4:	2101      	movs	r1, #1
 100c7e6:	3818      	subs	r0, #24
 100c7e8:	f7ff bfda 	b.w	100c7a0 <z_sched_wake_thread>

0100c7ec <z_unpend_first_thread>:
{
 100c7ec:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
 100c7ee:	f04f 0320 	mov.w	r3, #32
 100c7f2:	f3ef 8511 	mrs	r5, BASEPRI
 100c7f6:	f383 8812 	msr	BASEPRI_MAX, r3
 100c7fa:	f3bf 8f6f 	isb	sy
	return list->head == list;
 100c7fe:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 100c800:	42a0      	cmp	r0, r4
 100c802:	d00d      	beq.n	100c820 <z_unpend_first_thread+0x34>
		if (thread != NULL) {
 100c804:	b134      	cbz	r4, 100c814 <z_unpend_first_thread+0x28>
			unpend_thread_no_timeout(thread);
 100c806:	4620      	mov	r0, r4
 100c808:	f7ff ff88 	bl	100c71c <unpend_thread_no_timeout>
 100c80c:	f104 0018 	add.w	r0, r4, #24
 100c810:	f000 f81e 	bl	100c850 <z_abort_timeout>
	__asm__ volatile(
 100c814:	f385 8811 	msr	BASEPRI, r5
 100c818:	f3bf 8f6f 	isb	sy
}
 100c81c:	4620      	mov	r0, r4
 100c81e:	bd38      	pop	{r3, r4, r5, pc}
 100c820:	2400      	movs	r4, #0
 100c822:	e7f7      	b.n	100c814 <z_unpend_first_thread+0x28>

0100c824 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
 100c824:	4603      	mov	r3, r0
 100c826:	b920      	cbnz	r0, 100c832 <z_reschedule_irqlock+0xe>
 100c828:	f3ef 8205 	mrs	r2, IPSR
 100c82c:	b90a      	cbnz	r2, 100c832 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
 100c82e:	f7fd b815 	b.w	100985c <arch_swap>
 100c832:	f383 8811 	msr	BASEPRI, r3
 100c836:	f3bf 8f6f 	isb	sy
}
 100c83a:	4770      	bx	lr

0100c83c <z_reschedule_unlocked>:
	__asm__ volatile(
 100c83c:	f04f 0320 	mov.w	r3, #32
 100c840:	f3ef 8011 	mrs	r0, BASEPRI
 100c844:	f383 8812 	msr	BASEPRI_MAX, r3
 100c848:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
 100c84c:	f7ff bfea 	b.w	100c824 <z_reschedule_irqlock>

0100c850 <z_abort_timeout>:
{
 100c850:	b510      	push	{r4, lr}
 100c852:	f04f 0220 	mov.w	r2, #32
 100c856:	f3ef 8411 	mrs	r4, BASEPRI
 100c85a:	f382 8812 	msr	BASEPRI_MAX, r2
 100c85e:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
 100c862:	6803      	ldr	r3, [r0, #0]
 100c864:	b13b      	cbz	r3, 100c876 <z_abort_timeout+0x26>
			remove_timeout(to);
 100c866:	f7ff fae9 	bl	100be3c <remove_timeout>
			ret = 0;
 100c86a:	2000      	movs	r0, #0
	__asm__ volatile(
 100c86c:	f384 8811 	msr	BASEPRI, r4
 100c870:	f3bf 8f6f 	isb	sy
}
 100c874:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
 100c876:	f06f 0015 	mvn.w	r0, #21
 100c87a:	e7f7      	b.n	100c86c <z_abort_timeout+0x1c>

0100c87c <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
 100c87c:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
 100c87e:	f7ff fbd9 	bl	100c034 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
 100c882:	bd08      	pop	{r3, pc}

0100c884 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
 100c884:	b108      	cbz	r0, 100c88a <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
 100c886:	f7fc bf5d 	b.w	1009744 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
 100c88a:	4770      	bx	lr

0100c88c <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
 100c88c:	4770      	bx	lr

0100c88e <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
 100c88e:	4770      	bx	lr
