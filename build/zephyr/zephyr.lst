
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0001c000 <_vector_table>:
   1c000:	80 cb 00 20 c9 e7 01 00 5d 4f 02 00 9d e7 01 00     ... ....]O......
   1c010:	9d e7 01 00 9d e7 01 00 9d e7 01 00 9d e7 01 00     ................
	...
   1c02c:	41 e4 01 00 9d e7 01 00 00 00 00 00 e1 e3 01 00     A...............
   1c03c:	9d e7 01 00                                         ....

0001c040 <_irq_vector_table>:
   1c040:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c050:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c060:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c070:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c080:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c090:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c0a0:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c0b0:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c0c0:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c0d0:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c0e0:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c0f0:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c100:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c110:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c120:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c130:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c140:	c5 e4 01 00 c5 e4 01 00 c5 e4 01 00 c5 e4 01 00     ................
   1c150:	c5 e4 01 00                                         ....

Disassembly of section text:

0001c154 <__aeabi_uldivmod>:
   1c154:	b953      	cbnz	r3, 1c16c <__aeabi_uldivmod+0x18>
   1c156:	b94a      	cbnz	r2, 1c16c <__aeabi_uldivmod+0x18>
   1c158:	2900      	cmp	r1, #0
   1c15a:	bf08      	it	eq
   1c15c:	2800      	cmpeq	r0, #0
   1c15e:	bf1c      	itt	ne
   1c160:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   1c164:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   1c168:	f000 b80c 	b.w	1c184 <__aeabi_idiv0>
   1c16c:	f1ad 0c08 	sub.w	ip, sp, #8
   1c170:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1c174:	f000 f808 	bl	1c188 <__udivmoddi4>
   1c178:	f8dd e004 	ldr.w	lr, [sp, #4]
   1c17c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1c180:	b004      	add	sp, #16
   1c182:	4770      	bx	lr

0001c184 <__aeabi_idiv0>:
   1c184:	4770      	bx	lr
   1c186:	bf00      	nop

0001c188 <__udivmoddi4>:
   1c188:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c18c:	4686      	mov	lr, r0
   1c18e:	468c      	mov	ip, r1
   1c190:	4608      	mov	r0, r1
   1c192:	9e08      	ldr	r6, [sp, #32]
   1c194:	4615      	mov	r5, r2
   1c196:	4674      	mov	r4, lr
   1c198:	4619      	mov	r1, r3
   1c19a:	2b00      	cmp	r3, #0
   1c19c:	f040 80c1 	bne.w	1c322 <__udivmoddi4+0x19a>
   1c1a0:	4285      	cmp	r5, r0
   1c1a2:	fab2 f282 	clz	r2, r2
   1c1a6:	d945      	bls.n	1c234 <__udivmoddi4+0xac>
   1c1a8:	b14a      	cbz	r2, 1c1be <__udivmoddi4+0x36>
   1c1aa:	f1c2 0320 	rsb	r3, r2, #32
   1c1ae:	fa00 fc02 	lsl.w	ip, r0, r2
   1c1b2:	4095      	lsls	r5, r2
   1c1b4:	4094      	lsls	r4, r2
   1c1b6:	fa2e f303 	lsr.w	r3, lr, r3
   1c1ba:	ea43 0c0c 	orr.w	ip, r3, ip
   1c1be:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c1c2:	b2a8      	uxth	r0, r5
   1c1c4:	0c23      	lsrs	r3, r4, #16
   1c1c6:	fbbc f8fe 	udiv	r8, ip, lr
   1c1ca:	fb0e cc18 	mls	ip, lr, r8, ip
   1c1ce:	fb08 f900 	mul.w	r9, r8, r0
   1c1d2:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
   1c1d6:	4599      	cmp	r9, r3
   1c1d8:	d928      	bls.n	1c22c <__udivmoddi4+0xa4>
   1c1da:	18eb      	adds	r3, r5, r3
   1c1dc:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
   1c1e0:	d204      	bcs.n	1c1ec <__udivmoddi4+0x64>
   1c1e2:	4599      	cmp	r9, r3
   1c1e4:	d902      	bls.n	1c1ec <__udivmoddi4+0x64>
   1c1e6:	f1a8 0702 	sub.w	r7, r8, #2
   1c1ea:	442b      	add	r3, r5
   1c1ec:	eba3 0309 	sub.w	r3, r3, r9
   1c1f0:	b2a4      	uxth	r4, r4
   1c1f2:	fbb3 fcfe 	udiv	ip, r3, lr
   1c1f6:	fb0e 331c 	mls	r3, lr, ip, r3
   1c1fa:	fb0c f000 	mul.w	r0, ip, r0
   1c1fe:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1c202:	42a0      	cmp	r0, r4
   1c204:	d914      	bls.n	1c230 <__udivmoddi4+0xa8>
   1c206:	192c      	adds	r4, r5, r4
   1c208:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   1c20c:	d204      	bcs.n	1c218 <__udivmoddi4+0x90>
   1c20e:	42a0      	cmp	r0, r4
   1c210:	d902      	bls.n	1c218 <__udivmoddi4+0x90>
   1c212:	f1ac 0302 	sub.w	r3, ip, #2
   1c216:	442c      	add	r4, r5
   1c218:	1a24      	subs	r4, r4, r0
   1c21a:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
   1c21e:	b11e      	cbz	r6, 1c228 <__udivmoddi4+0xa0>
   1c220:	40d4      	lsrs	r4, r2
   1c222:	2300      	movs	r3, #0
   1c224:	6034      	str	r4, [r6, #0]
   1c226:	6073      	str	r3, [r6, #4]
   1c228:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c22c:	4647      	mov	r7, r8
   1c22e:	e7dd      	b.n	1c1ec <__udivmoddi4+0x64>
   1c230:	4663      	mov	r3, ip
   1c232:	e7f1      	b.n	1c218 <__udivmoddi4+0x90>
   1c234:	bb92      	cbnz	r2, 1c29c <__udivmoddi4+0x114>
   1c236:	1b43      	subs	r3, r0, r5
   1c238:	2101      	movs	r1, #1
   1c23a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c23e:	b2af      	uxth	r7, r5
   1c240:	0c20      	lsrs	r0, r4, #16
   1c242:	fbb3 fcfe 	udiv	ip, r3, lr
   1c246:	fb0e 331c 	mls	r3, lr, ip, r3
   1c24a:	fb0c f807 	mul.w	r8, ip, r7
   1c24e:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
   1c252:	4598      	cmp	r8, r3
   1c254:	d961      	bls.n	1c31a <__udivmoddi4+0x192>
   1c256:	18eb      	adds	r3, r5, r3
   1c258:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   1c25c:	d204      	bcs.n	1c268 <__udivmoddi4+0xe0>
   1c25e:	4598      	cmp	r8, r3
   1c260:	d902      	bls.n	1c268 <__udivmoddi4+0xe0>
   1c262:	f1ac 0002 	sub.w	r0, ip, #2
   1c266:	442b      	add	r3, r5
   1c268:	eba3 0308 	sub.w	r3, r3, r8
   1c26c:	b2a4      	uxth	r4, r4
   1c26e:	fbb3 fcfe 	udiv	ip, r3, lr
   1c272:	fb0e 331c 	mls	r3, lr, ip, r3
   1c276:	fb0c f707 	mul.w	r7, ip, r7
   1c27a:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1c27e:	42a7      	cmp	r7, r4
   1c280:	d94d      	bls.n	1c31e <__udivmoddi4+0x196>
   1c282:	192c      	adds	r4, r5, r4
   1c284:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   1c288:	d204      	bcs.n	1c294 <__udivmoddi4+0x10c>
   1c28a:	42a7      	cmp	r7, r4
   1c28c:	d902      	bls.n	1c294 <__udivmoddi4+0x10c>
   1c28e:	f1ac 0302 	sub.w	r3, ip, #2
   1c292:	442c      	add	r4, r5
   1c294:	1be4      	subs	r4, r4, r7
   1c296:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   1c29a:	e7c0      	b.n	1c21e <__udivmoddi4+0x96>
   1c29c:	f1c2 0320 	rsb	r3, r2, #32
   1c2a0:	4095      	lsls	r5, r2
   1c2a2:	4094      	lsls	r4, r2
   1c2a4:	fa20 f103 	lsr.w	r1, r0, r3
   1c2a8:	fa2e f303 	lsr.w	r3, lr, r3
   1c2ac:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c2b0:	4090      	lsls	r0, r2
   1c2b2:	b2af      	uxth	r7, r5
   1c2b4:	4303      	orrs	r3, r0
   1c2b6:	fbb1 fcfe 	udiv	ip, r1, lr
   1c2ba:	fb0e 101c 	mls	r0, lr, ip, r1
   1c2be:	0c19      	lsrs	r1, r3, #16
   1c2c0:	fb0c f807 	mul.w	r8, ip, r7
   1c2c4:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   1c2c8:	4588      	cmp	r8, r1
   1c2ca:	d922      	bls.n	1c312 <__udivmoddi4+0x18a>
   1c2cc:	1869      	adds	r1, r5, r1
   1c2ce:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   1c2d2:	d204      	bcs.n	1c2de <__udivmoddi4+0x156>
   1c2d4:	4588      	cmp	r8, r1
   1c2d6:	d902      	bls.n	1c2de <__udivmoddi4+0x156>
   1c2d8:	f1ac 0002 	sub.w	r0, ip, #2
   1c2dc:	4429      	add	r1, r5
   1c2de:	eba1 0108 	sub.w	r1, r1, r8
   1c2e2:	b29b      	uxth	r3, r3
   1c2e4:	fbb1 fcfe 	udiv	ip, r1, lr
   1c2e8:	fb0e 111c 	mls	r1, lr, ip, r1
   1c2ec:	fb0c f707 	mul.w	r7, ip, r7
   1c2f0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1c2f4:	429f      	cmp	r7, r3
   1c2f6:	d90e      	bls.n	1c316 <__udivmoddi4+0x18e>
   1c2f8:	18eb      	adds	r3, r5, r3
   1c2fa:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
   1c2fe:	d204      	bcs.n	1c30a <__udivmoddi4+0x182>
   1c300:	429f      	cmp	r7, r3
   1c302:	d902      	bls.n	1c30a <__udivmoddi4+0x182>
   1c304:	f1ac 0102 	sub.w	r1, ip, #2
   1c308:	442b      	add	r3, r5
   1c30a:	1bdb      	subs	r3, r3, r7
   1c30c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   1c310:	e793      	b.n	1c23a <__udivmoddi4+0xb2>
   1c312:	4660      	mov	r0, ip
   1c314:	e7e3      	b.n	1c2de <__udivmoddi4+0x156>
   1c316:	4661      	mov	r1, ip
   1c318:	e7f7      	b.n	1c30a <__udivmoddi4+0x182>
   1c31a:	4660      	mov	r0, ip
   1c31c:	e7a4      	b.n	1c268 <__udivmoddi4+0xe0>
   1c31e:	4663      	mov	r3, ip
   1c320:	e7b8      	b.n	1c294 <__udivmoddi4+0x10c>
   1c322:	4283      	cmp	r3, r0
   1c324:	d906      	bls.n	1c334 <__udivmoddi4+0x1ac>
   1c326:	b916      	cbnz	r6, 1c32e <__udivmoddi4+0x1a6>
   1c328:	2100      	movs	r1, #0
   1c32a:	4608      	mov	r0, r1
   1c32c:	e77c      	b.n	1c228 <__udivmoddi4+0xa0>
   1c32e:	e9c6 e000 	strd	lr, r0, [r6]
   1c332:	e7f9      	b.n	1c328 <__udivmoddi4+0x1a0>
   1c334:	fab3 f783 	clz	r7, r3
   1c338:	b98f      	cbnz	r7, 1c35e <__udivmoddi4+0x1d6>
   1c33a:	4283      	cmp	r3, r0
   1c33c:	d301      	bcc.n	1c342 <__udivmoddi4+0x1ba>
   1c33e:	4572      	cmp	r2, lr
   1c340:	d808      	bhi.n	1c354 <__udivmoddi4+0x1cc>
   1c342:	ebbe 0402 	subs.w	r4, lr, r2
   1c346:	eb60 0303 	sbc.w	r3, r0, r3
   1c34a:	2001      	movs	r0, #1
   1c34c:	469c      	mov	ip, r3
   1c34e:	b91e      	cbnz	r6, 1c358 <__udivmoddi4+0x1d0>
   1c350:	2100      	movs	r1, #0
   1c352:	e769      	b.n	1c228 <__udivmoddi4+0xa0>
   1c354:	4638      	mov	r0, r7
   1c356:	e7fa      	b.n	1c34e <__udivmoddi4+0x1c6>
   1c358:	e9c6 4c00 	strd	r4, ip, [r6]
   1c35c:	e7f8      	b.n	1c350 <__udivmoddi4+0x1c8>
   1c35e:	f1c7 0c20 	rsb	ip, r7, #32
   1c362:	40bb      	lsls	r3, r7
   1c364:	fa0e f507 	lsl.w	r5, lr, r7
   1c368:	fa22 f40c 	lsr.w	r4, r2, ip
   1c36c:	fa2e f10c 	lsr.w	r1, lr, ip
   1c370:	40ba      	lsls	r2, r7
   1c372:	431c      	orrs	r4, r3
   1c374:	fa20 f30c 	lsr.w	r3, r0, ip
   1c378:	40b8      	lsls	r0, r7
   1c37a:	ea4f 4914 	mov.w	r9, r4, lsr #16
   1c37e:	4301      	orrs	r1, r0
   1c380:	fa1f fe84 	uxth.w	lr, r4
   1c384:	fbb3 f8f9 	udiv	r8, r3, r9
   1c388:	fb09 3018 	mls	r0, r9, r8, r3
   1c38c:	0c0b      	lsrs	r3, r1, #16
   1c38e:	fb08 fa0e 	mul.w	sl, r8, lr
   1c392:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   1c396:	459a      	cmp	sl, r3
   1c398:	d940      	bls.n	1c41c <__udivmoddi4+0x294>
   1c39a:	18e3      	adds	r3, r4, r3
   1c39c:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
   1c3a0:	d204      	bcs.n	1c3ac <__udivmoddi4+0x224>
   1c3a2:	459a      	cmp	sl, r3
   1c3a4:	d902      	bls.n	1c3ac <__udivmoddi4+0x224>
   1c3a6:	f1a8 0002 	sub.w	r0, r8, #2
   1c3aa:	4423      	add	r3, r4
   1c3ac:	eba3 030a 	sub.w	r3, r3, sl
   1c3b0:	b289      	uxth	r1, r1
   1c3b2:	fbb3 f8f9 	udiv	r8, r3, r9
   1c3b6:	fb09 3318 	mls	r3, r9, r8, r3
   1c3ba:	fb08 fe0e 	mul.w	lr, r8, lr
   1c3be:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   1c3c2:	458e      	cmp	lr, r1
   1c3c4:	d92c      	bls.n	1c420 <__udivmoddi4+0x298>
   1c3c6:	1861      	adds	r1, r4, r1
   1c3c8:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   1c3cc:	d204      	bcs.n	1c3d8 <__udivmoddi4+0x250>
   1c3ce:	458e      	cmp	lr, r1
   1c3d0:	d902      	bls.n	1c3d8 <__udivmoddi4+0x250>
   1c3d2:	f1a8 0302 	sub.w	r3, r8, #2
   1c3d6:	4421      	add	r1, r4
   1c3d8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   1c3dc:	eba1 010e 	sub.w	r1, r1, lr
   1c3e0:	fba0 9802 	umull	r9, r8, r0, r2
   1c3e4:	4541      	cmp	r1, r8
   1c3e6:	46ce      	mov	lr, r9
   1c3e8:	4643      	mov	r3, r8
   1c3ea:	d302      	bcc.n	1c3f2 <__udivmoddi4+0x26a>
   1c3ec:	d106      	bne.n	1c3fc <__udivmoddi4+0x274>
   1c3ee:	454d      	cmp	r5, r9
   1c3f0:	d204      	bcs.n	1c3fc <__udivmoddi4+0x274>
   1c3f2:	3801      	subs	r0, #1
   1c3f4:	ebb9 0e02 	subs.w	lr, r9, r2
   1c3f8:	eb68 0304 	sbc.w	r3, r8, r4
   1c3fc:	2e00      	cmp	r6, #0
   1c3fe:	d0a7      	beq.n	1c350 <__udivmoddi4+0x1c8>
   1c400:	ebb5 020e 	subs.w	r2, r5, lr
   1c404:	eb61 0103 	sbc.w	r1, r1, r3
   1c408:	fa01 fc0c 	lsl.w	ip, r1, ip
   1c40c:	fa22 f307 	lsr.w	r3, r2, r7
   1c410:	40f9      	lsrs	r1, r7
   1c412:	ea4c 0303 	orr.w	r3, ip, r3
   1c416:	e9c6 3100 	strd	r3, r1, [r6]
   1c41a:	e799      	b.n	1c350 <__udivmoddi4+0x1c8>
   1c41c:	4640      	mov	r0, r8
   1c41e:	e7c5      	b.n	1c3ac <__udivmoddi4+0x224>
   1c420:	4643      	mov	r3, r8
   1c422:	e7d9      	b.n	1c3d8 <__udivmoddi4+0x250>

0001c424 <button_pressed_isr>:
					       gpio_port_pins_t pins)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;

	return api->port_toggle_bits(port, pins);
   1c424:	4802      	ldr	r0, [pc, #8]	; (1c430 <button_pressed_isr+0xc>)
   1c426:	f44f 7180 	mov.w	r1, #256	; 0x100
   1c42a:	6883      	ldr	r3, [r0, #8]
   1c42c:	695b      	ldr	r3, [r3, #20]
   1c42e:	4718      	bx	r3
   1c430:	00026228 	.word	0x00026228

0001c434 <main>:
	gpio_pin_toggle_dt(&led);
}
static struct gpio_callback button_cb_data;

void main(void)
{
   1c434:	b570      	push	{r4, r5, r6, lr}
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
   1c436:	4c1e      	ldr	r4, [pc, #120]	; (1c4b0 <main+0x7c>)
   1c438:	4620      	mov	r0, r4
   1c43a:	f009 fb4b 	bl	25ad4 <z_device_is_ready>
	int ret;
	/* Verify that the device is ready for use */
	if (!device_is_ready(led.port)) {
   1c43e:	2800      	cmp	r0, #0
   1c440:	d034      	beq.n	1c4ac <main+0x78>
   1c442:	4620      	mov	r0, r4
   1c444:	f009 fb46 	bl	25ad4 <z_device_is_ready>
		return;
	}
	if (!device_is_ready(button.port)) {
   1c448:	b380      	cbz	r0, 1c4ac <main+0x78>
		return;
	}
	/* Configure the pin connected to the button to be an input pin and set its hardware specifications */
	ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
   1c44a:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   1c44e:	4819      	ldr	r0, [pc, #100]	; (1c4b4 <main+0x80>)
   1c450:	f007 fff0 	bl	24434 <gpio_pin_configure_dt>
	if (ret < 0) {
   1c454:	2800      	cmp	r0, #0
   1c456:	db29      	blt.n	1c4ac <main+0x78>
		return;
	}
	ret = gpio_pin_configure_dt(&button, GPIO_INPUT);
   1c458:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   1c45c:	4816      	ldr	r0, [pc, #88]	; (1c4b8 <main+0x84>)
   1c45e:	f007 ffe9 	bl	24434 <gpio_pin_configure_dt>
	if (ret < 0) {
   1c462:	2800      	cmp	r0, #0
   1c464:	db22      	blt.n	1c4ac <main+0x78>
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
   1c466:	6923      	ldr	r3, [r4, #16]
	const struct gpio_driver_api *api =
   1c468:	68a5      	ldr	r5, [r4, #8]
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
   1c46a:	681b      	ldr	r3, [r3, #0]
	return api->pin_interrupt_configure(port, pin, mode, trig);
   1c46c:	f04f 72a0 	mov.w	r2, #20971520	; 0x1400000
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
   1c470:	f413 4f80 	tst.w	r3, #16384	; 0x4000
	return api->pin_interrupt_configure(port, pin, mode, trig);
   1c474:	bf14      	ite	ne
   1c476:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
   1c47a:	f04f 6380 	moveq.w	r3, #67108864	; 0x4000000
   1c47e:	210e      	movs	r1, #14
   1c480:	4620      	mov	r0, r4
   1c482:	69ae      	ldr	r6, [r5, #24]
   1c484:	47b0      	blx	r6
		return;
	}
	ret = gpio_pin_interrupt_configure_dt(&button,GPIO_INT_EDGE_TO_ACTIVE);
	if (ret < 0) {
   1c486:	2800      	cmp	r0, #0
   1c488:	db10      	blt.n	1c4ac <main+0x78>
				      gpio_port_pins_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
   1c48a:	490c      	ldr	r1, [pc, #48]	; (1c4bc <main+0x88>)
   1c48c:	4b0c      	ldr	r3, [pc, #48]	; (1c4c0 <main+0x8c>)
   1c48e:	604b      	str	r3, [r1, #4]
	callback->pin_mask = pin_mask;
   1c490:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   1c494:	608b      	str	r3, [r1, #8]
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->api;

	if (api->manage_callback == NULL) {
   1c496:	69eb      	ldr	r3, [r5, #28]
   1c498:	b113      	cbz	r3, 1c4a0 <main+0x6c>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
   1c49a:	2201      	movs	r2, #1
   1c49c:	4620      	mov	r0, r4
   1c49e:	4798      	blx	r3
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm0 = { .val = timeout };
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
   1c4a0:	2100      	movs	r1, #0
   1c4a2:	f04f 7096 	mov.w	r0, #19660800	; 0x12c0000
   1c4a6:	f007 fccb 	bl	23e40 <z_impl_k_sleep>
   1c4aa:	e7f9      	b.n	1c4a0 <main+0x6c>
	
	while (1) {
		
		k_msleep(SLEEP_TIME_MS); // Put the main thread to sleep for 100ms for power optimization
	}
}
   1c4ac:	bd70      	pop	{r4, r5, r6, pc}
   1c4ae:	bf00      	nop
   1c4b0:	00026228 	.word	0x00026228
   1c4b4:	00026648 	.word	0x00026648
   1c4b8:	00026650 	.word	0x00026650
   1c4bc:	2000a730 	.word	0x2000a730
   1c4c0:	0001c425 	.word	0x0001c425

0001c4c4 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
   1c4c4:	4b01      	ldr	r3, [pc, #4]	; (1c4cc <char_out+0x8>)
   1c4c6:	681b      	ldr	r3, [r3, #0]
   1c4c8:	4718      	bx	r3
   1c4ca:	bf00      	nop
   1c4cc:	2000a0b0 	.word	0x2000a0b0

0001c4d0 <__printk_hook_install>:
	_char_out = fn;
   1c4d0:	4b01      	ldr	r3, [pc, #4]	; (1c4d8 <__printk_hook_install+0x8>)
   1c4d2:	6018      	str	r0, [r3, #0]
}
   1c4d4:	4770      	bx	lr
   1c4d6:	bf00      	nop
   1c4d8:	2000a0b0 	.word	0x2000a0b0

0001c4dc <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
   1c4dc:	b507      	push	{r0, r1, r2, lr}
   1c4de:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
   1c4e0:	2100      	movs	r1, #0
   1c4e2:	4602      	mov	r2, r0
   1c4e4:	9100      	str	r1, [sp, #0]
   1c4e6:	4803      	ldr	r0, [pc, #12]	; (1c4f4 <vprintk+0x18>)
   1c4e8:	f000 f914 	bl	1c714 <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
   1c4ec:	b003      	add	sp, #12
   1c4ee:	f85d fb04 	ldr.w	pc, [sp], #4
   1c4f2:	bf00      	nop
   1c4f4:	0001c4c5 	.word	0x0001c4c5

0001c4f8 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   1c4f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1c4fc:	8b05      	ldrh	r5, [r0, #24]
{
   1c4fe:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   1c500:	0728      	lsls	r0, r5, #28
{
   1c502:	4690      	mov	r8, r2
	if (processing) {
   1c504:	d411      	bmi.n	1c52a <process_event+0x32>

	sys_slist_init(&clients);
	do {
		onoff_transition_fn transit = NULL;

		if (evt == EVT_RECHECK) {
   1c506:	2902      	cmp	r1, #2
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1c508:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
   1c50c:	f040 80cd 	bne.w	1c6aa <process_event+0x1b2>
			evt = process_recheck(mgr);
   1c510:	4620      	mov	r0, r4
   1c512:	f008 f9a7 	bl	24864 <process_recheck>
		}

		if (evt == EVT_NOP) {
   1c516:	b178      	cbz	r0, 1c538 <process_event+0x40>
			break;
		}

		res = 0;
		if (evt == EVT_COMPLETE) {
   1c518:	3801      	subs	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c51a:	8b21      	ldrh	r1, [r4, #24]
   1c51c:	2804      	cmp	r0, #4
   1c51e:	d811      	bhi.n	1c544 <process_event+0x4c>
   1c520:	e8df f000 	tbb	[pc, r0]
   1c524:	856d10c3 	.word	0x856d10c3
   1c528:	95          	.byte	0x95
   1c529:	00          	.byte	0x00
		if (evt == EVT_COMPLETE) {
   1c52a:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   1c52c:	bf0c      	ite	eq
   1c52e:	f045 0510 	orreq.w	r5, r5, #16
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c532:	f045 0520 	orrne.w	r5, r5, #32
   1c536:	8325      	strh	r5, [r4, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   1c538:	f388 8811 	msr	BASEPRI, r8
   1c53c:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   1c540:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c544:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1c548:	45aa      	cmp	sl, r5
   1c54a:	f000 80a6 	beq.w	1c69a <process_event+0x1a2>
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
   1c54e:	2700      	movs	r7, #0
   1c550:	46b9      	mov	r9, r7
   1c552:	463e      	mov	r6, r7
   1c554:	68a3      	ldr	r3, [r4, #8]
   1c556:	2b00      	cmp	r3, #0
   1c558:	f000 80bd 	beq.w	1c6d6 <process_event+0x1de>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   1c55c:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   1c560:	8321      	strh	r1, [r4, #24]
   1c562:	f388 8811 	msr	BASEPRI, r8
   1c566:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   1c56a:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   1c56c:	2900      	cmp	r1, #0
   1c56e:	f000 80bb 	beq.w	1c6e8 <process_event+0x1f0>
	return node->next;
   1c572:	680d      	ldr	r5, [r1, #0]
   1c574:	2900      	cmp	r1, #0
   1c576:	f000 80b7 	beq.w	1c6e8 <process_event+0x1f0>
		mon->callback(mgr, mon, state, res);
   1c57a:	4633      	mov	r3, r6
   1c57c:	4652      	mov	r2, sl
   1c57e:	4620      	mov	r0, r4
   1c580:	f8d1 8004 	ldr.w	r8, [r1, #4]
   1c584:	47c0      	blx	r8
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   1c586:	2d00      	cmp	r5, #0
   1c588:	d076      	beq.n	1c678 <process_event+0x180>
   1c58a:	682b      	ldr	r3, [r5, #0]
   1c58c:	4629      	mov	r1, r5
   1c58e:	461d      	mov	r5, r3
   1c590:	e7f0      	b.n	1c574 <process_event+0x7c>
   1c592:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   1c596:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   1c598:	2a01      	cmp	r2, #1
   1c59a:	d81b      	bhi.n	1c5d4 <process_event+0xdc>
	list->head = NULL;
   1c59c:	2200      	movs	r2, #0
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c59e:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   1c5a2:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   1c5a4:	6827      	ldr	r7, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5a6:	b289      	uxth	r1, r1
	list->tail = NULL;
   1c5a8:	e9c4 2200 	strd	r2, r2, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   1c5ac:	d109      	bne.n	1c5c2 <process_event+0xca>
   1c5ae:	463b      	mov	r3, r7
   1c5b0:	e003      	b.n	1c5ba <process_event+0xc2>
				mgr->refs += 1U;
   1c5b2:	8b62      	ldrh	r2, [r4, #26]
   1c5b4:	3201      	adds	r2, #1
   1c5b6:	8362      	strh	r2, [r4, #26]
	return node->next;
   1c5b8:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   1c5ba:	2b00      	cmp	r3, #0
   1c5bc:	d1f9      	bne.n	1c5b2 <process_event+0xba>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5be:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
   1c5c2:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c5c4:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   1c5c6:	f008 f94d 	bl	24864 <process_recheck>
   1c5ca:	2800      	cmp	r0, #0
   1c5cc:	d07b      	beq.n	1c6c6 <process_event+0x1ce>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c5ce:	f041 0120 	orr.w	r1, r1, #32
   1c5d2:	e077      	b.n	1c6c4 <process_event+0x1cc>
	} else if (state == ONOFF_STATE_TO_OFF) {
   1c5d4:	2b04      	cmp	r3, #4
   1c5d6:	d10a      	bne.n	1c5ee <process_event+0xf6>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5d8:	f021 0107 	bic.w	r1, r1, #7
   1c5dc:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
   1c5de:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c5e0:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   1c5e2:	f008 f93f 	bl	24864 <process_recheck>
   1c5e6:	b110      	cbz	r0, 1c5ee <process_event+0xf6>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c5e8:	f041 0120 	orr.w	r1, r1, #32
   1c5ec:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c5ee:	8b21      	ldrh	r1, [r4, #24]
   1c5f0:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1c5f4:	45aa      	cmp	sl, r5
   1c5f6:	d050      	beq.n	1c69a <process_event+0x1a2>
   1c5f8:	2700      	movs	r7, #0
		onoff_transition_fn transit = NULL;
   1c5fa:	46b9      	mov	r9, r7
   1c5fc:	e7aa      	b.n	1c554 <process_event+0x5c>
			transit = mgr->transitions->start;
   1c5fe:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c600:	f021 0107 	bic.w	r1, r1, #7
   1c604:	f041 0106 	orr.w	r1, r1, #6
				   && !sys_slist_is_empty(&mgr->monitors);
   1c608:	2d06      	cmp	r5, #6
			transit = mgr->transitions->start;
   1c60a:	f8d3 9000 	ldr.w	r9, [r3]
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c60e:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   1c610:	d12d      	bne.n	1c66e <process_event+0x176>
		    || (transit != NULL)) {
   1c612:	f1b9 0f00 	cmp.w	r9, #0
   1c616:	d040      	beq.n	1c69a <process_event+0x1a2>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   1c618:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   1c61c:	8321      	strh	r1, [r4, #24]
   1c61e:	f388 8811 	msr	BASEPRI, r8
   1c622:	f3bf 8f6f 	isb	sy
				transit(mgr, transition_complete);
   1c626:	4620      	mov	r0, r4
   1c628:	4939      	ldr	r1, [pc, #228]	; (1c710 <process_event+0x218>)
   1c62a:	47c8      	blx	r9
   1c62c:	e029      	b.n	1c682 <process_event+0x18a>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c62e:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->stop;
   1c632:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c634:	f041 0104 	orr.w	r1, r1, #4
   1c638:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
   1c63a:	2d04      	cmp	r5, #4
			transit = mgr->transitions->stop;
   1c63c:	f8d3 9004 	ldr.w	r9, [r3, #4]
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c640:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   1c642:	d0e6      	beq.n	1c612 <process_event+0x11a>
   1c644:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c646:	f04f 0a04 	mov.w	sl, #4
		res = 0;
   1c64a:	463e      	mov	r6, r7
   1c64c:	e782      	b.n	1c554 <process_event+0x5c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c64e:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->reset;
   1c652:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c654:	f041 0105 	orr.w	r1, r1, #5
   1c658:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
   1c65a:	2d05      	cmp	r5, #5
			transit = mgr->transitions->reset;
   1c65c:	f8d3 9008 	ldr.w	r9, [r3, #8]
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c660:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   1c662:	d0d6      	beq.n	1c612 <process_event+0x11a>
   1c664:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c666:	f04f 0a05 	mov.w	sl, #5
		res = 0;
   1c66a:	463e      	mov	r6, r7
   1c66c:	e772      	b.n	1c554 <process_event+0x5c>
				   && !sys_slist_is_empty(&mgr->monitors);
   1c66e:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c670:	f04f 0a06 	mov.w	sl, #6
		res = 0;
   1c674:	463e      	mov	r6, r7
   1c676:	e76d      	b.n	1c554 <process_event+0x5c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   1c678:	462b      	mov	r3, r5
   1c67a:	e787      	b.n	1c58c <process_event+0x94>
			if (transit != NULL) {
   1c67c:	f1b9 0f00 	cmp.w	r9, #0
   1c680:	d1d1      	bne.n	1c626 <process_event+0x12e>
	__asm__ volatile(
   1c682:	f04f 0320 	mov.w	r3, #32
   1c686:	f3ef 8811 	mrs	r8, BASEPRI
   1c68a:	f383 8812 	msr	BASEPRI_MAX, r3
   1c68e:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   1c692:	8b23      	ldrh	r3, [r4, #24]
   1c694:	f023 0308 	bic.w	r3, r3, #8
   1c698:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   1c69a:	8b25      	ldrh	r5, [r4, #24]
   1c69c:	06ea      	lsls	r2, r5, #27
   1c69e:	d52e      	bpl.n	1c6fe <process_event+0x206>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   1c6a0:	f025 0310 	bic.w	r3, r5, #16
   1c6a4:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   1c6a6:	f005 0507 	and.w	r5, r5, #7
			res = mgr->last_res;
   1c6aa:	6966      	ldr	r6, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1c6ac:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   1c6ae:	2e00      	cmp	r6, #0
   1c6b0:	f6bf af6f 	bge.w	1c592 <process_event+0x9a>
	list->head = NULL;
   1c6b4:	2300      	movs	r3, #0
		*clients = mgr->clients;
   1c6b6:	6827      	ldr	r7, [r4, #0]
	list->tail = NULL;
   1c6b8:	e9c4 3300 	strd	r3, r3, [r4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c6bc:	f021 0107 	bic.w	r1, r1, #7
   1c6c0:	f041 0101 	orr.w	r1, r1, #1
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c6c4:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c6c6:	8b21      	ldrh	r1, [r4, #24]
   1c6c8:	f04f 0900 	mov.w	r9, #0
   1c6cc:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1c6d0:	45aa      	cmp	sl, r5
   1c6d2:	f47f af3f 	bne.w	1c554 <process_event+0x5c>
		    || !sys_slist_is_empty(&clients)
   1c6d6:	2f00      	cmp	r7, #0
   1c6d8:	d09b      	beq.n	1c612 <process_event+0x11a>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   1c6da:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   1c6de:	8321      	strh	r1, [r4, #24]
	__asm__ volatile(
   1c6e0:	f388 8811 	msr	BASEPRI, r8
   1c6e4:	f3bf 8f6f 	isb	sy
			if (!sys_slist_is_empty(&clients)) {
   1c6e8:	2f00      	cmp	r7, #0
   1c6ea:	d0c7      	beq.n	1c67c <process_event+0x184>
	return node->next;
   1c6ec:	683d      	ldr	r5, [r7, #0]
		notify_one(mgr, cli, state, res);
   1c6ee:	4639      	mov	r1, r7
   1c6f0:	4633      	mov	r3, r6
   1c6f2:	4652      	mov	r2, sl
   1c6f4:	4620      	mov	r0, r4
   1c6f6:	f008 f8e1 	bl	248bc <notify_one>
	list->head = node;
   1c6fa:	462f      	mov	r7, r5
	while (!sys_slist_is_empty(list)) {
   1c6fc:	e7f4      	b.n	1c6e8 <process_event+0x1f0>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   1c6fe:	06ab      	lsls	r3, r5, #26
   1c700:	f57f af1a 	bpl.w	1c538 <process_event+0x40>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   1c704:	f025 0320 	bic.w	r3, r5, #32
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   1c708:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   1c70a:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
   1c70e:	e6ff      	b.n	1c510 <process_event+0x18>
   1c710:	000248e9 	.word	0x000248e9

0001c714 <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
   1c714:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c718:	4681      	mov	r9, r0
   1c71a:	468b      	mov	fp, r1
   1c71c:	4617      	mov	r7, r2
   1c71e:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   1c720:	2500      	movs	r5, #0
{
   1c722:	b095      	sub	sp, #84	; 0x54
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   1c724:	7838      	ldrb	r0, [r7, #0]
   1c726:	b908      	cbnz	r0, 1c72c <z_cbvprintf_impl+0x18>
			OUTC(' ');
			--width;
		}
	}

	return count;
   1c728:	4628      	mov	r0, r5
   1c72a:	e357      	b.n	1cddc <z_cbvprintf_impl+0x6c8>
			OUTC(*fp++);
   1c72c:	1c7b      	adds	r3, r7, #1
		if (*fp != '%') {
   1c72e:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
   1c730:	9303      	str	r3, [sp, #12]
		if (*fp != '%') {
   1c732:	d006      	beq.n	1c742 <z_cbvprintf_impl+0x2e>
			OUTC('%');
   1c734:	4659      	mov	r1, fp
   1c736:	47c8      	blx	r9
   1c738:	2800      	cmp	r0, #0
   1c73a:	f2c0 834f 	blt.w	1cddc <z_cbvprintf_impl+0x6c8>
   1c73e:	3501      	adds	r5, #1
		if (bps == NULL) {
   1c740:	e1fb      	b.n	1cb3a <z_cbvprintf_impl+0x426>
		} state = {
   1c742:	2218      	movs	r2, #24
   1c744:	2100      	movs	r1, #0
   1c746:	a80e      	add	r0, sp, #56	; 0x38
   1c748:	f008 fc56 	bl	24ff8 <memset>
	if (*sp == '%') {
   1c74c:	787b      	ldrb	r3, [r7, #1]
   1c74e:	2b25      	cmp	r3, #37	; 0x25
   1c750:	d07d      	beq.n	1c84e <z_cbvprintf_impl+0x13a>
   1c752:	2300      	movs	r3, #0
   1c754:	4698      	mov	r8, r3
   1c756:	469e      	mov	lr, r3
   1c758:	469c      	mov	ip, r3
   1c75a:	461e      	mov	r6, r3
   1c75c:	1c78      	adds	r0, r7, #1
   1c75e:	4601      	mov	r1, r0
		switch (*sp) {
   1c760:	f810 2b01 	ldrb.w	r2, [r0], #1
   1c764:	2a2b      	cmp	r2, #43	; 0x2b
   1c766:	f000 80a1 	beq.w	1c8ac <z_cbvprintf_impl+0x198>
   1c76a:	f200 8098 	bhi.w	1c89e <z_cbvprintf_impl+0x18a>
   1c76e:	2a20      	cmp	r2, #32
   1c770:	f000 809f 	beq.w	1c8b2 <z_cbvprintf_impl+0x19e>
   1c774:	2a23      	cmp	r2, #35	; 0x23
   1c776:	f000 809f 	beq.w	1c8b8 <z_cbvprintf_impl+0x1a4>
   1c77a:	b12b      	cbz	r3, 1c788 <z_cbvprintf_impl+0x74>
   1c77c:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c780:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1c784:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c788:	f1b8 0f00 	cmp.w	r8, #0
   1c78c:	d005      	beq.n	1c79a <z_cbvprintf_impl+0x86>
   1c78e:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c792:	f043 0320 	orr.w	r3, r3, #32
   1c796:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c79a:	f1be 0f00 	cmp.w	lr, #0
   1c79e:	d005      	beq.n	1c7ac <z_cbvprintf_impl+0x98>
   1c7a0:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7a4:	f043 0310 	orr.w	r3, r3, #16
   1c7a8:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c7ac:	f1bc 0f00 	cmp.w	ip, #0
   1c7b0:	d005      	beq.n	1c7be <z_cbvprintf_impl+0xaa>
   1c7b2:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7b6:	f043 0308 	orr.w	r3, r3, #8
   1c7ba:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c7be:	b12e      	cbz	r6, 1c7cc <z_cbvprintf_impl+0xb8>
   1c7c0:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7c4:	f043 0304 	orr.w	r3, r3, #4
   1c7c8:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (conv->flag_zero && conv->flag_dash) {
   1c7cc:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7d0:	f003 0044 	and.w	r0, r3, #68	; 0x44
   1c7d4:	2844      	cmp	r0, #68	; 0x44
   1c7d6:	d103      	bne.n	1c7e0 <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
   1c7d8:	f36f 1386 	bfc	r3, #6, #1
   1c7dc:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	conv->width_present = true;
   1c7e0:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
   1c7e4:	2a2a      	cmp	r2, #42	; 0x2a
	conv->width_present = true;
   1c7e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1c7ea:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
   1c7ee:	d17f      	bne.n	1c8f0 <z_cbvprintf_impl+0x1dc>
		conv->width_star = true;
   1c7f0:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
   1c7f4:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
   1c7f6:	f042 0201 	orr.w	r2, r2, #1
   1c7fa:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	conv->prec_present = (*sp == '.');
   1c7fe:	781a      	ldrb	r2, [r3, #0]
   1c800:	2a2e      	cmp	r2, #46	; 0x2e
   1c802:	bf0c      	ite	eq
   1c804:	2101      	moveq	r1, #1
   1c806:	2100      	movne	r1, #0
   1c808:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c80c:	f361 0241 	bfi	r2, r1, #1, #1
   1c810:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	if (!conv->prec_present) {
   1c814:	d178      	bne.n	1c908 <z_cbvprintf_impl+0x1f4>
	if (*sp == '*') {
   1c816:	785a      	ldrb	r2, [r3, #1]
   1c818:	2a2a      	cmp	r2, #42	; 0x2a
   1c81a:	d06e      	beq.n	1c8fa <z_cbvprintf_impl+0x1e6>
	size_t val = 0;
   1c81c:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   1c81e:	f04f 0c0a 	mov.w	ip, #10
	++sp;
   1c822:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   1c824:	4619      	mov	r1, r3
   1c826:	f811 0b01 	ldrb.w	r0, [r1], #1
   1c82a:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
   1c82e:	2e09      	cmp	r6, #9
   1c830:	f240 8095 	bls.w	1c95e <z_cbvprintf_impl+0x24a>
	conv->unsupported |= ((conv->prec_value < 0)
   1c834:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	conv->prec_value = prec;
   1c838:	9212      	str	r2, [sp, #72]	; 0x48
	conv->unsupported |= ((conv->prec_value < 0)
   1c83a:	f3c1 0040 	ubfx	r0, r1, #1, #1
   1c83e:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
   1c842:	460a      	mov	r2, r1
   1c844:	f360 0241 	bfi	r2, r0, #1, #1
   1c848:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
   1c84c:	e05c      	b.n	1c908 <z_cbvprintf_impl+0x1f4>
		conv->specifier = *sp++;
   1c84e:	1cba      	adds	r2, r7, #2
   1c850:	9203      	str	r2, [sp, #12]
   1c852:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->width_star) {
   1c856:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
   1c85a:	07da      	lsls	r2, r3, #31
   1c85c:	f140 812e 	bpl.w	1cabc <z_cbvprintf_impl+0x3a8>
			width = va_arg(ap, int);
   1c860:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
   1c864:	f1b8 0f00 	cmp.w	r8, #0
   1c868:	da07      	bge.n	1c87a <z_cbvprintf_impl+0x166>
				conv->flag_dash = true;
   1c86a:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				width = -width;
   1c86e:	f1c8 0800 	rsb	r8, r8, #0
				conv->flag_dash = true;
   1c872:	f042 0204 	orr.w	r2, r2, #4
   1c876:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
		if (conv->prec_star) {
   1c87a:	075e      	lsls	r6, r3, #29
   1c87c:	f140 8127 	bpl.w	1cace <z_cbvprintf_impl+0x3ba>
			int arg = va_arg(ap, int);
   1c880:	f854 ab04 	ldr.w	sl, [r4], #4
			if (arg < 0) {
   1c884:	f1ba 0f00 	cmp.w	sl, #0
   1c888:	f280 8126 	bge.w	1cad8 <z_cbvprintf_impl+0x3c4>
				conv->prec_present = false;
   1c88c:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
   1c890:	f36f 0341 	bfc	r3, #1, #1
   1c894:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
		int precision = -1;
   1c898:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
   1c89c:	e11c      	b.n	1cad8 <z_cbvprintf_impl+0x3c4>
		switch (*sp) {
   1c89e:	2a2d      	cmp	r2, #45	; 0x2d
   1c8a0:	d00d      	beq.n	1c8be <z_cbvprintf_impl+0x1aa>
   1c8a2:	2a30      	cmp	r2, #48	; 0x30
   1c8a4:	f47f af69 	bne.w	1c77a <z_cbvprintf_impl+0x66>
   1c8a8:	2301      	movs	r3, #1
	} while (loop);
   1c8aa:	e758      	b.n	1c75e <z_cbvprintf_impl+0x4a>
		switch (*sp) {
   1c8ac:	f04f 0c01 	mov.w	ip, #1
   1c8b0:	e755      	b.n	1c75e <z_cbvprintf_impl+0x4a>
   1c8b2:	f04f 0e01 	mov.w	lr, #1
   1c8b6:	e752      	b.n	1c75e <z_cbvprintf_impl+0x4a>
   1c8b8:	f04f 0801 	mov.w	r8, #1
   1c8bc:	e74f      	b.n	1c75e <z_cbvprintf_impl+0x4a>
   1c8be:	2601      	movs	r6, #1
   1c8c0:	e74d      	b.n	1c75e <z_cbvprintf_impl+0x4a>
		val = 10U * val + *sp++ - '0';
   1c8c2:	4603      	mov	r3, r0
   1c8c4:	fb0e 6202 	mla	r2, lr, r2, r6
   1c8c8:	3a30      	subs	r2, #48	; 0x30
   1c8ca:	4618      	mov	r0, r3
   1c8cc:	f810 6b01 	ldrb.w	r6, [r0], #1
   1c8d0:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
   1c8d4:	f1bc 0f09 	cmp.w	ip, #9
   1c8d8:	d9f3      	bls.n	1c8c2 <z_cbvprintf_impl+0x1ae>
	if (sp != wp) {
   1c8da:	4299      	cmp	r1, r3
   1c8dc:	d08f      	beq.n	1c7fe <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
   1c8de:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
		conv->width_value = width;
   1c8e2:	9211      	str	r2, [sp, #68]	; 0x44
				      || (width != (size_t)conv->width_value));
   1c8e4:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
   1c8e6:	f362 0141 	bfi	r1, r2, #1, #1
   1c8ea:	f88d 1040 	strb.w	r1, [sp, #64]	; 0x40
   1c8ee:	e786      	b.n	1c7fe <z_cbvprintf_impl+0xea>
   1c8f0:	460b      	mov	r3, r1
	size_t val = 0;
   1c8f2:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   1c8f4:	f04f 0e0a 	mov.w	lr, #10
   1c8f8:	e7e7      	b.n	1c8ca <z_cbvprintf_impl+0x1b6>
		conv->prec_star = true;
   1c8fa:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
   1c8fe:	3302      	adds	r3, #2
		conv->prec_star = true;
   1c900:	f042 0204 	orr.w	r2, r2, #4
   1c904:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	switch (*sp) {
   1c908:	781a      	ldrb	r2, [r3, #0]
   1c90a:	2a6c      	cmp	r2, #108	; 0x6c
   1c90c:	d047      	beq.n	1c99e <z_cbvprintf_impl+0x28a>
   1c90e:	d82b      	bhi.n	1c968 <z_cbvprintf_impl+0x254>
   1c910:	2a68      	cmp	r2, #104	; 0x68
   1c912:	d031      	beq.n	1c978 <z_cbvprintf_impl+0x264>
   1c914:	2a6a      	cmp	r2, #106	; 0x6a
   1c916:	d04b      	beq.n	1c9b0 <z_cbvprintf_impl+0x29c>
   1c918:	2a4c      	cmp	r2, #76	; 0x4c
   1c91a:	d051      	beq.n	1c9c0 <z_cbvprintf_impl+0x2ac>
	conv->specifier = *sp++;
   1c91c:	461a      	mov	r2, r3
   1c91e:	f812 3b01 	ldrb.w	r3, [r2], #1
	switch (conv->specifier) {
   1c922:	2b78      	cmp	r3, #120	; 0x78
	conv->specifier = *sp++;
   1c924:	9203      	str	r2, [sp, #12]
   1c926:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->length_mod == LENGTH_UPPER_L) {
   1c92a:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
	switch (conv->specifier) {
   1c92e:	f200 80be 	bhi.w	1caae <z_cbvprintf_impl+0x39a>
   1c932:	2b6d      	cmp	r3, #109	; 0x6d
   1c934:	d851      	bhi.n	1c9da <z_cbvprintf_impl+0x2c6>
   1c936:	2b69      	cmp	r3, #105	; 0x69
   1c938:	f200 80b9 	bhi.w	1caae <z_cbvprintf_impl+0x39a>
   1c93c:	2b57      	cmp	r3, #87	; 0x57
   1c93e:	d867      	bhi.n	1ca10 <z_cbvprintf_impl+0x2fc>
   1c940:	2b41      	cmp	r3, #65	; 0x41
   1c942:	d003      	beq.n	1c94c <z_cbvprintf_impl+0x238>
   1c944:	3b45      	subs	r3, #69	; 0x45
   1c946:	2b02      	cmp	r3, #2
   1c948:	f200 80b1 	bhi.w	1caae <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_FP;
   1c94c:	2204      	movs	r2, #4
   1c94e:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1c952:	f362 0302 	bfi	r3, r2, #0, #3
   1c956:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
			unsupported = true;
   1c95a:	2301      	movs	r3, #1
			break;
   1c95c:	e073      	b.n	1ca46 <z_cbvprintf_impl+0x332>
		val = 10U * val + *sp++ - '0';
   1c95e:	fb0c 0202 	mla	r2, ip, r2, r0
   1c962:	460b      	mov	r3, r1
   1c964:	3a30      	subs	r2, #48	; 0x30
   1c966:	e75d      	b.n	1c824 <z_cbvprintf_impl+0x110>
	switch (*sp) {
   1c968:	2a74      	cmp	r2, #116	; 0x74
   1c96a:	d025      	beq.n	1c9b8 <z_cbvprintf_impl+0x2a4>
   1c96c:	2a7a      	cmp	r2, #122	; 0x7a
   1c96e:	d1d5      	bne.n	1c91c <z_cbvprintf_impl+0x208>
		conv->length_mod = LENGTH_Z;
   1c970:	2106      	movs	r1, #6
   1c972:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c976:	e00c      	b.n	1c992 <z_cbvprintf_impl+0x27e>
		if (*++sp == 'h') {
   1c978:	785a      	ldrb	r2, [r3, #1]
   1c97a:	2a68      	cmp	r2, #104	; 0x68
   1c97c:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c980:	d106      	bne.n	1c990 <z_cbvprintf_impl+0x27c>
			conv->length_mod = LENGTH_HH;
   1c982:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
   1c984:	f361 02c6 	bfi	r2, r1, #3, #4
   1c988:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
			++sp;
   1c98c:	3302      	adds	r3, #2
   1c98e:	e7c5      	b.n	1c91c <z_cbvprintf_impl+0x208>
			conv->length_mod = LENGTH_H;
   1c990:	2102      	movs	r1, #2
   1c992:	f361 02c6 	bfi	r2, r1, #3, #4
   1c996:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		if (*++sp == 'h') {
   1c99a:	3301      	adds	r3, #1
   1c99c:	e7be      	b.n	1c91c <z_cbvprintf_impl+0x208>
		if (*++sp == 'l') {
   1c99e:	785a      	ldrb	r2, [r3, #1]
   1c9a0:	2a6c      	cmp	r2, #108	; 0x6c
   1c9a2:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c9a6:	d101      	bne.n	1c9ac <z_cbvprintf_impl+0x298>
			conv->length_mod = LENGTH_LL;
   1c9a8:	2104      	movs	r1, #4
   1c9aa:	e7eb      	b.n	1c984 <z_cbvprintf_impl+0x270>
			conv->length_mod = LENGTH_L;
   1c9ac:	2103      	movs	r1, #3
   1c9ae:	e7f0      	b.n	1c992 <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_J;
   1c9b0:	2105      	movs	r1, #5
   1c9b2:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c9b6:	e7ec      	b.n	1c992 <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_T;
   1c9b8:	2107      	movs	r1, #7
   1c9ba:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c9be:	e7e8      	b.n	1c992 <z_cbvprintf_impl+0x27e>
		conv->unsupported = true;
   1c9c0:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
   1c9c4:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
   1c9c8:	f022 0202 	bic.w	r2, r2, #2
   1c9cc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   1c9d0:	f042 0202 	orr.w	r2, r2, #2
   1c9d4:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
		break;
   1c9d8:	e7df      	b.n	1c99a <z_cbvprintf_impl+0x286>
	switch (conv->specifier) {
   1c9da:	3b6e      	subs	r3, #110	; 0x6e
   1c9dc:	b2d9      	uxtb	r1, r3
   1c9de:	2301      	movs	r3, #1
   1c9e0:	408b      	lsls	r3, r1
   1c9e2:	f240 4182 	movw	r1, #1154	; 0x482
   1c9e6:	420b      	tst	r3, r1
   1c9e8:	d137      	bne.n	1ca5a <z_cbvprintf_impl+0x346>
   1c9ea:	f013 0f24 	tst.w	r3, #36	; 0x24
   1c9ee:	d151      	bne.n	1ca94 <z_cbvprintf_impl+0x380>
   1c9f0:	07d8      	lsls	r0, r3, #31
   1c9f2:	d55c      	bpl.n	1caae <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_PTR;
   1c9f4:	2103      	movs	r1, #3
   1c9f6:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1c9fa:	f361 0302 	bfi	r3, r1, #0, #3
   1c9fe:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca02:	f002 0378 	and.w	r3, r2, #120	; 0x78
   1ca06:	f1a3 0140 	sub.w	r1, r3, #64	; 0x40
   1ca0a:	424b      	negs	r3, r1
   1ca0c:	414b      	adcs	r3, r1
   1ca0e:	e01a      	b.n	1ca46 <z_cbvprintf_impl+0x332>
   1ca10:	2001      	movs	r0, #1
	switch (conv->specifier) {
   1ca12:	f1a3 0158 	sub.w	r1, r3, #88	; 0x58
   1ca16:	b2c9      	uxtb	r1, r1
   1ca18:	fa00 f101 	lsl.w	r1, r0, r1
   1ca1c:	f411 4f62 	tst.w	r1, #57856	; 0xe200
   1ca20:	d194      	bne.n	1c94c <z_cbvprintf_impl+0x238>
   1ca22:	f640 0601 	movw	r6, #2049	; 0x801
   1ca26:	4231      	tst	r1, r6
   1ca28:	d11d      	bne.n	1ca66 <z_cbvprintf_impl+0x352>
   1ca2a:	f411 3f04 	tst.w	r1, #135168	; 0x21000
   1ca2e:	d03e      	beq.n	1caae <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_SINT;
   1ca30:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ca34:	f360 0302 	bfi	r3, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca38:	f002 0278 	and.w	r2, r2, #120	; 0x78
   1ca3c:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_SINT;
   1ca3e:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca42:	d034      	beq.n	1caae <z_cbvprintf_impl+0x39a>
	bool unsupported = false;
   1ca44:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
   1ca46:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
   1ca4a:	f3c2 0140 	ubfx	r1, r2, #1, #1
   1ca4e:	430b      	orrs	r3, r1
   1ca50:	f363 0241 	bfi	r2, r3, #1, #1
   1ca54:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
   1ca58:	e6fd      	b.n	1c856 <z_cbvprintf_impl+0x142>
		conv->specifier_cat = SPECIFIER_UINT;
   1ca5a:	2102      	movs	r1, #2
   1ca5c:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ca60:	f361 0302 	bfi	r3, r1, #0, #3
   1ca64:	e7e8      	b.n	1ca38 <z_cbvprintf_impl+0x324>
   1ca66:	2002      	movs	r0, #2
   1ca68:	f89d 1042 	ldrb.w	r1, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca6c:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
   1ca70:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca74:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
   1ca76:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
			conv->invalid = true;
   1ca7a:	bf02      	ittt	eq
   1ca7c:	f89d 1040 	ldrbeq.w	r1, [sp, #64]	; 0x40
   1ca80:	f041 0101 	orreq.w	r1, r1, #1
   1ca84:	f88d 1040 	strbeq.w	r1, [sp, #64]	; 0x40
		if (conv->specifier == 'c') {
   1ca88:	2b63      	cmp	r3, #99	; 0x63
   1ca8a:	d1db      	bne.n	1ca44 <z_cbvprintf_impl+0x330>
			unsupported = (conv->length_mod != LENGTH_NONE);
   1ca8c:	1e13      	subs	r3, r2, #0
   1ca8e:	bf18      	it	ne
   1ca90:	2301      	movne	r3, #1
   1ca92:	e7d8      	b.n	1ca46 <z_cbvprintf_impl+0x332>
		conv->specifier_cat = SPECIFIER_PTR;
   1ca94:	2103      	movs	r1, #3
   1ca96:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
   1ca9a:	f012 0f78 	tst.w	r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
   1ca9e:	f361 0302 	bfi	r3, r1, #0, #3
   1caa2:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
   1caa6:	bf14      	ite	ne
   1caa8:	2301      	movne	r3, #1
   1caaa:	2300      	moveq	r3, #0
   1caac:	e7cb      	b.n	1ca46 <z_cbvprintf_impl+0x332>
		conv->invalid = true;
   1caae:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1cab2:	f043 0301 	orr.w	r3, r3, #1
   1cab6:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
		break;
   1caba:	e7c3      	b.n	1ca44 <z_cbvprintf_impl+0x330>
		} else if (conv->width_present) {
   1cabc:	f99d 2040 	ldrsb.w	r2, [sp, #64]	; 0x40
   1cac0:	2a00      	cmp	r2, #0
		int width = -1;
   1cac2:	bfac      	ite	ge
   1cac4:	f04f 38ff 	movge.w	r8, #4294967295	; 0xffffffff
			width = conv->width_value;
   1cac8:	f8dd 8044 	ldrlt.w	r8, [sp, #68]	; 0x44
   1cacc:	e6d5      	b.n	1c87a <z_cbvprintf_impl+0x166>
		} else if (conv->prec_present) {
   1cace:	0798      	lsls	r0, r3, #30
   1cad0:	f57f aee2 	bpl.w	1c898 <z_cbvprintf_impl+0x184>
			precision = conv->prec_value;
   1cad4:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
		conv->pad0_value = 0;
   1cad8:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
   1cada:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
			= (enum specifier_cat_enum)conv->specifier_cat;
   1cade:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
			= (enum length_mod_enum)conv->length_mod;
   1cae2:	f89d 1041 	ldrb.w	r1, [sp, #65]	; 0x41
		enum specifier_cat_enum specifier_cat
   1cae6:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
   1caea:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
   1caec:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
   1caf0:	d133      	bne.n	1cb5a <z_cbvprintf_impl+0x446>
			switch (length_mod) {
   1caf2:	1ecb      	subs	r3, r1, #3
   1caf4:	2b04      	cmp	r3, #4
   1caf6:	d804      	bhi.n	1cb02 <z_cbvprintf_impl+0x3ee>
   1caf8:	e8df f003 	tbb	[pc, r3]
   1cafc:	21464621 	.word	0x21464621
   1cb00:	21          	.byte	0x21
   1cb01:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
   1cb02:	6823      	ldr	r3, [r4, #0]
			if (length_mod == LENGTH_HH) {
   1cb04:	2901      	cmp	r1, #1
				value->sint = va_arg(ap, int);
   1cb06:	ea4f 72e3 	mov.w	r2, r3, asr #31
   1cb0a:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
   1cb0e:	d11c      	bne.n	1cb4a <z_cbvprintf_impl+0x436>
				value->sint = (signed char)value->sint;
   1cb10:	f99d 3038 	ldrsb.w	r3, [sp, #56]	; 0x38
   1cb14:	17da      	asrs	r2, r3, #31
   1cb16:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
				value->sint = va_arg(ap, int);
   1cb1a:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
   1cb1c:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1cb20:	f013 0603 	ands.w	r6, r3, #3
   1cb24:	d050      	beq.n	1cbc8 <z_cbvprintf_impl+0x4b4>
			OUTS(sp, fp);
   1cb26:	463a      	mov	r2, r7
   1cb28:	4659      	mov	r1, fp
   1cb2a:	4648      	mov	r0, r9
   1cb2c:	9b03      	ldr	r3, [sp, #12]
   1cb2e:	f007 fff9 	bl	24b24 <outs>
   1cb32:	2800      	cmp	r0, #0
   1cb34:	f2c0 8152 	blt.w	1cddc <z_cbvprintf_impl+0x6c8>
   1cb38:	4405      	add	r5, r0
			continue;
   1cb3a:	9f03      	ldr	r7, [sp, #12]
   1cb3c:	e5f2      	b.n	1c724 <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   1cb3e:	f854 3b04 	ldr.w	r3, [r4], #4
   1cb42:	17da      	asrs	r2, r3, #31
				value->uint = (unsigned char)value->uint;
   1cb44:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
   1cb48:	e7e8      	b.n	1cb1c <z_cbvprintf_impl+0x408>
			} else if (length_mod == LENGTH_H) {
   1cb4a:	2902      	cmp	r1, #2
   1cb4c:	d1e5      	bne.n	1cb1a <z_cbvprintf_impl+0x406>
				value->sint = (short)value->sint;
   1cb4e:	b21a      	sxth	r2, r3
   1cb50:	f343 33c0 	sbfx	r3, r3, #15, #1
   1cb54:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   1cb58:	e7df      	b.n	1cb1a <z_cbvprintf_impl+0x406>
		} else if (specifier_cat == SPECIFIER_UINT) {
   1cb5a:	2b02      	cmp	r3, #2
   1cb5c:	d124      	bne.n	1cba8 <z_cbvprintf_impl+0x494>
			switch (length_mod) {
   1cb5e:	1ecb      	subs	r3, r1, #3
   1cb60:	2b04      	cmp	r3, #4
   1cb62:	d804      	bhi.n	1cb6e <z_cbvprintf_impl+0x45a>
   1cb64:	e8df f003 	tbb	[pc, r3]
   1cb68:	18101018 	.word	0x18101018
   1cb6c:	18          	.byte	0x18
   1cb6d:	00          	.byte	0x00
			if (length_mod == LENGTH_HH) {
   1cb6e:	2901      	cmp	r1, #1
   1cb70:	f04f 0200 	mov.w	r2, #0
				value->uint = va_arg(ap, unsigned int);
   1cb74:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
   1cb78:	d014      	beq.n	1cba4 <z_cbvprintf_impl+0x490>
			} else if (length_mod == LENGTH_H) {
   1cb7a:	2902      	cmp	r1, #2
				value->uint = va_arg(ap, unsigned int);
   1cb7c:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			} else if (length_mod == LENGTH_H) {
   1cb80:	d1cc      	bne.n	1cb1c <z_cbvprintf_impl+0x408>
				value->uint = (unsigned short)value->uint;
   1cb82:	b29b      	uxth	r3, r3
			value->ptr = va_arg(ap, void *);
   1cb84:	930e      	str	r3, [sp, #56]	; 0x38
   1cb86:	e7c9      	b.n	1cb1c <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap,
   1cb88:	3407      	adds	r4, #7
   1cb8a:	f024 0407 	bic.w	r4, r4, #7
				value->uint =
   1cb8e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
   1cb92:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
   1cb96:	e7c1      	b.n	1cb1c <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap, size_t);
   1cb98:	f854 3b04 	ldr.w	r3, [r4], #4
   1cb9c:	930e      	str	r3, [sp, #56]	; 0x38
   1cb9e:	2300      	movs	r3, #0
   1cba0:	930f      	str	r3, [sp, #60]	; 0x3c
			} else if (length_mod == LENGTH_H) {
   1cba2:	e7bb      	b.n	1cb1c <z_cbvprintf_impl+0x408>
				value->uint = (unsigned char)value->uint;
   1cba4:	b2db      	uxtb	r3, r3
   1cba6:	e7cd      	b.n	1cb44 <z_cbvprintf_impl+0x430>
		} else if (specifier_cat == SPECIFIER_FP) {
   1cba8:	2b04      	cmp	r3, #4
   1cbaa:	d108      	bne.n	1cbbe <z_cbvprintf_impl+0x4aa>
					(sint_value_type)va_arg(ap, long long);
   1cbac:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
   1cbae:	f024 0407 	bic.w	r4, r4, #7
   1cbb2:	e9d4 2300 	ldrd	r2, r3, [r4]
   1cbb6:	3408      	adds	r4, #8
   1cbb8:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   1cbbc:	e7ae      	b.n	1cb1c <z_cbvprintf_impl+0x408>
		} else if (specifier_cat == SPECIFIER_PTR) {
   1cbbe:	2b03      	cmp	r3, #3
   1cbc0:	d1ac      	bne.n	1cb1c <z_cbvprintf_impl+0x408>
			value->ptr = va_arg(ap, void *);
   1cbc2:	f854 3b04 	ldr.w	r3, [r4], #4
   1cbc6:	e7dd      	b.n	1cb84 <z_cbvprintf_impl+0x470>
		switch (conv->specifier) {
   1cbc8:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
   1cbcc:	2878      	cmp	r0, #120	; 0x78
   1cbce:	d8b4      	bhi.n	1cb3a <z_cbvprintf_impl+0x426>
   1cbd0:	2862      	cmp	r0, #98	; 0x62
   1cbd2:	d81c      	bhi.n	1cc0e <z_cbvprintf_impl+0x4fa>
   1cbd4:	2825      	cmp	r0, #37	; 0x25
   1cbd6:	f43f adad 	beq.w	1c734 <z_cbvprintf_impl+0x20>
   1cbda:	2858      	cmp	r0, #88	; 0x58
   1cbdc:	d1ad      	bne.n	1cb3a <z_cbvprintf_impl+0x426>
			bps = encode_uint(value->uint, conv, buf, bpe);
   1cbde:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1cbe2:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cbe6:	9300      	str	r3, [sp, #0]
   1cbe8:	aa10      	add	r2, sp, #64	; 0x40
   1cbea:	ab08      	add	r3, sp, #32
   1cbec:	f007 ff54 	bl	24a98 <encode_uint>
			if (precision >= 0) {
   1cbf0:	f1ba 0f00 	cmp.w	sl, #0
			bps = encode_uint(value->uint, conv, buf, bpe);
   1cbf4:	4607      	mov	r7, r0
			if (precision >= 0) {
   1cbf6:	f280 8099 	bge.w	1cd2c <z_cbvprintf_impl+0x618>
		if (bps == NULL) {
   1cbfa:	2f00      	cmp	r7, #0
   1cbfc:	d09d      	beq.n	1cb3a <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
   1cbfe:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cc02:	1bd8      	subs	r0, r3, r7
		if (sign != 0) {
   1cc04:	2e00      	cmp	r6, #0
   1cc06:	f000 80c0 	beq.w	1cd8a <z_cbvprintf_impl+0x676>
			nj_len += 1U;
   1cc0a:	3001      	adds	r0, #1
   1cc0c:	e0bd      	b.n	1cd8a <z_cbvprintf_impl+0x676>
		switch (conv->specifier) {
   1cc0e:	3863      	subs	r0, #99	; 0x63
   1cc10:	2815      	cmp	r0, #21
   1cc12:	d892      	bhi.n	1cb3a <z_cbvprintf_impl+0x426>
   1cc14:	a201      	add	r2, pc, #4	; (adr r2, 1cc1c <z_cbvprintf_impl+0x508>)
   1cc16:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
   1cc1a:	bf00      	nop
   1cc1c:	0001ccf1 	.word	0x0001ccf1
   1cc20:	0001cd03 	.word	0x0001cd03
   1cc24:	0001cb3b 	.word	0x0001cb3b
   1cc28:	0001cb3b 	.word	0x0001cb3b
   1cc2c:	0001cb3b 	.word	0x0001cb3b
   1cc30:	0001cb3b 	.word	0x0001cb3b
   1cc34:	0001cd03 	.word	0x0001cd03
   1cc38:	0001cb3b 	.word	0x0001cb3b
   1cc3c:	0001cb3b 	.word	0x0001cb3b
   1cc40:	0001cb3b 	.word	0x0001cb3b
   1cc44:	0001cb3b 	.word	0x0001cb3b
   1cc48:	0001cd8f 	.word	0x0001cd8f
   1cc4c:	0001cd27 	.word	0x0001cd27
   1cc50:	0001cd4d 	.word	0x0001cd4d
   1cc54:	0001cb3b 	.word	0x0001cb3b
   1cc58:	0001cb3b 	.word	0x0001cb3b
   1cc5c:	0001cc75 	.word	0x0001cc75
   1cc60:	0001cb3b 	.word	0x0001cb3b
   1cc64:	0001cd27 	.word	0x0001cd27
   1cc68:	0001cb3b 	.word	0x0001cb3b
   1cc6c:	0001cb3b 	.word	0x0001cb3b
   1cc70:	0001cd27 	.word	0x0001cd27
			if (precision >= 0) {
   1cc74:	f1ba 0f00 	cmp.w	sl, #0
			bps = (const char *)value->ptr;
   1cc78:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			if (precision >= 0) {
   1cc7a:	db35      	blt.n	1cce8 <z_cbvprintf_impl+0x5d4>
				len = strnlen(bps, precision);
   1cc7c:	4651      	mov	r1, sl
   1cc7e:	4638      	mov	r0, r7
   1cc80:	f008 f9a6 	bl	24fd0 <strnlen>
			bpe = bps + len;
   1cc84:	eb07 0a00 	add.w	sl, r7, r0
		if (bps == NULL) {
   1cc88:	2f00      	cmp	r7, #0
   1cc8a:	f43f af56 	beq.w	1cb3a <z_cbvprintf_impl+0x426>
		char sign = 0;
   1cc8e:	2600      	movs	r6, #0
		if (conv->altform_0c) {
   1cc90:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1cc94:	f013 0210 	ands.w	r2, r3, #16
   1cc98:	9205      	str	r2, [sp, #20]
   1cc9a:	f000 8092 	beq.w	1cdc2 <z_cbvprintf_impl+0x6ae>
			nj_len += 2U;
   1cc9e:	3002      	adds	r0, #2
		if (conv->pad_fp) {
   1cca0:	065b      	lsls	r3, r3, #25
		nj_len += conv->pad0_value;
   1cca2:	9a11      	ldr	r2, [sp, #68]	; 0x44
			nj_len += conv->pad0_pre_exp;
   1cca4:	bf48      	it	mi
   1cca6:	9b12      	ldrmi	r3, [sp, #72]	; 0x48
		nj_len += conv->pad0_value;
   1cca8:	4410      	add	r0, r2
			nj_len += conv->pad0_pre_exp;
   1ccaa:	bf48      	it	mi
   1ccac:	18c0      	addmi	r0, r0, r3
		if (width > 0) {
   1ccae:	f1b8 0f00 	cmp.w	r8, #0
		nj_len += conv->pad0_value;
   1ccb2:	9204      	str	r2, [sp, #16]
		if (width > 0) {
   1ccb4:	f340 809f 	ble.w	1cdf6 <z_cbvprintf_impl+0x6e2>
			if (!conv->flag_dash) {
   1ccb8:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
			width -= (int)nj_len;
   1ccbc:	eba8 0800 	sub.w	r8, r8, r0
			if (!conv->flag_dash) {
   1ccc0:	f3c2 0380 	ubfx	r3, r2, #2, #1
   1ccc4:	0750      	lsls	r0, r2, #29
   1ccc6:	9306      	str	r3, [sp, #24]
   1ccc8:	f100 8095 	bmi.w	1cdf6 <z_cbvprintf_impl+0x6e2>
				if (conv->flag_zero) {
   1cccc:	0651      	lsls	r1, r2, #25
   1ccce:	f140 8088 	bpl.w	1cde2 <z_cbvprintf_impl+0x6ce>
					if (sign != 0) {
   1ccd2:	b13e      	cbz	r6, 1cce4 <z_cbvprintf_impl+0x5d0>
						OUTC(sign);
   1ccd4:	4659      	mov	r1, fp
   1ccd6:	4630      	mov	r0, r6
   1ccd8:	47c8      	blx	r9
   1ccda:	2800      	cmp	r0, #0
   1ccdc:	db7e      	blt.n	1cddc <z_cbvprintf_impl+0x6c8>
   1ccde:	9b06      	ldr	r3, [sp, #24]
   1cce0:	3501      	adds	r5, #1
   1cce2:	461e      	mov	r6, r3
					pad = '0';
   1cce4:	2230      	movs	r2, #48	; 0x30
   1cce6:	e07d      	b.n	1cde4 <z_cbvprintf_impl+0x6d0>
				len = strlen(bps);
   1cce8:	4638      	mov	r0, r7
   1ccea:	f008 f96a 	bl	24fc2 <strlen>
   1ccee:	e7c9      	b.n	1cc84 <z_cbvprintf_impl+0x570>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   1ccf0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
		char sign = 0;
   1ccf2:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
   1ccf4:	2001      	movs	r0, #1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   1ccf6:	f88d 3020 	strb.w	r3, [sp, #32]
			bps = buf;
   1ccfa:	af08      	add	r7, sp, #32
			bpe = buf + 1;
   1ccfc:	f10d 0a21 	add.w	sl, sp, #33	; 0x21
   1cd00:	e7c6      	b.n	1cc90 <z_cbvprintf_impl+0x57c>
			if (conv->flag_plus) {
   1cd02:	0719      	lsls	r1, r3, #28
			} else if (conv->flag_space) {
   1cd04:	bf5a      	itte	pl
   1cd06:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
   1cd0a:	015e      	lslpl	r6, r3, #5
				sign = '+';
   1cd0c:	262b      	movmi	r6, #43	; 0x2b
			sint = value->sint;
   1cd0e:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
			if (sint < 0) {
   1cd12:	2b00      	cmp	r3, #0
   1cd14:	f6bf af63 	bge.w	1cbde <z_cbvprintf_impl+0x4ca>
				value->uint = (uint_value_type)-sint;
   1cd18:	4252      	negs	r2, r2
   1cd1a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
   1cd1e:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
   1cd20:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   1cd24:	e75b      	b.n	1cbde <z_cbvprintf_impl+0x4ca>
		switch (conv->specifier) {
   1cd26:	2600      	movs	r6, #0
   1cd28:	e759      	b.n	1cbde <z_cbvprintf_impl+0x4ca>
		char sign = 0;
   1cd2a:	2600      	movs	r6, #0
				conv->flag_zero = false;
   1cd2c:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				size_t len = bpe - bps;
   1cd30:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cd34:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
   1cd36:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
   1cd3a:	459a      	cmp	sl, r3
				conv->flag_zero = false;
   1cd3c:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				if (len < (size_t)precision) {
   1cd40:	f67f af5b 	bls.w	1cbfa <z_cbvprintf_impl+0x4e6>
					conv->pad0_value = precision - (int)len;
   1cd44:	ebaa 0303 	sub.w	r3, sl, r3
   1cd48:	9311      	str	r3, [sp, #68]	; 0x44
   1cd4a:	e756      	b.n	1cbfa <z_cbvprintf_impl+0x4e6>
			if (value->ptr != NULL) {
   1cd4c:	980e      	ldr	r0, [sp, #56]	; 0x38
   1cd4e:	b390      	cbz	r0, 1cdb6 <z_cbvprintf_impl+0x6a2>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   1cd50:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cd54:	9300      	str	r3, [sp, #0]
   1cd56:	2100      	movs	r1, #0
   1cd58:	ab08      	add	r3, sp, #32
   1cd5a:	aa10      	add	r2, sp, #64	; 0x40
   1cd5c:	f007 fe9c 	bl	24a98 <encode_uint>
				conv->altform_0c = true;
   1cd60:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
   1cd64:	f1ba 0f00 	cmp.w	sl, #0
				conv->altform_0c = true;
   1cd68:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   1cd6c:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
   1cd70:	f043 0310 	orr.w	r3, r3, #16
				bps = encode_uint((uintptr_t)value->ptr, conv,
   1cd74:	4607      	mov	r7, r0
				conv->altform_0c = true;
   1cd76:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
   1cd7a:	dad6      	bge.n	1cd2a <z_cbvprintf_impl+0x616>
		if (bps == NULL) {
   1cd7c:	2800      	cmp	r0, #0
   1cd7e:	f43f aedc 	beq.w	1cb3a <z_cbvprintf_impl+0x426>
		char sign = 0;
   1cd82:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
   1cd84:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cd88:	1a18      	subs	r0, r3, r0
		if (sign != 0) {
   1cd8a:	469a      	mov	sl, r3
   1cd8c:	e780      	b.n	1cc90 <z_cbvprintf_impl+0x57c>
				store_count(conv, value->ptr, count);
   1cd8e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	switch ((enum length_mod_enum)conv->length_mod) {
   1cd90:	2907      	cmp	r1, #7
   1cd92:	f63f aed2 	bhi.w	1cb3a <z_cbvprintf_impl+0x426>
   1cd96:	e8df f001 	tbb	[pc, r1]
   1cd9a:	040c      	.short	0x040c
   1cd9c:	08080c06 	.word	0x08080c06
   1cda0:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
   1cda2:	701d      	strb	r5, [r3, #0]
		if (bps == NULL) {
   1cda4:	e6c9      	b.n	1cb3a <z_cbvprintf_impl+0x426>
		*(short *)dp = (short)count;
   1cda6:	801d      	strh	r5, [r3, #0]
		if (bps == NULL) {
   1cda8:	e6c7      	b.n	1cb3a <z_cbvprintf_impl+0x426>
		*(intmax_t *)dp = (intmax_t)count;
   1cdaa:	17ea      	asrs	r2, r5, #31
   1cdac:	e9c3 5200 	strd	r5, r2, [r3]
		if (bps == NULL) {
   1cdb0:	e6c3      	b.n	1cb3a <z_cbvprintf_impl+0x426>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   1cdb2:	601d      	str	r5, [r3, #0]
		if (bps == NULL) {
   1cdb4:	e6c1      	b.n	1cb3a <z_cbvprintf_impl+0x426>
   1cdb6:	4f2f      	ldr	r7, [pc, #188]	; (1ce74 <z_cbvprintf_impl+0x760>)
		char sign = 0;
   1cdb8:	4606      	mov	r6, r0
			bpe = bps + 5;
   1cdba:	f107 0a05 	add.w	sl, r7, #5
		size_t nj_len = (bpe - bps);
   1cdbe:	2005      	movs	r0, #5
   1cdc0:	e766      	b.n	1cc90 <z_cbvprintf_impl+0x57c>
		} else if (conv->altform_0) {
   1cdc2:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
   1cdc4:	bf48      	it	mi
   1cdc6:	3001      	addmi	r0, #1
   1cdc8:	e76a      	b.n	1cca0 <z_cbvprintf_impl+0x58c>
					OUTC(pad);
   1cdca:	4610      	mov	r0, r2
   1cdcc:	9307      	str	r3, [sp, #28]
   1cdce:	9206      	str	r2, [sp, #24]
   1cdd0:	4659      	mov	r1, fp
   1cdd2:	47c8      	blx	r9
   1cdd4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   1cdd8:	2800      	cmp	r0, #0
   1cdda:	da04      	bge.n	1cde6 <z_cbvprintf_impl+0x6d2>
#undef OUTS
#undef OUTC
}
   1cddc:	b015      	add	sp, #84	; 0x54
   1cdde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
   1cde2:	2220      	movs	r2, #32
					pad = '0';
   1cde4:	4643      	mov	r3, r8
				while (width-- > 0) {
   1cde6:	4619      	mov	r1, r3
   1cde8:	2900      	cmp	r1, #0
   1cdea:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
   1cdee:	dcec      	bgt.n	1cdca <z_cbvprintf_impl+0x6b6>
   1cdf0:	4445      	add	r5, r8
   1cdf2:	4698      	mov	r8, r3
   1cdf4:	1a6d      	subs	r5, r5, r1
		if (sign != 0) {
   1cdf6:	b12e      	cbz	r6, 1ce04 <z_cbvprintf_impl+0x6f0>
			OUTC(sign);
   1cdf8:	4659      	mov	r1, fp
   1cdfa:	4630      	mov	r0, r6
   1cdfc:	47c8      	blx	r9
   1cdfe:	2800      	cmp	r0, #0
   1ce00:	dbec      	blt.n	1cddc <z_cbvprintf_impl+0x6c8>
   1ce02:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
   1ce04:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ce08:	06da      	lsls	r2, r3, #27
   1ce0a:	d401      	bmi.n	1ce10 <z_cbvprintf_impl+0x6fc>
   1ce0c:	071b      	lsls	r3, r3, #28
   1ce0e:	d505      	bpl.n	1ce1c <z_cbvprintf_impl+0x708>
				OUTC('0');
   1ce10:	4659      	mov	r1, fp
   1ce12:	2030      	movs	r0, #48	; 0x30
   1ce14:	47c8      	blx	r9
   1ce16:	2800      	cmp	r0, #0
   1ce18:	dbe0      	blt.n	1cddc <z_cbvprintf_impl+0x6c8>
   1ce1a:	3501      	adds	r5, #1
			if (conv->altform_0c) {
   1ce1c:	9b05      	ldr	r3, [sp, #20]
   1ce1e:	b133      	cbz	r3, 1ce2e <z_cbvprintf_impl+0x71a>
				OUTC(conv->specifier);
   1ce20:	4659      	mov	r1, fp
   1ce22:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
   1ce26:	47c8      	blx	r9
   1ce28:	2800      	cmp	r0, #0
   1ce2a:	dbd7      	blt.n	1cddc <z_cbvprintf_impl+0x6c8>
   1ce2c:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   1ce2e:	9e04      	ldr	r6, [sp, #16]
   1ce30:	442e      	add	r6, r5
   1ce32:	e005      	b.n	1ce40 <z_cbvprintf_impl+0x72c>
				OUTC('0');
   1ce34:	4659      	mov	r1, fp
   1ce36:	2030      	movs	r0, #48	; 0x30
   1ce38:	47c8      	blx	r9
   1ce3a:	2800      	cmp	r0, #0
   1ce3c:	dbce      	blt.n	1cddc <z_cbvprintf_impl+0x6c8>
   1ce3e:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   1ce40:	1b73      	subs	r3, r6, r5
   1ce42:	2b00      	cmp	r3, #0
   1ce44:	dcf6      	bgt.n	1ce34 <z_cbvprintf_impl+0x720>
			OUTS(bps, bpe);
   1ce46:	4653      	mov	r3, sl
   1ce48:	463a      	mov	r2, r7
   1ce4a:	4659      	mov	r1, fp
   1ce4c:	4648      	mov	r0, r9
   1ce4e:	f007 fe69 	bl	24b24 <outs>
   1ce52:	2800      	cmp	r0, #0
   1ce54:	dbc2      	blt.n	1cddc <z_cbvprintf_impl+0x6c8>
   1ce56:	4405      	add	r5, r0
		while (width > 0) {
   1ce58:	44a8      	add	r8, r5
   1ce5a:	eba8 0305 	sub.w	r3, r8, r5
   1ce5e:	2b00      	cmp	r3, #0
   1ce60:	f77f ae6b 	ble.w	1cb3a <z_cbvprintf_impl+0x426>
			OUTC(' ');
   1ce64:	4659      	mov	r1, fp
   1ce66:	2020      	movs	r0, #32
   1ce68:	47c8      	blx	r9
   1ce6a:	2800      	cmp	r0, #0
   1ce6c:	dbb6      	blt.n	1cddc <z_cbvprintf_impl+0x6c8>
   1ce6e:	3501      	adds	r5, #1
			--width;
   1ce70:	e7f3      	b.n	1ce5a <z_cbvprintf_impl+0x746>
   1ce72:	bf00      	nop
   1ce74:	000269cd 	.word	0x000269cd

0001ce78 <z_arm_on_enter_cpu_idle>:
		DIV_ROUND_UP(200 * CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
				 1000000);
	static uint32_t timestamps[5];
	static bool timestamps_filled;
	static uint8_t current;
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
   1ce78:	2305      	movs	r3, #5

	return true;
}

bool z_arm_on_enter_cpu_idle(void)
{
   1ce7a:	b570      	push	{r4, r5, r6, lr}
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
   1ce7c:	4d14      	ldr	r5, [pc, #80]	; (1ced0 <z_arm_on_enter_cpu_idle+0x58>)
   1ce7e:	4e15      	ldr	r6, [pc, #84]	; (1ced4 <z_arm_on_enter_cpu_idle+0x5c>)
   1ce80:	782c      	ldrb	r4, [r5, #0]
   1ce82:	3401      	adds	r4, #1
   1ce84:	fbb4 f3f3 	udiv	r3, r4, r3
   1ce88:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1ce8c:	1ae4      	subs	r4, r4, r3
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   1ce8e:	f008 fc85 	bl	2579c <sys_clock_cycle_get_32>
	if (timestamps_filled &&
   1ce92:	4a11      	ldr	r2, [pc, #68]	; (1ced8 <z_arm_on_enter_cpu_idle+0x60>)
   1ce94:	7813      	ldrb	r3, [r2, #0]
   1ce96:	b123      	cbz	r3, 1cea2 <z_arm_on_enter_cpu_idle+0x2a>
	    (now - timestamps[oldest]) < (window_cycles + 1)) {
   1ce98:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   1ce9c:	1ac0      	subs	r0, r0, r3
	if (timestamps_filled &&
   1ce9e:	2807      	cmp	r0, #7
   1cea0:	d913      	bls.n	1ceca <z_arm_on_enter_cpu_idle+0x52>
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1cea2:	4b0e      	ldr	r3, [pc, #56]	; (1cedc <z_arm_on_enter_cpu_idle+0x64>)
   1cea4:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
	if (nrf_power_event_check(NRF_POWER, NRF_POWER_EVENT_SLEEPENTER)) {
   1cea8:	b141      	cbz	r1, 1cebc <z_arm_on_enter_cpu_idle+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1ceaa:	2100      	movs	r1, #0
   1ceac:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   1ceb0:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
   1ceb4:	702c      	strb	r4, [r5, #0]
		if (current == 0) {
   1ceb6:	b90c      	cbnz	r4, 1cebc <z_arm_on_enter_cpu_idle+0x44>
			timestamps_filled = true;
   1ceb8:	2301      	movs	r3, #1
   1ceba:	7013      	strb	r3, [r2, #0]
	timestamps[current] = k_cycle_get_32();
   1cebc:	782c      	ldrb	r4, [r5, #0]
   1cebe:	f008 fc6d 	bl	2579c <sys_clock_cycle_get_32>
   1cec2:	f846 0024 	str.w	r0, [r6, r4, lsl #2]
	return true;
   1cec6:	2001      	movs	r0, #1
		suppress_message = true;
	}
#endif

	return ok_to_sleep;
}
   1cec8:	bd70      	pop	{r4, r5, r6, pc}
		return false;
   1ceca:	2000      	movs	r0, #0
   1cecc:	e7fc      	b.n	1cec8 <z_arm_on_enter_cpu_idle+0x50>
   1cece:	bf00      	nop
   1ced0:	2000b5fd 	.word	0x2000b5fd
   1ced4:	2000a73c 	.word	0x2000a73c
   1ced8:	2000b5fc 	.word	0x2000b5fc
   1cedc:	40005000 	.word	0x40005000

0001cee0 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   1cee0:	b148      	cbz	r0, 1cef6 <arch_busy_wait+0x16>

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
   1cee2:	4b05      	ldr	r3, [pc, #20]	; (1cef8 <arch_busy_wait+0x18>)
   1cee4:	4a05      	ldr	r2, [pc, #20]	; (1cefc <arch_busy_wait+0x1c>)
   1cee6:	681b      	ldr	r3, [r3, #0]
   1cee8:	fbb3 f3f2 	udiv	r3, r3, r2
    delay_cycles(cycles);
   1ceec:	4358      	muls	r0, r3
   1ceee:	4b04      	ldr	r3, [pc, #16]	; (1cf00 <arch_busy_wait+0x20>)
   1cef0:	f043 0301 	orr.w	r3, r3, #1
   1cef4:	4718      	bx	r3
}

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   1cef6:	4770      	bx	lr
   1cef8:	2000a204 	.word	0x2000a204
   1cefc:	000f4240 	.word	0x000f4240
   1cf00:	00026640 	.word	0x00026640

0001cf04 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   1cf04:	f008 bc87 	b.w	25816 <SystemInit>

0001cf08 <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   1cf08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1cf0c:	4605      	mov	r5, r0
	__asm__ volatile(
   1cf0e:	f04f 0320 	mov.w	r3, #32
   1cf12:	f3ef 8611 	mrs	r6, BASEPRI
   1cf16:	f383 8812 	msr	BASEPRI_MAX, r3
   1cf1a:	f3bf 8f6f 	isb	sy
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_cpus_pm_state[_current_cpu->id].state);
   1cf1e:	f04f 090c 	mov.w	r9, #12
	return list->head;
   1cf22:	4b0d      	ldr	r3, [pc, #52]	; (1cf58 <pm_state_notify+0x50>)
   1cf24:	4f0d      	ldr	r7, [pc, #52]	; (1cf5c <pm_state_notify+0x54>)
   1cf26:	681c      	ldr	r4, [r3, #0]
   1cf28:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1cf60 <pm_state_notify+0x58>
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   1cf2c:	b92c      	cbnz	r4, 1cf3a <pm_state_notify+0x32>
	__asm__ volatile(
   1cf2e:	f386 8811 	msr	BASEPRI, r6
   1cf32:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   1cf36:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			callback = notifier->state_exit;
   1cf3a:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
			callback = notifier->state_entry;
   1cf3e:	2d00      	cmp	r5, #0
   1cf40:	bf18      	it	ne
   1cf42:	4613      	movne	r3, r2
		if (callback) {
   1cf44:	b12b      	cbz	r3, 1cf52 <pm_state_notify+0x4a>
			callback(z_cpus_pm_state[_current_cpu->id].state);
   1cf46:	f898 2010 	ldrb.w	r2, [r8, #16]
   1cf4a:	fb09 f202 	mul.w	r2, r9, r2
   1cf4e:	5cb8      	ldrb	r0, [r7, r2]
   1cf50:	4798      	blx	r3
	return node->next;
   1cf52:	6824      	ldr	r4, [r4, #0]
   1cf54:	e7ea      	b.n	1cf2c <pm_state_notify+0x24>
   1cf56:	bf00      	nop
   1cf58:	2000a768 	.word	0x2000a768
   1cf5c:	2000a75c 	.word	0x2000a75c
   1cf60:	2000b5c0 	.word	0x2000b5c0

0001cf64 <pm_system_resume>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   1cf64:	2201      	movs	r2, #1

void pm_system_resume(void)
{
   1cf66:	b570      	push	{r4, r5, r6, lr}
	uint8_t id = CURRENT_CPU;
   1cf68:	4b16      	ldr	r3, [pc, #88]	; (1cfc4 <pm_system_resume+0x60>)
   1cf6a:	7c1c      	ldrb	r4, [r3, #16]
   1cf6c:	f004 031f 	and.w	r3, r4, #31
   1cf70:	409a      	lsls	r2, r3
	atomic_val_t old;

	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1cf72:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1cf74:	4b14      	ldr	r3, [pc, #80]	; (1cfc8 <pm_system_resume+0x64>)
   1cf76:	0961      	lsrs	r1, r4, #5
   1cf78:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1cf7c:	e8d3 1fef 	ldaex	r1, [r3]
   1cf80:	ea01 0500 	and.w	r5, r1, r0
   1cf84:	e8c3 5fe6 	stlex	r6, r5, [r3]
   1cf88:	2e00      	cmp	r6, #0
   1cf8a:	d1f7      	bne.n	1cf7c <pm_system_resume+0x18>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   1cf8c:	420a      	tst	r2, r1
   1cf8e:	d013      	beq.n	1cfb8 <pm_system_resume+0x54>
	if (pm_state_exit_post_ops != NULL) {
   1cf90:	4b0e      	ldr	r3, [pc, #56]	; (1cfcc <pm_system_resume+0x68>)
   1cf92:	4d0f      	ldr	r5, [pc, #60]	; (1cfd0 <pm_system_resume+0x6c>)
   1cf94:	b18b      	cbz	r3, 1cfba <pm_system_resume+0x56>
		pm_state_exit_post_ops(info->state, info->substate_id);
   1cf96:	230c      	movs	r3, #12
   1cf98:	4363      	muls	r3, r4
   1cf9a:	18ea      	adds	r2, r5, r3
   1cf9c:	7851      	ldrb	r1, [r2, #1]
   1cf9e:	5ce8      	ldrb	r0, [r5, r3]
   1cfa0:	f007 feb1 	bl	24d06 <pm_state_exit_post_ops>
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
		pm_state_notify(false);
   1cfa4:	2000      	movs	r0, #0
   1cfa6:	f7ff ffaf 	bl	1cf08 <pm_state_notify>
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   1cfaa:	230c      	movs	r3, #12
   1cfac:	435c      	muls	r4, r3
   1cfae:	2300      	movs	r3, #0
   1cfb0:	192a      	adds	r2, r5, r4
   1cfb2:	512b      	str	r3, [r5, r4]
   1cfb4:	e9c2 3301 	strd	r3, r3, [r2, #4]
			0, 0};
	}
}
   1cfb8:	bd70      	pop	{r4, r5, r6, pc}
   1cfba:	f383 8811 	msr	BASEPRI, r3
   1cfbe:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   1cfc2:	e7ef      	b.n	1cfa4 <pm_system_resume+0x40>
   1cfc4:	2000b5c0 	.word	0x2000b5c0
   1cfc8:	2000a770 	.word	0x2000a770
   1cfcc:	00024d07 	.word	0x00024d07
   1cfd0:	2000a75c 	.word	0x2000a75c

0001cfd4 <pm_system_suspend>:

	return true;
}

bool pm_system_suspend(int32_t ticks)
{
   1cfd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t id = CURRENT_CPU;
   1cfd8:	4b32      	ldr	r3, [pc, #200]	; (1d0a4 <pm_system_suspend+0xd0>)
{
   1cfda:	4607      	mov	r7, r0
	uint8_t id = CURRENT_CPU;
   1cfdc:	7c1d      	ldrb	r5, [r3, #16]
	__asm__ volatile(
   1cfde:	f04f 0320 	mov.w	r3, #32
   1cfe2:	f3ef 8811 	mrs	r8, BASEPRI
   1cfe6:	f383 8812 	msr	BASEPRI_MAX, r3
   1cfea:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key;

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	key = k_spin_lock(&pm_forced_state_lock);
	if (z_cpus_pm_forced_state[id].state != PM_STATE_ACTIVE) {
   1cfee:	240c      	movs	r4, #12
   1cff0:	436c      	muls	r4, r5
   1cff2:	4b2d      	ldr	r3, [pc, #180]	; (1d0a8 <pm_system_suspend+0xd4>)
   1cff4:	4e2d      	ldr	r6, [pc, #180]	; (1d0ac <pm_system_suspend+0xd8>)
   1cff6:	5d19      	ldrb	r1, [r3, r4]
   1cff8:	191a      	adds	r2, r3, r4
   1cffa:	2900      	cmp	r1, #0
   1cffc:	d047      	beq.n	1d08e <pm_system_suspend+0xba>
		z_cpus_pm_state[id] = z_cpus_pm_forced_state[id];
   1cffe:	ca07      	ldmia	r2, {r0, r1, r2}
   1d000:	eb06 0c04 	add.w	ip, r6, r4
   1d004:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		z_cpus_pm_forced_state[id].state = PM_STATE_ACTIVE;
   1d008:	2200      	movs	r2, #0
   1d00a:	551a      	strb	r2, [r3, r4]
	__asm__ volatile(
   1d00c:	f388 8811 	msr	BASEPRI, r8
   1d010:	f3bf 8f6f 	isb	sy
			z_cpus_pm_state[id] = *info;
		}
	}
	k_spin_unlock(&pm_forced_state_lock, key);

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
   1d014:	230c      	movs	r3, #12
   1d016:	436b      	muls	r3, r5
   1d018:	5cf0      	ldrb	r0, [r6, r3]
   1d01a:	18f2      	adds	r2, r6, r3
   1d01c:	b3a8      	cbz	r0, 1d08a <pm_system_suspend+0xb6>
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);
		return false;
	}

	if (ticks != K_TICKS_FOREVER) {
   1d01e:	1c7b      	adds	r3, r7, #1
   1d020:	d010      	beq.n	1d044 <pm_system_suspend+0x70>
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
   1d022:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   1d026:	2100      	movs	r1, #0
   1d028:	f8d2 c008 	ldr.w	ip, [r2, #8]
   1d02c:	4c20      	ldr	r4, [pc, #128]	; (1d0b0 <pm_system_suspend+0xdc>)
   1d02e:	2300      	movs	r3, #0
   1d030:	fbec 4100 	umlal	r4, r1, ip, r0
   1d034:	4a1f      	ldr	r2, [pc, #124]	; (1d0b4 <pm_system_suspend+0xe0>)
   1d036:	4620      	mov	r0, r4
   1d038:	f7ff f88c 	bl	1c154 <__aeabi_uldivmod>
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		sys_clock_set_timeout(ticks -
   1d03c:	2101      	movs	r1, #1
   1d03e:	1a38      	subs	r0, r7, r0
   1d040:	f003 fc24 	bl	2088c <sys_clock_set_timeout>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   1d044:	f006 fe42 	bl	23ccc <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   1d048:	2001      	movs	r0, #1
   1d04a:	f7ff ff5d 	bl	1cf08 <pm_state_notify>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1d04e:	4b1a      	ldr	r3, [pc, #104]	; (1d0b8 <pm_system_suspend+0xe4>)
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   1d050:	096a      	lsrs	r2, r5, #5
   1d052:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	atomic_val_t mask = ATOMIC_MASK(bit);
   1d056:	2201      	movs	r2, #1
   1d058:	f005 011f 	and.w	r1, r5, #31
   1d05c:	408a      	lsls	r2, r1
   1d05e:	e8d3 0fef 	ldaex	r0, [r3]
   1d062:	4310      	orrs	r0, r2
   1d064:	e8c3 0fe1 	stlex	r1, r0, [r3]
   1d068:	2900      	cmp	r1, #0
   1d06a:	d1f8      	bne.n	1d05e <pm_system_suspend+0x8a>
	if (pm_state_set != NULL) {
   1d06c:	4b13      	ldr	r3, [pc, #76]	; (1d0bc <pm_system_suspend+0xe8>)
   1d06e:	b13b      	cbz	r3, 1d080 <pm_system_suspend+0xac>
		pm_state_set(info->state, info->substate_id);
   1d070:	230c      	movs	r3, #12
   1d072:	fb03 f005 	mul.w	r0, r3, r5
   1d076:	1833      	adds	r3, r6, r0
   1d078:	7859      	ldrb	r1, [r3, #1]
   1d07a:	5c30      	ldrb	r0, [r6, r0]
   1d07c:	f007 fe37 	bl	24cee <pm_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_cpus_pm_state[id].state);
	pm_system_resume();
   1d080:	f7ff ff70 	bl	1cf64 <pm_system_resume>
	k_sched_unlock();
   1d084:	f006 fe36 	bl	23cf4 <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);

	return true;
   1d088:	2001      	movs	r0, #1
}
   1d08a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		info = pm_policy_next_state(id, ticks);
   1d08e:	4601      	mov	r1, r0
   1d090:	4628      	mov	r0, r5
   1d092:	f000 f815 	bl	1d0c0 <pm_policy_next_state>
		if (info != NULL) {
   1d096:	2800      	cmp	r0, #0
   1d098:	d0b8      	beq.n	1d00c <pm_system_suspend+0x38>
			z_cpus_pm_state[id] = *info;
   1d09a:	c807      	ldmia	r0, {r0, r1, r2}
   1d09c:	4434      	add	r4, r6
   1d09e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
   1d0a2:	e7b3      	b.n	1d00c <pm_system_suspend+0x38>
   1d0a4:	2000b5c0 	.word	0x2000b5c0
   1d0a8:	2000a750 	.word	0x2000a750
   1d0ac:	2000a75c 	.word	0x2000a75c
   1d0b0:	000f423f 	.word	0x000f423f
   1d0b4:	000f4240 	.word	0x000f4240
   1d0b8:	2000a770 	.word	0x2000a770
   1d0bc:	00024cef 	.word	0x00024cef

0001d0c0 <pm_policy_next_state>:
	}
}

#ifdef CONFIG_PM_POLICY_DEFAULT
const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
   1d0c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d0c4:	b085      	sub	sp, #20
   1d0c6:	460e      	mov	r6, r1
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
   1d0c8:	a903      	add	r1, sp, #12
   1d0ca:	f000 f843 	bl	1d154 <pm_state_cpu_get_all>
   1d0ce:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   1d0d2:	4604      	mov	r4, r0
   1d0d4:	f04f 0b00 	mov.w	fp, #0

		min_residency = k_us_to_ticks_ceil32(state->min_residency_us);
		exit_latency = k_us_to_ticks_ceil32(state->exit_latency_us);

		/* skip state if it brings too much latency */
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   1d0d8:	4b1b      	ldr	r3, [pc, #108]	; (1d148 <pm_policy_next_state+0x88>)
   1d0da:	9d03      	ldr	r5, [sp, #12]
   1d0dc:	f8d3 a000 	ldr.w	sl, [r3]
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   1d0e0:	1e43      	subs	r3, r0, #1
   1d0e2:	b21b      	sxth	r3, r3
   1d0e4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1d0e8:	f8df 8060 	ldr.w	r8, [pc, #96]	; 1d14c <pm_policy_next_state+0x8c>
   1d0ec:	eb05 0583 	add.w	r5, r5, r3, lsl #2
   1d0f0:	b924      	cbnz	r4, 1d0fc <pm_policy_next_state+0x3c>
		    (ticks >= (min_residency + exit_latency))) {
			return state;
		}
	}

	return NULL;
   1d0f2:	46a1      	mov	r9, r4
}
   1d0f4:	4648      	mov	r0, r9
   1d0f6:	b005      	add	sp, #20
   1d0f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d0fc:	46c4      	mov	ip, r8
   1d0fe:	4659      	mov	r1, fp
   1d100:	6868      	ldr	r0, [r5, #4]
   1d102:	2300      	movs	r3, #0
   1d104:	fbe0 c107 	umlal	ip, r1, r0, r7
   1d108:	4a11      	ldr	r2, [pc, #68]	; (1d150 <pm_policy_next_state+0x90>)
   1d10a:	4660      	mov	r0, ip
   1d10c:	f7ff f822 	bl	1c154 <__aeabi_uldivmod>
   1d110:	46c4      	mov	ip, r8
   1d112:	4659      	mov	r1, fp
   1d114:	9001      	str	r0, [sp, #4]
   1d116:	68a8      	ldr	r0, [r5, #8]
   1d118:	2300      	movs	r3, #0
   1d11a:	fbe0 c107 	umlal	ip, r1, r0, r7
   1d11e:	4a0c      	ldr	r2, [pc, #48]	; (1d150 <pm_policy_next_state+0x90>)
   1d120:	4660      	mov	r0, ip
   1d122:	f7ff f817 	bl	1c154 <__aeabi_uldivmod>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   1d126:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
		const struct pm_state_info *state = &cpu_states[i];
   1d12a:	46a9      	mov	r9, r5
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   1d12c:	d001      	beq.n	1d132 <pm_policy_next_state+0x72>
   1d12e:	4582      	cmp	sl, r0
   1d130:	d905      	bls.n	1d13e <pm_policy_next_state+0x7e>
		if ((ticks == K_TICKS_FOREVER) ||
   1d132:	1c73      	adds	r3, r6, #1
   1d134:	d0de      	beq.n	1d0f4 <pm_policy_next_state+0x34>
		    (ticks >= (min_residency + exit_latency))) {
   1d136:	9b01      	ldr	r3, [sp, #4]
   1d138:	4418      	add	r0, r3
		if ((ticks == K_TICKS_FOREVER) ||
   1d13a:	42b0      	cmp	r0, r6
   1d13c:	d9da      	bls.n	1d0f4 <pm_policy_next_state+0x34>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   1d13e:	3c01      	subs	r4, #1
   1d140:	b2a4      	uxth	r4, r4
   1d142:	3d0c      	subs	r5, #12
   1d144:	e7d4      	b.n	1d0f0 <pm_policy_next_state+0x30>
   1d146:	bf00      	nop
   1d148:	2000a0b4 	.word	0x2000a0b4
   1d14c:	000f423f 	.word	0x000f423f
   1d150:	000f4240 	.word	0x000f4240

0001d154 <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD_SEP(DT_PATH(cpus), DT_NUM_CPU_POWER_STATES, (,))
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
   1d154:	b908      	cbnz	r0, 1d15a <pm_state_cpu_get_all+0x6>
		return 0;
	}

	*states = cpus_states[cpu];
   1d156:	4b02      	ldr	r3, [pc, #8]	; (1d160 <pm_state_cpu_get_all+0xc>)
   1d158:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
   1d15a:	2000      	movs	r0, #0
   1d15c:	4770      	bx	lr
   1d15e:	bf00      	nop
   1d160:	00026658 	.word	0x00026658

0001d164 <class_handler>:
 * usb_enable() is no longer needed.
 */

static int class_handler(struct usb_setup_packet *pSetup,
			 int32_t *len, uint8_t **data)
{
   1d164:	b4f0      	push	{r4, r5, r6, r7}
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d166:	4b0c      	ldr	r3, [pc, #48]	; (1d198 <class_handler+0x34>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d168:	4e0c      	ldr	r6, [pc, #48]	; (1d19c <class_handler+0x38>)
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d16a:	6a5f      	ldr	r7, [r3, #36]	; 0x24
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d16c:	4b0c      	ldr	r3, [pc, #48]	; (1d1a0 <class_handler+0x3c>)
   1d16e:	42b3      	cmp	r3, r6
   1d170:	d303      	bcc.n	1d17a <class_handler+0x16>
			return iface->class_handler(pSetup, len, data);
		}
	}

	return -ENOTSUP;
}
   1d172:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1d176:	bcf0      	pop	{r4, r5, r6, r7}
   1d178:	4770      	bx	lr
		if_descr = cfg_data->interface_descriptor;
   1d17a:	685d      	ldr	r5, [r3, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d17c:	42bd      	cmp	r5, r7
   1d17e:	d309      	bcc.n	1d194 <class_handler+0x30>
		if (iface->class_handler &&
   1d180:	691c      	ldr	r4, [r3, #16]
   1d182:	b13c      	cbz	r4, 1d194 <class_handler+0x30>
		    if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
   1d184:	f895 c002 	ldrb.w	ip, [r5, #2]
   1d188:	7905      	ldrb	r5, [r0, #4]
		if (iface->class_handler &&
   1d18a:	45ac      	cmp	ip, r5
   1d18c:	d102      	bne.n	1d194 <class_handler+0x30>
			return iface->class_handler(pSetup, len, data);
   1d18e:	4623      	mov	r3, r4
}
   1d190:	bcf0      	pop	{r4, r5, r6, r7}
			return iface->class_handler(pSetup, len, data);
   1d192:	4718      	bx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d194:	3324      	adds	r3, #36	; 0x24
   1d196:	e7ea      	b.n	1d16e <class_handler+0xa>
   1d198:	2000a774 	.word	0x2000a774
   1d19c:	2000a410 	.word	0x2000a410
   1d1a0:	2000a3ec 	.word	0x2000a3ec

0001d1a4 <custom_handler>:

static int custom_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
   1d1a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d1a8:	4605      	mov	r5, r0
   1d1aa:	460e      	mov	r6, r1
   1d1ac:	4617      	mov	r7, r2
	struct usb_interface_cfg_data *iface;

	LOG_DBG("bRequest 0x%02x, wIndex 0x%04x",
		pSetup->bRequest, pSetup->wIndex);

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d1ae:	4c12      	ldr	r4, [pc, #72]	; (1d1f8 <custom_handler+0x54>)
   1d1b0:	f8df 8048 	ldr.w	r8, [pc, #72]	; 1d1fc <custom_handler+0x58>
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d1b4:	f8df 9048 	ldr.w	r9, [pc, #72]	; 1d200 <custom_handler+0x5c>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d1b8:	4544      	cmp	r4, r8
   1d1ba:	d303      	bcc.n	1d1c4 <custom_handler+0x20>
			}
		}
	}

	return -ENOTSUP;
}
   1d1bc:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1d1c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if_descr = cfg_data->interface_descriptor;
   1d1c4:	6862      	ldr	r2, [r4, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d1c6:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
   1d1ca:	429a      	cmp	r2, r3
   1d1cc:	d312      	bcc.n	1d1f4 <custom_handler+0x50>
		if (iface->custom_handler == NULL) {
   1d1ce:	69a3      	ldr	r3, [r4, #24]
   1d1d0:	b183      	cbz	r3, 1d1f4 <custom_handler+0x50>
		if (if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
   1d1d2:	7890      	ldrb	r0, [r2, #2]
   1d1d4:	7929      	ldrb	r1, [r5, #4]
   1d1d6:	4288      	cmp	r0, r1
   1d1d8:	d105      	bne.n	1d1e6 <custom_handler+0x42>
			return iface->custom_handler(pSetup, len, data);
   1d1da:	463a      	mov	r2, r7
   1d1dc:	4631      	mov	r1, r6
   1d1de:	4628      	mov	r0, r5
}
   1d1e0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return iface->custom_handler(pSetup, len, data);
   1d1e4:	4718      	bx	r3
			if (if_descr->bInterfaceClass == USB_BCC_AUDIO) {
   1d1e6:	7952      	ldrb	r2, [r2, #5]
   1d1e8:	2a01      	cmp	r2, #1
   1d1ea:	d103      	bne.n	1d1f4 <custom_handler+0x50>
				(void)iface->custom_handler(pSetup, len, data);
   1d1ec:	463a      	mov	r2, r7
   1d1ee:	4631      	mov	r1, r6
   1d1f0:	4628      	mov	r0, r5
   1d1f2:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d1f4:	3424      	adds	r4, #36	; 0x24
   1d1f6:	e7df      	b.n	1d1b8 <custom_handler+0x14>
   1d1f8:	2000a3ec 	.word	0x2000a3ec
   1d1fc:	2000a410 	.word	0x2000a410
   1d200:	2000a774 	.word	0x2000a774

0001d204 <vendor_handler>:

static int vendor_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
   1d204:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d208:	4605      	mov	r5, r0
   1d20a:	460e      	mov	r6, r1
   1d20c:	4617      	mov	r7, r2
		if (!usb_handle_os_desc_feature(pSetup, len, data)) {
			return 0;
		}
	}

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d20e:	4c0a      	ldr	r4, [pc, #40]	; (1d238 <vendor_handler+0x34>)
   1d210:	f8df 8028 	ldr.w	r8, [pc, #40]	; 1d23c <vendor_handler+0x38>
   1d214:	4544      	cmp	r4, r8
   1d216:	d302      	bcc.n	1d21e <vendor_handler+0x1a>
				return 0;
			}
		}
	}

	return -ENOTSUP;
   1d218:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1d21c:	e009      	b.n	1d232 <vendor_handler+0x2e>
		if (iface->vendor_handler) {
   1d21e:	6963      	ldr	r3, [r4, #20]
   1d220:	b90b      	cbnz	r3, 1d226 <vendor_handler+0x22>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d222:	3424      	adds	r4, #36	; 0x24
   1d224:	e7f6      	b.n	1d214 <vendor_handler+0x10>
			if (!iface->vendor_handler(pSetup, len, data)) {
   1d226:	463a      	mov	r2, r7
   1d228:	4631      	mov	r1, r6
   1d22a:	4628      	mov	r0, r5
   1d22c:	4798      	blx	r3
   1d22e:	2800      	cmp	r0, #0
   1d230:	d1f7      	bne.n	1d222 <vendor_handler+0x1e>
}
   1d232:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1d236:	bf00      	nop
   1d238:	2000a3ec 	.word	0x2000a3ec
   1d23c:	2000a410 	.word	0x2000a410

0001d240 <disable_endpoint>:
{
   1d240:	b510      	push	{r4, lr}
   1d242:	4604      	mov	r4, r0
	ret = usb_dc_ep_disable(ep_addr);
   1d244:	f007 ff16 	bl	25074 <usb_dc_ep_disable>
	if (ret == -EALREADY) {
   1d248:	f110 0f78 	cmn.w	r0, #120	; 0x78
   1d24c:	d000      	beq.n	1d250 <disable_endpoint+0x10>
	} else if (ret) {
   1d24e:	b950      	cbnz	r0, 1d266 <disable_endpoint+0x26>
	ep_bm = get_ep_bm_from_addr(ep_addr);
   1d250:	4620      	mov	r0, r4
   1d252:	f007 fd7f 	bl	24d54 <get_ep_bm_from_addr>
	usb_dev.ep_bm &= ~ep_bm;
   1d256:	4a04      	ldr	r2, [pc, #16]	; (1d268 <disable_endpoint+0x28>)
   1d258:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
   1d25c:	ea23 0300 	bic.w	r3, r3, r0
	return 0;
   1d260:	2000      	movs	r0, #0
	usb_dev.ep_bm &= ~ep_bm;
   1d262:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
}
   1d266:	bd10      	pop	{r4, pc}
   1d268:	2000a774 	.word	0x2000a774

0001d26c <usb_reset_alt_setting>:
	memset(usb_dev.alt_setting, 0, ARRAY_SIZE(usb_dev.alt_setting));
   1d26c:	2208      	movs	r2, #8
   1d26e:	2100      	movs	r1, #0
   1d270:	4801      	ldr	r0, [pc, #4]	; (1d278 <usb_reset_alt_setting+0xc>)
   1d272:	f007 bec1 	b.w	24ff8 <memset>
   1d276:	bf00      	nop
   1d278:	2000a82f 	.word	0x2000a82f

0001d27c <is_ep_valid.part.0>:
static bool is_ep_valid(uint8_t ep)
   1d27c:	b570      	push	{r4, r5, r6, lr}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d27e:	4b0b      	ldr	r3, [pc, #44]	; (1d2ac <is_ep_valid.part.0+0x30>)
   1d280:	4c0b      	ldr	r4, [pc, #44]	; (1d2b0 <is_ep_valid.part.0+0x34>)
   1d282:	42a3      	cmp	r3, r4
   1d284:	d301      	bcc.n	1d28a <is_ep_valid.part.0+0xe>
	return false;
   1d286:	2000      	movs	r0, #0
}
   1d288:	bd70      	pop	{r4, r5, r6, pc}
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d28a:	2200      	movs	r2, #0
		ep_data = cfg_data->endpoint;
   1d28c:	6a19      	ldr	r1, [r3, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d28e:	7f1e      	ldrb	r6, [r3, #28]
			if (ep_data[n].ep_addr == ep) {
   1d290:	3904      	subs	r1, #4
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d292:	b2d5      	uxtb	r5, r2
   1d294:	42ae      	cmp	r6, r5
   1d296:	d801      	bhi.n	1d29c <is_ep_valid.part.0+0x20>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d298:	3324      	adds	r3, #36	; 0x24
   1d29a:	e7f2      	b.n	1d282 <is_ep_valid.part.0+0x6>
			if (ep_data[n].ep_addr == ep) {
   1d29c:	3201      	adds	r2, #1
   1d29e:	f811 5032 	ldrb.w	r5, [r1, r2, lsl #3]
   1d2a2:	4285      	cmp	r5, r0
   1d2a4:	d1f5      	bne.n	1d292 <is_ep_valid.part.0+0x16>
		return true;
   1d2a6:	2001      	movs	r0, #1
   1d2a8:	e7ee      	b.n	1d288 <is_ep_valid.part.0+0xc>
   1d2aa:	bf00      	nop
   1d2ac:	2000a3ec 	.word	0x2000a3ec
   1d2b0:	2000a410 	.word	0x2000a410

0001d2b4 <usb_handle_request.constprop.0>:
static bool usb_handle_request(struct usb_setup_packet *setup,
   1d2b4:	b508      	push	{r3, lr}
	handler = usb_dev.req_handlers[type];
   1d2b6:	4809      	ldr	r0, [pc, #36]	; (1d2dc <usb_handle_request.constprop.0+0x28>)
	uint32_t type = setup->RequestType.type;
   1d2b8:	7803      	ldrb	r3, [r0, #0]
   1d2ba:	f3c3 1341 	ubfx	r3, r3, #5, #2
	handler = usb_dev.req_handlers[type];
   1d2be:	330a      	adds	r3, #10
   1d2c0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	if (handler == NULL) {
   1d2c4:	b13b      	cbz	r3, 1d2d6 <usb_handle_request.constprop.0+0x22>
	if ((*handler)(setup, len, data) < 0) {
   1d2c6:	f100 0208 	add.w	r2, r0, #8
   1d2ca:	f100 0110 	add.w	r1, r0, #16
   1d2ce:	4798      	blx	r3
   1d2d0:	43c0      	mvns	r0, r0
   1d2d2:	0fc0      	lsrs	r0, r0, #31
}
   1d2d4:	bd08      	pop	{r3, pc}
		return false;
   1d2d6:	4618      	mov	r0, r3
   1d2d8:	e7fc      	b.n	1d2d4 <usb_handle_request.constprop.0+0x20>
   1d2da:	bf00      	nop
   1d2dc:	2000a774 	.word	0x2000a774

0001d2e0 <forward_status_cb>:
	if (status == USB_DC_DISCONNECTED) {
   1d2e0:	2804      	cmp	r0, #4
{
   1d2e2:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d2e6:	4604      	mov	r4, r0
   1d2e8:	460f      	mov	r7, r1
   1d2ea:	f8df 9094 	ldr.w	r9, [pc, #148]	; 1d380 <forward_status_cb+0xa0>
	if (status == USB_DC_DISCONNECTED) {
   1d2ee:	d016      	beq.n	1d31e <forward_status_cb+0x3e>
	if (status == USB_DC_DISCONNECTED || status == USB_DC_RESET) {
   1d2f0:	2801      	cmp	r0, #1
   1d2f2:	d12d      	bne.n	1d350 <forward_status_cb+0x70>
		if (usb_dev.configured) {
   1d2f4:	f8df 808c 	ldr.w	r8, [pc, #140]	; 1d384 <forward_status_cb+0xa4>
   1d2f8:	f898 30b9 	ldrb.w	r3, [r8, #185]	; 0xb9
   1d2fc:	b343      	cbz	r3, 1d350 <forward_status_cb+0x70>
			usb_cancel_transfers();
   1d2fe:	f000 fdb9 	bl	1de74 <usb_cancel_transfers>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d302:	4d21      	ldr	r5, [pc, #132]	; (1d388 <forward_status_cb+0xa8>)
   1d304:	454d      	cmp	r5, r9
   1d306:	d220      	bcs.n	1d34a <forward_status_cb+0x6a>
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d308:	f04f 0a00 	mov.w	sl, #0
		ep_data = cfg_data->endpoint;
   1d30c:	f8d5 b020 	ldr.w	fp, [r5, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d310:	7f2b      	ldrb	r3, [r5, #28]
   1d312:	fa5f f68a 	uxtb.w	r6, sl
   1d316:	42b3      	cmp	r3, r6
   1d318:	d804      	bhi.n	1d324 <forward_status_cb+0x44>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d31a:	3524      	adds	r5, #36	; 0x24
   1d31c:	e7f2      	b.n	1d304 <forward_status_cb+0x24>
		usb_reset_alt_setting();
   1d31e:	f7ff ffa5 	bl	1d26c <usb_reset_alt_setting>
	if (status == USB_DC_DISCONNECTED || status == USB_DC_RESET) {
   1d322:	e7e7      	b.n	1d2f4 <forward_status_cb+0x14>
			ret = endpoint_callback(&ep_data[n]);
   1d324:	eb0b 06c6 	add.w	r6, fp, r6, lsl #3
	ret = usb_dc_ep_disable(ep_data->ep_addr);
   1d328:	7930      	ldrb	r0, [r6, #4]
   1d32a:	f007 fea3 	bl	25074 <usb_dc_ep_disable>
   1d32e:	4602      	mov	r2, r0
	ep_bm = get_ep_bm_from_addr(ep_data->ep_addr);
   1d330:	7930      	ldrb	r0, [r6, #4]
   1d332:	f007 fd0f 	bl	24d54 <get_ep_bm_from_addr>
	usb_dev.ep_bm &= ~ep_bm;
   1d336:	f8d8 30c4 	ldr.w	r3, [r8, #196]	; 0xc4
			if (ret < 0) {
   1d33a:	2a00      	cmp	r2, #0
	usb_dev.ep_bm &= ~ep_bm;
   1d33c:	ea23 0300 	bic.w	r3, r3, r0
   1d340:	f8c8 30c4 	str.w	r3, [r8, #196]	; 0xc4
			if (ret < 0) {
   1d344:	f10a 0a01 	add.w	sl, sl, #1
   1d348:	dae2      	bge.n	1d310 <forward_status_cb+0x30>
			usb_dev.configured = false;
   1d34a:	2300      	movs	r3, #0
   1d34c:	f888 30b9 	strb.w	r3, [r8, #185]	; 0xb9
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d350:	4d0d      	ldr	r5, [pc, #52]	; (1d388 <forward_status_cb+0xa8>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d352:	454d      	cmp	r5, r9
   1d354:	d308      	bcc.n	1d368 <forward_status_cb+0x88>
	if (usb_dev.user_status_callback) {
   1d356:	4b0b      	ldr	r3, [pc, #44]	; (1d384 <forward_status_cb+0xa4>)
   1d358:	6a1b      	ldr	r3, [r3, #32]
   1d35a:	b16b      	cbz	r3, 1d378 <forward_status_cb+0x98>
		usb_dev.user_status_callback(status, param);
   1d35c:	4639      	mov	r1, r7
   1d35e:	4620      	mov	r0, r4
}
   1d360:	b001      	add	sp, #4
   1d362:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		usb_dev.user_status_callback(status, param);
   1d366:	4718      	bx	r3
		if (cfg_data->cb_usb_status) {
   1d368:	68eb      	ldr	r3, [r5, #12]
   1d36a:	b11b      	cbz	r3, 1d374 <forward_status_cb+0x94>
			cfg_data->cb_usb_status(cfg_data, status, param);
   1d36c:	463a      	mov	r2, r7
   1d36e:	4621      	mov	r1, r4
   1d370:	4628      	mov	r0, r5
   1d372:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d374:	3524      	adds	r5, #36	; 0x24
   1d376:	e7ec      	b.n	1d352 <forward_status_cb+0x72>
}
   1d378:	b001      	add	sp, #4
   1d37a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d37e:	bf00      	nop
   1d380:	2000a410 	.word	0x2000a410
   1d384:	2000a774 	.word	0x2000a774
   1d388:	2000a3ec 	.word	0x2000a3ec

0001d38c <usb_halt_endpoint_req.isra.0>:
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
   1d38c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t ep = setup->wIndex;
   1d38e:	b2c4      	uxtb	r4, r0
	if (USB_EP_GET_IDX(ep) == 0) {
   1d390:	0663      	lsls	r3, r4, #25
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
   1d392:	460d      	mov	r5, r1
	uint8_t ep = setup->wIndex;
   1d394:	f88d 4007 	strb.w	r4, [sp, #7]
	if (USB_EP_GET_IDX(ep) == 0) {
   1d398:	d007      	beq.n	1d3aa <usb_halt_endpoint_req.isra.0+0x1e>
   1d39a:	4620      	mov	r0, r4
   1d39c:	f7ff ff6e 	bl	1d27c <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
   1d3a0:	b178      	cbz	r0, 1d3c2 <usb_halt_endpoint_req.isra.0+0x36>
	return (usb_dev.configuration != 0);
   1d3a2:	4b0d      	ldr	r3, [pc, #52]	; (1d3d8 <usb_halt_endpoint_req.isra.0+0x4c>)
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
   1d3a4:	f893 00ba 	ldrb.w	r0, [r3, #186]	; 0xba
   1d3a8:	b158      	cbz	r0, 1d3c2 <usb_halt_endpoint_req.isra.0+0x36>
			usb_dc_ep_set_stall(ep);
   1d3aa:	4620      	mov	r0, r4
   1d3ac:	4e0a      	ldr	r6, [pc, #40]	; (1d3d8 <usb_halt_endpoint_req.isra.0+0x4c>)
		if (halt) {
   1d3ae:	b155      	cbz	r5, 1d3c6 <usb_halt_endpoint_req.isra.0+0x3a>
			usb_dc_ep_set_stall(ep);
   1d3b0:	f002 f816 	bl	1f3e0 <usb_dc_ep_set_stall>
			if (usb_dev.status_callback) {
   1d3b4:	69f3      	ldr	r3, [r6, #28]
   1d3b6:	b11b      	cbz	r3, 1d3c0 <usb_halt_endpoint_req.isra.0+0x34>
				usb_dev.status_callback(USB_DC_SET_HALT, &ep);
   1d3b8:	2008      	movs	r0, #8
   1d3ba:	f10d 0107 	add.w	r1, sp, #7
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
   1d3be:	4798      	blx	r3
		return true;
   1d3c0:	2001      	movs	r0, #1
}
   1d3c2:	b002      	add	sp, #8
   1d3c4:	bd70      	pop	{r4, r5, r6, pc}
			usb_dc_ep_clear_stall(ep);
   1d3c6:	f002 f833 	bl	1f430 <usb_dc_ep_clear_stall>
			if (usb_dev.status_callback) {
   1d3ca:	69f3      	ldr	r3, [r6, #28]
   1d3cc:	2b00      	cmp	r3, #0
   1d3ce:	d0f7      	beq.n	1d3c0 <usb_halt_endpoint_req.isra.0+0x34>
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
   1d3d0:	2009      	movs	r0, #9
   1d3d2:	f10d 0107 	add.w	r1, sp, #7
   1d3d6:	e7f2      	b.n	1d3be <usb_halt_endpoint_req.isra.0+0x32>
   1d3d8:	2000a774 	.word	0x2000a774

0001d3dc <set_endpoint>:
{
   1d3dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ep_cfg.ep_addr = ep_desc->bEndpointAddress;
   1d3de:	7886      	ldrb	r6, [r0, #2]
	if (ep_bm & usb_dev.ep_bm) {
   1d3e0:	4c1e      	ldr	r4, [pc, #120]	; (1d45c <set_endpoint+0x80>)
	ep_cfg.ep_addr = ep_desc->bEndpointAddress;
   1d3e2:	f88d 6000 	strb.w	r6, [sp]
	ep_cfg.ep_mps = sys_le16_to_cpu(ep_desc->wMaxPacketSize);
   1d3e6:	7903      	ldrb	r3, [r0, #4]
   1d3e8:	7942      	ldrb	r2, [r0, #5]
   1d3ea:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1d3ee:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
   1d3f2:	78c3      	ldrb	r3, [r0, #3]
	ep_bm = get_ep_bm_from_addr(ep_desc->bEndpointAddress);
   1d3f4:	4630      	mov	r0, r6
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
   1d3f6:	f003 0303 	and.w	r3, r3, #3
   1d3fa:	f88d 3004 	strb.w	r3, [sp, #4]
	ep_bm = get_ep_bm_from_addr(ep_desc->bEndpointAddress);
   1d3fe:	f007 fca9 	bl	24d54 <get_ep_bm_from_addr>
	if (ep_bm & usb_dev.ep_bm) {
   1d402:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
	ep_bm = get_ep_bm_from_addr(ep_desc->bEndpointAddress);
   1d406:	4605      	mov	r5, r0
	if (ep_bm & usb_dev.ep_bm) {
   1d408:	4218      	tst	r0, r3
   1d40a:	d00b      	beq.n	1d424 <set_endpoint+0x48>
	usb_cancel_transfer(ep_cfg.ep_addr);
   1d40c:	4630      	mov	r0, r6
   1d40e:	f000 fd13 	bl	1de38 <usb_cancel_transfer>
	return disable_endpoint(ep_cfg.ep_addr) ? false : true;
   1d412:	4630      	mov	r0, r6
   1d414:	f7ff ff14 	bl	1d240 <disable_endpoint>
		if (!k_is_in_isr()) {
   1d418:	f008 fbc5 	bl	25ba6 <k_is_in_isr>
   1d41c:	b910      	cbnz	r0, 1d424 <set_endpoint+0x48>
		union { uintptr_t x; int32_t val; } parm0 = { .val = us };
		return (int32_t) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_USLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_usleep(us);
   1d41e:	2096      	movs	r0, #150	; 0x96
   1d420:	f006 fd28 	bl	23e74 <z_impl_k_usleep>
	ret = usb_dc_ep_configure(&ep_cfg);
   1d424:	4668      	mov	r0, sp
   1d426:	f001 ffb7 	bl	1f398 <usb_dc_ep_configure>
	if (ret == -EALREADY) {
   1d42a:	f110 0f78 	cmn.w	r0, #120	; 0x78
   1d42e:	d003      	beq.n	1d438 <set_endpoint+0x5c>
	} else if (ret) {
   1d430:	b110      	cbz	r0, 1d438 <set_endpoint+0x5c>
		return false;
   1d432:	2000      	movs	r0, #0
}
   1d434:	b002      	add	sp, #8
   1d436:	bd70      	pop	{r4, r5, r6, pc}
	ret = usb_dc_ep_enable(ep_cfg.ep_addr);
   1d438:	f89d 0000 	ldrb.w	r0, [sp]
   1d43c:	f002 f834 	bl	1f4a8 <usb_dc_ep_enable>
	if (ret == -EALREADY) {
   1d440:	f110 0f78 	cmn.w	r0, #120	; 0x78
   1d444:	d001      	beq.n	1d44a <set_endpoint+0x6e>
	} else if (ret) {
   1d446:	2800      	cmp	r0, #0
   1d448:	d1f3      	bne.n	1d432 <set_endpoint+0x56>
	usb_dev.configured = true;
   1d44a:	2001      	movs	r0, #1
	usb_dev.ep_bm |= ep_bm;
   1d44c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
	usb_dev.configured = true;
   1d450:	f884 00b9 	strb.w	r0, [r4, #185]	; 0xb9
	usb_dev.ep_bm |= ep_bm;
   1d454:	432b      	orrs	r3, r5
   1d456:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	return true;
   1d45a:	e7eb      	b.n	1d434 <set_endpoint+0x58>
   1d45c:	2000a774 	.word	0x2000a774

0001d460 <usb_handle_standard_request>:
{
   1d460:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (usb_dev.custom_req_handler &&
   1d464:	4d92      	ldr	r5, [pc, #584]	; (1d6b0 <usb_handle_standard_request+0x250>)
{
   1d466:	4604      	mov	r4, r0
	if (usb_dev.custom_req_handler &&
   1d468:	69ab      	ldr	r3, [r5, #24]
{
   1d46a:	460e      	mov	r6, r1
   1d46c:	4617      	mov	r7, r2
	if (usb_dev.custom_req_handler &&
   1d46e:	b9c3      	cbnz	r3, 1d4a2 <usb_handle_standard_request+0x42>
	switch (setup->RequestType.recipient) {
   1d470:	7820      	ldrb	r0, [r4, #0]
   1d472:	f000 001f 	and.w	r0, r0, #31
   1d476:	2801      	cmp	r0, #1
   1d478:	d076      	beq.n	1d568 <usb_handle_standard_request+0x108>
   1d47a:	2802      	cmp	r0, #2
   1d47c:	f000 80dc 	beq.w	1d638 <usb_handle_standard_request+0x1d8>
   1d480:	bb00      	cbnz	r0, 1d4c4 <usb_handle_standard_request+0x64>
	if (usb_reqtype_is_to_host(setup)) {
   1d482:	f994 1000 	ldrsb.w	r1, [r4]
	uint8_t *data = *data_buf;
   1d486:	683a      	ldr	r2, [r7, #0]
	if (usb_reqtype_is_to_host(setup)) {
   1d488:	2900      	cmp	r1, #0
		switch (setup->bRequest) {
   1d48a:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   1d48c:	da2e      	bge.n	1d4ec <usb_handle_standard_request+0x8c>
		switch (setup->bRequest) {
   1d48e:	2b06      	cmp	r3, #6
   1d490:	d00c      	beq.n	1d4ac <usb_handle_standard_request+0x4c>
   1d492:	2b08      	cmp	r3, #8
   1d494:	d025      	beq.n	1d4e2 <usb_handle_standard_request+0x82>
   1d496:	b9ab      	cbnz	r3, 1d4c4 <usb_handle_standard_request+0x64>
	data[1] = 0U;
   1d498:	7053      	strb	r3, [r2, #1]
		data[0] |= USB_GET_STATUS_SELF_POWERED;
   1d49a:	2301      	movs	r3, #1
   1d49c:	7013      	strb	r3, [r2, #0]
		*len = 2;
   1d49e:	2302      	movs	r3, #2
   1d4a0:	e103      	b.n	1d6aa <usb_handle_standard_request+0x24a>
	    !usb_dev.custom_req_handler(setup, len, data_buf)) {
   1d4a2:	4798      	blx	r3
	if (usb_dev.custom_req_handler &&
   1d4a4:	2800      	cmp	r0, #0
   1d4a6:	d1e3      	bne.n	1d470 <usb_handle_standard_request+0x10>
		return 0;
   1d4a8:	2000      	movs	r0, #0
   1d4aa:	e00d      	b.n	1d4c8 <usb_handle_standard_request+0x68>
			return usb_get_descriptor(setup, len, data_buf);
   1d4ac:	8863      	ldrh	r3, [r4, #2]
	type = USB_GET_DESCRIPTOR_TYPE(setup->wValue);
   1d4ae:	0a19      	lsrs	r1, r3, #8
	if ((type == USB_DESC_INTERFACE) || (type == USB_DESC_ENDPOINT) ||
   1d4b0:	1f0a      	subs	r2, r1, #4
   1d4b2:	2a01      	cmp	r2, #1
	type = USB_GET_DESCRIPTOR_TYPE(setup->wValue);
   1d4b4:	468c      	mov	ip, r1
	if ((type == USB_DESC_INTERFACE) || (type == USB_DESC_ENDPOINT) ||
   1d4b6:	d905      	bls.n	1d4c4 <usb_handle_standard_request+0x64>
   1d4b8:	2907      	cmp	r1, #7
   1d4ba:	d803      	bhi.n	1d4c4 <usb_handle_standard_request+0x64>
	index = USB_GET_DESCRIPTOR_INDEX(setup->wValue);
   1d4bc:	b2da      	uxtb	r2, r3
	p = (uint8_t *)usb_dev.descriptors;
   1d4be:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	while (p[DESC_bLength] != 0U) {
   1d4c0:	781c      	ldrb	r4, [r3, #0]
   1d4c2:	b91c      	cbnz	r4, 1d4cc <usb_handle_standard_request+0x6c>
			rc = -EINVAL;
   1d4c4:	f06f 0015 	mvn.w	r0, #21
}
   1d4c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (p[DESC_bDescriptorType] == type) {
   1d4cc:	785d      	ldrb	r5, [r3, #1]
   1d4ce:	4565      	cmp	r5, ip
   1d4d0:	d103      	bne.n	1d4da <usb_handle_standard_request+0x7a>
			if (cur_index == index) {
   1d4d2:	4282      	cmp	r2, r0
   1d4d4:	f000 80e4 	beq.w	1d6a0 <usb_handle_standard_request+0x240>
			cur_index++;
   1d4d8:	3001      	adds	r0, #1
		p += p[DESC_bLength];
   1d4da:	4423      	add	r3, r4
   1d4dc:	e7f0      	b.n	1d4c0 <usb_handle_standard_request+0x60>
			*len = p[DESC_bLength];
   1d4de:	781b      	ldrb	r3, [r3, #0]
   1d4e0:	e0e3      	b.n	1d6aa <usb_handle_standard_request+0x24a>
			data[0] = usb_dev.configuration;
   1d4e2:	f895 30ba 	ldrb.w	r3, [r5, #186]	; 0xba
   1d4e6:	7013      	strb	r3, [r2, #0]
				*len = 1;
   1d4e8:	2301      	movs	r3, #1
   1d4ea:	e0de      	b.n	1d6aa <usb_handle_standard_request+0x24a>
		switch (setup->bRequest) {
   1d4ec:	2b05      	cmp	r3, #5
   1d4ee:	d011      	beq.n	1d514 <usb_handle_standard_request+0xb4>
   1d4f0:	2b09      	cmp	r3, #9
   1d4f2:	d1e7      	bne.n	1d4c4 <usb_handle_standard_request+0x64>
	if (setup->wValue == 0U) {
   1d4f4:	8863      	ldrh	r3, [r4, #2]
	uint8_t *p = (uint8_t *)usb_dev.descriptors;
   1d4f6:	6a6e      	ldr	r6, [r5, #36]	; 0x24
	if (setup->wValue == 0U) {
   1d4f8:	2b00      	cmp	r3, #0
   1d4fa:	d132      	bne.n	1d562 <usb_handle_standard_request+0x102>
		usb_reset_alt_setting();
   1d4fc:	f7ff feb6 	bl	1d26c <usb_reset_alt_setting>
		usb_dev.configuration = setup->wValue;
   1d500:	8863      	ldrh	r3, [r4, #2]
   1d502:	f885 30ba 	strb.w	r3, [r5, #186]	; 0xba
		if (usb_dev.status_callback) {
   1d506:	69eb      	ldr	r3, [r5, #28]
   1d508:	2b00      	cmp	r3, #0
   1d50a:	d0cd      	beq.n	1d4a8 <usb_handle_standard_request+0x48>
			usb_dev.status_callback(USB_DC_CONFIGURED,
   1d50c:	2003      	movs	r0, #3
   1d50e:	4969      	ldr	r1, [pc, #420]	; (1d6b4 <usb_handle_standard_request+0x254>)
   1d510:	4798      	blx	r3
   1d512:	e7c9      	b.n	1d4a8 <usb_handle_standard_request+0x48>
			return !usb_dc_set_address(setup->wValue);
   1d514:	78a0      	ldrb	r0, [r4, #2]
   1d516:	f001 ff2d 	bl	1f374 <usb_dc_set_address>
		if (usb_handle_std_device_req(setup, len, data_buf) == false) {
   1d51a:	2800      	cmp	r0, #0
   1d51c:	d0c4      	beq.n	1d4a8 <usb_handle_standard_request+0x48>
   1d51e:	e7d1      	b.n	1d4c4 <usb_handle_standard_request+0x64>
		switch (p[DESC_bDescriptorType]) {
   1d520:	7873      	ldrb	r3, [r6, #1]
   1d522:	2b04      	cmp	r3, #4
   1d524:	d010      	beq.n	1d548 <usb_handle_standard_request+0xe8>
   1d526:	2b05      	cmp	r3, #5
   1d528:	d011      	beq.n	1d54e <usb_handle_standard_request+0xee>
   1d52a:	2b02      	cmp	r3, #2
   1d52c:	d104      	bne.n	1d538 <usb_handle_standard_request+0xd8>
			cur_config = p[CONF_DESC_bConfigurationValue];
   1d52e:	7977      	ldrb	r7, [r6, #5]
			if (cur_config == setup->wValue) {
   1d530:	8863      	ldrh	r3, [r4, #2]
				found = true;
   1d532:	42bb      	cmp	r3, r7
   1d534:	bf08      	it	eq
   1d536:	2001      	moveq	r0, #1
		p += p[DESC_bLength];
   1d538:	7833      	ldrb	r3, [r6, #0]
   1d53a:	441e      	add	r6, r3
	while (p[DESC_bLength] != 0U) {
   1d53c:	7833      	ldrb	r3, [r6, #0]
   1d53e:	2b00      	cmp	r3, #0
   1d540:	d1ee      	bne.n	1d520 <usb_handle_standard_request+0xc0>
	if (found) {
   1d542:	2800      	cmp	r0, #0
   1d544:	d0be      	beq.n	1d4c4 <usb_handle_standard_request+0x64>
   1d546:	e7d9      	b.n	1d4fc <usb_handle_standard_request+0x9c>
			cur_alt_setting =
   1d548:	f896 8003 	ldrb.w	r8, [r6, #3]
			break;
   1d54c:	e7f4      	b.n	1d538 <usb_handle_standard_request+0xd8>
			if ((cur_config != setup->wValue) ||
   1d54e:	8863      	ldrh	r3, [r4, #2]
   1d550:	42bb      	cmp	r3, r7
   1d552:	d1f1      	bne.n	1d538 <usb_handle_standard_request+0xd8>
   1d554:	f1b8 0f00 	cmp.w	r8, #0
   1d558:	d1ee      	bne.n	1d538 <usb_handle_standard_request+0xd8>
			found = set_endpoint((struct usb_ep_descriptor *)p);
   1d55a:	4630      	mov	r0, r6
   1d55c:	f7ff ff3e 	bl	1d3dc <set_endpoint>
			break;
   1d560:	e7ea      	b.n	1d538 <usb_handle_standard_request+0xd8>
	uint8_t cur_config = 0xFF;
   1d562:	27ff      	movs	r7, #255	; 0xff
	uint8_t cur_alt_setting = 0xFF;
   1d564:	46b8      	mov	r8, r7
   1d566:	e7e9      	b.n	1d53c <usb_handle_standard_request+0xdc>
	if (!is_device_configured() ||
   1d568:	f895 30ba 	ldrb.w	r3, [r5, #186]	; 0xba
   1d56c:	f8d7 c000 	ldr.w	ip, [r7]
   1d570:	2b00      	cmp	r3, #0
   1d572:	d0a7      	beq.n	1d4c4 <usb_handle_standard_request+0x64>
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
   1d574:	6a6f      	ldr	r7, [r5, #36]	; 0x24
	   (!is_interface_valid((uint8_t)setup->wIndex))) {
   1d576:	88a2      	ldrh	r2, [r4, #4]
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
   1d578:	463b      	mov	r3, r7
	   (!is_interface_valid((uint8_t)setup->wIndex))) {
   1d57a:	f894 e004 	ldrb.w	lr, [r4, #4]
	while (p[DESC_bLength] != 0U) {
   1d57e:	7818      	ldrb	r0, [r3, #0]
   1d580:	2800      	cmp	r0, #0
   1d582:	d09f      	beq.n	1d4c4 <usb_handle_standard_request+0x64>
		if (p[DESC_bDescriptorType] == USB_DESC_CONFIGURATION) {
   1d584:	7859      	ldrb	r1, [r3, #1]
   1d586:	2902      	cmp	r1, #2
   1d588:	d104      	bne.n	1d594 <usb_handle_standard_request+0x134>
			if (interface < cfg_descr->bNumInterfaces) {
   1d58a:	f893 8004 	ldrb.w	r8, [r3, #4]
   1d58e:	45f0      	cmp	r8, lr
   1d590:	f200 8092 	bhi.w	1d6b8 <usb_handle_standard_request+0x258>
		p += p[DESC_bLength];
   1d594:	4403      	add	r3, r0
   1d596:	e7f2      	b.n	1d57e <usb_handle_standard_request+0x11e>
			data[0] = 0U;
   1d598:	f88c 3000 	strb.w	r3, [ip]
			data[1] = 0U;
   1d59c:	f88c 3001 	strb.w	r3, [ip, #1]
			*len = 2;
   1d5a0:	6031      	str	r1, [r6, #0]
			return true;
   1d5a2:	e781      	b.n	1d4a8 <usb_handle_standard_request+0x48>
		p += p[DESC_bLength];
   1d5a4:	441f      	add	r7, r3
   1d5a6:	e093      	b.n	1d6d0 <usb_handle_standard_request+0x270>
		if (setup->bRequest == USB_SREQ_SET_INTERFACE) {
   1d5a8:	2b0b      	cmp	r3, #11
   1d5aa:	d18b      	bne.n	1d4c4 <usb_handle_standard_request+0x64>
	bool ret = false;
   1d5ac:	2600      	movs	r6, #0
	uint8_t cur_iface = 0xFF;
   1d5ae:	f04f 08ff 	mov.w	r8, #255	; 0xff
	const uint8_t *if_desc = NULL;
   1d5b2:	46b2      	mov	sl, r6
	uint8_t cur_alt_setting = 0xFF;
   1d5b4:	46c1      	mov	r9, r8
   1d5b6:	e006      	b.n	1d5c6 <usb_handle_standard_request+0x166>
		switch (p[DESC_bDescriptorType]) {
   1d5b8:	787b      	ldrb	r3, [r7, #1]
   1d5ba:	2b04      	cmp	r3, #4
   1d5bc:	d00f      	beq.n	1d5de <usb_handle_standard_request+0x17e>
   1d5be:	2b05      	cmp	r3, #5
   1d5c0:	d021      	beq.n	1d606 <usb_handle_standard_request+0x1a6>
		p += p[DESC_bLength];
   1d5c2:	783b      	ldrb	r3, [r7, #0]
   1d5c4:	441f      	add	r7, r3
	while (p[DESC_bLength] != 0U) {
   1d5c6:	783b      	ldrb	r3, [r7, #0]
   1d5c8:	2b00      	cmp	r3, #0
   1d5ca:	d1f5      	bne.n	1d5b8 <usb_handle_standard_request+0x158>
	if (usb_dev.status_callback) {
   1d5cc:	69eb      	ldr	r3, [r5, #28]
   1d5ce:	b113      	cbz	r3, 1d5d6 <usb_handle_standard_request+0x176>
		usb_dev.status_callback(USB_DC_INTERFACE, if_desc);
   1d5d0:	4651      	mov	r1, sl
   1d5d2:	2007      	movs	r0, #7
   1d5d4:	4798      	blx	r3
		if (usb_handle_std_interface_req(setup, len, data_buf) == false) {
   1d5d6:	2e00      	cmp	r6, #0
   1d5d8:	f47f af66 	bne.w	1d4a8 <usb_handle_standard_request+0x48>
   1d5dc:	e772      	b.n	1d4c4 <usb_handle_standard_request+0x64>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
   1d5de:	f897 8002 	ldrb.w	r8, [r7, #2]
			if (cur_iface == setup->wIndex &&
   1d5e2:	88a3      	ldrh	r3, [r4, #4]
			cur_alt_setting = p[INTF_DESC_bAlternateSetting];
   1d5e4:	f897 9003 	ldrb.w	r9, [r7, #3]
			if (cur_iface == setup->wIndex &&
   1d5e8:	4598      	cmp	r8, r3
   1d5ea:	d1ea      	bne.n	1d5c2 <usb_handle_standard_request+0x162>
			    cur_alt_setting == setup->wValue) {
   1d5ec:	8863      	ldrh	r3, [r4, #2]
			if (cur_iface == setup->wIndex &&
   1d5ee:	4599      	cmp	r9, r3
   1d5f0:	d1e7      	bne.n	1d5c2 <usb_handle_standard_request+0x162>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
   1d5f2:	f1b8 0f07 	cmp.w	r8, #7
   1d5f6:	d81c      	bhi.n	1d632 <usb_handle_standard_request+0x1d2>
		usb_dev.alt_setting[iface] = alt_setting;
   1d5f8:	eb05 0308 	add.w	r3, r5, r8
		return true;
   1d5fc:	46ba      	mov	sl, r7
   1d5fe:	2601      	movs	r6, #1
				ret = usb_set_alt_setting(setup->wIndex,
   1d600:	f883 90bb 	strb.w	r9, [r3, #187]	; 0xbb
		return true;
   1d604:	e7dd      	b.n	1d5c2 <usb_handle_standard_request+0x162>
			if (cur_iface == setup->wIndex) {
   1d606:	88a3      	ldrh	r3, [r4, #4]
   1d608:	4543      	cmp	r3, r8
   1d60a:	d1da      	bne.n	1d5c2 <usb_handle_standard_request+0x162>
	if (cur_alt_setting != alt_setting) {
   1d60c:	78a3      	ldrb	r3, [r4, #2]
   1d60e:	454b      	cmp	r3, r9
   1d610:	d00a      	beq.n	1d628 <usb_handle_standard_request+0x1c8>
		ret = reset_endpoint(ep_desc);
   1d612:	78be      	ldrb	r6, [r7, #2]
	usb_cancel_transfer(ep_cfg.ep_addr);
   1d614:	4630      	mov	r0, r6
   1d616:	f000 fc0f 	bl	1de38 <usb_cancel_transfer>
	return disable_endpoint(ep_cfg.ep_addr) ? false : true;
   1d61a:	4630      	mov	r0, r6
   1d61c:	f7ff fe10 	bl	1d240 <disable_endpoint>
   1d620:	fab0 f680 	clz	r6, r0
   1d624:	0976      	lsrs	r6, r6, #5
   1d626:	e7cc      	b.n	1d5c2 <usb_handle_standard_request+0x162>
		ret = set_endpoint(ep_desc);
   1d628:	4638      	mov	r0, r7
   1d62a:	f7ff fed7 	bl	1d3dc <set_endpoint>
   1d62e:	4606      	mov	r6, r0
   1d630:	e7c7      	b.n	1d5c2 <usb_handle_standard_request+0x162>
   1d632:	46ba      	mov	sl, r7
	return false;
   1d634:	2600      	movs	r6, #0
   1d636:	e7c4      	b.n	1d5c2 <usb_handle_standard_request+0x162>
	if (usb_reqtype_is_to_host(setup)) {
   1d638:	f994 2000 	ldrsb.w	r2, [r4]
		switch (setup->bRequest) {
   1d63c:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   1d63e:	2a00      	cmp	r2, #0
   1d640:	da18      	bge.n	1d674 <usb_handle_standard_request+0x214>
		if (setup->bRequest == USB_SREQ_GET_STATUS) {
   1d642:	2b00      	cmp	r3, #0
   1d644:	f47f af3e 	bne.w	1d4c4 <usb_handle_standard_request+0x64>
	uint8_t ep = setup->wIndex;
   1d648:	7924      	ldrb	r4, [r4, #4]
   1d64a:	683f      	ldr	r7, [r7, #0]
	if (USB_EP_GET_IDX(ep) == 0) {
   1d64c:	0663      	lsls	r3, r4, #25
   1d64e:	d00a      	beq.n	1d666 <usb_handle_standard_request+0x206>
   1d650:	4620      	mov	r0, r4
   1d652:	f7ff fe13 	bl	1d27c <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
   1d656:	2800      	cmp	r0, #0
   1d658:	f43f af34 	beq.w	1d4c4 <usb_handle_standard_request+0x64>
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
   1d65c:	f895 30ba 	ldrb.w	r3, [r5, #186]	; 0xba
   1d660:	2b00      	cmp	r3, #0
   1d662:	f43f af2f 	beq.w	1d4c4 <usb_handle_standard_request+0x64>
		usb_dc_ep_is_stalled(ep, &data[0]);
   1d666:	4639      	mov	r1, r7
   1d668:	4620      	mov	r0, r4
   1d66a:	f001 ff01 	bl	1f470 <usb_dc_ep_is_stalled>
		data[1] = 0U;
   1d66e:	2300      	movs	r3, #0
   1d670:	707b      	strb	r3, [r7, #1]
   1d672:	e714      	b.n	1d49e <usb_handle_standard_request+0x3e>
		switch (setup->bRequest) {
   1d674:	2b01      	cmp	r3, #1
   1d676:	d008      	beq.n	1d68a <usb_handle_standard_request+0x22a>
   1d678:	2b03      	cmp	r3, #3
   1d67a:	f47f af23 	bne.w	1d4c4 <usb_handle_standard_request+0x64>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
   1d67e:	8863      	ldrh	r3, [r4, #2]
   1d680:	2b00      	cmp	r3, #0
   1d682:	f47f af1f 	bne.w	1d4c4 <usb_handle_standard_request+0x64>
				return usb_halt_endpoint_req(setup, true);
   1d686:	2101      	movs	r1, #1
   1d688:	e003      	b.n	1d692 <usb_handle_standard_request+0x232>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
   1d68a:	8861      	ldrh	r1, [r4, #2]
   1d68c:	2900      	cmp	r1, #0
   1d68e:	f47f af19 	bne.w	1d4c4 <usb_handle_standard_request+0x64>
				return usb_halt_endpoint_req(setup, true);
   1d692:	88a0      	ldrh	r0, [r4, #4]
   1d694:	f7ff fe7a 	bl	1d38c <usb_halt_endpoint_req.isra.0>
		if (usb_handle_std_endpoint_req(setup, len, data_buf) == false) {
   1d698:	2800      	cmp	r0, #0
   1d69a:	f47f af05 	bne.w	1d4a8 <usb_handle_standard_request+0x48>
   1d69e:	e711      	b.n	1d4c4 <usb_handle_standard_request+0x64>
		if (type == USB_DESC_CONFIGURATION) {
   1d6a0:	2902      	cmp	r1, #2
		*data = p;
   1d6a2:	603b      	str	r3, [r7, #0]
		if (type == USB_DESC_CONFIGURATION) {
   1d6a4:	f47f af1b 	bne.w	1d4de <usb_handle_standard_request+0x7e>
			*len = (p[CONF_DESC_wTotalLength]) |
   1d6a8:	885b      	ldrh	r3, [r3, #2]
		*len = 2;
   1d6aa:	6033      	str	r3, [r6, #0]
		return true;
   1d6ac:	e6fc      	b.n	1d4a8 <usb_handle_standard_request+0x48>
   1d6ae:	bf00      	nop
   1d6b0:	2000a774 	.word	0x2000a774
   1d6b4:	2000a82e 	.word	0x2000a82e
	if (usb_reqtype_is_to_host(setup)) {
   1d6b8:	f994 0000 	ldrsb.w	r0, [r4]
		switch (setup->bRequest) {
   1d6bc:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   1d6be:	2800      	cmp	r0, #0
   1d6c0:	f6bf af72 	bge.w	1d5a8 <usb_handle_standard_request+0x148>
		switch (setup->bRequest) {
   1d6c4:	2b00      	cmp	r3, #0
   1d6c6:	f43f af67 	beq.w	1d598 <usb_handle_standard_request+0x138>
   1d6ca:	2b0a      	cmp	r3, #10
   1d6cc:	f47f aefa 	bne.w	1d4c4 <usb_handle_standard_request+0x64>
	while (p[DESC_bLength] != 0U) {
   1d6d0:	783b      	ldrb	r3, [r7, #0]
   1d6d2:	2b00      	cmp	r3, #0
   1d6d4:	f43f aef6 	beq.w	1d4c4 <usb_handle_standard_request+0x64>
		if (p[DESC_bDescriptorType] == USB_DESC_INTERFACE) {
   1d6d8:	7879      	ldrb	r1, [r7, #1]
   1d6da:	2904      	cmp	r1, #4
   1d6dc:	f47f af62 	bne.w	1d5a4 <usb_handle_standard_request+0x144>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
   1d6e0:	78b9      	ldrb	r1, [r7, #2]
			if (cur_iface == setup->wIndex) {
   1d6e2:	428a      	cmp	r2, r1
   1d6e4:	f47f af5e 	bne.w	1d5a4 <usb_handle_standard_request+0x144>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
   1d6e8:	2a07      	cmp	r2, #7
	return 0;
   1d6ea:	bf8e      	itee	hi
   1d6ec:	2300      	movhi	r3, #0
		return usb_dev.alt_setting[iface];
   1d6ee:	1952      	addls	r2, r2, r5
   1d6f0:	f892 30bb 	ldrbls.w	r3, [r2, #187]	; 0xbb
				data[0] = usb_get_alt_setting(cur_iface);
   1d6f4:	f88c 3000 	strb.w	r3, [ip]
   1d6f8:	e6f6      	b.n	1d4e8 <usb_handle_standard_request+0x88>
   1d6fa:	bf00      	nop

0001d6fc <usb_data_to_host>:
{
   1d6fc:	b513      	push	{r0, r1, r4, lr}
	if (usb_dev.zlp_flag == false) {
   1d6fe:	4c13      	ldr	r4, [pc, #76]	; (1d74c <usb_data_to_host+0x50>)
   1d700:	7d23      	ldrb	r3, [r4, #20]
   1d702:	b9cb      	cbnz	r3, 1d738 <usb_data_to_host+0x3c>
		uint32_t chunk = usb_dev.data_buf_residue;
   1d704:	68e2      	ldr	r2, [r4, #12]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
   1d706:	ab01      	add	r3, sp, #4
   1d708:	2080      	movs	r0, #128	; 0x80
   1d70a:	68a1      	ldr	r1, [r4, #8]
		uint32_t chunk = usb_dev.data_buf_residue;
   1d70c:	9201      	str	r2, [sp, #4]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
   1d70e:	f007 fb30 	bl	24d72 <usb_write>
		usb_dev.data_buf += chunk;
   1d712:	9a01      	ldr	r2, [sp, #4]
   1d714:	68a3      	ldr	r3, [r4, #8]
   1d716:	4413      	add	r3, r2
   1d718:	60a3      	str	r3, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
   1d71a:	68e3      	ldr	r3, [r4, #12]
   1d71c:	1a9b      	subs	r3, r3, r2
   1d71e:	60e3      	str	r3, [r4, #12]
		if (!usb_dev.data_buf_residue && chunk &&
   1d720:	b943      	cbnz	r3, 1d734 <usb_data_to_host+0x38>
   1d722:	b13a      	cbz	r2, 1d734 <usb_data_to_host+0x38>
		    usb_dev.setup.wLength > usb_dev.data_buf_len) {
   1d724:	6923      	ldr	r3, [r4, #16]
   1d726:	88e2      	ldrh	r2, [r4, #6]
		if (!usb_dev.data_buf_residue && chunk &&
   1d728:	429a      	cmp	r2, r3
   1d72a:	dd03      	ble.n	1d734 <usb_data_to_host+0x38>
			if (!(usb_dev.data_buf_len % USB_MAX_CTRL_MPS)) {
   1d72c:	069b      	lsls	r3, r3, #26
   1d72e:	d101      	bne.n	1d734 <usb_data_to_host+0x38>
				usb_dev.zlp_flag = true;
   1d730:	2301      	movs	r3, #1
   1d732:	7523      	strb	r3, [r4, #20]
}
   1d734:	b002      	add	sp, #8
   1d736:	bd10      	pop	{r4, pc}
		usb_dev.zlp_flag = false;
   1d738:	2300      	movs	r3, #0
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
   1d73a:	2080      	movs	r0, #128	; 0x80
   1d73c:	461a      	mov	r2, r3
   1d73e:	4619      	mov	r1, r3
		usb_dev.zlp_flag = false;
   1d740:	7523      	strb	r3, [r4, #20]
}
   1d742:	b002      	add	sp, #8
   1d744:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
   1d748:	f001 bed8 	b.w	1f4fc <usb_dc_ep_write>
   1d74c:	2000a774 	.word	0x2000a774

0001d750 <usb_handle_control_transfer>:
	uint32_t chunk = 0U;
   1d750:	2300      	movs	r3, #0
{
   1d752:	b530      	push	{r4, r5, lr}
   1d754:	b085      	sub	sp, #20
   1d756:	4602      	mov	r2, r0
   1d758:	460d      	mov	r5, r1
	uint32_t chunk = 0U;
   1d75a:	9301      	str	r3, [sp, #4]
	if (ep == USB_CONTROL_EP_OUT && ep_status == USB_DC_EP_SETUP) {
   1d75c:	2800      	cmp	r0, #0
   1d75e:	d158      	bne.n	1d812 <usb_handle_control_transfer+0xc2>
   1d760:	2900      	cmp	r1, #0
   1d762:	d135      	bne.n	1d7d0 <usb_handle_control_transfer+0x80>
		if (usb_dc_ep_read(ep, (uint8_t *)&setup_raw,
   1d764:	2208      	movs	r2, #8
   1d766:	460b      	mov	r3, r1
   1d768:	eb0d 0102 	add.w	r1, sp, r2
   1d76c:	f007 fc9b 	bl	250a6 <usb_dc_ep_read>
   1d770:	2800      	cmp	r0, #0
   1d772:	da04      	bge.n	1d77e <usb_handle_control_transfer+0x2e>
			usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
   1d774:	2080      	movs	r0, #128	; 0x80
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
   1d776:	f001 fe33 	bl	1f3e0 <usb_dc_ep_set_stall>
}
   1d77a:	b005      	add	sp, #20
   1d77c:	bd30      	pop	{r4, r5, pc}
		setup->bmRequestType = setup_raw.bmRequestType;
   1d77e:	4c2a      	ldr	r4, [pc, #168]	; (1d828 <usb_handle_control_transfer+0xd8>)
   1d780:	9a02      	ldr	r2, [sp, #8]
		usb_dev.data_buf_residue = 0;
   1d782:	e9c4 5503 	strd	r5, r5, [r4, #12]
		setup->bmRequestType = setup_raw.bmRequestType;
   1d786:	6022      	str	r2, [r4, #0]
		setup->wIndex = sys_le16_to_cpu(setup_raw.wIndex);
   1d788:	9a03      	ldr	r2, [sp, #12]
		setup->wLength = sys_le16_to_cpu(setup_raw.wLength);
   1d78a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
		setup->wIndex = sys_le16_to_cpu(setup_raw.wIndex);
   1d78e:	6062      	str	r2, [r4, #4]
		usb_dev.data_buf = usb_dev.req_data;
   1d790:	f104 0238 	add.w	r2, r4, #56	; 0x38
   1d794:	60a2      	str	r2, [r4, #8]
		if (usb_reqtype_is_to_device(setup)) {
   1d796:	f99d 2008 	ldrsb.w	r2, [sp, #8]
		usb_dev.zlp_flag = false;
   1d79a:	7525      	strb	r5, [r4, #20]
		if (usb_reqtype_is_to_device(setup)) {
   1d79c:	2a00      	cmp	r2, #0
   1d79e:	db0a      	blt.n	1d7b6 <usb_handle_control_transfer+0x66>
			if (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {
   1d7a0:	2b80      	cmp	r3, #128	; 0x80
   1d7a2:	d904      	bls.n	1d7ae <usb_handle_control_transfer+0x5e>
				usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
   1d7a4:	2080      	movs	r0, #128	; 0x80
   1d7a6:	f001 fe1b 	bl	1f3e0 <usb_dc_ep_set_stall>
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
   1d7aa:	2000      	movs	r0, #0
   1d7ac:	e7e3      	b.n	1d776 <usb_handle_control_transfer+0x26>
			if (setup->wLength) {
   1d7ae:	b113      	cbz	r3, 1d7b6 <usb_handle_control_transfer+0x66>
				usb_dev.data_buf_residue = setup->wLength;
   1d7b0:	e9c4 3303 	strd	r3, r3, [r4, #12]
				return;
   1d7b4:	e7e1      	b.n	1d77a <usb_handle_control_transfer+0x2a>
		if (!usb_handle_request(setup,
   1d7b6:	f7ff fd7d 	bl	1d2b4 <usb_handle_request.constprop.0>
   1d7ba:	2800      	cmp	r0, #0
   1d7bc:	d0da      	beq.n	1d774 <usb_handle_control_transfer+0x24>
		usb_dev.data_buf_residue = MIN(usb_dev.data_buf_len,
   1d7be:	88e2      	ldrh	r2, [r4, #6]
   1d7c0:	6923      	ldr	r3, [r4, #16]
   1d7c2:	429a      	cmp	r2, r3
   1d7c4:	bfd4      	ite	le
   1d7c6:	60e2      	strle	r2, [r4, #12]
   1d7c8:	60e3      	strgt	r3, [r4, #12]
			usb_data_to_host();
   1d7ca:	f7ff ff97 	bl	1d6fc <usb_data_to_host>
   1d7ce:	e7d4      	b.n	1d77a <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue <= 0) {
   1d7d0:	4c15      	ldr	r4, [pc, #84]	; (1d828 <usb_handle_control_transfer+0xd8>)
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   1d7d2:	ab01      	add	r3, sp, #4
   1d7d4:	e9d4 1502 	ldrd	r1, r5, [r4, #8]
		if (usb_dev.data_buf_residue <= 0) {
   1d7d8:	2d00      	cmp	r5, #0
   1d7da:	dc04      	bgt.n	1d7e6 <usb_handle_control_transfer+0x96>
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   1d7dc:	f007 fc63 	bl	250a6 <usb_dc_ep_read>
   1d7e0:	2800      	cmp	r0, #0
   1d7e2:	daca      	bge.n	1d77a <usb_handle_control_transfer+0x2a>
   1d7e4:	e7c6      	b.n	1d774 <usb_handle_control_transfer+0x24>
		if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   1d7e6:	462a      	mov	r2, r5
   1d7e8:	f007 fc5d 	bl	250a6 <usb_dc_ep_read>
   1d7ec:	2800      	cmp	r0, #0
   1d7ee:	dbd9      	blt.n	1d7a4 <usb_handle_control_transfer+0x54>
		usb_dev.data_buf += chunk;
   1d7f0:	9a01      	ldr	r2, [sp, #4]
   1d7f2:	68a3      	ldr	r3, [r4, #8]
   1d7f4:	4413      	add	r3, r2
   1d7f6:	60a3      	str	r3, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
   1d7f8:	68e3      	ldr	r3, [r4, #12]
   1d7fa:	1a9b      	subs	r3, r3, r2
   1d7fc:	60e3      	str	r3, [r4, #12]
		if (usb_dev.data_buf_residue == 0) {
   1d7fe:	2b00      	cmp	r3, #0
   1d800:	d1bb      	bne.n	1d77a <usb_handle_control_transfer+0x2a>
			usb_dev.data_buf = usb_dev.req_data;
   1d802:	f104 0338 	add.w	r3, r4, #56	; 0x38
   1d806:	60a3      	str	r3, [r4, #8]
			if (!usb_handle_request(setup,
   1d808:	f7ff fd54 	bl	1d2b4 <usb_handle_request.constprop.0>
   1d80c:	2800      	cmp	r0, #0
   1d80e:	d1dc      	bne.n	1d7ca <usb_handle_control_transfer+0x7a>
   1d810:	e7b0      	b.n	1d774 <usb_handle_control_transfer+0x24>
	} else if (ep == USB_CONTROL_EP_IN) {
   1d812:	2880      	cmp	r0, #128	; 0x80
   1d814:	d1b1      	bne.n	1d77a <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue != 0 || usb_dev.zlp_flag == true) {
   1d816:	4b04      	ldr	r3, [pc, #16]	; (1d828 <usb_handle_control_transfer+0xd8>)
   1d818:	68da      	ldr	r2, [r3, #12]
   1d81a:	2a00      	cmp	r2, #0
   1d81c:	d1d5      	bne.n	1d7ca <usb_handle_control_transfer+0x7a>
   1d81e:	7d1b      	ldrb	r3, [r3, #20]
   1d820:	2b00      	cmp	r3, #0
   1d822:	d1d2      	bne.n	1d7ca <usb_handle_control_transfer+0x7a>
   1d824:	e7a9      	b.n	1d77a <usb_handle_control_transfer+0x2a>
   1d826:	bf00      	nop
   1d828:	2000a774 	.word	0x2000a774

0001d82c <usb_set_config>:
	usb_dev.descriptors = usb_descriptors;
   1d82c:	4b05      	ldr	r3, [pc, #20]	; (1d844 <usb_set_config+0x18>)
	usb_dev.req_handlers[type] = handler;
   1d82e:	4a06      	ldr	r2, [pc, #24]	; (1d848 <usb_set_config+0x1c>)
	usb_dev.descriptors = usb_descriptors;
   1d830:	6258      	str	r0, [r3, #36]	; 0x24
	usb_dev.req_handlers[type] = handler;
   1d832:	629a      	str	r2, [r3, #40]	; 0x28
   1d834:	4a05      	ldr	r2, [pc, #20]	; (1d84c <usb_set_config+0x20>)

	/* register class request handlers for each interface*/
	usb_register_custom_req_handler(custom_handler);

	return 0;
}
   1d836:	2000      	movs	r0, #0
	usb_dev.req_handlers[type] = handler;
   1d838:	62da      	str	r2, [r3, #44]	; 0x2c
   1d83a:	4a05      	ldr	r2, [pc, #20]	; (1d850 <usb_set_config+0x24>)
   1d83c:	631a      	str	r2, [r3, #48]	; 0x30
	usb_dev.custom_req_handler = handler;
   1d83e:	4a05      	ldr	r2, [pc, #20]	; (1d854 <usb_set_config+0x28>)
   1d840:	619a      	str	r2, [r3, #24]
}
   1d842:	4770      	bx	lr
   1d844:	2000a774 	.word	0x2000a774
   1d848:	0001d461 	.word	0x0001d461
   1d84c:	0001d165 	.word	0x0001d165
   1d850:	0001d205 	.word	0x0001d205
   1d854:	0001d1a5 	.word	0x0001d1a5

0001d858 <usb_enable>:

int usb_enable(usb_dc_status_callback status_cb)
{
   1d858:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1d85c:	4604      	mov	r4, r0
	 * This should only be called once.
	 */
	LOG_DBG("lock usb_enable_lock mutex");
	k_mutex_lock(&usb_enable_lock, K_FOREVER);

	if (usb_dev.enabled == true) {
   1d85e:	4d3b      	ldr	r5, [pc, #236]	; (1d94c <usb_enable+0xf4>)
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke3(parm0.x, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   1d860:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1d864:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1d868:	4839      	ldr	r0, [pc, #228]	; (1d950 <usb_enable+0xf8>)
   1d86a:	f005 fd7f 	bl	2336c <z_impl_k_mutex_lock>
   1d86e:	f895 60b8 	ldrb.w	r6, [r5, #184]	; 0xb8
   1d872:	2e00      	cmp	r6, #0
   1d874:	d167      	bne.n	1d946 <usb_enable+0xee>
	usb_dev.status_callback = cb;
   1d876:	4837      	ldr	r0, [pc, #220]	; (1d954 <usb_enable+0xfc>)
	ret = usb_vbus_set(true);
	if (ret < 0) {
		goto out;
	}

	usb_dev.user_status_callback = status_cb;
   1d878:	622c      	str	r4, [r5, #32]
	usb_dev.status_callback = cb;
   1d87a:	61e8      	str	r0, [r5, #28]
	usb_register_status_callback(forward_status_cb);
	usb_dc_set_status_callback(forward_status_cb);
   1d87c:	f001 ff58 	bl	1f730 <usb_dc_set_status_callback>

	ret = usb_dc_attach();
   1d880:	f001 fd46 	bl	1f310 <usb_dc_attach>
	if (ret < 0) {
   1d884:	1e04      	subs	r4, r0, #0
   1d886:	db42      	blt.n	1d90e <usb_enable+0xb6>
		goto out;
	}

	ret = usb_transfer_init();
   1d888:	f000 fb18 	bl	1debc <usb_transfer_init>
	if (ret < 0) {
   1d88c:	1e04      	subs	r4, r0, #0
   1d88e:	db3e      	blt.n	1d90e <usb_enable+0xb6>
		goto out;
	}

	/* Configure control EP */
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
   1d890:	2340      	movs	r3, #64	; 0x40
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;

	ep0_cfg.ep_addr = USB_CONTROL_EP_OUT;
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d892:	4668      	mov	r0, sp
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
   1d894:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;
   1d898:	f88d 6004 	strb.w	r6, [sp, #4]
	ep0_cfg.ep_addr = USB_CONTROL_EP_OUT;
   1d89c:	f88d 6000 	strb.w	r6, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d8a0:	f001 fd7a 	bl	1f398 <usb_dc_ep_configure>
	if (ret < 0) {
   1d8a4:	1e04      	subs	r4, r0, #0
   1d8a6:	db32      	blt.n	1d90e <usb_enable+0xb6>
		goto out;
	}

	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
   1d8a8:	2780      	movs	r7, #128	; 0x80
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d8aa:	4668      	mov	r0, sp
	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
   1d8ac:	f88d 7000 	strb.w	r7, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d8b0:	f001 fd72 	bl	1f398 <usb_dc_ep_configure>
	if (ret < 0) {
   1d8b4:	1e04      	subs	r4, r0, #0
   1d8b6:	db2a      	blt.n	1d90e <usb_enable+0xb6>
		goto out;
	}

	/* Register endpoint 0 handlers*/
	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_OUT,
   1d8b8:	4630      	mov	r0, r6
   1d8ba:	4927      	ldr	r1, [pc, #156]	; (1d958 <usb_enable+0x100>)
   1d8bc:	f001 ff24 	bl	1f708 <usb_dc_ep_set_callback>
				     usb_handle_control_transfer);
	if (ret < 0) {
   1d8c0:	1e04      	subs	r4, r0, #0
   1d8c2:	db24      	blt.n	1d90e <usb_enable+0xb6>
		goto out;
	}

	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_IN,
   1d8c4:	4638      	mov	r0, r7
   1d8c6:	4924      	ldr	r1, [pc, #144]	; (1d958 <usb_enable+0x100>)
   1d8c8:	f001 ff1e 	bl	1f708 <usb_dc_ep_set_callback>
				     usb_handle_control_transfer);
	if (ret < 0) {
   1d8cc:	1e04      	subs	r4, r0, #0
   1d8ce:	db1e      	blt.n	1d90e <usb_enable+0xb6>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d8d0:	4c22      	ldr	r4, [pc, #136]	; (1d95c <usb_enable+0x104>)
   1d8d2:	f8df 808c 	ldr.w	r8, [pc, #140]	; 1d960 <usb_enable+0x108>
   1d8d6:	4544      	cmp	r4, r8
   1d8d8:	d320      	bcc.n	1d91c <usb_enable+0xc4>
	if (ret < 0) {
		goto out;
	}

	/* Enable control EP */
	ret = usb_dc_ep_enable(USB_CONTROL_EP_OUT);
   1d8da:	2000      	movs	r0, #0
   1d8dc:	f001 fde4 	bl	1f4a8 <usb_dc_ep_enable>
	if (ret < 0) {
   1d8e0:	1e04      	subs	r4, r0, #0
   1d8e2:	db14      	blt.n	1d90e <usb_enable+0xb6>
		goto out;
	}
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_OUT);
   1d8e4:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4

	ret = usb_dc_ep_enable(USB_CONTROL_EP_IN);
   1d8e8:	2080      	movs	r0, #128	; 0x80
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_OUT);
   1d8ea:	f043 0301 	orr.w	r3, r3, #1
   1d8ee:	f8c5 30c4 	str.w	r3, [r5, #196]	; 0xc4
	ret = usb_dc_ep_enable(USB_CONTROL_EP_IN);
   1d8f2:	f001 fdd9 	bl	1f4a8 <usb_dc_ep_enable>
	if (ret < 0) {
   1d8f6:	1e04      	subs	r4, r0, #0
   1d8f8:	db09      	blt.n	1d90e <usb_enable+0xb6>
		goto out;
	}
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_IN);
   1d8fa:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4

	usb_dev.enabled = true;
	ret = 0;
   1d8fe:	2400      	movs	r4, #0
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_IN);
   1d900:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1d904:	f8c5 30c4 	str.w	r3, [r5, #196]	; 0xc4
	usb_dev.enabled = true;
   1d908:	2301      	movs	r3, #1
   1d90a:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
		union { uintptr_t x; struct k_mutex * val; } parm0 = { .val = mutex };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
   1d90e:	4810      	ldr	r0, [pc, #64]	; (1d950 <usb_enable+0xf8>)
   1d910:	f005 fda6 	bl	23460 <z_impl_k_mutex_unlock>
out:
	LOG_DBG("unlock usb_enable_lock mutex");
	k_mutex_unlock(&usb_enable_lock);
	return ret;
}
   1d914:	4620      	mov	r0, r4
   1d916:	b002      	add	sp, #8
   1d918:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d91c:	2600      	movs	r6, #0
		ep_data = cfg_data->endpoint;
   1d91e:	6a27      	ldr	r7, [r4, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d920:	7f22      	ldrb	r2, [r4, #28]
   1d922:	b2f3      	uxtb	r3, r6
   1d924:	429a      	cmp	r2, r3
   1d926:	d801      	bhi.n	1d92c <usb_enable+0xd4>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d928:	3424      	adds	r4, #36	; 0x24
   1d92a:	e7d4      	b.n	1d8d6 <usb_enable+0x7e>
			if (usb_dc_ep_set_callback(ep_data[n].ep_addr,
   1d92c:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
   1d930:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
   1d934:	7910      	ldrb	r0, [r2, #4]
   1d936:	f001 fee7 	bl	1f708 <usb_dc_ep_set_callback>
   1d93a:	3601      	adds	r6, #1
   1d93c:	2800      	cmp	r0, #0
   1d93e:	d0ef      	beq.n	1d920 <usb_enable+0xc8>
   1d940:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1d944:	e7e3      	b.n	1d90e <usb_enable+0xb6>
		ret = -EALREADY;
   1d946:	f06f 0477 	mvn.w	r4, #119	; 0x77
   1d94a:	e7e0      	b.n	1d90e <usb_enable+0xb6>
   1d94c:	2000a774 	.word	0x2000a774
   1d950:	2000a308 	.word	0x2000a308
   1d954:	0001d2e1 	.word	0x0001d2e1
   1d958:	0001d751 	.word	0x0001d751
   1d95c:	2000a3ec 	.word	0x2000a3ec
   1d960:	2000a410 	.word	0x2000a410

0001d964 <usb_device_init>:
/*
 * This function configures the USB device stack based on USB descriptor and
 * usb_cfg_data.
 */
static int usb_device_init(void)
{
   1d964:	b510      	push	{r4, lr}
	uint8_t *device_descriptor;

	if (usb_dev.enabled == true) {
   1d966:	4b0a      	ldr	r3, [pc, #40]	; (1d990 <usb_device_init+0x2c>)
   1d968:	f893 40b8 	ldrb.w	r4, [r3, #184]	; 0xb8
   1d96c:	b94c      	cbnz	r4, 1d982 <usb_device_init+0x1e>
		return -EALREADY;
	}

	/* register device descriptor */
	device_descriptor = usb_get_device_descriptor();
   1d96e:	f000 f855 	bl	1da1c <usb_get_device_descriptor>
	if (!device_descriptor) {
   1d972:	b148      	cbz	r0, 1d988 <usb_device_init+0x24>
		LOG_ERR("Failed to configure USB device stack");
		return -1;
	}

	usb_set_config(device_descriptor);
   1d974:	f7ff ff5a 	bl	1d82c <usb_set_config>

	if (IS_ENABLED(CONFIG_USB_DEVICE_INITIALIZE_AT_BOOT)) {
		return usb_enable(NULL);
   1d978:	4620      	mov	r0, r4
	}

	return 0;
}
   1d97a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return usb_enable(NULL);
   1d97e:	f7ff bf6b 	b.w	1d858 <usb_enable>
		return -EALREADY;
   1d982:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
   1d986:	bd10      	pop	{r4, pc}
		return -1;
   1d988:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1d98c:	e7fb      	b.n	1d986 <usb_device_init+0x22>
   1d98e:	bf00      	nop
   1d990:	2000a774 	.word	0x2000a774

0001d994 <usb_update_sn_string_descriptor>:
 * case the device ID returned by the HWINFO driver is bigger, the lower
 * part is used for the USB Serial Number, as that part is usually having
 * more entropy.
 */
__weak uint8_t *usb_update_sn_string_descriptor(void)
{
   1d994:	b530      	push	{r4, r5, lr}
	 * unless the user requested a longer serial number.
	 */
	const int usblen = sizeof(CONFIG_USB_DEVICE_SN) / 2;
	uint8_t hwid[MAX(16, sizeof(CONFIG_USB_DEVICE_SN) / 2)];
	static uint8_t sn[sizeof(CONFIG_USB_DEVICE_SN) + 1];
	const char hex[] = "0123456789ABCDEF";
   1d996:	4b1f      	ldr	r3, [pc, #124]	; (1da14 <usb_update_sn_string_descriptor+0x80>)
{
   1d998:	b08b      	sub	sp, #44	; 0x2c
	const char hex[] = "0123456789ABCDEF";
   1d99a:	aa05      	add	r2, sp, #20
   1d99c:	f103 0510 	add.w	r5, r3, #16
   1d9a0:	4614      	mov	r4, r2
   1d9a2:	6818      	ldr	r0, [r3, #0]
   1d9a4:	6859      	ldr	r1, [r3, #4]
   1d9a6:	3308      	adds	r3, #8
   1d9a8:	c403      	stmia	r4!, {r0, r1}
   1d9aa:	42ab      	cmp	r3, r5
   1d9ac:	4622      	mov	r2, r4
   1d9ae:	d1f7      	bne.n	1d9a0 <usb_update_sn_string_descriptor+0xc>
   1d9b0:	781b      	ldrb	r3, [r3, #0]
	int hwlen, skip;

	memset(hwid, 0, sizeof(hwid));
   1d9b2:	2210      	movs	r2, #16
	const char hex[] = "0123456789ABCDEF";
   1d9b4:	7023      	strb	r3, [r4, #0]
	memset(hwid, 0, sizeof(hwid));
   1d9b6:	2100      	movs	r1, #0
   1d9b8:	a801      	add	r0, sp, #4
   1d9ba:	f007 fb1d 	bl	24ff8 <memset>
	memset(sn, 0, sizeof(sn));
   1d9be:	2212      	movs	r2, #18
   1d9c0:	2100      	movs	r1, #0
   1d9c2:	4815      	ldr	r0, [pc, #84]	; (1da18 <usb_update_sn_string_descriptor+0x84>)
   1d9c4:	f007 fb18 	bl	24ff8 <memset>
		union { uintptr_t x; size_t val; } parm1 = { .val = length };
		return (ssize_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_HWINFO_GET_DEVICE_ID);
	}
#endif
	compiler_barrier();
	return z_impl_hwinfo_get_device_id(buffer, length);
   1d9c8:	2110      	movs	r1, #16
   1d9ca:	a801      	add	r0, sp, #4
   1d9cc:	f002 f9b8 	bl	1fd40 <z_impl_hwinfo_get_device_id>

	hwlen = hwinfo_get_device_id(hwid, sizeof(hwid));
	if (hwlen > 0) {
   1d9d0:	2800      	cmp	r0, #0
   1d9d2:	dd1b      	ble.n	1da0c <usb_update_sn_string_descriptor+0x78>
		skip = MAX(0, hwlen - usblen);
   1d9d4:	2808      	cmp	r0, #8
   1d9d6:	bfb8      	it	lt
   1d9d8:	2008      	movlt	r0, #8
   1d9da:	ab01      	add	r3, sp, #4
   1d9dc:	3809      	subs	r0, #9
   1d9de:	181a      	adds	r2, r3, r0
		LOG_HEXDUMP_DBG(&hwid[skip], usblen, "Serial Number");
		for (int i = 0; i < usblen; i++) {
   1d9e0:	2000      	movs	r0, #0
   1d9e2:	490d      	ldr	r1, [pc, #52]	; (1da18 <usb_update_sn_string_descriptor+0x84>)
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   1d9e4:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   1d9e8:	ac0a      	add	r4, sp, #40	; 0x28
   1d9ea:	eb04 1413 	add.w	r4, r4, r3, lsr #4
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   1d9ee:	f003 030f 	and.w	r3, r3, #15
   1d9f2:	3328      	adds	r3, #40	; 0x28
   1d9f4:	446b      	add	r3, sp
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   1d9f6:	f814 4c14 	ldrb.w	r4, [r4, #-20]
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   1d9fa:	f813 3c14 	ldrb.w	r3, [r3, #-20]
		for (int i = 0; i < usblen; i++) {
   1d9fe:	3001      	adds	r0, #1
   1da00:	2808      	cmp	r0, #8
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   1da02:	700c      	strb	r4, [r1, #0]
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   1da04:	704b      	strb	r3, [r1, #1]
		for (int i = 0; i < usblen; i++) {
   1da06:	f101 0102 	add.w	r1, r1, #2
   1da0a:	d1eb      	bne.n	1d9e4 <usb_update_sn_string_descriptor+0x50>
		}
	}

	return sn;
}
   1da0c:	4802      	ldr	r0, [pc, #8]	; (1da18 <usb_update_sn_string_descriptor+0x84>)
   1da0e:	b00b      	add	sp, #44	; 0x2c
   1da10:	bd30      	pop	{r4, r5, pc}
   1da12:	bf00      	nop
   1da14:	000269e5 	.word	0x000269e5
   1da18:	2000b5fe 	.word	0x2000b5fe

0001da1c <usb_get_device_descriptor>:
	return 0;
}


uint8_t *usb_get_device_descriptor(void)
{
   1da1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1da20:	4c63      	ldr	r4, [pc, #396]	; (1dbb0 <usb_get_device_descriptor+0x194>)
   1da22:	b085      	sub	sp, #20
	uint8_t str_descr_idx = 0U;
   1da24:	2600      	movs	r6, #0
	uint32_t requested_ep = BIT(16) | BIT(0);
   1da26:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
	uint8_t numof_ifaces = 0U;
   1da2a:	46b1      	mov	r9, r6
	struct usb_cfg_data *cfg_data = NULL;
   1da2c:	4635      	mov	r5, r6
	struct usb_cfg_descriptor *cfg_descr = NULL;
   1da2e:	46b2      	mov	sl, r6
	while (head->bLength != 0U) {
   1da30:	7823      	ldrb	r3, [r4, #0]
   1da32:	b92b      	cbnz	r3, 1da40 <usb_get_device_descriptor+0x24>
	if ((head + 1) != __usb_descriptor_end) {
   1da34:	4b5f      	ldr	r3, [pc, #380]	; (1dbb4 <usb_get_device_descriptor+0x198>)
   1da36:	3402      	adds	r4, #2
   1da38:	429c      	cmp	r4, r3
   1da3a:	d1f3      	bne.n	1da24 <usb_get_device_descriptor+0x8>
	if (usb_fix_descriptor(__usb_descriptor_start)) {
		LOG_ERR("Failed to fixup USB descriptor");
		return NULL;
	}

	return (uint8_t *) __usb_descriptor_start;
   1da3c:	485c      	ldr	r0, [pc, #368]	; (1dbb0 <usb_get_device_descriptor+0x194>)
   1da3e:	e01c      	b.n	1da7a <usb_get_device_descriptor+0x5e>
		switch (head->bDescriptorType) {
   1da40:	7863      	ldrb	r3, [r4, #1]
   1da42:	2b05      	cmp	r3, #5
   1da44:	d805      	bhi.n	1da52 <usb_get_device_descriptor+0x36>
   1da46:	e8df f003 	tbb	[pc, r3]
   1da4a:	0479      	.short	0x0479
   1da4c:	25077903 	.word	0x25077903
   1da50:	46a2      	mov	sl, r4
		head = (struct usb_desc_header *)((uint8_t *)head + head->bLength);
   1da52:	7823      	ldrb	r3, [r4, #0]
   1da54:	441c      	add	r4, r3
   1da56:	e7eb      	b.n	1da30 <usb_get_device_descriptor+0x14>
			if (if_descr->bAlternateSetting) {
   1da58:	78e3      	ldrb	r3, [r4, #3]
   1da5a:	2b00      	cmp	r3, #0
   1da5c:	d1f9      	bne.n	1da52 <usb_get_device_descriptor+0x36>
			if (if_descr->bInterfaceNumber == 0U) {
   1da5e:	78a3      	ldrb	r3, [r4, #2]
   1da60:	b173      	cbz	r3, 1da80 <usb_get_device_descriptor+0x64>
			numof_ifaces++;
   1da62:	f109 0901 	add.w	r9, r9, #1
   1da66:	fa5f f989 	uxtb.w	r9, r9
			break;
   1da6a:	e7f2      	b.n	1da52 <usb_get_device_descriptor+0x36>
		if (cfg_data->interface_descriptor == iface) {
   1da6c:	686a      	ldr	r2, [r5, #4]
   1da6e:	4294      	cmp	r4, r2
   1da70:	d009      	beq.n	1da86 <usb_get_device_descriptor+0x6a>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1da72:	3524      	adds	r5, #36	; 0x24
   1da74:	429d      	cmp	r5, r3
   1da76:	d3f9      	bcc.n	1da6c <usb_get_device_descriptor+0x50>
		return NULL;
   1da78:	2000      	movs	r0, #0
}
   1da7a:	b005      	add	sp, #20
   1da7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1da80:	4d4d      	ldr	r5, [pc, #308]	; (1dbb8 <usb_get_device_descriptor+0x19c>)
   1da82:	4b4e      	ldr	r3, [pc, #312]	; (1dbbc <usb_get_device_descriptor+0x1a0>)
   1da84:	e7f6      	b.n	1da74 <usb_get_device_descriptor+0x58>
				if (cfg_data->interface_config) {
   1da86:	68ab      	ldr	r3, [r5, #8]
   1da88:	2b00      	cmp	r3, #0
   1da8a:	d0ea      	beq.n	1da62 <usb_get_device_descriptor+0x46>
					cfg_data->interface_config(head,
   1da8c:	4649      	mov	r1, r9
   1da8e:	4620      	mov	r0, r4
   1da90:	4798      	blx	r3
   1da92:	e7e6      	b.n	1da62 <usb_get_device_descriptor+0x46>
			if (!cfg_data) {
   1da94:	2d00      	cmp	r5, #0
   1da96:	d0ef      	beq.n	1da78 <usb_get_device_descriptor+0x5c>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
   1da98:	2300      	movs	r3, #0
   1da9a:	2101      	movs	r1, #1
   1da9c:	7f2a      	ldrb	r2, [r5, #28]
   1da9e:	4293      	cmp	r3, r2
   1daa0:	d2ea      	bcs.n	1da78 <usb_get_device_descriptor+0x5c>
		if (ep_descr->bEndpointAddress != ep_data[i].ep_addr) {
   1daa2:	6a2a      	ldr	r2, [r5, #32]
   1daa4:	78a7      	ldrb	r7, [r4, #2]
   1daa6:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   1daaa:	7910      	ldrb	r0, [r2, #4]
   1daac:	4287      	cmp	r7, r0
   1daae:	d001      	beq.n	1dab4 <usb_get_device_descriptor+0x98>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
   1dab0:	3301      	adds	r3, #1
   1dab2:	e7f3      	b.n	1da9c <usb_get_device_descriptor+0x80>
   1dab4:	2701      	movs	r7, #1
			ep_cfg.ep_type = (ep_descr->bmAttributes &
   1dab6:	78e0      	ldrb	r0, [r4, #3]
   1dab8:	fa5f f887 	uxtb.w	r8, r7
   1dabc:	f000 0003 	and.w	r0, r0, #3
   1dac0:	f88d 000c 	strb.w	r0, [sp, #12]
			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
   1dac4:	7920      	ldrb	r0, [r4, #4]
   1dac6:	f894 c005 	ldrb.w	ip, [r4, #5]
   1daca:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
   1dace:	f8ad 000a 	strh.w	r0, [sp, #10]
			if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   1dad2:	f994 0002 	ldrsb.w	r0, [r4, #2]
   1dad6:	2800      	cmp	r0, #0
   1dad8:	da25      	bge.n	1db26 <usb_get_device_descriptor+0x10a>
				if ((*requested_ep & (1U << (idx + 16U)))) {
   1dada:	f107 0010 	add.w	r0, r7, #16
   1dade:	fa01 f000 	lsl.w	r0, r1, r0
   1dae2:	ea10 0f0b 	tst.w	r0, fp
   1dae6:	d125      	bne.n	1db34 <usb_get_device_descriptor+0x118>
				ep_cfg.ep_addr = (USB_EP_DIR_IN | idx);
   1dae8:	f048 0080 	orr.w	r0, r8, #128	; 0x80
   1daec:	f88d 0008 	strb.w	r0, [sp, #8]
			if (!usb_dc_ep_check_cap(&ep_cfg)) {
   1daf0:	a802      	add	r0, sp, #8
   1daf2:	e9cd 3200 	strd	r3, r2, [sp]
   1daf6:	f007 faa5 	bl	25044 <usb_dc_ep_check_cap>
   1dafa:	e9dd 3200 	ldrd	r3, r2, [sp]
   1dafe:	2101      	movs	r1, #1
   1db00:	b9c0      	cbnz	r0, 1db34 <usb_get_device_descriptor+0x118>
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
   1db02:	f89d 3008 	ldrb.w	r3, [sp, #8]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   1db06:	f013 0f80 	tst.w	r3, #128	; 0x80
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
   1db0a:	70a3      	strb	r3, [r4, #2]
				ep_data[i].ep_addr = ep_cfg.ep_addr;
   1db0c:	7113      	strb	r3, [r2, #4]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   1db0e:	460b      	mov	r3, r1
					*requested_ep |= (1U << (idx + 16U));
   1db10:	bf1d      	ittte	ne
   1db12:	f108 0810 	addne.w	r8, r8, #16
   1db16:	fa5f f888 	uxtbne.w	r8, r8
   1db1a:	fa01 f308 	lslne.w	r3, r1, r8
					*requested_ep |= (1U << idx);
   1db1e:	40bb      	lsleq	r3, r7
   1db20:	ea4b 0b03 	orr.w	fp, fp, r3
				return 0;
   1db24:	e795      	b.n	1da52 <usb_get_device_descriptor+0x36>
				if ((*requested_ep & (1U << (idx)))) {
   1db26:	fa01 f007 	lsl.w	r0, r1, r7
   1db2a:	ea10 0f0b 	tst.w	r0, fp
   1db2e:	d101      	bne.n	1db34 <usb_get_device_descriptor+0x118>
   1db30:	4640      	mov	r0, r8
   1db32:	e7db      	b.n	1daec <usb_get_device_descriptor+0xd0>
		for (uint8_t idx = 1; idx < 16U; idx++) {
   1db34:	3701      	adds	r7, #1
   1db36:	2f10      	cmp	r7, #16
   1db38:	d1bd      	bne.n	1dab6 <usb_get_device_descriptor+0x9a>
   1db3a:	e7b9      	b.n	1dab0 <usb_get_device_descriptor+0x94>
			if (str_descr_idx == USB_DESC_SERIAL_NUMBER_IDX) {
   1db3c:	2e03      	cmp	r6, #3
   1db3e:	d11d      	bne.n	1db7c <usb_get_device_descriptor+0x160>
	uint8_t *runtime_sn =  usb_update_sn_string_descriptor();
   1db40:	f7ff ff28 	bl	1d994 <usb_update_sn_string_descriptor>
	if (!runtime_sn) {
   1db44:	4607      	mov	r7, r0
   1db46:	b168      	cbz	r0, 1db64 <usb_get_device_descriptor+0x148>
	runtime_sn_len = strlen(runtime_sn);
   1db48:	f007 fa3b 	bl	24fc2 <strlen>
	if (!runtime_sn_len) {
   1db4c:	4680      	mov	r8, r0
   1db4e:	b148      	cbz	r0, 1db64 <usb_get_device_descriptor+0x148>
	default_sn_len = strlen(CONFIG_USB_DEVICE_SN);
   1db50:	481b      	ldr	r0, [pc, #108]	; (1dbc0 <usb_get_device_descriptor+0x1a4>)
   1db52:	f007 fa36 	bl	24fc2 <strlen>
	if (runtime_sn_len != default_sn_len) {
   1db56:	4580      	cmp	r8, r0
   1db58:	d104      	bne.n	1db64 <usb_get_device_descriptor+0x148>
	memcpy(sn->bString, runtime_sn, runtime_sn_len);
   1db5a:	4642      	mov	r2, r8
   1db5c:	4639      	mov	r1, r7
   1db5e:	1ca0      	adds	r0, r4, #2
   1db60:	f007 fa3f 	bl	24fe2 <memcpy>
	for (int i = idx_max; i >= 0; i -= 2) {
   1db64:	f06f 0102 	mvn.w	r1, #2
	int idx_max = USB_BSTRING_UTF16LE_IDX_MAX(str_descr->bLength);
   1db68:	7823      	ldrb	r3, [r4, #0]
	for (int i = idx_max; i >= 0; i -= 2) {
   1db6a:	1b09      	subs	r1, r1, r4
   1db6c:	18e2      	adds	r2, r4, r3
   1db6e:	eb04 0353 	add.w	r3, r4, r3, lsr #1
   1db72:	42d1      	cmn	r1, r2
   1db74:	d513      	bpl.n	1db9e <usb_get_device_descriptor+0x182>
			str_descr_idx += 1U;
   1db76:	3601      	adds	r6, #1
   1db78:	b2f6      	uxtb	r6, r6
			break;
   1db7a:	e76a      	b.n	1da52 <usb_get_device_descriptor+0x36>
			if (str_descr_idx) {
   1db7c:	2e00      	cmp	r6, #0
   1db7e:	d1f1      	bne.n	1db64 <usb_get_device_descriptor+0x148>
				if (!cfg_descr) {
   1db80:	f1ba 0f00 	cmp.w	sl, #0
   1db84:	f43f af78 	beq.w	1da78 <usb_get_device_descriptor+0x5c>
				sys_put_le16((uint8_t *)head - (uint8_t *)cfg_descr,
   1db88:	eba4 030a 	sub.w	r3, r4, sl
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
   1db8c:	f88a 3002 	strb.w	r3, [sl, #2]
	dst[1] = val >> 8;
   1db90:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1db94:	f88a 3003 	strb.w	r3, [sl, #3]
				cfg_descr->bNumInterfaces = numof_ifaces;
   1db98:	f88a 9004 	strb.w	r9, [sl, #4]
   1db9c:	e7eb      	b.n	1db76 <usb_get_device_descriptor+0x15a>
		buf[i] = 0U;
   1db9e:	f04f 0000 	mov.w	r0, #0
   1dba2:	f802 0c01 	strb.w	r0, [r2, #-1]
		buf[i - 1] = buf[ascii_idx_max--];
   1dba6:	f813 0901 	ldrb.w	r0, [r3], #-1
   1dbaa:	f802 0d02 	strb.w	r0, [r2, #-2]!
	for (int i = idx_max; i >= 0; i -= 2) {
   1dbae:	e7e0      	b.n	1db72 <usb_get_device_descriptor+0x156>
   1dbb0:	2000a32c 	.word	0x2000a32c
   1dbb4:	2000a3eb 	.word	0x2000a3eb
   1dbb8:	2000a3ec 	.word	0x2000a3ec
   1dbbc:	2000a410 	.word	0x2000a410
   1dbc0:	000269e5 	.word	0x000269e5

0001dbc4 <usb_ep_get_transfer>:
static struct usb_transfer_data ut_data[CONFIG_USB_MAX_NUM_TRANSFERS];

/* Transfer management */
static struct usb_transfer_data *usb_ep_get_transfer(uint8_t ep)
{
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dbc4:	4b09      	ldr	r3, [pc, #36]	; (1dbec <usb_ep_get_transfer+0x28>)
   1dbc6:	2100      	movs	r1, #0
   1dbc8:	461a      	mov	r2, r3
{
   1dbca:	b510      	push	{r4, lr}
		if (ut_data[i].ep == ep && ut_data[i].status != 0) {
   1dbcc:	781c      	ldrb	r4, [r3, #0]
   1dbce:	4284      	cmp	r4, r0
   1dbd0:	d104      	bne.n	1dbdc <usb_ep_get_transfer+0x18>
   1dbd2:	685c      	ldr	r4, [r3, #4]
   1dbd4:	b114      	cbz	r4, 1dbdc <usb_ep_get_transfer+0x18>
			return &ut_data[i];
   1dbd6:	eb02 1081 	add.w	r0, r2, r1, lsl #6
		}
	}

	return NULL;
}
   1dbda:	bd10      	pop	{r4, pc}
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dbdc:	3101      	adds	r1, #1
   1dbde:	2904      	cmp	r1, #4
   1dbe0:	f103 0340 	add.w	r3, r3, #64	; 0x40
   1dbe4:	d1f2      	bne.n	1dbcc <usb_ep_get_transfer+0x8>
	return NULL;
   1dbe6:	2000      	movs	r0, #0
   1dbe8:	e7f7      	b.n	1dbda <usb_ep_get_transfer+0x16>
   1dbea:	bf00      	nop
   1dbec:	2000a83c 	.word	0x2000a83c

0001dbf0 <usb_transfer_work>:

	return false;
}

static void usb_transfer_work(struct k_work *item)
{
   1dbf0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	uint8_t ep;

	trans = CONTAINER_OF(item, struct usb_transfer_data, work);
	ep = trans->ep;

	if (trans->status != -EBUSY) {
   1dbf4:	f850 3c28 	ldr.w	r3, [r0, #-40]
{
   1dbf8:	4604      	mov	r4, r0
	if (trans->status != -EBUSY) {
   1dbfa:	3310      	adds	r3, #16
	ep = trans->ep;
   1dbfc:	f810 6c2c 	ldrb.w	r6, [r0, #-44]
	if (trans->status != -EBUSY) {
   1dc00:	d110      	bne.n	1dc24 <usb_transfer_work+0x34>
		/* transfer cancelled or already completed */
		LOG_DBG("Transfer cancelled or completed, ep 0x%02x", ep);
		goto done;
	}

	if (trans->flags & USB_TRANS_WRITE) {
   1dc02:	6903      	ldr	r3, [r0, #16]
		if (!trans->bsize) {
   1dc04:	f850 2c20 	ldr.w	r2, [r0, #-32]
	if (trans->flags & USB_TRANS_WRITE) {
   1dc08:	0799      	lsls	r1, r3, #30
   1dc0a:	d53c      	bpl.n	1dc86 <usb_transfer_work+0x96>
		if (!trans->bsize) {
   1dc0c:	bb02      	cbnz	r2, 1dc50 <usb_transfer_work+0x60>
			if (!(trans->flags & USB_TRANS_NO_ZLP)) {
   1dc0e:	f013 0304 	ands.w	r3, r3, #4
   1dc12:	d104      	bne.n	1dc1e <usb_transfer_work+0x2e>
				LOG_DBG("Transfer ZLP");
				usb_write(ep, NULL, 0, NULL);
   1dc14:	461a      	mov	r2, r3
   1dc16:	4619      	mov	r1, r3
   1dc18:	4630      	mov	r0, r6
   1dc1a:	f007 f8aa 	bl	24d72 <usb_write>
			}
			trans->status = 0;
   1dc1e:	2300      	movs	r3, #0

		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
		if (ret) {
			LOG_ERR("Transfer error %d, ep 0x%02x", ret, ep);
			/* transfer error */
			trans->status = -EINVAL;
   1dc20:	f844 3c28 	str.w	r3, [r4, #-40]
		/* we expect mote data, clear NAK */
		usb_dc_ep_read_continue(ep);
	}

done:
	if (trans->status != -EBUSY && trans->cb) { /* Transfer complete */
   1dc24:	f854 3c28 	ldr.w	r3, [r4, #-40]
   1dc28:	3310      	adds	r3, #16
   1dc2a:	d00e      	beq.n	1dc4a <usb_transfer_work+0x5a>
   1dc2c:	f854 5c18 	ldr.w	r5, [r4, #-24]
   1dc30:	b15d      	cbz	r5, 1dc4a <usb_transfer_work+0x5a>
		usb_transfer_callback cb = trans->cb;
		int tsize = trans->tsize;
   1dc32:	f854 7c1c 	ldr.w	r7, [r4, #-28]
		void *priv = trans->priv;
   1dc36:	f854 8c14 	ldr.w	r8, [r4, #-20]

		if (k_is_in_isr()) {
   1dc3a:	f007 ffb4 	bl	25ba6 <k_is_in_isr>
   1dc3e:	2800      	cmp	r0, #0
   1dc40:	d04c      	beq.n	1dcdc <usb_transfer_work+0xec>
			/* reschedule completion in thread context */
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dc42:	4621      	mov	r1, r4
   1dc44:	482b      	ldr	r0, [pc, #172]	; (1dcf4 <usb_transfer_work+0x104>)
   1dc46:	f008 f8a2 	bl	25d8e <k_work_submit_to_queue>
		k_sem_give(&trans->sem);

		/* Transfer completion callback */
		cb(ep, tsize, priv);
	}
}
   1dc4a:	b002      	add	sp, #8
   1dc4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
   1dc50:	f850 1c24 	ldr.w	r1, [r0, #-36]
   1dc54:	ab01      	add	r3, sp, #4
   1dc56:	4630      	mov	r0, r6
   1dc58:	f007 f88b 	bl	24d72 <usb_write>
		if (ret) {
   1dc5c:	b110      	cbz	r0, 1dc64 <usb_transfer_work+0x74>
			trans->status = -EINVAL;
   1dc5e:	f06f 0315 	mvn.w	r3, #21
   1dc62:	e7dd      	b.n	1dc20 <usb_transfer_work+0x30>
		trans->buffer += bytes;
   1dc64:	9a01      	ldr	r2, [sp, #4]
   1dc66:	f854 3c24 	ldr.w	r3, [r4, #-36]
   1dc6a:	4413      	add	r3, r2
   1dc6c:	f844 3c24 	str.w	r3, [r4, #-36]
		trans->bsize -= bytes;
   1dc70:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1dc74:	1a9b      	subs	r3, r3, r2
   1dc76:	f844 3c20 	str.w	r3, [r4, #-32]
		trans->tsize += bytes;
   1dc7a:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   1dc7e:	4413      	add	r3, r2
   1dc80:	f844 3c1c 	str.w	r3, [r4, #-28]
   1dc84:	e7ce      	b.n	1dc24 <usb_transfer_work+0x34>
		ret = usb_dc_ep_read_wait(ep, trans->buffer, trans->bsize,
   1dc86:	f850 1c24 	ldr.w	r1, [r0, #-36]
   1dc8a:	ab01      	add	r3, sp, #4
   1dc8c:	4630      	mov	r0, r6
   1dc8e:	f001 fcb1 	bl	1f5f4 <usb_dc_ep_read_wait>
		if (ret) {
   1dc92:	2800      	cmp	r0, #0
   1dc94:	d1e3      	bne.n	1dc5e <usb_transfer_work+0x6e>
		trans->buffer += bytes;
   1dc96:	9d01      	ldr	r5, [sp, #4]
   1dc98:	f854 3c24 	ldr.w	r3, [r4, #-36]
   1dc9c:	442b      	add	r3, r5
   1dc9e:	f844 3c24 	str.w	r3, [r4, #-36]
		trans->bsize -= bytes;
   1dca2:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1dca6:	1b5b      	subs	r3, r3, r5
   1dca8:	f844 3c20 	str.w	r3, [r4, #-32]
		trans->tsize += bytes;
   1dcac:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   1dcb0:	442b      	add	r3, r5
   1dcb2:	f844 3c1c 	str.w	r3, [r4, #-28]
		if (!bytes || (bytes % usb_dc_ep_mps(ep)) || !trans->bsize) {
   1dcb6:	2d00      	cmp	r5, #0
   1dcb8:	d0b1      	beq.n	1dc1e <usb_transfer_work+0x2e>
   1dcba:	4630      	mov	r0, r6
   1dcbc:	f001 fd3e 	bl	1f73c <usb_dc_ep_mps>
   1dcc0:	fbb5 f3f0 	udiv	r3, r5, r0
   1dcc4:	fb03 5510 	mls	r5, r3, r0, r5
   1dcc8:	2d00      	cmp	r5, #0
   1dcca:	d1a8      	bne.n	1dc1e <usb_transfer_work+0x2e>
   1dccc:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1dcd0:	2b00      	cmp	r3, #0
   1dcd2:	d0a4      	beq.n	1dc1e <usb_transfer_work+0x2e>
		usb_dc_ep_read_continue(ep);
   1dcd4:	4630      	mov	r0, r6
   1dcd6:	f001 fcd5 	bl	1f684 <usb_dc_ep_read_continue>
   1dcda:	e7a3      	b.n	1dc24 <usb_transfer_work+0x34>
		trans->cb = NULL;
   1dcdc:	f844 0c18 	str.w	r0, [r4, #-24]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   1dce0:	f1a4 0010 	sub.w	r0, r4, #16
   1dce4:	f005 fc2c 	bl	23540 <z_impl_k_sem_give>
		cb(ep, tsize, priv);
   1dce8:	4642      	mov	r2, r8
   1dcea:	4639      	mov	r1, r7
   1dcec:	4630      	mov	r0, r6
   1dcee:	47a8      	blx	r5
   1dcf0:	e7ab      	b.n	1dc4a <usb_transfer_work+0x5a>
   1dcf2:	bf00      	nop
   1dcf4:	2000a410 	.word	0x2000a410

0001dcf8 <usb_transfer_ep_callback>:

void usb_transfer_ep_callback(uint8_t ep, enum usb_dc_ep_cb_status_code status)
{
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);

	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
   1dcf8:	1e4b      	subs	r3, r1, #1
   1dcfa:	2b01      	cmp	r3, #1
{
   1dcfc:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1dcfe:	4606      	mov	r6, r0
   1dd00:	460d      	mov	r5, r1
	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
   1dd02:	d80f      	bhi.n	1dd24 <usb_transfer_ep_callback+0x2c>
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);
   1dd04:	f7ff ff5e 	bl	1dbc4 <usb_ep_get_transfer>
		return;
	}

	if (!trans) {
   1dd08:	4604      	mov	r4, r0
   1dd0a:	b968      	cbnz	r0, 1dd28 <usb_transfer_ep_callback+0x30>
		if (status == USB_DC_EP_DATA_OUT) {
   1dd0c:	2d01      	cmp	r5, #1
   1dd0e:	d109      	bne.n	1dd24 <usb_transfer_ep_callback+0x2c>
			 * so drain it).
			 */
			do {
				uint8_t data;

				usb_dc_ep_read_wait(ep, &data, 1, &bytes);
   1dd10:	ab01      	add	r3, sp, #4
   1dd12:	2201      	movs	r2, #1
   1dd14:	4630      	mov	r0, r6
   1dd16:	f10d 0103 	add.w	r1, sp, #3
   1dd1a:	f001 fc6b 	bl	1f5f4 <usb_dc_ep_read_wait>
			} while (bytes);
   1dd1e:	9b01      	ldr	r3, [sp, #4]
   1dd20:	2b00      	cmp	r3, #0
   1dd22:	d1f5      	bne.n	1dd10 <usb_transfer_ep_callback+0x18>
		/* Read (out) needs to be done from ep_callback */
		usb_transfer_work(&trans->work);
	} else {
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
	}
}
   1dd24:	b002      	add	sp, #8
   1dd26:	bd70      	pop	{r4, r5, r6, pc}
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
   1dd28:	f007 ff3d 	bl	25ba6 <k_is_in_isr>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dd2c:	f104 012c 	add.w	r1, r4, #44	; 0x2c
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
   1dd30:	b108      	cbz	r0, 1dd36 <usb_transfer_ep_callback+0x3e>
   1dd32:	2d01      	cmp	r5, #1
   1dd34:	d105      	bne.n	1dd42 <usb_transfer_ep_callback+0x4a>
		usb_transfer_work(&trans->work);
   1dd36:	4608      	mov	r0, r1
}
   1dd38:	b002      	add	sp, #8
   1dd3a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		usb_transfer_work(&trans->work);
   1dd3e:	f7ff bf57 	b.w	1dbf0 <usb_transfer_work>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dd42:	4803      	ldr	r0, [pc, #12]	; (1dd50 <usb_transfer_ep_callback+0x58>)
}
   1dd44:	b002      	add	sp, #8
   1dd46:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dd4a:	f008 b820 	b.w	25d8e <k_work_submit_to_queue>
   1dd4e:	bf00      	nop
   1dd50:	2000a410 	.word	0x2000a410

0001dd54 <usb_transfer>:

int usb_transfer(uint8_t ep, uint8_t *data, size_t dlen, unsigned int flags,
		 usb_transfer_callback cb, void *cb_data)
{
   1dd54:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1dd58:	4606      	mov	r6, r0
   1dd5a:	4615      	mov	r5, r2
   1dd5c:	4698      	mov	r8, r3
   1dd5e:	9101      	str	r1, [sp, #4]
	struct usb_transfer_data *trans = NULL;
	int key, ret = 0;

	/* Parallel transfer to same endpoint is not supported. */
	if (usb_transfer_is_busy(ep)) {
   1dd60:	f007 f84d 	bl	24dfe <usb_transfer_is_busy>
   1dd64:	4604      	mov	r4, r0
   1dd66:	2800      	cmp	r0, #0
   1dd68:	d15c      	bne.n	1de24 <usb_transfer+0xd0>
	__asm__ volatile(
   1dd6a:	f04f 0320 	mov.w	r3, #32
   1dd6e:	f3ef 8a11 	mrs	sl, BASEPRI
   1dd72:	f383 8812 	msr	BASEPRI_MAX, r3
   1dd76:	f3bf 8f6f 	isb	sy
	LOG_DBG("Transfer start, ep 0x%02x, data %p, dlen %zd",
		ep, data, dlen);

	key = irq_lock();

	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dd7a:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 1de2c <usb_transfer+0xd8>
	return z_impl_k_sem_take(sem, timeout);
   1dd7e:	2200      	movs	r2, #0
   1dd80:	2300      	movs	r3, #0
   1dd82:	4658      	mov	r0, fp
   1dd84:	f005 fbfc 	bl	23580 <z_impl_k_sem_take>
		if (!k_sem_take(&ut_data[i].sem, K_NO_WAIT)) {
   1dd88:	b970      	cbnz	r0, 1dda8 <usb_transfer+0x54>
		LOG_ERR("No transfer slot available");
		ret = -ENOMEM;
		goto done;
	}

	if (trans->status == -EBUSY) {
   1dd8a:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 1de30 <usb_transfer+0xdc>
   1dd8e:	01a7      	lsls	r7, r4, #6
   1dd90:	eb09 1484 	add.w	r4, r9, r4, lsl #6
   1dd94:	6863      	ldr	r3, [r4, #4]
   1dd96:	f113 0f10 	cmn.w	r3, #16
   1dd9a:	d114      	bne.n	1ddc6 <usb_transfer+0x72>
   1dd9c:	9301      	str	r3, [sp, #4]
	z_impl_k_sem_give(sem);
   1dd9e:	4658      	mov	r0, fp
   1dda0:	f005 fbce 	bl	23540 <z_impl_k_sem_give>
		/* A transfer is already ongoing and not completed */
		LOG_ERR("A transfer is already ongoing, ep 0x%02x", ep);
		k_sem_give(&trans->sem);
		ret = -EBUSY;
		goto done;
   1dda4:	9b01      	ldr	r3, [sp, #4]
   1dda6:	e006      	b.n	1ddb6 <usb_transfer+0x62>
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dda8:	3401      	adds	r4, #1
   1ddaa:	2c04      	cmp	r4, #4
   1ddac:	f10b 0b40 	add.w	fp, fp, #64	; 0x40
   1ddb0:	d1e5      	bne.n	1dd7e <usb_transfer+0x2a>
		ret = -ENOMEM;
   1ddb2:	f06f 030b 	mvn.w	r3, #11
	__asm__ volatile(
   1ddb6:	f38a 8811 	msr	BASEPRI, sl
   1ddba:	f3bf 8f6f 	isb	sy
	}

done:
	irq_unlock(key);
	return ret;
}
   1ddbe:	4618      	mov	r0, r3
   1ddc0:	b003      	add	sp, #12
   1ddc2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	trans->buffer = data;
   1ddc6:	9b01      	ldr	r3, [sp, #4]
	trans->tsize = 0;
   1ddc8:	6120      	str	r0, [r4, #16]
	trans->bsize = dlen;
   1ddca:	e9c4 3502 	strd	r3, r5, [r4, #8]
	trans->cb = cb;
   1ddce:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
   1ddd0:	4630      	mov	r0, r6
	trans->cb = cb;
   1ddd2:	6163      	str	r3, [r4, #20]
	trans->priv = cb_data;
   1ddd4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	trans->ep = ep;
   1ddd6:	f809 6007 	strb.w	r6, [r9, r7]
	trans->priv = cb_data;
   1ddda:	61a3      	str	r3, [r4, #24]
	trans->status = -EBUSY;
   1dddc:	f06f 030f 	mvn.w	r3, #15
	trans->flags = flags;
   1dde0:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
	trans->status = -EBUSY;
   1dde4:	6063      	str	r3, [r4, #4]
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
   1dde6:	f001 fca9 	bl	1f73c <usb_dc_ep_mps>
   1ddea:	b158      	cbz	r0, 1de04 <usb_transfer+0xb0>
   1ddec:	4630      	mov	r0, r6
   1ddee:	f001 fca5 	bl	1f73c <usb_dc_ep_mps>
   1ddf2:	fbb5 f3f0 	udiv	r3, r5, r0
   1ddf6:	fb03 5510 	mls	r5, r3, r0, r5
   1ddfa:	b11d      	cbz	r5, 1de04 <usb_transfer+0xb0>
		trans->flags |= USB_TRANS_NO_ZLP;
   1ddfc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1ddfe:	f043 0304 	orr.w	r3, r3, #4
   1de02:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (flags & USB_TRANS_WRITE) {
   1de04:	f018 0f02 	tst.w	r8, #2
   1de08:	d007      	beq.n	1de1a <usb_transfer+0xc6>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de0a:	f107 012c 	add.w	r1, r7, #44	; 0x2c
   1de0e:	4809      	ldr	r0, [pc, #36]	; (1de34 <usb_transfer+0xe0>)
   1de10:	4449      	add	r1, r9
   1de12:	f007 ffbc 	bl	25d8e <k_work_submit_to_queue>
	int key, ret = 0;
   1de16:	2300      	movs	r3, #0
   1de18:	e7cd      	b.n	1ddb6 <usb_transfer+0x62>
		ret = usb_dc_ep_read_continue(ep);
   1de1a:	4630      	mov	r0, r6
   1de1c:	f001 fc32 	bl	1f684 <usb_dc_ep_read_continue>
   1de20:	4603      	mov	r3, r0
   1de22:	e7c8      	b.n	1ddb6 <usb_transfer+0x62>
		return -EBUSY;
   1de24:	f06f 030f 	mvn.w	r3, #15
   1de28:	e7c9      	b.n	1ddbe <usb_transfer+0x6a>
   1de2a:	bf00      	nop
   1de2c:	2000a858 	.word	0x2000a858
   1de30:	2000a83c 	.word	0x2000a83c
   1de34:	2000a410 	.word	0x2000a410

0001de38 <usb_cancel_transfer>:

void usb_cancel_transfer(uint8_t ep)
{
   1de38:	b510      	push	{r4, lr}
	__asm__ volatile(
   1de3a:	f04f 0320 	mov.w	r3, #32
   1de3e:	f3ef 8411 	mrs	r4, BASEPRI
   1de42:	f383 8812 	msr	BASEPRI_MAX, r3
   1de46:	f3bf 8f6f 	isb	sy
	struct usb_transfer_data *trans;
	unsigned int key;

	key = irq_lock();

	trans = usb_ep_get_transfer(ep);
   1de4a:	f7ff febb 	bl	1dbc4 <usb_ep_get_transfer>
	if (!trans) {
   1de4e:	b150      	cbz	r0, 1de66 <usb_cancel_transfer+0x2e>
		goto done;
	}

	if (trans->status != -EBUSY) {
   1de50:	6843      	ldr	r3, [r0, #4]
   1de52:	3310      	adds	r3, #16
   1de54:	d107      	bne.n	1de66 <usb_cancel_transfer+0x2e>
		goto done;
	}

	trans->status = -ECANCELED;
   1de56:	f06f 038b 	mvn.w	r3, #139	; 0x8b
	k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de5a:	f100 012c 	add.w	r1, r0, #44	; 0x2c
	trans->status = -ECANCELED;
   1de5e:	6043      	str	r3, [r0, #4]
	k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de60:	4803      	ldr	r0, [pc, #12]	; (1de70 <usb_cancel_transfer+0x38>)
   1de62:	f007 ff94 	bl	25d8e <k_work_submit_to_queue>
	__asm__ volatile(
   1de66:	f384 8811 	msr	BASEPRI, r4
   1de6a:	f3bf 8f6f 	isb	sy

done:
	irq_unlock(key);
}
   1de6e:	bd10      	pop	{r4, pc}
   1de70:	2000a410 	.word	0x2000a410

0001de74 <usb_cancel_transfers>:

void usb_cancel_transfers(void)
{
   1de74:	b570      	push	{r4, r5, r6, lr}
   1de76:	2504      	movs	r5, #4
   1de78:	4c0e      	ldr	r4, [pc, #56]	; (1deb4 <usb_cancel_transfers+0x40>)
	__asm__ volatile(
   1de7a:	f04f 0320 	mov.w	r3, #32
   1de7e:	f3ef 8611 	mrs	r6, BASEPRI
   1de82:	f383 8812 	msr	BASEPRI_MAX, r3
   1de86:	f3bf 8f6f 	isb	sy
		struct usb_transfer_data *trans = &ut_data[i];
		unsigned int key;

		key = irq_lock();

		if (trans->status == -EBUSY) {
   1de8a:	6863      	ldr	r3, [r4, #4]
   1de8c:	3310      	adds	r3, #16
   1de8e:	d107      	bne.n	1dea0 <usb_cancel_transfers+0x2c>
			trans->status = -ECANCELED;
   1de90:	f06f 038b 	mvn.w	r3, #139	; 0x8b
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de94:	4808      	ldr	r0, [pc, #32]	; (1deb8 <usb_cancel_transfers+0x44>)
			trans->status = -ECANCELED;
   1de96:	6063      	str	r3, [r4, #4]
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de98:	f104 012c 	add.w	r1, r4, #44	; 0x2c
   1de9c:	f007 ff77 	bl	25d8e <k_work_submit_to_queue>
	__asm__ volatile(
   1dea0:	f386 8811 	msr	BASEPRI, r6
   1dea4:	f3bf 8f6f 	isb	sy
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dea8:	3d01      	subs	r5, #1
   1deaa:	f104 0440 	add.w	r4, r4, #64	; 0x40
   1deae:	d1e4      	bne.n	1de7a <usb_cancel_transfers+0x6>
			LOG_DBG("Cancel transfer for ep: 0x%02x", trans->ep);
		}

		irq_unlock(key);
	}
}
   1deb0:	bd70      	pop	{r4, r5, r6, pc}
   1deb2:	bf00      	nop
   1deb4:	2000a83c 	.word	0x2000a83c
   1deb8:	2000a410 	.word	0x2000a410

0001debc <usb_transfer_init>:
	return pdata.tsize;
}

/* Init transfer slots */
int usb_transfer_init(void)
{
   1debc:	b570      	push	{r4, r5, r6, lr}
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1debe:	2500      	movs	r5, #0
   1dec0:	4c09      	ldr	r4, [pc, #36]	; (1dee8 <usb_transfer_init+0x2c>)
		k_work_init(&ut_data[i].work, usb_transfer_work);
   1dec2:	4e0a      	ldr	r6, [pc, #40]	; (1deec <usb_transfer_init+0x30>)
   1dec4:	4631      	mov	r1, r6
   1dec6:	4620      	mov	r0, r4
   1dec8:	f007 ff44 	bl	25d54 <k_work_init>
	return z_impl_k_sem_init(sem, initial_count, limit);
   1decc:	2201      	movs	r2, #1
   1dece:	f1a4 0010 	sub.w	r0, r4, #16
   1ded2:	4611      	mov	r1, r2
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1ded4:	3501      	adds	r5, #1
   1ded6:	f007 ff00 	bl	25cda <z_impl_k_sem_init>
   1deda:	2d04      	cmp	r5, #4
   1dedc:	f104 0440 	add.w	r4, r4, #64	; 0x40
   1dee0:	d1f0      	bne.n	1dec4 <usb_transfer_init+0x8>
		k_sem_init(&ut_data[i].sem, 1, 1);
	}

	return 0;
}
   1dee2:	2000      	movs	r0, #0
   1dee4:	bd70      	pop	{r4, r5, r6, pc}
   1dee6:	bf00      	nop
   1dee8:	2000a868 	.word	0x2000a868
   1deec:	0001dbf1 	.word	0x0001dbf1

0001def0 <cdc_acm_class_handle_req>:
 *
 * @return  0 on success, negative errno code on fail.
 */
int cdc_acm_class_handle_req(struct usb_setup_packet *setup,
			     int32_t *len, uint8_t **data)
{
   1def0:	b570      	push	{r4, r5, r6, lr}
   1def2:	4604      	mov	r4, r0
   1def4:	460e      	mov	r6, r1
	struct cdc_acm_dev_data_t *dev_data;
	struct usb_dev_data *common;
	uint32_t rate;
	uint32_t new_rate;

	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
   1def6:	7901      	ldrb	r1, [r0, #4]
   1def8:	4812      	ldr	r0, [pc, #72]	; (1df44 <cdc_acm_class_handle_req+0x54>)
{
   1defa:	4615      	mov	r5, r2
	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
   1defc:	f006 ff5c 	bl	24db8 <usb_get_dev_data_by_iface>
					   (uint8_t)setup->wIndex);
	if (common == NULL) {
   1df00:	b1e8      	cbz	r0, 1df3e <cdc_acm_class_handle_req+0x4e>
		return -ENODEV;
	}

	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);

	if (usb_reqtype_is_to_device(setup)) {
   1df02:	f994 2000 	ldrsb.w	r2, [r4]
		switch (setup->bRequest) {
   1df06:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_device(setup)) {
   1df08:	2a00      	cmp	r2, #0
   1df0a:	db11      	blt.n	1df30 <cdc_acm_class_handle_req+0x40>
		switch (setup->bRequest) {
   1df0c:	2b20      	cmp	r3, #32
   1df0e:	d004      	beq.n	1df1a <cdc_acm_class_handle_req+0x2a>
   1df10:	2b22      	cmp	r3, #34	; 0x22
   1df12:	d009      	beq.n	1df28 <cdc_acm_class_handle_req+0x38>
		}
	}

	LOG_DBG("CDC ACM bmRequestType 0x%02x bRequest 0x%02x unsupported",
		setup->bmRequestType, setup->bRequest);
	return -ENOTSUP;
   1df14:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1df18:	e005      	b.n	1df26 <cdc_acm_class_handle_req+0x36>
			memcpy(&dev_data->line_coding, *data,
   1df1a:	2207      	movs	r2, #7
   1df1c:	6829      	ldr	r1, [r5, #0]
   1df1e:	3810      	subs	r0, #16
   1df20:	f007 f85f 	bl	24fe2 <memcpy>
			return 0;
   1df24:	2000      	movs	r0, #0
}
   1df26:	bd70      	pop	{r4, r5, r6, pc}
			dev_data->line_state = (uint8_t)setup->wValue;
   1df28:	8863      	ldrh	r3, [r4, #2]
   1df2a:	f800 3c09 	strb.w	r3, [r0, #-9]
			return 0;
   1df2e:	e7f9      	b.n	1df24 <cdc_acm_class_handle_req+0x34>
		if (setup->bRequest == GET_LINE_CODING) {
   1df30:	2b21      	cmp	r3, #33	; 0x21
   1df32:	d1ef      	bne.n	1df14 <cdc_acm_class_handle_req+0x24>
			*len = sizeof(dev_data->line_coding);
   1df34:	2307      	movs	r3, #7
			*data = (uint8_t *)(&dev_data->line_coding);
   1df36:	3810      	subs	r0, #16
   1df38:	6028      	str	r0, [r5, #0]
			*len = sizeof(dev_data->line_coding);
   1df3a:	6033      	str	r3, [r6, #0]
			return 0;
   1df3c:	e7f2      	b.n	1df24 <cdc_acm_class_handle_req+0x34>
		return -ENODEV;
   1df3e:	f06f 0012 	mvn.w	r0, #18
   1df42:	e7f0      	b.n	1df26 <cdc_acm_class_handle_req+0x36>
   1df44:	2000a93c 	.word	0x2000a93c

0001df48 <cdc_acm_int_in>:
 *
 * @param ep        Endpoint address.
 * @param ep_status Endpoint status code.
 */
static void cdc_acm_int_in(uint8_t ep, enum usb_dc_ep_cb_status_code ep_status)
{
   1df48:	4601      	mov	r1, r0
   1df4a:	b508      	push	{r3, lr}
	struct cdc_acm_dev_data_t *dev_data;
	struct usb_dev_data *common;

	ARG_UNUSED(ep_status);

	common = usb_get_dev_data_by_ep(&cdc_acm_data_devlist, ep);
   1df4c:	4803      	ldr	r0, [pc, #12]	; (1df5c <cdc_acm_int_in+0x14>)
   1df4e:	f006 ff40 	bl	24dd2 <usb_get_dev_data_by_ep>
	if (common == NULL) {
   1df52:	b110      	cbz	r0, 1df5a <cdc_acm_int_in+0x12>
		return;
	}

	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);

	dev_data->notification_sent = 1U;
   1df54:	2301      	movs	r3, #1
   1df56:	f800 3c07 	strb.w	r3, [r0, #-7]
	LOG_DBG("CDC_IntIN EP[%x]\r", ep);
}
   1df5a:	bd08      	pop	{r3, pc}
   1df5c:	2000a93c 	.word	0x2000a93c

0001df60 <cdc_acm_irq_rx_enable>:
 */
static void cdc_acm_irq_rx_enable(const struct device *dev)
{
	struct cdc_acm_dev_data_t * const dev_data = dev->data;

	dev_data->rx_irq_ena = true;
   1df60:	2301      	movs	r3, #1
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1df62:	6901      	ldr	r1, [r0, #16]
	dev_data->rx_irq_ena = true;
   1df64:	f881 304b 	strb.w	r3, [r1, #75]	; 0x4b

	if (dev_data->cb && dev_data->rx_ready) {
   1df68:	680b      	ldr	r3, [r1, #0]
   1df6a:	b133      	cbz	r3, 1df7a <cdc_acm_irq_rx_enable+0x1a>
   1df6c:	f891 3049 	ldrb.w	r3, [r1, #73]	; 0x49
   1df70:	b11b      	cbz	r3, 1df7a <cdc_acm_irq_rx_enable+0x1a>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1df72:	4802      	ldr	r0, [pc, #8]	; (1df7c <cdc_acm_irq_rx_enable+0x1c>)
   1df74:	3108      	adds	r1, #8
   1df76:	f007 bf0a 	b.w	25d8e <k_work_submit_to_queue>
	}
}
   1df7a:	4770      	bx	lr
   1df7c:	2000a410 	.word	0x2000a410

0001df80 <cdc_acm_irq_tx_enable>:
	dev_data->tx_irq_ena = true;
   1df80:	2301      	movs	r3, #1
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1df82:	6901      	ldr	r1, [r0, #16]
	dev_data->tx_irq_ena = true;
   1df84:	f881 304a 	strb.w	r3, [r1, #74]	; 0x4a
	if (dev_data->cb && dev_data->tx_ready) {
   1df88:	680b      	ldr	r3, [r1, #0]
   1df8a:	b133      	cbz	r3, 1df9a <cdc_acm_irq_tx_enable+0x1a>
   1df8c:	f891 3048 	ldrb.w	r3, [r1, #72]	; 0x48
   1df90:	b11b      	cbz	r3, 1df9a <cdc_acm_irq_tx_enable+0x1a>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1df92:	4802      	ldr	r0, [pc, #8]	; (1df9c <cdc_acm_irq_tx_enable+0x1c>)
   1df94:	3108      	adds	r1, #8
   1df96:	f007 befa 	b.w	25d8e <k_work_submit_to_queue>
}
   1df9a:	4770      	bx	lr
   1df9c:	2000a410 	.word	0x2000a410

0001dfa0 <cdc_acm_reset_port>:
	dev_data->tx_ready = false;
   1dfa0:	2100      	movs	r1, #0
{
   1dfa2:	4603      	mov	r3, r0
	dev_data->line_coding = (struct cdc_acm_line_coding)
   1dfa4:	4a0c      	ldr	r2, [pc, #48]	; (1dfd8 <cdc_acm_reset_port+0x38>)
	dev_data->tx_ready = false;
   1dfa6:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
	dev_data->line_coding = (struct cdc_acm_line_coding)
   1dfaa:	6810      	ldr	r0, [r2, #0]
	dev_data->serial_state = 0;
   1dfac:	f883 109c 	strb.w	r1, [r3, #156]	; 0x9c
	dev_data->line_coding = (struct cdc_acm_line_coding)
   1dfb0:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
   1dfb4:	8890      	ldrh	r0, [r2, #4]
   1dfb6:	7992      	ldrb	r2, [r2, #6]
   1dfb8:	f8a3 0098 	strh.w	r0, [r3, #152]	; 0x98
   1dfbc:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
	dev_data->line_state = 0;
   1dfc0:	f883 109b 	strb.w	r1, [r3, #155]	; 0x9b
	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
   1dfc4:	2240      	movs	r2, #64	; 0x40
	dev_data->configured = false;
   1dfc6:	f8a3 109e 	strh.w	r1, [r3, #158]	; 0x9e
	dev_data->rx_paused = false;
   1dfca:	f883 10a0 	strb.w	r1, [r3, #160]	; 0xa0
	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
   1dfce:	f103 004c 	add.w	r0, r3, #76	; 0x4c
   1dfd2:	f007 b811 	b.w	24ff8 <memset>
   1dfd6:	bf00      	nop
   1dfd8:	00026630 	.word	0x00026630

0001dfdc <cdc_acm_fifo_fill>:
{
   1dfdc:	b538      	push	{r3, r4, r5, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1dfde:	6905      	ldr	r5, [r0, #16]
	if (!dev_data->configured || dev_data->suspended) {
   1dfe0:	f895 009e 	ldrb.w	r0, [r5, #158]	; 0x9e
   1dfe4:	b188      	cbz	r0, 1e00a <cdc_acm_fifo_fill+0x2e>
   1dfe6:	f895 309f 	ldrb.w	r3, [r5, #159]	; 0x9f
   1dfea:	b97b      	cbnz	r3, 1e00c <cdc_acm_fifo_fill+0x30>
	dev_data->tx_ready = false;
   1dfec:	f885 3048 	strb.w	r3, [r5, #72]	; 0x48
	wrote = ring_buf_put(dev_data->tx_ringbuf, tx_data, len);
   1dff0:	f8d5 0090 	ldr.w	r0, [r5, #144]	; 0x90
   1dff4:	f006 fddf 	bl	24bb6 <ring_buf_put>
   1dff8:	4604      	mov	r4, r0
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_NO_WAIT);
   1dffa:	2200      	movs	r2, #0
   1dffc:	2300      	movs	r3, #0
   1dffe:	4804      	ldr	r0, [pc, #16]	; (1e010 <cdc_acm_fifo_fill+0x34>)
   1e000:	f105 0118 	add.w	r1, r5, #24
   1e004:	f005 fc30 	bl	23868 <k_work_schedule_for_queue>
	return wrote;
   1e008:	4620      	mov	r0, r4
}
   1e00a:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   1e00c:	2000      	movs	r0, #0
   1e00e:	e7fc      	b.n	1e00a <cdc_acm_fifo_fill+0x2e>
   1e010:	2000a410 	.word	0x2000a410

0001e014 <cdc_acm_poll_out>:
 * is not ready, no data is transferred to the buffer, that is, c is dropped.
 * If the USB subsystem is ready and the buffer is full, the first character
 * from the tx_ringbuf is removed to make room for the new character.
 */
static void cdc_acm_poll_out(const struct device *dev, unsigned char c)
{
   1e014:	b513      	push	{r0, r1, r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1e016:	6904      	ldr	r4, [r0, #16]
{
   1e018:	f88d 1007 	strb.w	r1, [sp, #7]

	if (!dev_data->configured || dev_data->suspended) {
   1e01c:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
   1e020:	b1a3      	cbz	r3, 1e04c <cdc_acm_poll_out+0x38>
   1e022:	f894 309f 	ldrb.w	r3, [r4, #159]	; 0x9f
   1e026:	b98b      	cbnz	r3, 1e04c <cdc_acm_poll_out+0x38>
		return;
	}

	dev_data->tx_ready = false;

	if (!ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
   1e028:	f10d 0107 	add.w	r1, sp, #7
   1e02c:	2201      	movs	r2, #1
   1e02e:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
	dev_data->tx_ready = false;
   1e032:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	if (!ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
   1e036:	f006 fdbe 	bl	24bb6 <ring_buf_put>
   1e03a:	4601      	mov	r1, r0
   1e03c:	b140      	cbz	r0, 1e050 <cdc_acm_poll_out+0x3c>

	/* Schedule with minimal timeout to make it possible to send more than
	 * one byte per USB transfer. The latency increase is negligible while
	 * the increased throughput and reduced CPU usage is easily observable.
	 */
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_MSEC(1));
   1e03e:	2221      	movs	r2, #33	; 0x21
   1e040:	2300      	movs	r3, #0
   1e042:	480c      	ldr	r0, [pc, #48]	; (1e074 <cdc_acm_poll_out+0x60>)
   1e044:	f104 0118 	add.w	r1, r4, #24
   1e048:	f005 fc0e 	bl	23868 <k_work_schedule_for_queue>
}
   1e04c:	b002      	add	sp, #8
   1e04e:	bd10      	pop	{r4, pc}
		if (!ring_buf_get(dev_data->tx_ringbuf, NULL, 1) ||
   1e050:	2201      	movs	r2, #1
   1e052:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
   1e056:	f006 fdfe 	bl	24c56 <ring_buf_get>
   1e05a:	2800      	cmp	r0, #0
   1e05c:	d0f6      	beq.n	1e04c <cdc_acm_poll_out+0x38>
		    !ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
   1e05e:	2201      	movs	r2, #1
   1e060:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
   1e064:	f10d 0107 	add.w	r1, sp, #7
   1e068:	f006 fda5 	bl	24bb6 <ring_buf_put>
		if (!ring_buf_get(dev_data->tx_ringbuf, NULL, 1) ||
   1e06c:	2800      	cmp	r0, #0
   1e06e:	d1e6      	bne.n	1e03e <cdc_acm_poll_out+0x2a>
   1e070:	e7ec      	b.n	1e04c <cdc_acm_poll_out+0x38>
   1e072:	bf00      	nop
   1e074:	2000a410 	.word	0x2000a410

0001e078 <tx_work_handler>:
{
   1e078:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct usb_cfg_data *cfg = (void *)dev->config;
   1e07a:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
{
   1e07e:	4605      	mov	r5, r0
	uint8_t ep = cfg->endpoint[ACM_IN_EP_IDX].ep_addr;
   1e080:	685b      	ldr	r3, [r3, #4]
{
   1e082:	b085      	sub	sp, #20
	uint8_t ep = cfg->endpoint[ACM_IN_EP_IDX].ep_addr;
   1e084:	6a1b      	ldr	r3, [r3, #32]
   1e086:	7d1f      	ldrb	r7, [r3, #20]
	if (usb_transfer_is_busy(ep)) {
   1e088:	4638      	mov	r0, r7
   1e08a:	f006 feb8 	bl	24dfe <usb_transfer_is_busy>
   1e08e:	4606      	mov	r6, r0
   1e090:	b9e0      	cbnz	r0, 1e0cc <tx_work_handler+0x54>
	len = ring_buf_get_claim(dev_data->tx_ringbuf, &data,
   1e092:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1e096:	6fa8      	ldr	r0, [r5, #120]	; 0x78
   1e098:	a903      	add	r1, sp, #12
   1e09a:	f006 fdab 	bl	24bf4 <ring_buf_get_claim>
	if (!len) {
   1e09e:	4604      	mov	r4, r0
   1e0a0:	b1a0      	cbz	r0, 1e0cc <tx_work_handler+0x54>
	if (!(len % CONFIG_CDC_ACM_BULK_EP_MPS)) {
   1e0a2:	0683      	lsls	r3, r0, #26
	struct cdc_acm_dev_data_t *dev_data =
   1e0a4:	f1a5 0318 	sub.w	r3, r5, #24
	dev_data->tx_ready = false;
   1e0a8:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
	usb_transfer(ep, data, len, USB_TRANS_WRITE,
   1e0ac:	9301      	str	r3, [sp, #4]
   1e0ae:	4b08      	ldr	r3, [pc, #32]	; (1e0d0 <tx_work_handler+0x58>)
		len -= 1;
   1e0b0:	bf08      	it	eq
   1e0b2:	f100 34ff 	addeq.w	r4, r0, #4294967295	; 0xffffffff
	usb_transfer(ep, data, len, USB_TRANS_WRITE,
   1e0b6:	9903      	ldr	r1, [sp, #12]
   1e0b8:	9300      	str	r3, [sp, #0]
   1e0ba:	4622      	mov	r2, r4
   1e0bc:	2302      	movs	r3, #2
   1e0be:	4638      	mov	r0, r7
   1e0c0:	f7ff fe48 	bl	1dd54 <usb_transfer>
	ring_buf_get_finish(dev_data->tx_ringbuf, len);
   1e0c4:	4621      	mov	r1, r4
   1e0c6:	6fa8      	ldr	r0, [r5, #120]	; 0x78
   1e0c8:	f006 fdb0 	bl	24c2c <ring_buf_get_finish>
}
   1e0cc:	b005      	add	sp, #20
   1e0ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e0d0:	0001e0d5 	.word	0x0001e0d5

0001e0d4 <cdc_acm_write_cb>:
	dev_data->tx_ready = true;
   1e0d4:	2301      	movs	r3, #1
{
   1e0d6:	b510      	push	{r4, lr}
	dev_data->tx_ready = true;
   1e0d8:	f882 3048 	strb.w	r3, [r2, #72]	; 0x48
	if (dev_data->cb && dev_data->tx_irq_ena) {
   1e0dc:	6813      	ldr	r3, [r2, #0]
{
   1e0de:	4614      	mov	r4, r2
	if (dev_data->cb && dev_data->tx_irq_ena) {
   1e0e0:	b13b      	cbz	r3, 1e0f2 <cdc_acm_write_cb+0x1e>
   1e0e2:	f892 304a 	ldrb.w	r3, [r2, #74]	; 0x4a
   1e0e6:	b123      	cbz	r3, 1e0f2 <cdc_acm_write_cb+0x1e>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e0e8:	480a      	ldr	r0, [pc, #40]	; (1e114 <cdc_acm_write_cb+0x40>)
   1e0ea:	f102 0108 	add.w	r1, r2, #8
   1e0ee:	f007 fe4e 	bl	25d8e <k_work_submit_to_queue>
	if (ring_buf_is_empty(dev_data->tx_ringbuf)) {
   1e0f2:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   1e0f6:	689a      	ldr	r2, [r3, #8]
   1e0f8:	691b      	ldr	r3, [r3, #16]
   1e0fa:	429a      	cmp	r2, r3
   1e0fc:	d008      	beq.n	1e110 <cdc_acm_write_cb+0x3c>
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_NO_WAIT);
   1e0fe:	f104 0118 	add.w	r1, r4, #24
   1e102:	2200      	movs	r2, #0
}
   1e104:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_NO_WAIT);
   1e108:	2300      	movs	r3, #0
   1e10a:	4802      	ldr	r0, [pc, #8]	; (1e114 <cdc_acm_write_cb+0x40>)
   1e10c:	f005 bbac 	b.w	23868 <k_work_schedule_for_queue>
}
   1e110:	bd10      	pop	{r4, pc}
   1e112:	bf00      	nop
   1e114:	2000a410 	.word	0x2000a410

0001e118 <cdc_acm_init>:
	parent->next = child;
   1e118:	2300      	movs	r3, #0
{
   1e11a:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1e11c:	6904      	ldr	r4, [r0, #16]
   1e11e:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
   1e122:	4b0c      	ldr	r3, [pc, #48]	; (1e154 <cdc_acm_init+0x3c>)
	dev_data->common.dev = dev;
   1e124:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
   1e128:	6859      	ldr	r1, [r3, #4]
	sys_slist_append(&cdc_acm_data_devlist, &dev_data->common.node);
   1e12a:	f104 02a8 	add.w	r2, r4, #168	; 0xa8
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   1e12e:	b969      	cbnz	r1, 1e14c <cdc_acm_init+0x34>
	list->head = node;
   1e130:	e9c3 2200 	strd	r2, r2, [r3]
	k_work_init(&dev_data->cb_work, cdc_acm_irq_callback_work_handler);
   1e134:	f104 0008 	add.w	r0, r4, #8
   1e138:	4907      	ldr	r1, [pc, #28]	; (1e158 <cdc_acm_init+0x40>)
   1e13a:	f007 fe0b 	bl	25d54 <k_work_init>
	k_work_init_delayable(&dev_data->tx_work, tx_work_handler);
   1e13e:	f104 0018 	add.w	r0, r4, #24
   1e142:	4906      	ldr	r1, [pc, #24]	; (1e15c <cdc_acm_init+0x44>)
   1e144:	f007 fe34 	bl	25db0 <k_work_init_delayable>
}
   1e148:	2000      	movs	r0, #0
   1e14a:	bd10      	pop	{r4, pc}
	parent->next = child;
   1e14c:	600a      	str	r2, [r1, #0]
	list->tail = node;
   1e14e:	605a      	str	r2, [r3, #4]
}
   1e150:	e7f0      	b.n	1e134 <cdc_acm_init+0x1c>
   1e152:	bf00      	nop
   1e154:	2000a93c 	.word	0x2000a93c
   1e158:	00024e29 	.word	0x00024e29
   1e15c:	0001e079 	.word	0x0001e079

0001e160 <cdc_acm_read_cb>:
{
   1e160:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1e162:	4614      	mov	r4, r2
	wrote = ring_buf_put(dev_data->rx_ringbuf, dev_data->rx_buf, size);
   1e164:	f102 064c 	add.w	r6, r2, #76	; 0x4c
	if (size <= 0) {
   1e168:	1e0a      	subs	r2, r1, #0
{
   1e16a:	4605      	mov	r5, r0
	if (size <= 0) {
   1e16c:	dd1f      	ble.n	1e1ae <cdc_acm_read_cb+0x4e>
	wrote = ring_buf_put(dev_data->rx_ringbuf, dev_data->rx_buf, size);
   1e16e:	4631      	mov	r1, r6
   1e170:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   1e174:	f006 fd1f 	bl	24bb6 <ring_buf_put>
	dev_data->rx_ready = true;
   1e178:	2301      	movs	r3, #1
   1e17a:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
	if (dev_data->cb && dev_data->rx_irq_ena) {
   1e17e:	6823      	ldr	r3, [r4, #0]
   1e180:	b13b      	cbz	r3, 1e192 <cdc_acm_read_cb+0x32>
   1e182:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
   1e186:	b123      	cbz	r3, 1e192 <cdc_acm_read_cb+0x32>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e188:	480e      	ldr	r0, [pc, #56]	; (1e1c4 <cdc_acm_read_cb+0x64>)
   1e18a:	f104 0108 	add.w	r1, r4, #8
   1e18e:	f007 fdfe 	bl	25d8e <k_work_submit_to_queue>
	if (ring_buf_space_get(dev_data->rx_ringbuf) < sizeof(dev_data->rx_buf)) {
   1e192:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 *
 * @return Ring buffer free space (in bytes).
 */
static inline uint32_t ring_buf_space_get(struct ring_buf *buf)
{
	return buf->size - (buf->put_head - buf->get_tail);
   1e196:	684b      	ldr	r3, [r1, #4]
   1e198:	694a      	ldr	r2, [r1, #20]
   1e19a:	1a9a      	subs	r2, r3, r2
   1e19c:	69cb      	ldr	r3, [r1, #28]
   1e19e:	1a9b      	subs	r3, r3, r2
   1e1a0:	2b3f      	cmp	r3, #63	; 0x3f
   1e1a2:	d804      	bhi.n	1e1ae <cdc_acm_read_cb+0x4e>
		dev_data->rx_paused = true;
   1e1a4:	2301      	movs	r3, #1
   1e1a6:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
}
   1e1aa:	b002      	add	sp, #8
   1e1ac:	bd70      	pop	{r4, r5, r6, pc}
	usb_transfer(ep, dev_data->rx_buf, sizeof(dev_data->rx_buf),
   1e1ae:	4b06      	ldr	r3, [pc, #24]	; (1e1c8 <cdc_acm_read_cb+0x68>)
   1e1b0:	2240      	movs	r2, #64	; 0x40
   1e1b2:	9300      	str	r3, [sp, #0]
   1e1b4:	4631      	mov	r1, r6
   1e1b6:	2301      	movs	r3, #1
   1e1b8:	4628      	mov	r0, r5
   1e1ba:	9401      	str	r4, [sp, #4]
   1e1bc:	f7ff fdca 	bl	1dd54 <usb_transfer>
   1e1c0:	e7f3      	b.n	1e1aa <cdc_acm_read_cb+0x4a>
   1e1c2:	bf00      	nop
   1e1c4:	2000a410 	.word	0x2000a410
   1e1c8:	0001e161 	.word	0x0001e161

0001e1cc <cdc_acm_dev_status_cb>:
{
   1e1cc:	b538      	push	{r3, r4, r5, lr}
   1e1ce:	460d      	mov	r5, r1
	common = usb_get_dev_data_by_cfg(&cdc_acm_data_devlist, cfg);
   1e1d0:	4601      	mov	r1, r0
   1e1d2:	481e      	ldr	r0, [pc, #120]	; (1e24c <cdc_acm_dev_status_cb+0x80>)
   1e1d4:	f006 fde5 	bl	24da2 <usb_get_dev_data_by_cfg>
	if (common == NULL) {
   1e1d8:	4604      	mov	r4, r0
   1e1da:	b380      	cbz	r0, 1e23e <cdc_acm_dev_status_cb+0x72>
	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);
   1e1dc:	4602      	mov	r2, r0
	struct usb_cfg_data *cfg = (void *)dev->config;
   1e1de:	f852 39a4 	ldr.w	r3, [r2], #-164
	switch (status) {
   1e1e2:	1e69      	subs	r1, r5, #1
	struct usb_cfg_data *cfg = (void *)dev->config;
   1e1e4:	685b      	ldr	r3, [r3, #4]
	switch (status) {
   1e1e6:	2905      	cmp	r1, #5
   1e1e8:	d829      	bhi.n	1e23e <cdc_acm_dev_status_cb+0x72>
   1e1ea:	e8df f001 	tbb	[pc, r1]
   1e1ee:	2820      	.short	0x2820
   1e1f0:	29252003 	.word	0x29252003
		if (!dev_data->configured) {
   1e1f4:	f814 1c06 	ldrb.w	r1, [r4, #-6]
   1e1f8:	b931      	cbnz	r1, 1e208 <cdc_acm_dev_status_cb+0x3c>
			cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr, 0,
   1e1fa:	6a1b      	ldr	r3, [r3, #32]
   1e1fc:	7b18      	ldrb	r0, [r3, #12]
   1e1fe:	f7ff ffaf 	bl	1e160 <cdc_acm_read_cb>
			dev_data->configured = true;
   1e202:	2301      	movs	r3, #1
   1e204:	f804 3c06 	strb.w	r3, [r4, #-6]
		if (!dev_data->tx_ready) {
   1e208:	f814 3c5c 	ldrb.w	r3, [r4, #-92]
   1e20c:	b9bb      	cbnz	r3, 1e23e <cdc_acm_dev_status_cb+0x72>
			dev_data->tx_ready = true;
   1e20e:	2301      	movs	r3, #1
   1e210:	f804 3c5c 	strb.w	r3, [r4, #-92]
			if (dev_data->cb != NULL && dev_data->tx_irq_ena) {
   1e214:	f854 3ca4 	ldr.w	r3, [r4, #-164]
   1e218:	b18b      	cbz	r3, 1e23e <cdc_acm_dev_status_cb+0x72>
   1e21a:	f814 3c5a 	ldrb.w	r3, [r4, #-90]
   1e21e:	b173      	cbz	r3, 1e23e <cdc_acm_dev_status_cb+0x72>
				k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e220:	f1a4 019c 	sub.w	r1, r4, #156	; 0x9c
   1e224:	480a      	ldr	r0, [pc, #40]	; (1e250 <cdc_acm_dev_status_cb+0x84>)
}
   1e226:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e22a:	f007 bdb0 	b.w	25d8e <k_work_submit_to_queue>
		cdc_acm_reset_port(dev_data);
   1e22e:	4610      	mov	r0, r2
}
   1e230:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		cdc_acm_reset_port(dev_data);
   1e234:	f7ff beb4 	b.w	1dfa0 <cdc_acm_reset_port>
		dev_data->suspended = true;
   1e238:	2301      	movs	r3, #1
			dev_data->suspended = false;
   1e23a:	f804 3c05 	strb.w	r3, [r4, #-5]
}
   1e23e:	bd38      	pop	{r3, r4, r5, pc}
		if (dev_data->suspended) {
   1e240:	f814 3c05 	ldrb.w	r3, [r4, #-5]
   1e244:	2b00      	cmp	r3, #0
   1e246:	d0fa      	beq.n	1e23e <cdc_acm_dev_status_cb+0x72>
			dev_data->suspended = false;
   1e248:	2300      	movs	r3, #0
   1e24a:	e7f6      	b.n	1e23a <cdc_acm_dev_status_cb+0x6e>
   1e24c:	2000a93c 	.word	0x2000a93c
   1e250:	2000a410 	.word	0x2000a410

0001e254 <z_usb_work_q_init>:
K_KERNEL_STACK_DEFINE(z_usb_work_q_stack, CONFIG_USB_WORKQUEUE_STACK_SIZE);

struct k_work_q z_usb_work_q;

static int z_usb_work_q_init(void)
{
   1e254:	b537      	push	{r0, r1, r2, r4, r5, lr}

	k_work_queue_start(&z_usb_work_q,
   1e256:	2400      	movs	r4, #0
   1e258:	4d08      	ldr	r5, [pc, #32]	; (1e27c <z_usb_work_q_init+0x28>)
   1e25a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1e25e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1e262:	4628      	mov	r0, r5
   1e264:	4906      	ldr	r1, [pc, #24]	; (1e280 <z_usb_work_q_init+0x2c>)
   1e266:	9400      	str	r4, [sp, #0]
   1e268:	f005 fac6 	bl	237f8 <k_work_queue_start>
	return z_impl_k_thread_name_set(thread, str);
   1e26c:	4905      	ldr	r1, [pc, #20]	; (1e284 <z_usb_work_q_init+0x30>)
   1e26e:	4628      	mov	r0, r5
   1e270:	f007 fc9f 	bl	25bb2 <z_impl_k_thread_name_set>
			   K_KERNEL_STACK_SIZEOF(z_usb_work_q_stack),
			   CONFIG_USB_WORKQUEUE_PRIORITY, NULL);
	k_thread_name_set(&z_usb_work_q.thread, "usbworkq");

	return 0;
}
   1e274:	4620      	mov	r0, r4
   1e276:	b003      	add	sp, #12
   1e278:	bd30      	pop	{r4, r5, pc}
   1e27a:	bf00      	nop
   1e27c:	2000a410 	.word	0x2000a410
   1e280:	2000b640 	.word	0x2000b640
   1e284:	00026a2b 	.word	0x00026a2b

0001e288 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   1e288:	4901      	ldr	r1, [pc, #4]	; (1e290 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   1e28a:	2210      	movs	r2, #16
	str	r2, [r1]
   1e28c:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   1e28e:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   1e290:	e000ed10 	.word	0xe000ed10

0001e294 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   1e294:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   1e296:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   1e298:	f380 8811 	msr	BASEPRI, r0
	isb
   1e29c:	f3bf 8f6f 	isb	sy
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
   1e2a0:	b501      	push	{r0, lr}
   1e2a2:	f7fe fde9 	bl	1ce78 <z_arm_on_enter_cpu_idle>
   1e2a6:	2800      	cmp	r0, #0
   1e2a8:	d002      	beq.n	1e2b0 <_skip_0>
   1e2aa:	f3bf 8f4f 	dsb	sy
   1e2ae:	bf30      	wfi

0001e2b0 <_skip_0>:
   1e2b0:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   1e2b4:	b662      	cpsie	i
	isb
   1e2b6:	f3bf 8f6f 	isb	sy

	bx	lr
   1e2ba:	4770      	bx	lr

0001e2bc <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   1e2bc:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   1e2be:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   1e2c0:	f381 8811 	msr	BASEPRI, r1

	_sleep_if_allowed wfe
   1e2c4:	b501      	push	{r0, lr}
   1e2c6:	f7fe fdd7 	bl	1ce78 <z_arm_on_enter_cpu_idle>
   1e2ca:	2800      	cmp	r0, #0
   1e2cc:	d002      	beq.n	1e2d4 <_skip_1>
   1e2ce:	f3bf 8f4f 	dsb	sy
   1e2d2:	bf20      	wfe

0001e2d4 <_skip_1>:
   1e2d4:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

	msr	BASEPRI, r0
   1e2d8:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   1e2dc:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   1e2de:	4770      	bx	lr

0001e2e0 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   1e2e0:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   1e2e2:	2800      	cmp	r0, #0
   1e2e4:	db07      	blt.n	1e2f6 <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1e2e6:	2301      	movs	r3, #1
   1e2e8:	0941      	lsrs	r1, r0, #5
   1e2ea:	4a03      	ldr	r2, [pc, #12]	; (1e2f8 <arch_irq_enable+0x18>)
   1e2ec:	f000 001f 	and.w	r0, r0, #31
   1e2f0:	4083      	lsls	r3, r0
   1e2f2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
   1e2f6:	4770      	bx	lr
   1e2f8:	e000e100 	.word	0xe000e100

0001e2fc <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
   1e2fc:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   1e2fe:	2800      	cmp	r0, #0
   1e300:	db0c      	blt.n	1e31c <arch_irq_disable+0x20>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1e302:	2201      	movs	r2, #1
   1e304:	4906      	ldr	r1, [pc, #24]	; (1e320 <arch_irq_disable+0x24>)
   1e306:	0943      	lsrs	r3, r0, #5
   1e308:	f000 001f 	and.w	r0, r0, #31
   1e30c:	4082      	lsls	r2, r0
   1e30e:	3320      	adds	r3, #32
   1e310:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   1e314:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e318:	f3bf 8f6f 	isb	sy
}
   1e31c:	4770      	bx	lr
   1e31e:	bf00      	nop
   1e320:	e000e100 	.word	0xe000e100

0001e324 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   1e324:	4b05      	ldr	r3, [pc, #20]	; (1e33c <arch_irq_is_enabled+0x18>)
   1e326:	0942      	lsrs	r2, r0, #5
   1e328:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   1e32c:	2301      	movs	r3, #1
   1e32e:	f000 001f 	and.w	r0, r0, #31
   1e332:	fa03 f000 	lsl.w	r0, r3, r0
}
   1e336:	4010      	ands	r0, r2
   1e338:	4770      	bx	lr
   1e33a:	bf00      	nop
   1e33c:	e000e100 	.word	0xe000e100

0001e340 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   1e340:	b240      	sxtb	r0, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   1e342:	2800      	cmp	r0, #0
		prio += _IRQ_PRIO_OFFSET;
   1e344:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e348:	bfac      	ite	ge
   1e34a:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e34e:	4b06      	ldrlt	r3, [pc, #24]	; (1e368 <z_arm_irq_priority_set+0x28>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e350:	ea4f 1141 	mov.w	r1, r1, lsl #5
   1e354:	b2c9      	uxtb	r1, r1
   1e356:	bfab      	itete	ge
   1e358:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e35c:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e360:	f880 1300 	strbge.w	r1, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e364:	5419      	strblt	r1, [r3, r0]
}
   1e366:	4770      	bx	lr
   1e368:	e000ed14 	.word	0xe000ed14

0001e36c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   1e36c:	bf30      	wfi
    b z_SysNmiOnReset
   1e36e:	f7ff bffd 	b.w	1e36c <z_SysNmiOnReset>
   1e372:	bf00      	nop

0001e374 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   1e374:	4a0b      	ldr	r2, [pc, #44]	; (1e3a4 <z_arm_prep_c+0x30>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
   1e376:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   1e378:	4b0b      	ldr	r3, [pc, #44]	; (1e3a8 <z_arm_prep_c+0x34>)
   1e37a:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   1e37e:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
   1e380:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e384:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   1e388:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e38c:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   1e390:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   1e394:	f004 fe28 	bl	22fe8 <z_bss_zero>
	z_data_copy();
   1e398:	f005 fdfe 	bl	23f98 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   1e39c:	f000 fa08 	bl	1e7b0 <z_arm_interrupt_init>
	z_cstart();
   1e3a0:	f004 fe62 	bl	23068 <z_cstart>
   1e3a4:	0001c000 	.word	0x0001c000
   1e3a8:	e000ed00 	.word	0xe000ed00

0001e3ac <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   1e3ac:	4a09      	ldr	r2, [pc, #36]	; (1e3d4 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   1e3ae:	490a      	ldr	r1, [pc, #40]	; (1e3d8 <arch_swap+0x2c>)
	_current->arch.basepri = key;
   1e3b0:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   1e3b2:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   1e3b4:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
   1e3b6:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1e3b8:	4908      	ldr	r1, [pc, #32]	; (1e3dc <arch_swap+0x30>)
   1e3ba:	684b      	ldr	r3, [r1, #4]
   1e3bc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   1e3c0:	604b      	str	r3, [r1, #4]
   1e3c2:	2300      	movs	r3, #0
   1e3c4:	f383 8811 	msr	BASEPRI, r3
   1e3c8:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   1e3cc:	6893      	ldr	r3, [r2, #8]
}
   1e3ce:	6f98      	ldr	r0, [r3, #120]	; 0x78
   1e3d0:	4770      	bx	lr
   1e3d2:	bf00      	nop
   1e3d4:	2000b5c0 	.word	0x2000b5c0
   1e3d8:	0002697c 	.word	0x0002697c
   1e3dc:	e000ed00 	.word	0xe000ed00

0001e3e0 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   1e3e0:	4915      	ldr	r1, [pc, #84]	; (1e438 <z_arm_pendsv+0x58>)
    ldr r2, [r1, #_kernel_offset_to_current]
   1e3e2:	688a      	ldr	r2, [r1, #8]

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
   1e3e4:	f882 e07d 	strb.w	lr, [r2, #125]	; 0x7d
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   1e3e8:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   1e3ec:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   1e3ee:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   1e3f2:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   1e3f6:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   1e3f8:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   1e3fc:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   1e400:	4f0e      	ldr	r7, [pc, #56]	; (1e43c <z_arm_pendsv+0x5c>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   1e402:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   1e406:	698a      	ldr	r2, [r1, #24]

    str r2, [r1, #_kernel_offset_to_current]
   1e408:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   1e40a:	603e      	str	r6, [r7, #0]

#endif

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Restore EXC_RETURN value. */
    ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
   1e40c:	f992 e07d 	ldrsb.w	lr, [r2, #125]	; 0x7d

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   1e410:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
   1e412:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   1e414:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   1e416:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   1e41a:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   1e41e:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   1e422:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   1e426:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   1e42a:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   1e42c:	f006 fd9d 	bl	24f6a <configure_builtin_stack_guard>
    pop {r2, lr}
   1e430:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   1e434:	4770      	bx	lr
   1e436:	0000      	.short	0x0000
    ldr r1, =_kernel
   1e438:	2000b5c0 	.word	0x2000b5c0
    ldr v4, =_SCS_ICSR
   1e43c:	e000ed04 	.word	0xe000ed04

0001e440 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   1e440:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   1e444:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   1e446:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   1e44a:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   1e44e:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   1e450:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   1e454:	2902      	cmp	r1, #2
    beq _oops
   1e456:	d0ff      	beq.n	1e458 <_oops>

0001e458 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   1e458:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
   1e45a:	f006 fd77 	bl	24f4c <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
   1e45e:	bd01      	pop	{r0, pc}

0001e460 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   1e460:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   1e464:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
   1e466:	490c      	ldr	r1, [pc, #48]	; (1e498 <arch_new_thread+0x38>)
	iframe->a2 = (uint32_t)p1;
   1e468:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   1e46c:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
   1e46e:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
   1e472:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   1e476:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
   1e478:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
   1e47c:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   1e480:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   1e484:	f842 3c04 	str.w	r3, [r2, #-4]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   1e488:	2300      	movs	r3, #0
   1e48a:	6743      	str	r3, [r0, #116]	; 0x74

#if defined(CONFIG_ARM_STORE_EXC_RETURN) || defined(CONFIG_USERSPACE)
	thread->arch.mode = 0;
   1e48c:	f44f 433c 	mov.w	r3, #48128	; 0xbc00
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   1e490:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   1e492:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.mode = 0;
   1e494:	67c3      	str	r3, [r0, #124]	; 0x7c
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   1e496:	4770      	bx	lr
   1e498:	00024491 	.word	0x00024491

0001e49c <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   1e49c:	4b08      	ldr	r3, [pc, #32]	; (1e4c0 <arch_switch_to_main_thread+0x24>)
   1e49e:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   1e4a0:	6e43      	ldr	r3, [r0, #100]	; 0x64
   1e4a2:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   1e4a6:	4610      	mov	r0, r2
   1e4a8:	f381 8809 	msr	PSP, r1
   1e4ac:	2100      	movs	r1, #0
   1e4ae:	b663      	cpsie	if
   1e4b0:	f381 8811 	msr	BASEPRI, r1
   1e4b4:	f3bf 8f6f 	isb	sy
   1e4b8:	2200      	movs	r2, #0
   1e4ba:	2300      	movs	r3, #0
   1e4bc:	f005 ffe8 	bl	24490 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   1e4c0:	2000b5c0 	.word	0x2000b5c0

0001e4c4 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   1e4c4:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   1e4c6:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   1e4c8:	4a0b      	ldr	r2, [pc, #44]	; (1e4f8 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   1e4ca:	6950      	ldr	r0, [r2, #20]
	cmp r0, #0
   1e4cc:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   1e4ce:	bf1e      	ittt	ne
	movne	r1, #0
   1e4d0:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   1e4d2:	6151      	strne	r1, [r2, #20]
		blne	z_pm_save_idle_exit
   1e4d4:	f007 fb72 	blne	25bbc <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   1e4d8:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   1e4da:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   1e4de:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   1e4e2:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   1e4e6:	4905      	ldr	r1, [pc, #20]	; (1e4fc <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   1e4e8:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   1e4ea:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   1e4ec:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   1e4ee:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   1e4f2:	4903      	ldr	r1, [pc, #12]	; (1e500 <_isr_wrapper+0x3c>)
	bx r1
   1e4f4:	4708      	bx	r1
   1e4f6:	0000      	.short	0x0000
	ldr r2, =_kernel
   1e4f8:	2000b5c0 	.word	0x2000b5c0
	ldr r1, =_sw_isr_table
   1e4fc:	00026300 	.word	0x00026300
	ldr r1, =z_arm_int_exit
   1e500:	0001e505 	.word	0x0001e505

0001e504 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   1e504:	4b04      	ldr	r3, [pc, #16]	; (1e518 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   1e506:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   1e508:	6998      	ldr	r0, [r3, #24]
	cmp r0, r1
   1e50a:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   1e50c:	d003      	beq.n	1e516 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   1e50e:	4903      	ldr	r1, [pc, #12]	; (1e51c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   1e510:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   1e514:	600a      	str	r2, [r1, #0]

0001e516 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   1e516:	4770      	bx	lr
	ldr r3, =_kernel
   1e518:	2000b5c0 	.word	0x2000b5c0
	ldr r1, =_SCS_ICSR
   1e51c:	e000ed04 	.word	0xe000ed04

0001e520 <usage_fault.constprop.0>:
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   1e520:	4b15      	ldr	r3, [pc, #84]	; (1e578 <usage_fault.constprop.0+0x58>)
   1e522:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
   1e524:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
		reason = K_ERR_ARM_USAGE_DIV_0;
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   1e528:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
   1e52a:	bf14      	ite	ne
   1e52c:	201e      	movne	r0, #30
   1e52e:	201d      	moveq	r0, #29
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
   1e530:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
		PR_FAULT_INFO("  Unaligned memory access");
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   1e534:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
   1e536:	bf18      	it	ne
   1e538:	201f      	movne	r0, #31
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   1e53a:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   1e53e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_STACK_CHK_FAIL;
   1e540:	bf18      	it	ne
   1e542:	2002      	movne	r0, #2
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
   1e544:	f412 2f00 	tst.w	r2, #524288	; 0x80000
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   1e548:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
   1e54a:	bf18      	it	ne
   1e54c:	2021      	movne	r0, #33	; 0x21
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
   1e54e:	f412 2f80 	tst.w	r2, #262144	; 0x40000
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   1e552:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
   1e554:	bf18      	it	ne
   1e556:	2022      	movne	r0, #34	; 0x22
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
   1e558:	f412 3f00 	tst.w	r2, #131072	; 0x20000
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   1e55c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
   1e55e:	bf18      	it	ne
   1e560:	2023      	movne	r0, #35	; 0x23
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
   1e562:	f412 3f80 	tst.w	r2, #65536	; 0x10000
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   1e566:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	return reason;
}
   1e568:	bf18      	it	ne
   1e56a:	2024      	movne	r0, #36	; 0x24
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   1e56c:	ea6f 4202 	mvn.w	r2, r2, lsl #16
   1e570:	ea6f 4212 	mvn.w	r2, r2, lsr #16
   1e574:	629a      	str	r2, [r3, #40]	; 0x28
}
   1e576:	4770      	bx	lr
   1e578:	e000ed00 	.word	0xe000ed00

0001e57c <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1e57c:	b510      	push	{r4, lr}
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   1e57e:	4b19      	ldr	r3, [pc, #100]	; (1e5e4 <bus_fault.constprop.0+0x68>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1e580:	4602      	mov	r2, r0
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   1e582:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   1e584:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
   1e586:	f410 5f80 	tst.w	r0, #4096	; 0x1000
   1e58a:	bf14      	ite	ne
   1e58c:	2017      	movne	r0, #23
   1e58e:	2016      	moveq	r0, #22
		reason = K_ERR_ARM_BUS_UNSTACKING;
   1e590:	f414 6f00 	tst.w	r4, #2048	; 0x800
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   1e594:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_UNSTACKING;
   1e596:	bf18      	it	ne
   1e598:	2018      	movne	r0, #24
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   1e59a:	05a4      	lsls	r4, r4, #22
   1e59c:	d509      	bpl.n	1e5b2 <bus_fault.constprop.0+0x36>
		STORE_xFAR(bfar, SCB->BFAR);
   1e59e:	6b98      	ldr	r0, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   1e5a0:	6a98      	ldr	r0, [r3, #40]	; 0x28
   1e5a2:	0400      	lsls	r0, r0, #16
   1e5a4:	d504      	bpl.n	1e5b0 <bus_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
   1e5a6:	b11a      	cbz	r2, 1e5b0 <bus_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   1e5a8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e5aa:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   1e5ae:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
   1e5b0:	2019      	movs	r0, #25
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   1e5b2:	4b0c      	ldr	r3, [pc, #48]	; (1e5e4 <bus_fault.constprop.0+0x68>)
   1e5b4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
   1e5b6:	f412 6f80 	tst.w	r2, #1024	; 0x400
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   1e5ba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
   1e5bc:	bf18      	it	ne
   1e5be:	201a      	movne	r0, #26
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   1e5c0:	05d2      	lsls	r2, r2, #23
   1e5c2:	d40c      	bmi.n	1e5de <bus_fault.constprop.0+0x62>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   1e5c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
   1e5c6:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   1e5ca:	bf18      	it	ne
   1e5cc:	201c      	movne	r0, #28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   1e5ce:	4a05      	ldr	r2, [pc, #20]	; (1e5e4 <bus_fault.constprop.0+0x68>)
   1e5d0:	6a93      	ldr	r3, [r2, #40]	; 0x28
   1e5d2:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   1e5d6:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   1e5d8:	2300      	movs	r3, #0
   1e5da:	700b      	strb	r3, [r1, #0]
}
   1e5dc:	bd10      	pop	{r4, pc}
		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
   1e5de:	201b      	movs	r0, #27
   1e5e0:	e7f5      	b.n	1e5ce <bus_fault.constprop.0+0x52>
   1e5e2:	bf00      	nop
   1e5e4:	e000ed00 	.word	0xe000ed00

0001e5e8 <mem_manage_fault.constprop.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   1e5e8:	b510      	push	{r4, lr}
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   1e5ea:	4b1c      	ldr	r3, [pc, #112]	; (1e65c <mem_manage_fault.constprop.0+0x74>)
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   1e5ec:	4602      	mov	r2, r0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   1e5ee:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   1e5f0:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
   1e5f2:	f010 0f10 	tst.w	r0, #16
   1e5f6:	bf14      	ite	ne
   1e5f8:	2011      	movne	r0, #17
   1e5fa:	2010      	moveq	r0, #16
		reason = K_ERR_ARM_MEM_UNSTACKING;
   1e5fc:	f014 0f08 	tst.w	r4, #8
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   1e600:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_UNSTACKING;
   1e602:	bf18      	it	ne
   1e604:	2012      	movne	r0, #18
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   1e606:	07a4      	lsls	r4, r4, #30
   1e608:	d509      	bpl.n	1e61e <mem_manage_fault.constprop.0+0x36>
		uint32_t temp = SCB->MMFAR;
   1e60a:	6b58      	ldr	r0, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   1e60c:	6a98      	ldr	r0, [r3, #40]	; 0x28
   1e60e:	0600      	lsls	r0, r0, #24
   1e610:	d504      	bpl.n	1e61c <mem_manage_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
   1e612:	b11a      	cbz	r2, 1e61c <mem_manage_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   1e614:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e616:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   1e61a:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
   1e61c:	2013      	movs	r0, #19
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   1e61e:	4b0f      	ldr	r3, [pc, #60]	; (1e65c <mem_manage_fault.constprop.0+0x74>)
   1e620:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
   1e622:	f012 0f01 	tst.w	r2, #1
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   1e626:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
   1e628:	bf18      	it	ne
   1e62a:	2014      	movne	r0, #20
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
   1e62c:	f012 0f20 	tst.w	r2, #32
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   1e630:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
   1e632:	bf18      	it	ne
   1e634:	2015      	movne	r0, #21
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   1e636:	06d4      	lsls	r4, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   1e638:	bf58      	it	pl
   1e63a:	6a9b      	ldrpl	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   1e63c:	4b07      	ldr	r3, [pc, #28]	; (1e65c <mem_manage_fault.constprop.0+0x74>)
   1e63e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e640:	0692      	lsls	r2, r2, #26
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
   1e642:	bf42      	ittt	mi
   1e644:	6a5a      	ldrmi	r2, [r3, #36]	; 0x24
   1e646:	f422 5200 	bicmi.w	r2, r2, #8192	; 0x2000
   1e64a:	625a      	strmi	r2, [r3, #36]	; 0x24
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   1e64c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e64e:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   1e652:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   1e654:	2300      	movs	r3, #0
   1e656:	700b      	strb	r3, [r1, #0]
}
   1e658:	bd10      	pop	{r4, pc}
   1e65a:	bf00      	nop
   1e65c:	e000ed00 	.word	0xe000ed00

0001e660 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   1e660:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   1e662:	4b47      	ldr	r3, [pc, #284]	; (1e780 <z_arm_fault+0x120>)
{
   1e664:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   1e666:	685b      	ldr	r3, [r3, #4]
   1e668:	2600      	movs	r6, #0
{
   1e66a:	b08a      	sub	sp, #40	; 0x28
   1e66c:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1e670:	f386 8811 	msr	BASEPRI, r6
   1e674:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   1e678:	f002 407f 	and.w	r0, r2, #4278190080	; 0xff000000
   1e67c:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
   1e680:	d116      	bne.n	1e6b0 <z_arm_fault+0x50>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   1e682:	07d0      	lsls	r0, r2, #31
   1e684:	d414      	bmi.n	1e6b0 <z_arm_fault+0x50>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   1e686:	0654      	lsls	r4, r2, #25
   1e688:	d403      	bmi.n	1e692 <z_arm_fault+0x32>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   1e68a:	0710      	lsls	r0, r2, #28
   1e68c:	d404      	bmi.n	1e698 <z_arm_fault+0x38>
			*nested_exc = true;
   1e68e:	2601      	movs	r6, #1
   1e690:	e004      	b.n	1e69c <z_arm_fault+0x3c>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   1e692:	f012 0204 	ands.w	r2, r2, #4
   1e696:	d000      	beq.n	1e69a <z_arm_fault+0x3a>
			ptr_esf = (z_arch_esf_t *)psp;
   1e698:	460d      	mov	r5, r1
	*nested_exc = false;
   1e69a:	2600      	movs	r6, #0
	*recoverable = false;
   1e69c:	2200      	movs	r2, #0
	switch (fault) {
   1e69e:	3b03      	subs	r3, #3
	*recoverable = false;
   1e6a0:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
   1e6a4:	2b03      	cmp	r3, #3
   1e6a6:	d805      	bhi.n	1e6b4 <z_arm_fault+0x54>
   1e6a8:	e8df f003 	tbb	[pc, r3]
   1e6ac:	59605c1e 	.word	0x59605c1e
		return NULL;
   1e6b0:	4635      	mov	r5, r6
   1e6b2:	e7f3      	b.n	1e69c <z_arm_fault+0x3c>
   1e6b4:	2400      	movs	r4, #0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   1e6b6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1e6ba:	b99b      	cbnz	r3, 1e6e4 <z_arm_fault+0x84>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   1e6bc:	2220      	movs	r2, #32
   1e6be:	4629      	mov	r1, r5
   1e6c0:	a802      	add	r0, sp, #8
   1e6c2:	f006 fc8e 	bl	24fe2 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   1e6c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1e6c8:	2e00      	cmp	r6, #0
   1e6ca:	d053      	beq.n	1e774 <z_arm_fault+0x114>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   1e6cc:	f3c3 0208 	ubfx	r2, r3, #0, #9
   1e6d0:	b922      	cbnz	r2, 1e6dc <z_arm_fault+0x7c>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   1e6d2:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   1e6d6:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1e6da:	9309      	str	r3, [sp, #36]	; 0x24

	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
		reason = K_ERR_CPU_EXCEPTION;
	}

	z_arm_fatal_error(reason, &esf_copy);
   1e6dc:	4620      	mov	r0, r4
   1e6de:	a902      	add	r1, sp, #8
   1e6e0:	f006 fc32 	bl	24f48 <z_arm_fatal_error>
}
   1e6e4:	b00a      	add	sp, #40	; 0x28
   1e6e6:	bd70      	pop	{r4, r5, r6, pc}
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   1e6e8:	4b25      	ldr	r3, [pc, #148]	; (1e780 <z_arm_fault+0x120>)
   1e6ea:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1e6ec:	0791      	lsls	r1, r2, #30
   1e6ee:	d4e1      	bmi.n	1e6b4 <z_arm_fault+0x54>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   1e6f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1e6f2:	2a00      	cmp	r2, #0
   1e6f4:	dbde      	blt.n	1e6b4 <z_arm_fault+0x54>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   1e6f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1e6f8:	0052      	lsls	r2, r2, #1
   1e6fa:	d5db      	bpl.n	1e6b4 <z_arm_fault+0x54>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
   1e6fc:	695a      	ldr	r2, [r3, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
   1e6fe:	69a9      	ldr	r1, [r5, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
   1e700:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   1e704:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
   1e706:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e70a:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
   1e70e:	695a      	ldr	r2, [r3, #20]
	uint16_t fault_insn = *(ret_addr - 1);
   1e710:	f831 1c02 	ldrh.w	r1, [r1, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
   1e714:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   1e718:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
   1e71a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e71e:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   1e722:	f64d 7202 	movw	r2, #57090	; 0xdf02
   1e726:	4291      	cmp	r1, r2
   1e728:	d101      	bne.n	1e72e <z_arm_fault+0xce>
			reason = esf->basic.r0;
   1e72a:	682c      	ldr	r4, [r5, #0]
   1e72c:	e7c3      	b.n	1e6b6 <z_arm_fault+0x56>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
   1e72e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e730:	b2d2      	uxtb	r2, r2
   1e732:	b132      	cbz	r2, 1e742 <z_arm_fault+0xe2>
			reason = mem_manage_fault(esf, 1, recoverable);
   1e734:	2001      	movs	r0, #1
   1e736:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   1e73a:	f7ff ff55 	bl	1e5e8 <mem_manage_fault.constprop.0>
		reason = usage_fault(esf);
   1e73e:	4604      	mov	r4, r0
		break;
   1e740:	e7b9      	b.n	1e6b6 <z_arm_fault+0x56>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
   1e742:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e744:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
   1e748:	d005      	beq.n	1e756 <z_arm_fault+0xf6>
			reason = bus_fault(esf, 1, recoverable);
   1e74a:	2001      	movs	r0, #1
   1e74c:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   1e750:	f7ff ff14 	bl	1e57c <bus_fault.constprop.0>
   1e754:	e7f3      	b.n	1e73e <z_arm_fault+0xde>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
   1e756:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1e758:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   1e75c:	d3aa      	bcc.n	1e6b4 <z_arm_fault+0x54>
		reason = usage_fault(esf);
   1e75e:	f7ff fedf 	bl	1e520 <usage_fault.constprop.0>
   1e762:	e7ec      	b.n	1e73e <z_arm_fault+0xde>
		reason = mem_manage_fault(esf, 0, recoverable);
   1e764:	2000      	movs	r0, #0
   1e766:	f10d 0107 	add.w	r1, sp, #7
   1e76a:	e7e6      	b.n	1e73a <z_arm_fault+0xda>
		reason = bus_fault(esf, 0, recoverable);
   1e76c:	2000      	movs	r0, #0
   1e76e:	f10d 0107 	add.w	r1, sp, #7
   1e772:	e7ed      	b.n	1e750 <z_arm_fault+0xf0>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1e774:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   1e778:	f023 0301 	bic.w	r3, r3, #1
   1e77c:	e7ad      	b.n	1e6da <z_arm_fault+0x7a>
   1e77e:	bf00      	nop
   1e780:	e000ed00 	.word	0xe000ed00

0001e784 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   1e784:	4b04      	ldr	r3, [pc, #16]	; (1e798 <z_arm_fault_init+0x14>)
   1e786:	695a      	ldr	r2, [r3, #20]
   1e788:	f042 0210 	orr.w	r2, r2, #16
   1e78c:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   1e78e:	695a      	ldr	r2, [r3, #20]
   1e790:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   1e794:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
   1e796:	4770      	bx	lr
   1e798:	e000ed00 	.word	0xe000ed00

0001e79c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   1e79c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   1e7a0:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   1e7a4:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   1e7a6:	4672      	mov	r2, lr
	bl z_arm_fault
   1e7a8:	f7ff ff5a 	bl	1e660 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   1e7ac:	bd01      	pop	{r0, pc}
   1e7ae:	bf00      	nop

0001e7b0 <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   1e7b0:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e7b2:	2120      	movs	r1, #32
   1e7b4:	4803      	ldr	r0, [pc, #12]	; (1e7c4 <z_arm_interrupt_init+0x14>)
   1e7b6:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   1e7b8:	3301      	adds	r3, #1
   1e7ba:	2b45      	cmp	r3, #69	; 0x45
   1e7bc:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   1e7c0:	d1f9      	bne.n	1e7b6 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   1e7c2:	4770      	bx	lr
   1e7c4:	e000e100 	.word	0xe000e100

0001e7c8 <__start>:
    strb r0, [r1]
#endif /* CONFIG_DEBUG_THREAD_INFO */

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
   1e7c8:	2000      	movs	r0, #0
    msr CONTROL, r0
   1e7ca:	f380 8814 	msr	CONTROL, r0
    isb
   1e7ce:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
   1e7d2:	2000      	movs	r0, #0
    msr MSPLIM, r0
   1e7d4:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
   1e7d8:	f380 880b 	msr	PSPLIM, r0
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   1e7dc:	f7fe fb92 	bl	1cf04 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
   1e7e0:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
   1e7e2:	490e      	ldr	r1, [pc, #56]	; (1e81c <__start+0x54>)
    str r0, [r1]
   1e7e4:	6008      	str	r0, [r1, #0]
    dsb
   1e7e6:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   1e7ea:	480d      	ldr	r0, [pc, #52]	; (1e820 <__start+0x58>)
    msr msp, r0
   1e7ec:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
   1e7f0:	f000 f83e 	bl	1e870 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   1e7f4:	2020      	movs	r0, #32
    msr BASEPRI, r0
   1e7f6:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   1e7fa:	480a      	ldr	r0, [pc, #40]	; (1e824 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   1e7fc:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   1e800:	1840      	adds	r0, r0, r1
    msr PSP, r0
   1e802:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   1e806:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   1e80a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   1e80c:	4308      	orrs	r0, r1
    msr CONTROL, r0
   1e80e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   1e812:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   1e816:	f7ff fdad 	bl	1e374 <z_arm_prep_c>
   1e81a:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
   1e81c:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   1e820:	2000cb80 	.word	0x2000cb80
    ldr r0, =z_interrupt_stacks
   1e824:	2000be40 	.word	0x2000be40

0001e828 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
   1e828:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   1e82c:	4905      	ldr	r1, [pc, #20]	; (1e844 <sys_arch_reboot+0x1c>)
   1e82e:	4b06      	ldr	r3, [pc, #24]	; (1e848 <sys_arch_reboot+0x20>)
   1e830:	68ca      	ldr	r2, [r1, #12]
   1e832:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   1e836:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   1e838:	60cb      	str	r3, [r1, #12]
   1e83a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   1e83e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   1e840:	e7fd      	b.n	1e83e <sys_arch_reboot+0x16>
   1e842:	bf00      	nop
   1e844:	e000ed00 	.word	0xe000ed00
   1e848:	05fa0004 	.word	0x05fa0004

0001e84c <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
   1e84c:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
   1e84e:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
   1e850:	4906      	ldr	r1, [pc, #24]	; (1e86c <z_arm_clear_arm_mpu_config+0x20>)
   1e852:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
	int num_regions =
   1e856:	f3c2 2207 	ubfx	r2, r2, #8, #8
	for (i = 0; i < num_regions; i++) {
   1e85a:	4293      	cmp	r3, r2
   1e85c:	db00      	blt.n	1e860 <z_arm_clear_arm_mpu_config+0x14>
		ARM_MPU_ClrRegion(i);
	}
}
   1e85e:	4770      	bx	lr
  mpu->RNR = rnr;
   1e860:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
  mpu->RLAR = 0U;
   1e864:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0
	for (i = 0; i < num_regions; i++) {
   1e868:	3301      	adds	r3, #1
   1e86a:	e7f6      	b.n	1e85a <z_arm_clear_arm_mpu_config+0xe>
   1e86c:	e000ed00 	.word	0xe000ed00

0001e870 <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
   1e870:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
   1e872:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
   1e874:	2400      	movs	r4, #0
   1e876:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
   1e87a:	f7ff ffe7 	bl	1e84c <z_arm_clear_arm_mpu_config>
   1e87e:	4623      	mov	r3, r4
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
   1e880:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1e884:	4a0c      	ldr	r2, [pc, #48]	; (1e8b8 <z_arm_init_arch_hw_at_boot+0x48>)
   1e886:	f103 0120 	add.w	r1, r3, #32
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   1e88a:	3301      	adds	r3, #1
   1e88c:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
   1e88e:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   1e892:	d1f8      	bne.n	1e886 <z_arm_init_arch_hw_at_boot+0x16>
   1e894:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
   1e896:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1e89a:	4a07      	ldr	r2, [pc, #28]	; (1e8b8 <z_arm_init_arch_hw_at_boot+0x48>)
   1e89c:	f103 0160 	add.w	r1, r3, #96	; 0x60
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   1e8a0:	3301      	adds	r3, #1
   1e8a2:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
   1e8a4:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   1e8a8:	d1f8      	bne.n	1e89c <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
   1e8aa:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
   1e8ac:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e8b0:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
   1e8b4:	bd10      	pop	{r4, pc}
   1e8b6:	bf00      	nop
   1e8b8:	e000e100 	.word	0xe000e100

0001e8bc <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   1e8bc:	4b08      	ldr	r3, [pc, #32]	; (1e8e0 <z_impl_k_thread_abort+0x24>)
   1e8be:	689b      	ldr	r3, [r3, #8]
   1e8c0:	4283      	cmp	r3, r0
   1e8c2:	d10b      	bne.n	1e8dc <z_impl_k_thread_abort+0x20>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1e8c4:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   1e8c8:	b143      	cbz	r3, 1e8dc <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1e8ca:	4b06      	ldr	r3, [pc, #24]	; (1e8e4 <z_impl_k_thread_abort+0x28>)
   1e8cc:	685a      	ldr	r2, [r3, #4]
   1e8ce:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   1e8d2:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
   1e8d4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   1e8d6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   1e8da:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
   1e8dc:	f005 baea 	b.w	23eb4 <z_thread_abort>
   1e8e0:	2000b5c0 	.word	0x2000b5c0
   1e8e4:	e000ed00 	.word	0xe000ed00

0001e8e8 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   1e8e8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	 * into account the unused SRAM area, as well.
	 */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   1e8ea:	4c09      	ldr	r4, [pc, #36]	; (1e910 <z_arm_configure_static_mpu_regions+0x28>)
   1e8ec:	4a09      	ldr	r2, [pc, #36]	; (1e914 <z_arm_configure_static_mpu_regions+0x2c>)
   1e8ee:	4623      	mov	r3, r4
   1e8f0:	2101      	movs	r1, #1
   1e8f2:	4809      	ldr	r0, [pc, #36]	; (1e918 <z_arm_configure_static_mpu_regions+0x30>)
   1e8f4:	f000 f8ea 	bl	1eacc <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   1e8f8:	2300      	movs	r3, #0
   1e8fa:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   1e8fc:	4b07      	ldr	r3, [pc, #28]	; (1e91c <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1e8fe:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   1e900:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1e902:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   1e904:	9301      	str	r3, [sp, #4]
   1e906:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1e908:	f000 f8ea 	bl	1eae0 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   1e90c:	b004      	add	sp, #16
   1e90e:	bd10      	pop	{r4, pc}
   1e910:	20080000 	.word	0x20080000
   1e914:	2000a000 	.word	0x2000a000
   1e918:	000266a4 	.word	0x000266a4
   1e91c:	2000a410 	.word	0x2000a410

0001e920 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
   1e920:	b510      	push	{r4, lr}
	mpu_set_region(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
		| (region_conf->attr.rbar &
   1e922:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   1e924:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   1e926:	f004 021f 	and.w	r2, r4, #31
		(region_conf->base & MPU_RBAR_BASE_Msk)
   1e92a:	f023 031f 	bic.w	r3, r3, #31
		| (region_conf->attr.rbar &
   1e92e:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   1e930:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   1e932:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   1e934:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = rnr;
   1e938:	4905      	ldr	r1, [pc, #20]	; (1e950 <region_init+0x30>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   1e93a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   1e93e:	f043 0301 	orr.w	r3, r3, #1
	MPU->RNR = rnr;
   1e942:	f8c1 0098 	str.w	r0, [r1, #152]	; 0x98
	MPU->RBAR = rbar;
   1e946:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
	MPU->RLAR = rlar;
   1e94a:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   1e94e:	bd10      	pop	{r4, pc}
   1e950:	e000ed00 	.word	0xe000ed00

0001e954 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   1e954:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e958:	460f      	mov	r7, r1
   1e95a:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   1e95c:	4606      	mov	r6, r0
   1e95e:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = rnr;
   1e962:	4d4e      	ldr	r5, [pc, #312]	; (1ea9c <mpu_configure_regions_and_partition.constprop.0+0x148>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   1e964:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   1e966:	45b8      	cmp	r8, r7
   1e968:	f280 8094 	bge.w	1ea94 <mpu_configure_regions_and_partition.constprop.0+0x140>
		if (regions[i].size == 0U) {
   1e96c:	f8d6 9004 	ldr.w	r9, [r6, #4]
   1e970:	f1b9 0f00 	cmp.w	r9, #0
   1e974:	d036      	beq.n	1e9e4 <mpu_configure_regions_and_partition.constprop.0+0x90>
		&&
   1e976:	f1b9 0f1f 	cmp.w	r9, #31
   1e97a:	f240 8089 	bls.w	1ea90 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		&&
   1e97e:	f019 0f1f 	tst.w	r9, #31
   1e982:	f040 8085 	bne.w	1ea90 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		((part->start &
   1e986:	f8d6 a000 	ldr.w	sl, [r6]
		&&
   1e98a:	f01a 0f1f 	tst.w	sl, #31
   1e98e:	d17f      	bne.n	1ea90 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1e990:	4650      	mov	r0, sl
   1e992:	f006 faf0 	bl	24f76 <arm_cmse_mpu_region_get>
   1e996:	4683      	mov	fp, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1e998:	eb09 000a 	add.w	r0, r9, sl
   1e99c:	3801      	subs	r0, #1
   1e99e:	f006 faea 	bl	24f76 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   1e9a2:	4583      	cmp	fp, r0
   1e9a4:	d174      	bne.n	1ea90 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		 * inside which the new region will be configured.
		 */
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
   1e9a6:	f11b 0f16 	cmn.w	fp, #22
   1e9aa:	d071      	beq.n	1ea90 <mpu_configure_regions_and_partition.constprop.0+0x13c>
   1e9ac:	455c      	cmp	r4, fp
   1e9ae:	dd6f      	ble.n	1ea90 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	MPU->RNR = rnr;
   1e9b0:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
   1e9b4:	f8d5 109c 	ldr.w	r1, [r5, #156]	; 0x9c
	MPU->RNR = rnr;
   1e9b8:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RLAR;
   1e9bc:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	return mpu_get_rbar() & MPU_RBAR_BASE_Msk;
   1e9c0:	f021 011f 	bic.w	r1, r1, #31
	return (mpu_get_rlar() & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   1e9c4:	f043 0a1f 	orr.w	sl, r3, #31
		 * The new memory region is to be placed inside the underlying
		 * region, possibly splitting the underlying region into two.
		 */
		uint32_t u_reg_base = mpu_region_get_base(u_reg_index);
		uint32_t u_reg_last = mpu_region_get_last_addr(u_reg_index);
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   1e9c8:	e9d6 3200 	ldrd	r3, r2, [r6]
   1e9cc:	441a      	add	r2, r3

		if ((regions[i].start == u_reg_base) &&
   1e9ce:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   1e9d0:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
		if ((regions[i].start == u_reg_base) &&
   1e9d4:	d11e      	bne.n	1ea14 <mpu_configure_regions_and_partition.constprop.0+0xc0>
   1e9d6:	45ca      	cmp	sl, r9
   1e9d8:	d108      	bne.n	1e9ec <mpu_configure_regions_and_partition.constprop.0+0x98>
			 * underlying region. In this case we simply
			 * update the partition attributes of the
			 * underlying region with those of the new
			 * region.
			 */
			mpu_configure_region(u_reg_index, &regions[i]);
   1e9da:	4631      	mov	r1, r6
   1e9dc:	fa5f f08b 	uxtb.w	r0, fp
   1e9e0:	f006 fad2 	bl	24f88 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   1e9e4:	f108 0801 	add.w	r8, r8, #1
   1e9e8:	360c      	adds	r6, #12
   1e9ea:	e7bc      	b.n	1e966 <mpu_configure_regions_and_partition.constprop.0+0x12>
			 */
			mpu_region_set_base(u_reg_index,
				regions[i].start + regions[i].size);

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);
   1e9ec:	4631      	mov	r1, r6
	MPU->RNR = rnr;
   1e9ee:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
   1e9f2:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
		     | (base & MPU_RBAR_BASE_Msk));
   1e9f6:	f022 021f 	bic.w	r2, r2, #31
	mpu_set_rbar((mpu_get_rbar() & (~MPU_RBAR_BASE_Msk))
   1e9fa:	f003 031f 	and.w	r3, r3, #31
		     | (base & MPU_RBAR_BASE_Msk));
   1e9fe:	4313      	orrs	r3, r2
	MPU->RBAR = rbar;
   1ea00:	f8c5 309c 	str.w	r3, [r5, #156]	; 0x9c
				mpu_configure_region(reg_index, &regions[i]);
   1ea04:	b2e0      	uxtb	r0, r4
			 */
			mpu_region_set_limit(u_reg_index,
				regions[i].start - 1);

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);
   1ea06:	f006 fabf 	bl	24f88 <mpu_configure_region>

			if (reg_index == -EINVAL) {
   1ea0a:	f110 0f16 	cmn.w	r0, #22
   1ea0e:	d03f      	beq.n	1ea90 <mpu_configure_regions_and_partition.constprop.0+0x13c>

			if (reg_index == -EINVAL) {
				return reg_index;
			}

			reg_index++;
   1ea10:	1c44      	adds	r4, r0, #1
   1ea12:	e7e7      	b.n	1e9e4 <mpu_configure_regions_and_partition.constprop.0+0x90>
	MPU->RNR = rnr;
   1ea14:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RLAR;
   1ea18:	f8d5 20a0 	ldr.w	r2, [r5, #160]	; 0xa0
				regions[i].start - 1);
   1ea1c:	3b01      	subs	r3, #1
		     | (limit & MPU_RLAR_LIMIT_Msk));
   1ea1e:	f023 031f 	bic.w	r3, r3, #31
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
   1ea22:	f002 021f 	and.w	r2, r2, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
   1ea26:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
   1ea28:	45ca      	cmp	sl, r9
				mpu_configure_region(reg_index, &regions[i]);
   1ea2a:	4631      	mov	r1, r6
				mpu_configure_region(reg_index, &regions[i]);
   1ea2c:	b2e0      	uxtb	r0, r4
	MPU->RLAR = rlar;
   1ea2e:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
		} else if (reg_last == u_reg_last) {
   1ea32:	d0e8      	beq.n	1ea06 <mpu_configure_regions_and_partition.constprop.0+0xb2>
				mpu_configure_region(reg_index, &regions[i]);
   1ea34:	f006 faa8 	bl	24f88 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   1ea38:	f110 0f16 	cmn.w	r0, #22
   1ea3c:	d028      	beq.n	1ea90 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	MPU->RNR = rnr;
   1ea3e:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
   1ea42:	f8d5 209c 	ldr.w	r2, [r5, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
   1ea46:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
   1ea4a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
	attr->rbar = mpu_get_rbar() &
   1ea4e:	f362 0304 	bfi	r3, r2, #0, #5
   1ea52:	f88d 3008 	strb.w	r3, [sp, #8]
	return MPU->RLAR;
   1ea56:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
   1ea5a:	f89d 2008 	ldrb.w	r2, [sp, #8]
   1ea5e:	085b      	lsrs	r3, r3, #1
   1ea60:	f363 1247 	bfi	r2, r3, #5, #3
   1ea64:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
   1ea68:	e9d6 3200 	ldrd	r3, r2, [r6]
   1ea6c:	4413      	add	r3, r2
   1ea6e:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
   1ea70:	f023 031f 	bic.w	r3, r3, #31
			reg_index++;
   1ea74:	1c41      	adds	r1, r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
   1ea76:	4453      	add	r3, sl
   1ea78:	eba3 0309 	sub.w	r3, r3, r9
   1ea7c:	b2c8      	uxtb	r0, r1
   1ea7e:	f023 031f 	bic.w	r3, r3, #31

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   1ea82:	2807      	cmp	r0, #7
			fill_region.attr.r_limit =
   1ea84:	9303      	str	r3, [sp, #12]
   1ea86:	d803      	bhi.n	1ea90 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
   1ea88:	4669      	mov	r1, sp
   1ea8a:	f7ff ff49 	bl	1e920 <region_init>
   1ea8e:	e7bf      	b.n	1ea10 <mpu_configure_regions_and_partition.constprop.0+0xbc>
			return -EINVAL;
   1ea90:	f06f 0415 	mvn.w	r4, #21
		}
	}

	return reg_index;
}
   1ea94:	4620      	mov	r0, r4
   1ea96:	b005      	add	sp, #20
   1ea98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ea9c:	e000ed00 	.word	0xe000ed00

0001eaa0 <arm_core_mpu_enable>:
	 * background region for privileged software access if desired.
	 */
#if defined(CONFIG_MPU_DISABLE_BACKGROUND_MAP)
	MPU->CTRL = MPU_CTRL_ENABLE_Msk;
#else
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   1eaa0:	2205      	movs	r2, #5
   1eaa2:	4b04      	ldr	r3, [pc, #16]	; (1eab4 <arm_core_mpu_enable+0x14>)
   1eaa4:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
   1eaa8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1eaac:	f3bf 8f6f 	isb	sy
#endif

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   1eab0:	4770      	bx	lr
   1eab2:	bf00      	nop
   1eab4:	e000ed00 	.word	0xe000ed00

0001eab8 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   1eab8:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   1eabc:	2200      	movs	r2, #0
   1eabe:	4b02      	ldr	r3, [pc, #8]	; (1eac8 <arm_core_mpu_disable+0x10>)
   1eac0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
   1eac4:	4770      	bx	lr
   1eac6:	bf00      	nop
   1eac8:	e000ed00 	.word	0xe000ed00

0001eacc <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	*static_regions, const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   1eacc:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   1eace:	4c03      	ldr	r4, [pc, #12]	; (1eadc <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   1ead0:	7822      	ldrb	r2, [r4, #0]
   1ead2:	f7ff ff3f 	bl	1e954 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   1ead6:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   1ead8:	bd10      	pop	{r4, pc}
   1eada:	bf00      	nop
   1eadc:	2000b610 	.word	0x2000b610

0001eae0 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
   1eae0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1eae4:	4d29      	ldr	r5, [pc, #164]	; (1eb8c <arm_core_mpu_mark_areas_for_dynamic_regions+0xac>)
   1eae6:	468a      	mov	sl, r1

/* This internal function marks and stores the configuration of memory areas
 * where dynamic region programming is allowed. Return zero on success, or
 * -EINVAL on error.
 */
static int mpu_mark_areas_for_dynamic_regions(
   1eae8:	4606      	mov	r6, r0
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1eaea:	f04f 0800 	mov.w	r8, #0
   1eaee:	46ab      	mov	fp, r5
	MPU->RNR = rnr;
   1eaf0:	4f27      	ldr	r7, [pc, #156]	; (1eb90 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb0>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1eaf2:	45d0      	cmp	r8, sl
   1eaf4:	da1b      	bge.n	1eb2e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
   1eaf6:	f8d6 9004 	ldr.w	r9, [r6, #4]
   1eafa:	f1b9 0f00 	cmp.w	r9, #0
   1eafe:	d03f      	beq.n	1eb80 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   1eb00:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1eb02:	4608      	mov	r0, r1
   1eb04:	9101      	str	r1, [sp, #4]
   1eb06:	f006 fa36 	bl	24f76 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1eb0a:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1eb0c:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1eb0e:	eb09 0001 	add.w	r0, r9, r1
   1eb12:	3801      	subs	r0, #1
   1eb14:	f006 fa2f 	bl	24f76 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   1eb18:	4284      	cmp	r4, r0
   1eb1a:	f04f 0214 	mov.w	r2, #20
   1eb1e:	4b1d      	ldr	r3, [pc, #116]	; (1eb94 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb4>)
   1eb20:	d008      	beq.n	1eb34 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
   1eb22:	fb02 f308 	mul.w	r3, r2, r8
   1eb26:	f06f 0215 	mvn.w	r2, #21
   1eb2a:	f84b 2003 	str.w	r2, [fp, r3]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
   1eb2e:	b003      	add	sp, #12
   1eb30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   1eb34:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
   1eb38:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   1eb3a:	d0f8      	beq.n	1eb2e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   1eb3c:	7819      	ldrb	r1, [r3, #0]
   1eb3e:	42a1      	cmp	r1, r4
   1eb40:	ddf5      	ble.n	1eb2e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = mpu_get_rbar() &
   1eb42:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = rnr;
   1eb46:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
   1eb4a:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
	return MPU->RBAR;
   1eb4e:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
   1eb52:	f100 0108 	add.w	r1, r0, #8
   1eb56:	7b00      	ldrb	r0, [r0, #12]
   1eb58:	f364 0004 	bfi	r0, r4, #0, #5
   1eb5c:	7108      	strb	r0, [r1, #4]
	return MPU->RLAR;
   1eb5e:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
   1eb62:	790c      	ldrb	r4, [r1, #4]
   1eb64:	0840      	lsrs	r0, r0, #1
   1eb66:	f360 1447 	bfi	r4, r0, #5, #3
   1eb6a:	710c      	strb	r4, [r1, #4]
	return MPU->RBAR;
   1eb6c:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
	region_conf->base = mpu_get_rbar() & MPU_RBAR_BASE_Msk;
   1eb70:	f021 011f 	bic.w	r1, r1, #31
   1eb74:	6069      	str	r1, [r5, #4]
	return MPU->RLAR;
   1eb76:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
	region_conf->attr.r_limit = mpu_get_rlar() & MPU_RLAR_LIMIT_Msk;
   1eb7a:	f021 011f 	bic.w	r1, r1, #31
   1eb7e:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1eb80:	f108 0801 	add.w	r8, r8, #1
   1eb84:	3514      	adds	r5, #20
   1eb86:	360c      	adds	r6, #12
   1eb88:	e7b3      	b.n	1eaf2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
   1eb8a:	bf00      	nop
   1eb8c:	2000a944 	.word	0x2000a944
   1eb90:	e000ed00 	.word	0xe000ed00
   1eb94:	2000b610 	.word	0x2000b610

0001eb98 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   1eb98:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   1eb9a:	4d0e      	ldr	r5, [pc, #56]	; (1ebd4 <z_arm_mpu_init+0x3c>)
   1eb9c:	682c      	ldr	r4, [r5, #0]
   1eb9e:	2c08      	cmp	r4, #8
   1eba0:	d815      	bhi.n	1ebce <z_arm_mpu_init+0x36>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1eba2:	2000      	movs	r0, #0
	arm_core_mpu_disable();
   1eba4:	f7ff ff88 	bl	1eab8 <arm_core_mpu_disable>
	MPU->MAIR0 = mair0;
   1eba8:	4b0b      	ldr	r3, [pc, #44]	; (1ebd8 <z_arm_mpu_init+0x40>)
   1ebaa:	4a0c      	ldr	r2, [pc, #48]	; (1ebdc <z_arm_mpu_init+0x44>)
   1ebac:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1ebb0:	4284      	cmp	r4, r0
   1ebb2:	d105      	bne.n	1ebc0 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   1ebb4:	4b0a      	ldr	r3, [pc, #40]	; (1ebe0 <z_arm_mpu_init+0x48>)
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   1ebb6:	2000      	movs	r0, #0
	static_regions_num = mpu_config.num_regions;
   1ebb8:	701c      	strb	r4, [r3, #0]
	arm_core_mpu_enable();
   1ebba:	f7ff ff71 	bl	1eaa0 <arm_core_mpu_enable>
}
   1ebbe:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   1ebc0:	6869      	ldr	r1, [r5, #4]
   1ebc2:	eb01 1100 	add.w	r1, r1, r0, lsl #4
   1ebc6:	f7ff feab 	bl	1e920 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1ebca:	3001      	adds	r0, #1
   1ebcc:	e7f0      	b.n	1ebb0 <z_arm_mpu_init+0x18>
		return -1;
   1ebce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1ebd2:	e7f4      	b.n	1ebbe <z_arm_mpu_init+0x26>
   1ebd4:	000266b0 	.word	0x000266b0
   1ebd8:	e000ed00 	.word	0xe000ed00
   1ebdc:	0044ffaa 	.word	0x0044ffaa
   1ebe0:	2000b610 	.word	0x2000b610

0001ebe4 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
   1ebe4:	4b01      	ldr	r3, [pc, #4]	; (1ebec <__stdout_hook_install+0x8>)
   1ebe6:	6018      	str	r0, [r3, #0]
}
   1ebe8:	4770      	bx	lr
   1ebea:	bf00      	nop
   1ebec:	2000a110 	.word	0x2000a110

0001ebf0 <setup>:
	 * this case do the remainder of actions to properly configure and
	 * boot the Network MCU.
	 */

	/* Release the Network MCU, 'Release force off signal' */
	NRF_RESET->NETWORK.FORCEOFF = RESET_NETWORK_FORCEOFF_FORCEOFF_Release;
   1ebf0:	2000      	movs	r0, #0
   1ebf2:	4b02      	ldr	r3, [pc, #8]	; (1ebfc <setup+0xc>)
   1ebf4:	f8c3 0614 	str.w	r0, [r3, #1556]	; 0x614
	if (IS_ENABLED(CONFIG_BOARD_ENABLE_CPUNET)) {
		enable_cpunet();
	}

	return 0;
}
   1ebf8:	4770      	bx	lr
   1ebfa:	bf00      	nop
   1ebfc:	40005000 	.word	0x40005000

0001ec00 <usbd_evt_put>:
 * @brief Enqueue USBD event.
 *
 * @param Pointer to the previously allocated and filled event structure.
 */
static inline void usbd_evt_put(struct usbd_event *ev)
{
   1ec00:	4601      	mov	r1, r0
	k_fifo_put(&usbd_evt_fifo, ev);
   1ec02:	4801      	ldr	r0, [pc, #4]	; (1ec08 <usbd_evt_put+0x8>)
   1ec04:	f007 b85e 	b.w	25cc4 <k_queue_append>
   1ec08:	2000a31c 	.word	0x2000a31c

0001ec0c <usbd_work_schedule>:
	k_work_submit_to_queue(&usbd_work_queue, &get_usbd_ctx()->usb_work);
   1ec0c:	4901      	ldr	r1, [pc, #4]	; (1ec14 <usbd_work_schedule+0x8>)
   1ec0e:	4802      	ldr	r0, [pc, #8]	; (1ec18 <usbd_work_schedule+0xc>)
   1ec10:	f007 b8bd 	b.w	25d8e <k_work_submit_to_queue>
   1ec14:	2000a980 	.word	0x2000a980
   1ec18:	2000a4b0 	.word	0x2000a4b0

0001ec1c <endpoint_ctx>:
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1ec1c:	0602      	lsls	r2, r0, #24
	uint8_t ep_num = USB_EP_GET_IDX(ep);
   1ec1e:	f000 037f 	and.w	r3, r0, #127	; 0x7f
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1ec22:	d512      	bpl.n	1ec4a <endpoint_ctx+0x2e>
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
   1ec24:	2b08      	cmp	r3, #8
   1ec26:	d105      	bne.n	1ec34 <endpoint_ctx+0x18>
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec28:	0701      	lsls	r1, r0, #28
	ep_num = NRF_USBD_EP_NR_GET(ep);
   1ec2a:	f000 030f 	and.w	r3, r0, #15
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec2e:	d506      	bpl.n	1ec3e <endpoint_ctx+0x22>
			return &ctx->ep_ctx[EP_ISOIN_INDEX];
   1ec30:	480e      	ldr	r0, [pc, #56]	; (1ec6c <endpoint_ctx+0x50>)
   1ec32:	4770      	bx	lr
			if (ep_num >= CFG_EPIN_CNT) {
   1ec34:	f010 0f78 	tst.w	r0, #120	; 0x78
   1ec38:	d112      	bne.n	1ec60 <endpoint_ctx+0x44>
	ep_num = NRF_USBD_EP_NR_GET(ep);
   1ec3a:	f000 030f 	and.w	r3, r0, #15
			return &ctx->ep_ctx[ep_num];
   1ec3e:	204c      	movs	r0, #76	; 0x4c
   1ec40:	eb00 1043 	add.w	r0, r0, r3, lsl #5
   1ec44:	4b0a      	ldr	r3, [pc, #40]	; (1ec70 <endpoint_ctx+0x54>)
   1ec46:	4418      	add	r0, r3
   1ec48:	4770      	bx	lr
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
   1ec4a:	2b08      	cmp	r3, #8
   1ec4c:	d105      	bne.n	1ec5a <endpoint_ctx+0x3e>
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec4e:	0702      	lsls	r2, r0, #28
	ep_num = NRF_USBD_EP_NR_GET(ep);
   1ec50:	f000 030f 	and.w	r3, r0, #15
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec54:	d506      	bpl.n	1ec64 <endpoint_ctx+0x48>
			return &ctx->ep_ctx[EP_ISOOUT_INDEX];
   1ec56:	4807      	ldr	r0, [pc, #28]	; (1ec74 <endpoint_ctx+0x58>)
   1ec58:	4770      	bx	lr
			if (ep_num >= CFG_EPOUT_CNT) {
   1ec5a:	f010 0f78 	tst.w	r0, #120	; 0x78
   1ec5e:	d0f6      	beq.n	1ec4e <endpoint_ctx+0x32>
		return NULL;
   1ec60:	2000      	movs	r0, #0
}
   1ec62:	4770      	bx	lr
			return &ctx->ep_ctx[CFG_EPIN_CNT +
   1ec64:	4804      	ldr	r0, [pc, #16]	; (1ec78 <endpoint_ctx+0x5c>)
   1ec66:	eb00 1043 	add.w	r0, r0, r3, lsl #5
   1ec6a:	4770      	bx	lr
   1ec6c:	2000aaa4 	.word	0x2000aaa4
   1ec70:	2000a958 	.word	0x2000a958
   1ec74:	2000abc4 	.word	0x2000abc4
   1ec78:	2000aac4 	.word	0x2000aac4

0001ec7c <usbd_evt_get>:
	return z_impl_k_queue_get(queue, timeout);
   1ec7c:	2200      	movs	r2, #0
   1ec7e:	2300      	movs	r3, #0
   1ec80:	4801      	ldr	r0, [pc, #4]	; (1ec88 <usbd_evt_get+0xc>)
   1ec82:	f004 bc29 	b.w	234d8 <z_impl_k_queue_get>
   1ec86:	bf00      	nop
   1ec88:	2000a31c 	.word	0x2000a31c

0001ec8c <usbd_evt_flush>:

/**
 * @brief Drop all enqueued events.
 */
static inline void usbd_evt_flush(void)
{
   1ec8c:	b510      	push	{r4, lr}
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1ec8e:	4c05      	ldr	r4, [pc, #20]	; (1eca4 <usbd_evt_flush+0x18>)
	struct usbd_event *ev;

	do {
		ev = usbd_evt_get();
   1ec90:	f7ff fff4 	bl	1ec7c <usbd_evt_get>
		if (ev) {
   1ec94:	b120      	cbz	r0, 1eca0 <usbd_evt_flush+0x14>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1ec96:	1d01      	adds	r1, r0, #4
   1ec98:	4620      	mov	r0, r4
   1ec9a:	f006 ff5b 	bl	25b54 <k_mem_slab_free>
			usbd_evt_free(ev);
		}
	} while (ev != NULL);
   1ec9e:	e7f7      	b.n	1ec90 <usbd_evt_flush+0x4>
}
   1eca0:	bd10      	pop	{r4, pc}
   1eca2:	bf00      	nop
   1eca4:	2000a2d8 	.word	0x2000a2d8

0001eca8 <usbd_evt_alloc>:
 * This function should be called prior to usbd_evt_put().
 *
 * @returns Pointer to the allocated event or NULL if there was no space left.
 */
static inline struct usbd_event *usbd_evt_alloc(void)
{
   1eca8:	b507      	push	{r0, r1, r2, lr}
	struct usbd_event *ev;
	struct usbd_mem_block block;

	if (k_mem_slab_alloc(&fifo_elem_slab,
   1ecaa:	2300      	movs	r3, #0
   1ecac:	2200      	movs	r2, #0
   1ecae:	480e      	ldr	r0, [pc, #56]	; (1ece8 <usbd_evt_alloc+0x40>)
   1ecb0:	a901      	add	r1, sp, #4
   1ecb2:	f004 fa59 	bl	23168 <k_mem_slab_alloc>
   1ecb6:	b190      	cbz	r0, 1ecde <usbd_evt_alloc+0x36>
		 * Allocation may fail if workqueue thread is starved or event
		 * queue size is too small (CONFIG_USB_NRFX_EVT_QUEUE_SIZE).
		 * Wipe all events, free the space and schedule
		 * reinitialization.
		 */
		usbd_evt_flush();
   1ecb8:	f7ff ffe8 	bl	1ec8c <usbd_evt_flush>

		if (k_mem_slab_alloc(&fifo_elem_slab, (void **)&block.data, K_NO_WAIT)) {
   1ecbc:	2200      	movs	r2, #0
   1ecbe:	2300      	movs	r3, #0
   1ecc0:	4809      	ldr	r0, [pc, #36]	; (1ece8 <usbd_evt_alloc+0x40>)
   1ecc2:	a901      	add	r1, sp, #4
   1ecc4:	f004 fa50 	bl	23168 <k_mem_slab_alloc>
   1ecc8:	b938      	cbnz	r0, 1ecda <usbd_evt_alloc+0x32>
			return NULL;
		}

		ev = (struct usbd_event *)block.data;
		ev->block = block;
		ev->evt_type = USBD_EVT_REINIT;
   1ecca:	2304      	movs	r3, #4
		ev = (struct usbd_event *)block.data;
   1eccc:	9801      	ldr	r0, [sp, #4]
		ev->block = block;
   1ecce:	6040      	str	r0, [r0, #4]
		ev->evt_type = USBD_EVT_REINIT;
   1ecd0:	7403      	strb	r3, [r0, #16]
		usbd_evt_put(ev);
   1ecd2:	f7ff ff95 	bl	1ec00 <usbd_evt_put>
		usbd_work_schedule();
   1ecd6:	f7ff ff99 	bl	1ec0c <usbd_work_schedule>

		return NULL;
   1ecda:	2000      	movs	r0, #0
   1ecdc:	e001      	b.n	1ece2 <usbd_evt_alloc+0x3a>
	}

	ev = (struct usbd_event *)block.data;
   1ecde:	9801      	ldr	r0, [sp, #4]
	ev->block = block;
   1ece0:	6040      	str	r0, [r0, #4]

	return ev;
}
   1ece2:	b003      	add	sp, #12
   1ece4:	f85d fb04 	ldr.w	pc, [sp], #4
   1ece8:	2000a2d8 	.word	0x2000a2d8

0001ecec <submit_dc_power_event>:

static void submit_dc_power_event(enum usbd_periph_state state)
{
   1ecec:	b510      	push	{r4, lr}
   1ecee:	4604      	mov	r4, r0
	struct usbd_event *ev = usbd_evt_alloc();
   1ecf0:	f7ff ffda 	bl	1eca8 <usbd_evt_alloc>

	if (!ev) {
   1ecf4:	b160      	cbz	r0, 1ed10 <submit_dc_power_event+0x24>
		return;
	}

	ev->evt_type = USBD_EVT_POWER;
   1ecf6:	2200      	movs	r2, #0
	ev->evt.pwr_evt.state = state;
   1ecf8:	7204      	strb	r4, [r0, #8]
	ev->evt_type = USBD_EVT_POWER;
   1ecfa:	7402      	strb	r2, [r0, #16]

	usbd_evt_put(ev);
   1ecfc:	f7ff ff80 	bl	1ec00 <usbd_evt_put>

	if (usbd_ctx.attached) {
   1ed00:	4b04      	ldr	r3, [pc, #16]	; (1ed14 <submit_dc_power_event+0x28>)
   1ed02:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1ed06:	b11b      	cbz	r3, 1ed10 <submit_dc_power_event+0x24>
		usbd_work_schedule();
	}
}
   1ed08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usbd_work_schedule();
   1ed0c:	f7ff bf7e 	b.w	1ec0c <usbd_work_schedule>
}
   1ed10:	bd10      	pop	{r4, pc}
   1ed12:	bf00      	nop
   1ed14:	2000a958 	.word	0x2000a958

0001ed18 <usbd_event_transfer_data>:
		}
	}
}

static void usbd_event_transfer_data(nrfx_usbd_evt_t const *const p_event)
{
   1ed18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct nrf_usbd_ep_ctx *ep_ctx =
		endpoint_ctx(p_event->data.eptransfer.ep);
   1ed1a:	7887      	ldrb	r7, [r0, #2]
{
   1ed1c:	4606      	mov	r6, r0
		endpoint_ctx(p_event->data.eptransfer.ep);
   1ed1e:	4638      	mov	r0, r7
   1ed20:	f7ff ff7c 	bl	1ec1c <endpoint_ctx>

	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ed24:	063b      	lsls	r3, r7, #24
		endpoint_ctx(p_event->data.eptransfer.ep);
   1ed26:	4604      	mov	r4, r0
		switch (p_event->data.eptransfer.status) {
   1ed28:	78f5      	ldrb	r5, [r6, #3]
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ed2a:	d512      	bpl.n	1ed52 <usbd_event_transfer_data+0x3a>
		switch (p_event->data.eptransfer.status) {
   1ed2c:	2d00      	cmp	r5, #0
   1ed2e:	d143      	bne.n	1edb8 <usbd_event_transfer_data+0xa0>
		case NRFX_USBD_EP_OK: {
			struct usbd_event *ev = usbd_evt_alloc();
   1ed30:	f7ff ffba 	bl	1eca8 <usbd_evt_alloc>

			if (!ev) {
   1ed34:	4603      	mov	r3, r0
   1ed36:	2800      	cmp	r0, #0
   1ed38:	d03e      	beq.n	1edb8 <usbd_event_transfer_data+0xa0>

			LOG_DBG("write complete, ep 0x%02x",
				(uint32_t)p_event->data.eptransfer.ep);

			ep_ctx->write_in_progress = false;
			ev->evt_type = USBD_EVT_EP;
   1ed3a:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
   1ed3c:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
   1ed3e:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
   1ed40:	2203      	movs	r2, #3
   1ed42:	7302      	strb	r2, [r0, #12]
				(uint32_t)p_event->data.eptransfer.ep);

			ep_ctx->read_pending = true;
			ev->evt_type = USBD_EVT_EP;
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
			ev->evt.ep_evt.ep = ep_ctx;
   1ed44:	609c      	str	r4, [r3, #8]

			ev->evt_type = USBD_EVT_EP;
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
			ev->evt.ep_evt.ep = ep_ctx;

			usbd_evt_put(ev);
   1ed46:	f7ff ff5b 	bl	1ec00 <usbd_evt_put>
				p_event->data.eptransfer.ep);
		}
		break;
		}
	}
}
   1ed4a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			usbd_work_schedule();
   1ed4e:	f7ff bf5d 	b.w	1ec0c <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
   1ed52:	b14d      	cbz	r5, 1ed68 <usbd_event_transfer_data+0x50>
   1ed54:	2d01      	cmp	r5, #1
   1ed56:	d12f      	bne.n	1edb8 <usbd_event_transfer_data+0xa0>
			struct usbd_event *ev = usbd_evt_alloc();
   1ed58:	f7ff ffa6 	bl	1eca8 <usbd_evt_alloc>
			if (!ev) {
   1ed5c:	4603      	mov	r3, r0
   1ed5e:	b358      	cbz	r0, 1edb8 <usbd_event_transfer_data+0xa0>
			ep_ctx->read_pending = true;
   1ed60:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
   1ed62:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1ed64:	7305      	strb	r5, [r0, #12]
   1ed66:	e7ed      	b.n	1ed44 <usbd_event_transfer_data+0x2c>
			struct usbd_event *ev = usbd_evt_alloc();
   1ed68:	f7ff ff9e 	bl	1eca8 <usbd_evt_alloc>
			if (!ev) {
   1ed6c:	b320      	cbz	r0, 1edb8 <usbd_event_transfer_data+0xa0>
				p_event->data.eptransfer.ep);
   1ed6e:	78b2      	ldrb	r2, [r6, #2]

NRF_STATIC_INLINE uint32_t nrf_usbd_ep_amount_get(NRF_USBD_Type const * p_reg, uint8_t ep)
{
    uint32_t ret;

    if (NRF_USBD_EPIN_CHECK(ep))
   1ed70:	4b12      	ldr	r3, [pc, #72]	; (1edbc <usbd_event_transfer_data+0xa4>)
   1ed72:	f012 0f80 	tst.w	r2, #128	; 0x80
   1ed76:	f002 0108 	and.w	r1, r2, #8
   1ed7a:	d011      	beq.n	1eda0 <usbd_event_transfer_data+0x88>
    {
        if (NRF_USBD_EPISO_CHECK(ep))
   1ed7c:	b141      	cbz	r1, 1ed90 <usbd_event_transfer_data+0x78>
        {
            ret = p_reg->ISOIN.AMOUNT;
   1ed7e:	f8d3 36a8 	ldr.w	r3, [r3, #1704]	; 0x6a8
			ep_ctx->buf.len = nrf_usbd_ep_amount_get(NRF_USBD,
   1ed82:	60e3      	str	r3, [r4, #12]
			ev->evt_type = USBD_EVT_EP;
   1ed84:	2301      	movs	r3, #1
   1ed86:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ed88:	2302      	movs	r3, #2
			ev->evt.ep_evt.ep = ep_ctx;
   1ed8a:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ed8c:	7303      	strb	r3, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   1ed8e:	e7da      	b.n	1ed46 <usbd_event_transfer_data+0x2e>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPIN[epnr].AMOUNT;
   1ed90:	2114      	movs	r1, #20
   1ed92:	f002 020f 	and.w	r2, r2, #15
   1ed96:	fb01 3302 	mla	r3, r1, r2, r3
   1ed9a:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
   1ed9e:	e7f0      	b.n	1ed82 <usbd_event_transfer_data+0x6a>
        }
    }
    else
    {
        if (NRF_USBD_EPISO_CHECK(ep))
   1eda0:	b111      	cbz	r1, 1eda8 <usbd_event_transfer_data+0x90>
        {
            ret = p_reg->ISOOUT.AMOUNT;
   1eda2:	f8d3 37a8 	ldr.w	r3, [r3, #1960]	; 0x7a8
   1eda6:	e7ec      	b.n	1ed82 <usbd_event_transfer_data+0x6a>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPOUT[epnr].AMOUNT;
   1eda8:	2114      	movs	r1, #20
   1edaa:	f002 020f 	and.w	r2, r2, #15
   1edae:	fb01 3302 	mla	r3, r1, r2, r3
   1edb2:	f8d3 3708 	ldr.w	r3, [r3, #1800]	; 0x708
   1edb6:	e7e4      	b.n	1ed82 <usbd_event_transfer_data+0x6a>
}
   1edb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1edba:	bf00      	nop
   1edbc:	40036000 	.word	0x40036000

0001edc0 <usb_dc_power_event_handler>:
	switch (event) {
   1edc0:	2801      	cmp	r0, #1
{
   1edc2:	b507      	push	{r0, r1, r2, lr}
	switch (event) {
   1edc4:	d00f      	beq.n	1ede6 <usb_dc_power_event_handler+0x26>
   1edc6:	2802      	cmp	r0, #2
   1edc8:	d00e      	beq.n	1ede8 <usb_dc_power_event_handler+0x28>
   1edca:	b948      	cbnz	r0, 1ede0 <usb_dc_power_event_handler+0x20>
	z_impl_k_timer_start(timer, duration, period);
   1edcc:	2200      	movs	r2, #0
   1edce:	2300      	movs	r3, #0
   1edd0:	4808      	ldr	r0, [pc, #32]	; (1edf4 <usb_dc_power_event_handler+0x34>)
   1edd2:	e9cd 2300 	strd	r2, r3, [sp]
   1edd6:	f645 129a 	movw	r2, #22938	; 0x599a
   1edda:	2300      	movs	r3, #0
   1eddc:	f005 faa8 	bl	24330 <z_impl_k_timer_start>
}
   1ede0:	b003      	add	sp, #12
   1ede2:	f85d fb04 	ldr.w	pc, [sp], #4
	switch (event) {
   1ede6:	2000      	movs	r0, #0
}
   1ede8:	b003      	add	sp, #12
   1edea:	f85d eb04 	ldr.w	lr, [sp], #4
	submit_dc_power_event(new_state);
   1edee:	f7ff bf7d 	b.w	1ecec <submit_dc_power_event>
   1edf2:	bf00      	nop
   1edf4:	2000a2a0 	.word	0x2000a2a0

0001edf8 <usb_init>:
	}
	return 0;
}

static int usb_init(void)
{
   1edf8:	b513      	push	{r0, r1, r4, lr}

#ifdef CONFIG_HAS_HW_NRF_USBREG
	/* Use CLOCK/POWER priority for compatibility with other series where
	 * USB events are handled by CLOCK interrupt handler.
	 */
	IRQ_CONNECT(USBREGULATOR_IRQn,
   1edfa:	2200      	movs	r2, #0
   1edfc:	2101      	movs	r1, #1
   1edfe:	2037      	movs	r0, #55	; 0x37
   1ee00:	f7ff fa9e 	bl	1e340 <z_arm_irq_priority_set>
		    DT_IRQ(DT_INST(0, nordic_nrf_clock), priority),
		    nrfx_isr, nrfx_usbreg_irq_handler, 0);
	irq_enable(USBREGULATOR_IRQn);
   1ee04:	2037      	movs	r0, #55	; 0x37
   1ee06:	f7ff fa6b 	bl	1e2e0 <arch_irq_enable>

	static const nrfx_power_usbevt_config_t usbevt_config = {
		.handler = usb_dc_power_event_handler
	};

	err = nrfx_usbd_init(usbd_event_handler);
   1ee0a:	4812      	ldr	r0, [pc, #72]	; (1ee54 <usb_init+0x5c>)
   1ee0c:	f003 fb58 	bl	224c0 <nrfx_usbd_init>
	if (err != NRFX_SUCCESS) {
   1ee10:	4b11      	ldr	r3, [pc, #68]	; (1ee58 <usb_init+0x60>)
   1ee12:	4298      	cmp	r0, r3
   1ee14:	d11a      	bne.n	1ee4c <usb_init+0x54>
	 * a problem here.
	 */
	(void)nrfx_power_init(&power_config);
	nrfx_power_usbevt_init(&usbevt_config);

	k_work_queue_start(&usbd_work_queue,
   1ee16:	2400      	movs	r4, #0
	(void)nrfx_power_init(&power_config);
   1ee18:	4810      	ldr	r0, [pc, #64]	; (1ee5c <usb_init+0x64>)
   1ee1a:	f002 fb41 	bl	214a0 <nrfx_power_init>
	nrfx_power_usbevt_init(&usbevt_config);
   1ee1e:	4810      	ldr	r0, [pc, #64]	; (1ee60 <usb_init+0x68>)
   1ee20:	f003 ffea 	bl	22df8 <nrfx_usbreg_init>
	k_work_queue_start(&usbd_work_queue,
   1ee24:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1ee28:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1ee2c:	490d      	ldr	r1, [pc, #52]	; (1ee64 <usb_init+0x6c>)
   1ee2e:	480e      	ldr	r0, [pc, #56]	; (1ee68 <usb_init+0x70>)
   1ee30:	9400      	str	r4, [sp, #0]
   1ee32:	f004 fce1 	bl	237f8 <k_work_queue_start>
	return z_impl_k_thread_name_set(thread, str);
   1ee36:	490d      	ldr	r1, [pc, #52]	; (1ee6c <usb_init+0x74>)
   1ee38:	480b      	ldr	r0, [pc, #44]	; (1ee68 <usb_init+0x70>)
   1ee3a:	f006 feba 	bl	25bb2 <z_impl_k_thread_name_set>
			   usbd_work_queue_stack,
			   K_KERNEL_STACK_SIZEOF(usbd_work_queue_stack),
			   CONFIG_SYSTEM_WORKQUEUE_PRIORITY, NULL);

	k_thread_name_set(&usbd_work_queue.thread, "usbd_workq");
	k_work_init(&ctx->usb_work, usbd_work_handler);
   1ee3e:	480c      	ldr	r0, [pc, #48]	; (1ee70 <usb_init+0x78>)
   1ee40:	490c      	ldr	r1, [pc, #48]	; (1ee74 <usb_init+0x7c>)
   1ee42:	f006 ff87 	bl	25d54 <k_work_init>

	return 0;
   1ee46:	4620      	mov	r0, r4
}
   1ee48:	b002      	add	sp, #8
   1ee4a:	bd10      	pop	{r4, pc}
		return -EIO;
   1ee4c:	f06f 0004 	mvn.w	r0, #4
   1ee50:	e7fa      	b.n	1ee48 <usb_init+0x50>
   1ee52:	bf00      	nop
   1ee54:	0001eeb1 	.word	0x0001eeb1
   1ee58:	0bad0000 	.word	0x0bad0000
   1ee5c:	00026a66 	.word	0x00026a66
   1ee60:	000266d8 	.word	0x000266d8
   1ee64:	2000ba40 	.word	0x2000ba40
   1ee68:	2000a4b0 	.word	0x2000a4b0
   1ee6c:	00026a5b 	.word	0x00026a5b
   1ee70:	2000a980 	.word	0x2000a980
   1ee74:	0001f035 	.word	0x0001f035

0001ee78 <hfxo_stop.constprop.0.isra.0>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1ee78:	2300      	movs	r3, #0
static int hfxo_stop(struct nrf_usbd_ctx *ctx)
   1ee7a:	b510      	push	{r4, lr}
   1ee7c:	490b      	ldr	r1, [pc, #44]	; (1eeac <hfxo_stop.constprop.0.isra.0+0x34>)
   1ee7e:	e8d1 2fef 	ldaex	r2, [r1]
   1ee82:	2a01      	cmp	r2, #1
   1ee84:	d103      	bne.n	1ee8e <hfxo_stop.constprop.0.isra.0+0x16>
   1ee86:	e8c1 3fe0 	stlex	r0, r3, [r1]
   1ee8a:	2800      	cmp	r0, #0
   1ee8c:	d1f7      	bne.n	1ee7e <hfxo_stop.constprop.0.isra.0+0x6>
	if (atomic_cas(&ctx->clk_requested, 1, 0)) {
   1ee8e:	d10c      	bne.n	1eeaa <hfxo_stop.constprop.0.isra.0+0x32>
		return onoff_cancel_or_release(ctx->hfxo_mgr, &ctx->hfxo_cli);
   1ee90:	f851 4c04 	ldr.w	r4, [r1, #-4]
 * @retval negative other errors produced by onoff_release().
 */
static inline int onoff_cancel_or_release(struct onoff_manager *mgr,
					  struct onoff_client *cli)
{
	int rv = onoff_cancel(mgr, cli);
   1ee94:	3914      	subs	r1, #20
   1ee96:	4620      	mov	r0, r4
   1ee98:	f005 fdc4 	bl	24a24 <onoff_cancel>

	if (rv == -EALREADY) {
   1ee9c:	3078      	adds	r0, #120	; 0x78
   1ee9e:	d104      	bne.n	1eeaa <hfxo_stop.constprop.0.isra.0+0x32>
		rv = onoff_release(mgr);
   1eea0:	4620      	mov	r0, r4
}
   1eea2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1eea6:	f005 bd98 	b.w	249da <onoff_release>
   1eeaa:	bd10      	pop	{r4, pc}
   1eeac:	2000a978 	.word	0x2000a978

0001eeb0 <usbd_event_handler>:
{
   1eeb0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1eeb2:	4606      	mov	r6, r0
   1eeb4:	b089      	sub	sp, #36	; 0x24
	struct usbd_event evt = {0};
   1eeb6:	2214      	movs	r2, #20
   1eeb8:	2100      	movs	r1, #0
   1eeba:	a803      	add	r0, sp, #12
   1eebc:	f006 f89c 	bl	24ff8 <memset>
	switch (p_event->type) {
   1eec0:	7833      	ldrb	r3, [r6, #0]
   1eec2:	3b01      	subs	r3, #1
   1eec4:	2b05      	cmp	r3, #5
   1eec6:	d821      	bhi.n	1ef0c <usbd_event_handler+0x5c>
   1eec8:	e8df f003 	tbb	[pc, r3]
   1eecc:	1414037a 	.word	0x1414037a
   1eed0:	166a      	.short	0x166a
   1eed2:	2303      	movs	r3, #3
		evt.evt_type = USBD_EVT_POWER;
   1eed4:	2400      	movs	r4, #0
		evt.evt.pwr_evt.state = USBD_SUSPENDED;
   1eed6:	f88d 3014 	strb.w	r3, [sp, #20]
		ev = usbd_evt_alloc();
   1eeda:	f7ff fee5 	bl	1eca8 <usbd_evt_alloc>
		if (!ev) {
   1eede:	4603      	mov	r3, r0
   1eee0:	b1a0      	cbz	r0, 1ef0c <usbd_event_handler+0x5c>
		ev->evt = evt.evt;
   1eee2:	f100 0208 	add.w	r2, r0, #8
		ev->evt_type = evt.evt_type;
   1eee6:	7404      	strb	r4, [r0, #16]
		ev->evt = evt.evt;
   1eee8:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
   1eeec:	e882 0003 	stmia.w	r2, {r0, r1}
		usbd_evt_put(ev);
   1eef0:	4618      	mov	r0, r3
   1eef2:	e01d      	b.n	1ef30 <usbd_event_handler+0x80>
	switch (p_event->type) {
   1eef4:	2304      	movs	r3, #4
   1eef6:	e7ed      	b.n	1eed4 <usbd_event_handler+0x24>
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
   1eef8:	78b7      	ldrb	r7, [r6, #2]
   1eefa:	4638      	mov	r0, r7
   1eefc:	f7ff fe8e 	bl	1ec1c <endpoint_ctx>
		switch (ep_ctx->cfg.type) {
   1ef00:	7a83      	ldrb	r3, [r0, #10]
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
   1ef02:	4604      	mov	r4, r0
		switch (ep_ctx->cfg.type) {
   1ef04:	b123      	cbz	r3, 1ef10 <usbd_event_handler+0x60>
   1ef06:	3b01      	subs	r3, #1
   1ef08:	2b02      	cmp	r3, #2
   1ef0a:	d943      	bls.n	1ef94 <usbd_event_handler+0xe4>
}
   1ef0c:	b009      	add	sp, #36	; 0x24
   1ef0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ef10:	063b      	lsls	r3, r7, #24
		switch (p_event->data.eptransfer.status) {
   1ef12:	78f5      	ldrb	r5, [r6, #3]
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ef14:	d513      	bpl.n	1ef3e <usbd_event_handler+0x8e>
		switch (p_event->data.eptransfer.status) {
   1ef16:	2d00      	cmp	r5, #0
   1ef18:	d1f8      	bne.n	1ef0c <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
   1ef1a:	f7ff fec5 	bl	1eca8 <usbd_evt_alloc>
			if (!ev) {
   1ef1e:	4603      	mov	r3, r0
   1ef20:	2800      	cmp	r0, #0
   1ef22:	d0f3      	beq.n	1ef0c <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
   1ef24:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
   1ef26:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
   1ef28:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
   1ef2a:	2203      	movs	r2, #3
   1ef2c:	7302      	strb	r2, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   1ef2e:	609c      	str	r4, [r3, #8]
		usbd_evt_put(ev);
   1ef30:	f7ff fe66 	bl	1ec00 <usbd_evt_put>
}
   1ef34:	b009      	add	sp, #36	; 0x24
   1ef36:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		usbd_work_schedule();
   1ef3a:	f7ff be67 	b.w	1ec0c <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
   1ef3e:	b155      	cbz	r5, 1ef56 <usbd_event_handler+0xa6>
   1ef40:	2d01      	cmp	r5, #1
   1ef42:	d1e3      	bne.n	1ef0c <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
   1ef44:	f7ff feb0 	bl	1eca8 <usbd_evt_alloc>
			if (!ev) {
   1ef48:	4603      	mov	r3, r0
   1ef4a:	2800      	cmp	r0, #0
   1ef4c:	d0de      	beq.n	1ef0c <usbd_event_handler+0x5c>
			ep_ctx->read_pending = true;
   1ef4e:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
   1ef50:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1ef52:	7305      	strb	r5, [r0, #12]
   1ef54:	e7eb      	b.n	1ef2e <usbd_event_handler+0x7e>
			struct usbd_event *ev = usbd_evt_alloc();
   1ef56:	f7ff fea7 	bl	1eca8 <usbd_evt_alloc>
			if (!ev) {
   1ef5a:	4607      	mov	r7, r0
   1ef5c:	2800      	cmp	r0, #0
   1ef5e:	d0d5      	beq.n	1ef0c <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
   1ef60:	2301      	movs	r3, #1
   1ef62:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ef64:	2302      	movs	r3, #2
			ev->evt.ep_evt.ep = ep_ctx;
   1ef66:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ef68:	7303      	strb	r3, [r0, #12]
			err_code = nrfx_usbd_ep_status_get(
   1ef6a:	f104 010c 	add.w	r1, r4, #12
   1ef6e:	78b0      	ldrb	r0, [r6, #2]
   1ef70:	f006 fd75 	bl	25a5e <nrfx_usbd_ep_status_get>
			if (ctx->ctrl_read_len > ep_ctx->buf.len) {
   1ef74:	4a13      	ldr	r2, [pc, #76]	; (1efc4 <usbd_event_handler+0x114>)
   1ef76:	68e1      	ldr	r1, [r4, #12]
   1ef78:	f8b2 328c 	ldrh.w	r3, [r2, #652]	; 0x28c
   1ef7c:	428b      	cmp	r3, r1
   1ef7e:	d906      	bls.n	1ef8e <usbd_event_handler+0xde>
				ctx->ctrl_read_len -= ep_ctx->buf.len;
   1ef80:	1a5b      	subs	r3, r3, r1
   1ef82:	f8a2 328c 	strh.w	r3, [r2, #652]	; 0x28c
				nrfx_usbd_setup_data_clear();
   1ef86:	f003 fcd1 	bl	2292c <nrfx_usbd_setup_data_clear>
			usbd_evt_put(ev);
   1ef8a:	4638      	mov	r0, r7
   1ef8c:	e7d0      	b.n	1ef30 <usbd_event_handler+0x80>
				ctx->ctrl_read_len = 0U;
   1ef8e:	f8a2 528c 	strh.w	r5, [r2, #652]	; 0x28c
   1ef92:	e7fa      	b.n	1ef8a <usbd_event_handler+0xda>
			usbd_event_transfer_data(p_event);
   1ef94:	4630      	mov	r0, r6
}
   1ef96:	b009      	add	sp, #36	; 0x24
   1ef98:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			usbd_event_transfer_data(p_event);
   1ef9c:	f7ff bebc 	b.w	1ed18 <usbd_event_transfer_data>
		nrfx_usbd_setup_get(&drv_setup);
   1efa0:	a801      	add	r0, sp, #4
   1efa2:	f003 fc9d 	bl	228e0 <nrfx_usbd_setup_get>
		if ((drv_setup.bRequest != USB_SREQ_SET_ADDRESS)
   1efa6:	f89d 3005 	ldrb.w	r3, [sp, #5]
   1efaa:	2b05      	cmp	r3, #5
   1efac:	d104      	bne.n	1efb8 <usbd_event_handler+0x108>
		    || (USB_REQTYPE_GET_TYPE(drv_setup.bmRequestType)
   1efae:	f89d 3004 	ldrb.w	r3, [sp, #4]
   1efb2:	f013 0f60 	tst.w	r3, #96	; 0x60
   1efb6:	d0a9      	beq.n	1ef0c <usbd_event_handler+0x5c>
			evt.evt.ep_evt.ep = ep_ctx;
   1efb8:	4b03      	ldr	r3, [pc, #12]	; (1efc8 <usbd_event_handler+0x118>)
			evt.evt_type = USBD_EVT_EP;
   1efba:	2401      	movs	r4, #1
			evt.evt.ep_evt.ep = ep_ctx;
   1efbc:	9305      	str	r3, [sp, #20]
	if (put_evt) {
   1efbe:	e78c      	b.n	1eeda <usbd_event_handler+0x2a>
	switch (p_event->type) {
   1efc0:	2402      	movs	r4, #2
   1efc2:	e78a      	b.n	1eeda <usbd_event_handler+0x2a>
   1efc4:	2000a958 	.word	0x2000a958
   1efc8:	2000aac4 	.word	0x2000aac4

0001efcc <eps_ctx_init>:
{
   1efcc:	b538      	push	{r3, r4, r5, lr}
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   1efce:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
   1efd0:	f064 007f 	orn	r0, r4, #127	; 0x7f
   1efd4:	b2c0      	uxtb	r0, r0
   1efd6:	f7ff fe21 	bl	1ec1c <endpoint_ctx>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   1efda:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
   1efdc:	f006 f818 	bl	25010 <ep_ctx_reset>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   1efe0:	2c08      	cmp	r4, #8
   1efe2:	d1f5      	bne.n	1efd0 <eps_ctx_init+0x4>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   1efe4:	2400      	movs	r4, #0
   1efe6:	4d0e      	ldr	r5, [pc, #56]	; (1f020 <eps_ctx_init+0x54>)
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
   1efe8:	b2e0      	uxtb	r0, r4
   1efea:	f7ff fe17 	bl	1ec1c <endpoint_ctx>
		if (!ep_ctx->buf.block.data) {
   1efee:	6903      	ldr	r3, [r0, #16]
   1eff0:	b903      	cbnz	r3, 1eff4 <eps_ctx_init+0x28>
			ep_ctx->buf.block.data = ep_out_bufs[i];
   1eff2:	6105      	str	r5, [r0, #16]
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   1eff4:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
   1eff6:	f006 f80b 	bl	25010 <ep_ctx_reset>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   1effa:	2c08      	cmp	r4, #8
   1effc:	f105 0540 	add.w	r5, r5, #64	; 0x40
   1f000:	d1f2      	bne.n	1efe8 <eps_ctx_init+0x1c>
		ep_ctx_reset(ep_ctx);
   1f002:	4808      	ldr	r0, [pc, #32]	; (1f024 <eps_ctx_init+0x58>)
   1f004:	f006 f804 	bl	25010 <ep_ctx_reset>
		if (!ep_ctx->buf.block.data) {
   1f008:	4b07      	ldr	r3, [pc, #28]	; (1f028 <eps_ctx_init+0x5c>)
   1f00a:	f8d3 227c 	ldr.w	r2, [r3, #636]	; 0x27c
   1f00e:	b912      	cbnz	r2, 1f016 <eps_ctx_init+0x4a>
			ep_ctx->buf.block.data = ep_isoout_bufs[0];
   1f010:	4a06      	ldr	r2, [pc, #24]	; (1f02c <eps_ctx_init+0x60>)
   1f012:	f8c3 227c 	str.w	r2, [r3, #636]	; 0x27c
		ep_ctx_reset(ep_ctx);
   1f016:	4806      	ldr	r0, [pc, #24]	; (1f030 <eps_ctx_init+0x64>)
   1f018:	f005 fffa 	bl	25010 <ep_ctx_reset>
}
   1f01c:	2000      	movs	r0, #0
   1f01e:	bd38      	pop	{r3, r4, r5, pc}
   1f020:	2000afe8 	.word	0x2000afe8
   1f024:	2000aaa4 	.word	0x2000aaa4
   1f028:	2000a958 	.word	0x2000a958
   1f02c:	2000abe8 	.word	0x2000abe8
   1f030:	2000abc4 	.word	0x2000abc4

0001f034 <usbd_work_handler>:
{
   1f034:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1f038:	4607      	mov	r7, r0
	return get_usbd_ctx()->ready;
   1f03a:	4cad      	ldr	r4, [pc, #692]	; (1f2f0 <usbd_work_handler+0x2bc>)
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f03c:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 1f2f4 <usbd_work_handler+0x2c0>
{
   1f040:	b085      	sub	sp, #20
	while ((ev = usbd_evt_get()) != NULL) {
   1f042:	f7ff fe1b 	bl	1ec7c <usbd_evt_get>
   1f046:	b910      	cbnz	r0, 1f04e <usbd_work_handler+0x1a>
}
   1f048:	b005      	add	sp, #20
   1f04a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return get_usbd_ctx()->ready;
   1f04e:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
   1f052:	7c02      	ldrb	r2, [r0, #16]
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f054:	f100 0904 	add.w	r9, r0, #4
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
   1f058:	b93b      	cbnz	r3, 1f06a <usbd_work_handler+0x36>
   1f05a:	2a00      	cmp	r2, #0
   1f05c:	f000 8088 	beq.w	1f170 <usbd_work_handler+0x13c>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f060:	4649      	mov	r1, r9
   1f062:	48a4      	ldr	r0, [pc, #656]	; (1f2f4 <usbd_work_handler+0x2c0>)
   1f064:	f006 fd76 	bl	25b54 <k_mem_slab_free>
}
   1f068:	e7eb      	b.n	1f042 <usbd_work_handler+0xe>
		switch (ev->evt_type) {
   1f06a:	2a04      	cmp	r2, #4
   1f06c:	d844      	bhi.n	1f0f8 <usbd_work_handler+0xc4>
   1f06e:	e8df f012 	tbh	[pc, r2, lsl #1]
   1f072:	007f      	.short	0x007f
   1f074:	00fe0005 	.word	0x00fe0005
   1f078:	012f0114 	.word	0x012f0114
	switch (ep_evt->evt_type) {
   1f07c:	7b03      	ldrb	r3, [r0, #12]
	struct nrf_usbd_ep_ctx *ep_ctx = ep_evt->ep;
   1f07e:	6885      	ldr	r5, [r0, #8]
	switch (ep_evt->evt_type) {
   1f080:	2b03      	cmp	r3, #3
   1f082:	d839      	bhi.n	1f0f8 <usbd_work_handler+0xc4>
   1f084:	e8df f003 	tbb	[pc, r3]
   1f088:	615c3f02 	.word	0x615c3f02
	usbd_setup = (struct usb_setup_packet *)ep_ctx->buf.data;
   1f08c:	696e      	ldr	r6, [r5, #20]
	memset(usbd_setup, 0, sizeof(struct usb_setup_packet));
   1f08e:	2208      	movs	r2, #8
   1f090:	2100      	movs	r1, #0
   1f092:	4630      	mov	r0, r6
   1f094:	f005 ffb0 	bl	24ff8 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   1f098:	4b97      	ldr	r3, [pc, #604]	; (1f2f8 <usbd_work_handler+0x2c4>)
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   1f09a:	4898      	ldr	r0, [pc, #608]	; (1f2fc <usbd_work_handler+0x2c8>)
   1f09c:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
   1f0a0:	7032      	strb	r2, [r6, #0]
    return (uint8_t)(p_reg->BREQUEST);
   1f0a2:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
   1f0a6:	7072      	strb	r2, [r6, #1]
    const uint16_t val = p_reg->WVALUEL;
   1f0a8:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
   1f0ac:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
   1f0b0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wValue = nrf_usbd_setup_wvalue_get(NRF_USBD);
   1f0b4:	8072      	strh	r2, [r6, #2]
    const uint16_t val = p_reg->WINDEXL;
   1f0b6:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
   1f0ba:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
   1f0be:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wIndex = nrf_usbd_setup_windex_get(NRF_USBD);
   1f0c2:	80b2      	strh	r2, [r6, #4]
    const uint16_t val = p_reg->WLENGTHL;
   1f0c4:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
   1f0c8:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   1f0cc:	4631      	mov	r1, r6
   1f0ce:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
   1f0d2:	2208      	movs	r2, #8
	usbd_setup->wLength = nrf_usbd_setup_wlength_get(NRF_USBD);
   1f0d4:	80f3      	strh	r3, [r6, #6]
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
   1f0d6:	60ea      	str	r2, [r5, #12]
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   1f0d8:	f005 ff83 	bl	24fe2 <memcpy>
	ep_ctx->cfg.cb(ep_ctx->cfg.addr, USB_DC_EP_SETUP);
   1f0dc:	682b      	ldr	r3, [r5, #0]
   1f0de:	2100      	movs	r1, #0
   1f0e0:	7a68      	ldrb	r0, [r5, #9]
   1f0e2:	4798      	blx	r3
	if (usb_reqtype_is_to_device(usbd_setup) && usbd_setup->wLength) {
   1f0e4:	f996 3000 	ldrsb.w	r3, [r6]
   1f0e8:	2b00      	cmp	r3, #0
   1f0ea:	db08      	blt.n	1f0fe <usbd_work_handler+0xca>
   1f0ec:	88f3      	ldrh	r3, [r6, #6]
   1f0ee:	b133      	cbz	r3, 1f0fe <usbd_work_handler+0xca>
		ctx->ctrl_read_len = usbd_setup->wLength;
   1f0f0:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
		nrfx_usbd_setup_data_clear();
   1f0f4:	f003 fc1a 	bl	2292c <nrfx_usbd_setup_data_clear>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f0f8:	4649      	mov	r1, r9
   1f0fa:	4640      	mov	r0, r8
   1f0fc:	e7b2      	b.n	1f064 <usbd_work_handler+0x30>
		ctx->ctrl_read_len = 0U;
   1f0fe:	2300      	movs	r3, #0
   1f100:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
   1f104:	e7f8      	b.n	1f0f8 <usbd_work_handler+0xc4>
	if (!ep_ctx->read_pending) {
   1f106:	7f6b      	ldrb	r3, [r5, #29]
   1f108:	2b00      	cmp	r3, #0
   1f10a:	d0f5      	beq.n	1f0f8 <usbd_work_handler+0xc4>
	if (!ep_ctx->read_complete) {
   1f10c:	7f2b      	ldrb	r3, [r5, #28]
   1f10e:	2b00      	cmp	r3, #0
   1f110:	d0f2      	beq.n	1f0f8 <usbd_work_handler+0xc4>
	ep_ctx->read_pending = false;
   1f112:	2600      	movs	r6, #0
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f114:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	ep_ctx->read_pending = false;
   1f118:	776e      	strb	r6, [r5, #29]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f11a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f11e:	4878      	ldr	r0, [pc, #480]	; (1f300 <usbd_work_handler+0x2cc>)
	ep_ctx->read_complete = false;
   1f120:	772e      	strb	r6, [r5, #28]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f122:	f005 ff8b 	bl	2503c <k_mutex_lock.constprop.0.isra.0>
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
   1f126:	696b      	ldr	r3, [r5, #20]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
   1f128:	a901      	add	r1, sp, #4
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
   1f12a:	9301      	str	r3, [sp, #4]
   1f12c:	686b      	ldr	r3, [r5, #4]
   1f12e:	e9cd 3602 	strd	r3, r6, [sp, #8]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
   1f132:	7a68      	ldrb	r0, [r5, #9]
   1f134:	f003 fa06 	bl	22544 <nrfx_usbd_ep_transfer>
	k_mutex_unlock(&ctx->drv_lock);
   1f138:	4871      	ldr	r0, [pc, #452]	; (1f300 <usbd_work_handler+0x2cc>)
   1f13a:	f005 ff81 	bl	25040 <k_mutex_unlock.isra.0>
   1f13e:	e7db      	b.n	1f0f8 <usbd_work_handler+0xc4>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   1f140:	2101      	movs	r1, #1
   1f142:	682b      	ldr	r3, [r5, #0]
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   1f144:	7a68      	ldrb	r0, [r5, #9]
   1f146:	4798      	blx	r3
		break;
   1f148:	e7d6      	b.n	1f0f8 <usbd_work_handler+0xc4>
		if (ep_ctx->cfg.type == USB_DC_EP_CONTROL &&
   1f14a:	7aab      	ldrb	r3, [r5, #10]
   1f14c:	b96b      	cbnz	r3, 1f16a <usbd_work_handler+0x136>
   1f14e:	7feb      	ldrb	r3, [r5, #31]
   1f150:	b95b      	cbnz	r3, 1f16a <usbd_work_handler+0x136>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f152:	486b      	ldr	r0, [pc, #428]	; (1f300 <usbd_work_handler+0x2cc>)
   1f154:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f158:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f15c:	f005 ff6e 	bl	2503c <k_mutex_lock.constprop.0.isra.0>
			nrfx_usbd_setup_clear();
   1f160:	f003 fc18 	bl	22994 <nrfx_usbd_setup_clear>
			k_mutex_unlock(&ctx->drv_lock);
   1f164:	4866      	ldr	r0, [pc, #408]	; (1f300 <usbd_work_handler+0x2cc>)
   1f166:	f005 ff6b 	bl	25040 <k_mutex_unlock.isra.0>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   1f16a:	2102      	movs	r1, #2
   1f16c:	682b      	ldr	r3, [r5, #0]
   1f16e:	e7e9      	b.n	1f144 <usbd_work_handler+0x110>
	switch (pwr_evt->state) {
   1f170:	7a02      	ldrb	r2, [r0, #8]
   1f172:	2a04      	cmp	r2, #4
   1f174:	d8c0      	bhi.n	1f0f8 <usbd_work_handler+0xc4>
   1f176:	e8df f002 	tbb	[pc, r2]
   1f17a:	0355      	.short	0x0355
   1f17c:	631f      	.short	0x631f
   1f17e:	6f          	.byte	0x6f
   1f17f:	00          	.byte	0x00
		if (!nrfx_usbd_is_enabled()) {
   1f180:	f003 f968 	bl	22454 <nrfx_usbd_is_enabled>
   1f184:	4605      	mov	r5, r0
   1f186:	2800      	cmp	r0, #0
   1f188:	d1b6      	bne.n	1f0f8 <usbd_work_handler+0xc4>
			nrfx_usbd_enable();
   1f18a:	f003 f90f 	bl	223ac <nrfx_usbd_enable>
   1f18e:	2301      	movs	r3, #1
   1f190:	495c      	ldr	r1, [pc, #368]	; (1f304 <usbd_work_handler+0x2d0>)
   1f192:	e8d1 2fef 	ldaex	r2, [r1]
   1f196:	2a00      	cmp	r2, #0
   1f198:	d103      	bne.n	1f1a2 <usbd_work_handler+0x16e>
   1f19a:	e8c1 3fe0 	stlex	r0, r3, [r1]
   1f19e:	2800      	cmp	r0, #0
   1f1a0:	d1f7      	bne.n	1f192 <usbd_work_handler+0x15e>
	if (atomic_cas(&ctx->clk_requested, 0, 1)) {
   1f1a2:	d1a9      	bne.n	1f0f8 <usbd_work_handler+0xc4>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   1f1a4:	f841 5c08 	str.w	r5, [r1, #-8]
   1f1a8:	f841 5c10 	str.w	r5, [r1, #-16]
		return onoff_request(ctx->hfxo_mgr, &ctx->hfxo_cli);
   1f1ac:	69e0      	ldr	r0, [r4, #28]
   1f1ae:	3914      	subs	r1, #20
   1f1b0:	6163      	str	r3, [r4, #20]
   1f1b2:	f005 fbba 	bl	2492a <onoff_request>
   1f1b6:	e79f      	b.n	1f0f8 <usbd_work_handler+0xc4>
	switch (pwr_evt->state) {
   1f1b8:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
   1f1ba:	f065 007f 	orn	r0, r5, #127	; 0x7f
   1f1be:	b2c0      	uxtb	r0, r0
   1f1c0:	f7ff fd2c 	bl	1ec1c <endpoint_ctx>
		if (ep_ctx->cfg.en) {
   1f1c4:	7a03      	ldrb	r3, [r0, #8]
   1f1c6:	b113      	cbz	r3, 1f1ce <usbd_work_handler+0x19a>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f1c8:	7a40      	ldrb	r0, [r0, #9]
   1f1ca:	f003 fd91 	bl	22cf0 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPIN_CNT; i++) {
   1f1ce:	3501      	adds	r5, #1
   1f1d0:	2d08      	cmp	r5, #8
   1f1d2:	d1f2      	bne.n	1f1ba <usbd_work_handler+0x186>
		if (ep_ctx->cfg.en) {
   1f1d4:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
   1f1d8:	b11b      	cbz	r3, 1f1e2 <usbd_work_handler+0x1ae>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f1da:	f894 0155 	ldrb.w	r0, [r4, #341]	; 0x155
   1f1de:	f003 fd87 	bl	22cf0 <nrfx_usbd_ep_enable>
	switch (pwr_evt->state) {
   1f1e2:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
   1f1e4:	b2e8      	uxtb	r0, r5
   1f1e6:	f7ff fd19 	bl	1ec1c <endpoint_ctx>
		if (ep_ctx->cfg.en) {
   1f1ea:	7a03      	ldrb	r3, [r0, #8]
   1f1ec:	b113      	cbz	r3, 1f1f4 <usbd_work_handler+0x1c0>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f1ee:	7a40      	ldrb	r0, [r0, #9]
   1f1f0:	f003 fd7e 	bl	22cf0 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPOUT_CNT; i++) {
   1f1f4:	3501      	adds	r5, #1
   1f1f6:	2d08      	cmp	r5, #8
   1f1f8:	d1f4      	bne.n	1f1e4 <usbd_work_handler+0x1b0>
		if (ep_ctx->cfg.en) {
   1f1fa:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
   1f1fe:	b11b      	cbz	r3, 1f208 <usbd_work_handler+0x1d4>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f200:	f894 0275 	ldrb.w	r0, [r4, #629]	; 0x275
   1f204:	f003 fd74 	bl	22cf0 <nrfx_usbd_ep_enable>
		nrfx_usbd_start(true);
   1f208:	2001      	movs	r0, #1
   1f20a:	f003 f905 	bl	22418 <nrfx_usbd_start>
		ctx->ready = true;
   1f20e:	2301      	movs	r3, #1
   1f210:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
		if (ctx->status_cb) {
   1f214:	6823      	ldr	r3, [r4, #0]
   1f216:	2b00      	cmp	r3, #0
   1f218:	f43f af6e 	beq.w	1f0f8 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_CONNECTED, NULL);
   1f21c:	2100      	movs	r1, #0
   1f21e:	2002      	movs	r0, #2
				ctx->status_cb(USB_DC_SOF, NULL);
   1f220:	4798      	blx	r3
   1f222:	e769      	b.n	1f0f8 <usbd_work_handler+0xc4>
		ctx->ready = false;
   1f224:	2500      	movs	r5, #0
   1f226:	f884 5025 	strb.w	r5, [r4, #37]	; 0x25
		nrfx_usbd_disable();
   1f22a:	f003 fd1f 	bl	22c6c <nrfx_usbd_disable>
		err = hfxo_stop(ctx);
   1f22e:	f7ff fe23 	bl	1ee78 <hfxo_stop.constprop.0.isra.0>
		if (ctx->status_cb) {
   1f232:	6823      	ldr	r3, [r4, #0]
   1f234:	2b00      	cmp	r3, #0
   1f236:	f43f af5f 	beq.w	1f0f8 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_DISCONNECTED, NULL);
   1f23a:	4629      	mov	r1, r5
   1f23c:	2004      	movs	r0, #4
   1f23e:	e7ef      	b.n	1f220 <usbd_work_handler+0x1ec>
		if (dev_ready()) {
   1f240:	2b00      	cmp	r3, #0
   1f242:	f43f af59 	beq.w	1f0f8 <usbd_work_handler+0xc4>
			nrfx_usbd_suspend();
   1f246:	f003 f90f 	bl	22468 <nrfx_usbd_suspend>
			if (ctx->status_cb) {
   1f24a:	6823      	ldr	r3, [r4, #0]
   1f24c:	2b00      	cmp	r3, #0
   1f24e:	f43f af53 	beq.w	1f0f8 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_SUSPEND, NULL);
   1f252:	2100      	movs	r1, #0
   1f254:	2005      	movs	r0, #5
   1f256:	e7e3      	b.n	1f220 <usbd_work_handler+0x1ec>
		if (ctx->status_cb && dev_ready()) {
   1f258:	6822      	ldr	r2, [r4, #0]
   1f25a:	2a00      	cmp	r2, #0
   1f25c:	f43f af4c 	beq.w	1f0f8 <usbd_work_handler+0xc4>
   1f260:	2b00      	cmp	r3, #0
   1f262:	f43f af49 	beq.w	1f0f8 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_RESUME, NULL);
   1f266:	2100      	movs	r1, #0
   1f268:	2006      	movs	r0, #6
   1f26a:	4790      	blx	r2
   1f26c:	e744      	b.n	1f0f8 <usbd_work_handler+0xc4>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f26e:	f107 0510 	add.w	r5, r7, #16
   1f272:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f276:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f27a:	4628      	mov	r0, r5
   1f27c:	f005 fede 	bl	2503c <k_mutex_lock.constprop.0.isra.0>
			eps_ctx_init();
   1f280:	f7ff fea4 	bl	1efcc <eps_ctx_init>
			k_mutex_unlock(&ctx->drv_lock);
   1f284:	4628      	mov	r0, r5
   1f286:	f005 fedb 	bl	25040 <k_mutex_unlock.isra.0>
			if (ctx->status_cb) {
   1f28a:	f857 3c28 	ldr.w	r3, [r7, #-40]
   1f28e:	2b00      	cmp	r3, #0
   1f290:	f43f af32 	beq.w	1f0f8 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_RESET, NULL);
   1f294:	2100      	movs	r1, #0
   1f296:	2001      	movs	r0, #1
   1f298:	e7c2      	b.n	1f220 <usbd_work_handler+0x1ec>
	if (ep_ctx->cfg.en) {
   1f29a:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
   1f29e:	b17b      	cbz	r3, 1f2c0 <usbd_work_handler+0x28c>
		ep_ctx->read_pending = true;
   1f2a0:	2501      	movs	r5, #1
   1f2a2:	f884 5289 	strb.w	r5, [r4, #649]	; 0x289
		ep_ctx->read_complete = true;
   1f2a6:	f884 5288 	strb.w	r5, [r4, #648]	; 0x288
		ev = usbd_evt_alloc();
   1f2aa:	f7ff fcfd 	bl	1eca8 <usbd_evt_alloc>
		if (!ev) {
   1f2ae:	b138      	cbz	r0, 1f2c0 <usbd_work_handler+0x28c>
		ev->evt.ep_evt.ep = ep_ctx;
   1f2b0:	4a15      	ldr	r2, [pc, #84]	; (1f308 <usbd_work_handler+0x2d4>)
		ev->evt_type = USBD_EVT_EP;
   1f2b2:	7405      	strb	r5, [r0, #16]
		ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1f2b4:	7305      	strb	r5, [r0, #12]
		ev->evt.ep_evt.ep = ep_ctx;
   1f2b6:	6082      	str	r2, [r0, #8]
		usbd_evt_put(ev);
   1f2b8:	f7ff fca2 	bl	1ec00 <usbd_evt_put>
		usbd_work_schedule();
   1f2bc:	f7ff fca6 	bl	1ec0c <usbd_work_schedule>
			if (ctx->status_cb) {
   1f2c0:	f857 3c28 	ldr.w	r3, [r7, #-40]
   1f2c4:	2b00      	cmp	r3, #0
   1f2c6:	f43f af17 	beq.w	1f0f8 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_SOF, NULL);
   1f2ca:	2100      	movs	r1, #0
   1f2cc:	200a      	movs	r0, #10
   1f2ce:	e7a7      	b.n	1f220 <usbd_work_handler+0x1ec>
	nrfx_power_usbevt_disable();
   1f2d0:	f003 fd7a 	bl	22dc8 <nrfx_usbreg_disable>
	nrfx_usbd_disable();
   1f2d4:	f003 fcca 	bl	22c6c <nrfx_usbd_disable>
	nrfx_usbd_uninit();
   1f2d8:	f003 f85e 	bl	22398 <nrfx_usbd_uninit>
	usbd_evt_flush();
   1f2dc:	f7ff fcd6 	bl	1ec8c <usbd_evt_flush>
	ret = eps_ctx_init();
   1f2e0:	f7ff fe74 	bl	1efcc <eps_ctx_init>
	nrfx_power_usbevt_enable();
   1f2e4:	f003 fd68 	bl	22db8 <nrfx_usbreg_enable>
	err = nrfx_usbd_init(usbd_event_handler);
   1f2e8:	4808      	ldr	r0, [pc, #32]	; (1f30c <usbd_work_handler+0x2d8>)
   1f2ea:	f003 f8e9 	bl	224c0 <nrfx_usbd_init>
}
   1f2ee:	e703      	b.n	1f0f8 <usbd_work_handler+0xc4>
   1f2f0:	2000a958 	.word	0x2000a958
   1f2f4:	2000a2d8 	.word	0x2000a2d8
   1f2f8:	40036000 	.word	0x40036000
   1f2fc:	2000a95c 	.word	0x2000a95c
   1f300:	2000a990 	.word	0x2000a990
   1f304:	2000a978 	.word	0x2000a978
   1f308:	2000abc4 	.word	0x2000abc4
   1f30c:	0001eeb1 	.word	0x0001eeb1

0001f310 <usb_dc_attach>:
{
   1f310:	b538      	push	{r3, r4, r5, lr}
	if (ctx->attached) {
   1f312:	4d15      	ldr	r5, [pc, #84]	; (1f368 <usb_dc_attach+0x58>)
   1f314:	f895 4024 	ldrb.w	r4, [r5, #36]	; 0x24
   1f318:	bb24      	cbnz	r4, 1f364 <usb_dc_attach+0x54>
	return z_impl_k_mutex_init(mutex);
   1f31a:	f105 0038 	add.w	r0, r5, #56	; 0x38
   1f31e:	f006 fc5c 	bl	25bda <z_impl_k_mutex_init>
		z_nrf_clock_control_get_onoff(
   1f322:	2002      	movs	r0, #2
   1f324:	f000 fb20 	bl	1f968 <z_nrf_clock_control_get_onoff>
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f328:	4622      	mov	r2, r4
   1f32a:	2101      	movs	r1, #1
	ctx->hfxo_mgr =
   1f32c:	61e8      	str	r0, [r5, #28]
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f32e:	2036      	movs	r0, #54	; 0x36
   1f330:	f7ff f806 	bl	1e340 <z_arm_irq_priority_set>
	nrfx_power_usbevt_enable();
   1f334:	f003 fd40 	bl	22db8 <nrfx_usbreg_enable>
	ret = eps_ctx_init();
   1f338:	f7ff fe48 	bl	1efcc <eps_ctx_init>
	if (ret == 0) {
   1f33c:	4604      	mov	r4, r0
   1f33e:	b910      	cbnz	r0, 1f346 <usb_dc_attach+0x36>
		ctx->attached = true;
   1f340:	2301      	movs	r3, #1
   1f342:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
   1f346:	4b09      	ldr	r3, [pc, #36]	; (1f36c <usb_dc_attach+0x5c>)
	if (!k_fifo_is_empty(&usbd_evt_fifo)) {
   1f348:	681b      	ldr	r3, [r3, #0]
   1f34a:	b10b      	cbz	r3, 1f350 <usb_dc_attach+0x40>
		usbd_work_schedule();
   1f34c:	f7ff fc5e 	bl	1ec0c <usbd_work_schedule>
    return p_reg->INTENSET & mask;
}

NRF_STATIC_INLINE uint32_t nrf_usbreg_status_get(NRF_USBREG_Type const * p_reg)
{
    return p_reg->USBREGSTATUS;
   1f350:	4b07      	ldr	r3, [pc, #28]	; (1f370 <usb_dc_attach+0x60>)
   1f352:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_usbreg_state_t nrfx_usbreg_usbstatus_get(void)
{
    uint32_t status = nrf_usbreg_status_get(NRF_USBREGULATOR);
    if (0 == (status & NRF_USBREG_STATUS_VBUSDETECT_MASK))
   1f356:	07db      	lsls	r3, r3, #31
   1f358:	d502      	bpl.n	1f360 <usb_dc_attach+0x50>
		usb_dc_power_event_handler(NRFX_POWER_USB_EVT_DETECTED);
   1f35a:	2000      	movs	r0, #0
   1f35c:	f7ff fd30 	bl	1edc0 <usb_dc_power_event_handler>
}
   1f360:	4620      	mov	r0, r4
   1f362:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   1f364:	2400      	movs	r4, #0
   1f366:	e7fb      	b.n	1f360 <usb_dc_attach+0x50>
   1f368:	2000a958 	.word	0x2000a958
   1f36c:	2000a31c 	.word	0x2000a31c
   1f370:	40037000 	.word	0x40037000

0001f374 <usb_dc_set_address>:
	return get_usbd_ctx()->attached;
   1f374:	4b07      	ldr	r3, [pc, #28]	; (1f394 <usb_dc_set_address+0x20>)
	if (!dev_attached() || !dev_ready()) {
   1f376:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   1f37a:	b13a      	cbz	r2, 1f38c <usb_dc_set_address+0x18>
   1f37c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
		return -ENODEV;
   1f380:	2b00      	cmp	r3, #0
   1f382:	bf14      	ite	ne
   1f384:	2000      	movne	r0, #0
   1f386:	f06f 0012 	mvneq.w	r0, #18
   1f38a:	4770      	bx	lr
   1f38c:	f06f 0012 	mvn.w	r0, #18
}
   1f390:	4770      	bx	lr
   1f392:	bf00      	nop
   1f394:	2000a958 	.word	0x2000a958

0001f398 <usb_dc_ep_configure>:
{
   1f398:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f39a:	4b10      	ldr	r3, [pc, #64]	; (1f3dc <usb_dc_ep_configure+0x44>)
{
   1f39c:	4604      	mov	r4, r0
	if (!dev_attached()) {
   1f39e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1f3a2:	b1c3      	cbz	r3, 1f3d6 <usb_dc_ep_configure+0x3e>
	ep_ctx = endpoint_ctx(ep_cfg->ep_addr);
   1f3a4:	7805      	ldrb	r5, [r0, #0]
   1f3a6:	4628      	mov	r0, r5
   1f3a8:	f7ff fc38 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f3ac:	b910      	cbnz	r0, 1f3b4 <usb_dc_ep_configure+0x1c>
		return -EINVAL;
   1f3ae:	f06f 0015 	mvn.w	r0, #21
}
   1f3b2:	bd38      	pop	{r3, r4, r5, pc}
	ep_ctx->cfg.addr = ep_cfg->ep_addr;
   1f3b4:	7245      	strb	r5, [r0, #9]
	ep_ctx->cfg.type = ep_cfg->ep_type;
   1f3b6:	7923      	ldrb	r3, [r4, #4]
   1f3b8:	7283      	strb	r3, [r0, #10]
	ep_ctx->cfg.max_sz = ep_cfg->ep_mps;
   1f3ba:	8863      	ldrh	r3, [r4, #2]
   1f3bc:	6043      	str	r3, [r0, #4]
	if (!NRF_USBD_EPISO_CHECK(ep_cfg->ep_addr)) {
   1f3be:	7820      	ldrb	r0, [r4, #0]
   1f3c0:	8861      	ldrh	r1, [r4, #2]
   1f3c2:	f010 0f08 	tst.w	r0, #8
   1f3c6:	d102      	bne.n	1f3ce <usb_dc_ep_configure+0x36>
		if ((ep_cfg->ep_mps & (ep_cfg->ep_mps - 1)) != 0U) {
   1f3c8:	1e4b      	subs	r3, r1, #1
   1f3ca:	420b      	tst	r3, r1
   1f3cc:	d1ef      	bne.n	1f3ae <usb_dc_ep_configure+0x16>
	nrfx_usbd_ep_max_packet_size_set(ep_addr_to_nrfx(ep_cfg->ep_addr),
   1f3ce:	f006 fb41 	bl	25a54 <nrfx_usbd_ep_max_packet_size_set>
	return 0;
   1f3d2:	2000      	movs	r0, #0
   1f3d4:	e7ed      	b.n	1f3b2 <usb_dc_ep_configure+0x1a>
		return -ENODEV;
   1f3d6:	f06f 0012 	mvn.w	r0, #18
   1f3da:	e7ea      	b.n	1f3b2 <usb_dc_ep_configure+0x1a>
   1f3dc:	2000a958 	.word	0x2000a958

0001f3e0 <usb_dc_ep_set_stall>:
{
   1f3e0:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f3e2:	4b12      	ldr	r3, [pc, #72]	; (1f42c <usb_dc_ep_set_stall+0x4c>)
{
   1f3e4:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   1f3e6:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   1f3ea:	b1ca      	cbz	r2, 1f420 <usb_dc_ep_set_stall+0x40>
   1f3ec:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f3f0:	b1b3      	cbz	r3, 1f420 <usb_dc_ep_set_stall+0x40>
	ep_ctx = endpoint_ctx(ep);
   1f3f2:	f7ff fc13 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f3f6:	4604      	mov	r4, r0
   1f3f8:	b1a8      	cbz	r0, 1f426 <usb_dc_ep_set_stall+0x46>
	switch (ep_ctx->cfg.type) {
   1f3fa:	7a83      	ldrb	r3, [r0, #10]
   1f3fc:	2b01      	cmp	r3, #1
   1f3fe:	d012      	beq.n	1f426 <usb_dc_ep_set_stall+0x46>
   1f400:	d907      	bls.n	1f412 <usb_dc_ep_set_stall+0x32>
   1f402:	3b02      	subs	r3, #2
   1f404:	2b01      	cmp	r3, #1
   1f406:	d907      	bls.n	1f418 <usb_dc_ep_set_stall+0x38>
	ep_ctx->buf.len = 0U;
   1f408:	2000      	movs	r0, #0
	ep_ctx->buf.curr = ep_ctx->buf.data;
   1f40a:	6963      	ldr	r3, [r4, #20]
	ep_ctx->buf.len = 0U;
   1f40c:	60e0      	str	r0, [r4, #12]
	ep_ctx->buf.curr = ep_ctx->buf.data;
   1f40e:	61a3      	str	r3, [r4, #24]
}
   1f410:	bd38      	pop	{r3, r4, r5, pc}
		nrfx_usbd_setup_stall();
   1f412:	f003 fac7 	bl	229a4 <nrfx_usbd_setup_stall>
		break;
   1f416:	e7f7      	b.n	1f408 <usb_dc_ep_set_stall+0x28>
		nrfx_usbd_ep_stall(ep_addr_to_nrfx(ep));
   1f418:	4628      	mov	r0, r5
   1f41a:	f003 fa33 	bl	22884 <nrfx_usbd_ep_stall>
		break;
   1f41e:	e7f3      	b.n	1f408 <usb_dc_ep_set_stall+0x28>
		return -ENODEV;
   1f420:	f06f 0012 	mvn.w	r0, #18
   1f424:	e7f4      	b.n	1f410 <usb_dc_ep_set_stall+0x30>
	switch (ep_ctx->cfg.type) {
   1f426:	f06f 0015 	mvn.w	r0, #21
   1f42a:	e7f1      	b.n	1f410 <usb_dc_ep_set_stall+0x30>
   1f42c:	2000a958 	.word	0x2000a958

0001f430 <usb_dc_ep_clear_stall>:
{
   1f430:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f432:	4b0e      	ldr	r3, [pc, #56]	; (1f46c <usb_dc_ep_clear_stall+0x3c>)
{
   1f434:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   1f436:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   1f43a:	b182      	cbz	r2, 1f45e <usb_dc_ep_clear_stall+0x2e>
   1f43c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f440:	b16b      	cbz	r3, 1f45e <usb_dc_ep_clear_stall+0x2e>
	ep_ctx = endpoint_ctx(ep);
   1f442:	f7ff fbeb 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f446:	b168      	cbz	r0, 1f464 <usb_dc_ep_clear_stall+0x34>
	if (NRF_USBD_EPISO_CHECK(ep)) {
   1f448:	f015 0408 	ands.w	r4, r5, #8
   1f44c:	d10a      	bne.n	1f464 <usb_dc_ep_clear_stall+0x34>
	nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
   1f44e:	4628      	mov	r0, r5
   1f450:	f003 fa3a 	bl	228c8 <nrfx_usbd_ep_dtoggle_clear>
	nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
   1f454:	4628      	mov	r0, r5
   1f456:	f003 fc9f 	bl	22d98 <nrfx_usbd_ep_stall_clear>
	return 0;
   1f45a:	4620      	mov	r0, r4
}
   1f45c:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
   1f45e:	f06f 0012 	mvn.w	r0, #18
   1f462:	e7fb      	b.n	1f45c <usb_dc_ep_clear_stall+0x2c>
		return -EINVAL;
   1f464:	f06f 0015 	mvn.w	r0, #21
   1f468:	e7f8      	b.n	1f45c <usb_dc_ep_clear_stall+0x2c>
   1f46a:	bf00      	nop
   1f46c:	2000a958 	.word	0x2000a958

0001f470 <usb_dc_ep_is_stalled>:
{
   1f470:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f472:	4b0c      	ldr	r3, [pc, #48]	; (1f4a4 <usb_dc_ep_is_stalled+0x34>)
{
   1f474:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   1f476:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   1f47a:	460c      	mov	r4, r1
	if (!dev_attached() || !dev_ready()) {
   1f47c:	b162      	cbz	r2, 1f498 <usb_dc_ep_is_stalled+0x28>
   1f47e:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f482:	b14b      	cbz	r3, 1f498 <usb_dc_ep_is_stalled+0x28>
	ep_ctx = endpoint_ctx(ep);
   1f484:	f7ff fbca 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f488:	b148      	cbz	r0, 1f49e <usb_dc_ep_is_stalled+0x2e>
	if (!stalled) {
   1f48a:	b144      	cbz	r4, 1f49e <usb_dc_ep_is_stalled+0x2e>
	*stalled = (uint8_t) nrfx_usbd_ep_stall_check(ep_addr_to_nrfx(ep));
   1f48c:	4628      	mov	r0, r5
   1f48e:	f003 fa01 	bl	22894 <nrfx_usbd_ep_stall_check>
   1f492:	7020      	strb	r0, [r4, #0]
	return 0;
   1f494:	2000      	movs	r0, #0
}
   1f496:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
   1f498:	f06f 0012 	mvn.w	r0, #18
   1f49c:	e7fb      	b.n	1f496 <usb_dc_ep_is_stalled+0x26>
		return -EINVAL;
   1f49e:	f06f 0015 	mvn.w	r0, #21
   1f4a2:	e7f8      	b.n	1f496 <usb_dc_ep_is_stalled+0x26>
   1f4a4:	2000a958 	.word	0x2000a958

0001f4a8 <usb_dc_ep_enable>:
{
   1f4a8:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
   1f4aa:	4e13      	ldr	r6, [pc, #76]	; (1f4f8 <usb_dc_ep_enable+0x50>)
{
   1f4ac:	4604      	mov	r4, r0
	if (!dev_attached()) {
   1f4ae:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
   1f4b2:	b1c3      	cbz	r3, 1f4e6 <usb_dc_ep_enable+0x3e>
	ep_ctx = endpoint_ctx(ep);
   1f4b4:	f7ff fbb2 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f4b8:	4605      	mov	r5, r0
   1f4ba:	b1b8      	cbz	r0, 1f4ec <usb_dc_ep_enable+0x44>
	if (!NRF_USBD_EPISO_CHECK(ep)) {
   1f4bc:	0723      	lsls	r3, r4, #28
   1f4be:	d405      	bmi.n	1f4cc <usb_dc_ep_enable+0x24>
		nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
   1f4c0:	4620      	mov	r0, r4
   1f4c2:	f003 fa01 	bl	228c8 <nrfx_usbd_ep_dtoggle_clear>
		nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
   1f4c6:	4620      	mov	r0, r4
   1f4c8:	f003 fc66 	bl	22d98 <nrfx_usbd_ep_stall_clear>
	if (ep_ctx->cfg.en) {
   1f4cc:	7a2b      	ldrb	r3, [r5, #8]
   1f4ce:	b983      	cbnz	r3, 1f4f2 <usb_dc_ep_enable+0x4a>
	ep_ctx->cfg.en = true;
   1f4d0:	2301      	movs	r3, #1
   1f4d2:	722b      	strb	r3, [r5, #8]
	if (dev_ready()) {
   1f4d4:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
   1f4d8:	b90b      	cbnz	r3, 1f4de <usb_dc_ep_enable+0x36>
	return 0;
   1f4da:	2000      	movs	r0, #0
}
   1f4dc:	bd70      	pop	{r4, r5, r6, pc}
		nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep));
   1f4de:	4620      	mov	r0, r4
   1f4e0:	f003 fc06 	bl	22cf0 <nrfx_usbd_ep_enable>
   1f4e4:	e7f9      	b.n	1f4da <usb_dc_ep_enable+0x32>
		return -ENODEV;
   1f4e6:	f06f 0012 	mvn.w	r0, #18
   1f4ea:	e7f7      	b.n	1f4dc <usb_dc_ep_enable+0x34>
		return -EINVAL;
   1f4ec:	f06f 0015 	mvn.w	r0, #21
   1f4f0:	e7f4      	b.n	1f4dc <usb_dc_ep_enable+0x34>
		return -EALREADY;
   1f4f2:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1f4f6:	e7f1      	b.n	1f4dc <usb_dc_ep_enable+0x34>
   1f4f8:	2000a958 	.word	0x2000a958

0001f4fc <usb_dc_ep_write>:
{
   1f4fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return get_usbd_ctx()->attached;
   1f500:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 1f5e8 <usb_dc_ep_write+0xec>
{
   1f504:	461e      	mov	r6, r3
	if (!dev_attached() || !dev_ready()) {
   1f506:	f898 3024 	ldrb.w	r3, [r8, #36]	; 0x24
{
   1f50a:	4607      	mov	r7, r0
   1f50c:	4689      	mov	r9, r1
   1f50e:	4615      	mov	r5, r2
   1f510:	b085      	sub	sp, #20
	if (!dev_attached() || !dev_ready()) {
   1f512:	2b00      	cmp	r3, #0
   1f514:	d061      	beq.n	1f5da <usb_dc_ep_write+0xde>
   1f516:	f898 3025 	ldrb.w	r3, [r8, #37]	; 0x25
   1f51a:	2b00      	cmp	r3, #0
   1f51c:	d05d      	beq.n	1f5da <usb_dc_ep_write+0xde>
	if (NRF_USBD_EPOUT_CHECK(ep)) {
   1f51e:	0603      	lsls	r3, r0, #24
   1f520:	d55e      	bpl.n	1f5e0 <usb_dc_ep_write+0xe4>
	ep_ctx = endpoint_ctx(ep);
   1f522:	f7ff fb7b 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f526:	4604      	mov	r4, r0
   1f528:	2800      	cmp	r0, #0
   1f52a:	d059      	beq.n	1f5e0 <usb_dc_ep_write+0xe4>
	if (!ep_ctx->cfg.en) {
   1f52c:	7a03      	ldrb	r3, [r0, #8]
   1f52e:	2b00      	cmp	r3, #0
   1f530:	d056      	beq.n	1f5e0 <usb_dc_ep_write+0xe4>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f532:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f536:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f53a:	f108 0038 	add.w	r0, r8, #56	; 0x38
   1f53e:	f005 fd7d 	bl	2503c <k_mutex_lock.constprop.0.isra.0>
	if (ep_ctx->write_in_progress) {
   1f542:	7fa3      	ldrb	r3, [r4, #30]
   1f544:	b14b      	cbz	r3, 1f55a <usb_dc_ep_write+0x5e>
		k_mutex_unlock(&ctx->drv_lock);
   1f546:	f108 0038 	add.w	r0, r8, #56	; 0x38
   1f54a:	f005 fd79 	bl	25040 <k_mutex_unlock.isra.0>
		return -EAGAIN;
   1f54e:	f06f 040a 	mvn.w	r4, #10
}
   1f552:	4620      	mov	r0, r4
   1f554:	b005      	add	sp, #20
   1f556:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   1f55a:	7aa3      	ldrb	r3, [r4, #10]
	if (!data_len && ep_ctx->trans_zlp) {
   1f55c:	b1c5      	cbz	r5, 1f590 <usb_dc_ep_write+0x94>
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   1f55e:	b33b      	cbz	r3, 1f5b0 <usb_dc_ep_write+0xb4>
	ep_ctx->write_in_progress = true;
   1f560:	2301      	movs	r3, #1
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
   1f562:	f04f 0800 	mov.w	r8, #0
	ep_ctx->write_in_progress = true;
   1f566:	77a3      	strb	r3, [r4, #30]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
   1f568:	4638      	mov	r0, r7
   1f56a:	a901      	add	r1, sp, #4
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
   1f56c:	e9cd 9501 	strd	r9, r5, [sp, #4]
   1f570:	f8cd 800c 	str.w	r8, [sp, #12]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
   1f574:	f002 ffe6 	bl	22544 <nrfx_usbd_ep_transfer>
	if (err != NRFX_SUCCESS) {
   1f578:	4b1c      	ldr	r3, [pc, #112]	; (1f5ec <usb_dc_ep_write+0xf0>)
   1f57a:	4298      	cmp	r0, r3
   1f57c:	d029      	beq.n	1f5d2 <usb_dc_ep_write+0xd6>
		ep_ctx->write_in_progress = false;
   1f57e:	f884 801e 	strb.w	r8, [r4, #30]
		if (ret_bytes) {
   1f582:	bb1e      	cbnz	r6, 1f5cc <usb_dc_ep_write+0xd0>
		result = -EIO;
   1f584:	f06f 0404 	mvn.w	r4, #4
	k_mutex_unlock(&ctx->drv_lock);
   1f588:	4819      	ldr	r0, [pc, #100]	; (1f5f0 <usb_dc_ep_write+0xf4>)
   1f58a:	f005 fd59 	bl	25040 <k_mutex_unlock.isra.0>
	return result;
   1f58e:	e7e0      	b.n	1f552 <usb_dc_ep_write+0x56>
	if (!data_len && ep_ctx->trans_zlp) {
   1f590:	7fe2      	ldrb	r2, [r4, #31]
   1f592:	b102      	cbz	r2, 1f596 <usb_dc_ep_write+0x9a>
		ep_ctx->trans_zlp = false;
   1f594:	77e5      	strb	r5, [r4, #31]
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   1f596:	2b00      	cmp	r3, #0
   1f598:	d1e2      	bne.n	1f560 <usb_dc_ep_write+0x64>
	    && (nrfx_usbd_last_setup_dir_get() != ep)) {
   1f59a:	f003 fa0b 	bl	229b4 <nrfx_usbd_last_setup_dir_get>
   1f59e:	42b8      	cmp	r0, r7
   1f5a0:	d0de      	beq.n	1f560 <usb_dc_ep_write+0x64>
		nrfx_usbd_setup_clear();
   1f5a2:	f003 f9f7 	bl	22994 <nrfx_usbd_setup_clear>
		k_mutex_unlock(&ctx->drv_lock);
   1f5a6:	4812      	ldr	r0, [pc, #72]	; (1f5f0 <usb_dc_ep_write+0xf4>)
   1f5a8:	f005 fd4a 	bl	25040 <k_mutex_unlock.isra.0>
		return 0;
   1f5ac:	2400      	movs	r4, #0
   1f5ae:	e7d0      	b.n	1f552 <usb_dc_ep_write+0x56>
		if (data_len && usbd_ctx.setup.wLength > data_len &&
   1f5b0:	f8b8 300a 	ldrh.w	r3, [r8, #10]
   1f5b4:	42ab      	cmp	r3, r5
   1f5b6:	d9f0      	bls.n	1f59a <usb_dc_ep_write+0x9e>
		    !(data_len % ep_ctx->cfg.max_sz)) {
   1f5b8:	6862      	ldr	r2, [r4, #4]
   1f5ba:	fbb5 f3f2 	udiv	r3, r5, r2
   1f5be:	fb02 5313 	mls	r3, r2, r3, r5
		if (data_len && usbd_ctx.setup.wLength > data_len &&
   1f5c2:	2b00      	cmp	r3, #0
   1f5c4:	d1e9      	bne.n	1f59a <usb_dc_ep_write+0x9e>
			ep_ctx->trans_zlp = true;
   1f5c6:	2301      	movs	r3, #1
   1f5c8:	77e3      	strb	r3, [r4, #31]
	if ((ep_ctx->cfg.type == USB_DC_EP_CONTROL)
   1f5ca:	e7e6      	b.n	1f59a <usb_dc_ep_write+0x9e>
			*ret_bytes = 0;
   1f5cc:	f8c6 8000 	str.w	r8, [r6]
   1f5d0:	e7d8      	b.n	1f584 <usb_dc_ep_write+0x88>
		if (ret_bytes) {
   1f5d2:	b106      	cbz	r6, 1f5d6 <usb_dc_ep_write+0xda>
			*ret_bytes = data_len;
   1f5d4:	6035      	str	r5, [r6, #0]
	int result = 0;
   1f5d6:	2400      	movs	r4, #0
   1f5d8:	e7d6      	b.n	1f588 <usb_dc_ep_write+0x8c>
		return -ENODEV;
   1f5da:	f06f 0412 	mvn.w	r4, #18
   1f5de:	e7b8      	b.n	1f552 <usb_dc_ep_write+0x56>
		return -EINVAL;
   1f5e0:	f06f 0415 	mvn.w	r4, #21
   1f5e4:	e7b5      	b.n	1f552 <usb_dc_ep_write+0x56>
   1f5e6:	bf00      	nop
   1f5e8:	2000a958 	.word	0x2000a958
   1f5ec:	0bad0000 	.word	0x0bad0000
   1f5f0:	2000a990 	.word	0x2000a990

0001f5f4 <usb_dc_ep_read_wait>:
{
   1f5f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f5f8:	461d      	mov	r5, r3
	return get_usbd_ctx()->attached;
   1f5fa:	4b20      	ldr	r3, [pc, #128]	; (1f67c <usb_dc_ep_read_wait+0x88>)
{
   1f5fc:	4617      	mov	r7, r2
	if (!dev_attached() || !dev_ready()) {
   1f5fe:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   1f602:	460e      	mov	r6, r1
	if (!dev_attached() || !dev_ready()) {
   1f604:	2a00      	cmp	r2, #0
   1f606:	d033      	beq.n	1f670 <usb_dc_ep_read_wait+0x7c>
   1f608:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f60c:	b383      	cbz	r3, 1f670 <usb_dc_ep_read_wait+0x7c>
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1f60e:	0603      	lsls	r3, r0, #24
   1f610:	d431      	bmi.n	1f676 <usb_dc_ep_read_wait+0x82>
	if (!data && max_data_len) {
   1f612:	b901      	cbnz	r1, 1f616 <usb_dc_ep_read_wait+0x22>
   1f614:	bb7f      	cbnz	r7, 1f676 <usb_dc_ep_read_wait+0x82>
	ep_ctx = endpoint_ctx(ep);
   1f616:	f7ff fb01 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f61a:	4604      	mov	r4, r0
   1f61c:	b358      	cbz	r0, 1f676 <usb_dc_ep_read_wait+0x82>
	if (!ep_ctx->cfg.en) {
   1f61e:	7a03      	ldrb	r3, [r0, #8]
   1f620:	b34b      	cbz	r3, 1f676 <usb_dc_ep_read_wait+0x82>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f622:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f626:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f62a:	4815      	ldr	r0, [pc, #84]	; (1f680 <usb_dc_ep_read_wait+0x8c>)
   1f62c:	f005 fd06 	bl	2503c <k_mutex_lock.constprop.0.isra.0>
	bytes_to_copy = MIN(max_data_len, ep_ctx->buf.len);
   1f630:	68e3      	ldr	r3, [r4, #12]
   1f632:	46b8      	mov	r8, r7
   1f634:	429f      	cmp	r7, r3
   1f636:	bf28      	it	cs
   1f638:	4698      	movcs	r8, r3
	if (!data && !max_data_len) {
   1f63a:	b946      	cbnz	r6, 1f64e <usb_dc_ep_read_wait+0x5a>
   1f63c:	b93f      	cbnz	r7, 1f64e <usb_dc_ep_read_wait+0x5a>
		if (read_bytes) {
   1f63e:	b105      	cbz	r5, 1f642 <usb_dc_ep_read_wait+0x4e>
			*read_bytes = ep_ctx->buf.len;
   1f640:	602b      	str	r3, [r5, #0]
		k_mutex_unlock(&ctx->drv_lock);
   1f642:	480f      	ldr	r0, [pc, #60]	; (1f680 <usb_dc_ep_read_wait+0x8c>)
   1f644:	f005 fcfc 	bl	25040 <k_mutex_unlock.isra.0>
		return 0;
   1f648:	2000      	movs	r0, #0
}
   1f64a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	memcpy(data, ep_ctx->buf.curr, bytes_to_copy);
   1f64e:	4642      	mov	r2, r8
   1f650:	4630      	mov	r0, r6
   1f652:	69a1      	ldr	r1, [r4, #24]
   1f654:	f005 fcc5 	bl	24fe2 <memcpy>
	ep_ctx->buf.curr += bytes_to_copy;
   1f658:	69a3      	ldr	r3, [r4, #24]
   1f65a:	4443      	add	r3, r8
   1f65c:	61a3      	str	r3, [r4, #24]
	ep_ctx->buf.len -= bytes_to_copy;
   1f65e:	68e3      	ldr	r3, [r4, #12]
   1f660:	eba3 0308 	sub.w	r3, r3, r8
   1f664:	60e3      	str	r3, [r4, #12]
	if (read_bytes) {
   1f666:	2d00      	cmp	r5, #0
   1f668:	d0eb      	beq.n	1f642 <usb_dc_ep_read_wait+0x4e>
		*read_bytes = bytes_to_copy;
   1f66a:	f8c5 8000 	str.w	r8, [r5]
   1f66e:	e7e8      	b.n	1f642 <usb_dc_ep_read_wait+0x4e>
		return -ENODEV;
   1f670:	f06f 0012 	mvn.w	r0, #18
   1f674:	e7e9      	b.n	1f64a <usb_dc_ep_read_wait+0x56>
		return -EINVAL;
   1f676:	f06f 0015 	mvn.w	r0, #21
   1f67a:	e7e6      	b.n	1f64a <usb_dc_ep_read_wait+0x56>
   1f67c:	2000a958 	.word	0x2000a958
   1f680:	2000a990 	.word	0x2000a990

0001f684 <usb_dc_ep_read_continue>:
{
   1f684:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
   1f686:	4d1e      	ldr	r5, [pc, #120]	; (1f700 <usb_dc_ep_read_continue+0x7c>)
{
   1f688:	4603      	mov	r3, r0
	if (!dev_attached() || !dev_ready()) {
   1f68a:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   1f68e:	b382      	cbz	r2, 1f6f2 <usb_dc_ep_read_continue+0x6e>
   1f690:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   1f694:	b36a      	cbz	r2, 1f6f2 <usb_dc_ep_read_continue+0x6e>
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1f696:	061b      	lsls	r3, r3, #24
   1f698:	d42e      	bmi.n	1f6f8 <usb_dc_ep_read_continue+0x74>
	ep_ctx = endpoint_ctx(ep);
   1f69a:	f7ff fabf 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f69e:	4604      	mov	r4, r0
   1f6a0:	b350      	cbz	r0, 1f6f8 <usb_dc_ep_read_continue+0x74>
	if (!ep_ctx->cfg.en) {
   1f6a2:	7a03      	ldrb	r3, [r0, #8]
   1f6a4:	b343      	cbz	r3, 1f6f8 <usb_dc_ep_read_continue+0x74>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f6a6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f6aa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f6ae:	f105 0038 	add.w	r0, r5, #56	; 0x38
   1f6b2:	f005 fcc3 	bl	2503c <k_mutex_lock.constprop.0.isra.0>
	if (!ep_ctx->buf.len) {
   1f6b6:	68e3      	ldr	r3, [r4, #12]
   1f6b8:	b9b3      	cbnz	r3, 1f6e8 <usb_dc_ep_read_continue+0x64>
		ep_ctx->read_complete = true;
   1f6ba:	2601      	movs	r6, #1
		ep_ctx->buf.curr = ep_ctx->buf.data;
   1f6bc:	6963      	ldr	r3, [r4, #20]
		ep_ctx->read_complete = true;
   1f6be:	7726      	strb	r6, [r4, #28]
		ep_ctx->buf.curr = ep_ctx->buf.data;
   1f6c0:	61a3      	str	r3, [r4, #24]
		if (ep_ctx->read_pending) {
   1f6c2:	7f63      	ldrb	r3, [r4, #29]
   1f6c4:	b183      	cbz	r3, 1f6e8 <usb_dc_ep_read_continue+0x64>
			struct usbd_event *ev = usbd_evt_alloc();
   1f6c6:	f7ff faef 	bl	1eca8 <usbd_evt_alloc>
			if (!ev) {
   1f6ca:	b930      	cbnz	r0, 1f6da <usb_dc_ep_read_continue+0x56>
				k_mutex_unlock(&ctx->drv_lock);
   1f6cc:	f105 0038 	add.w	r0, r5, #56	; 0x38
   1f6d0:	f005 fcb6 	bl	25040 <k_mutex_unlock.isra.0>
				return -ENOMEM;
   1f6d4:	f06f 000b 	mvn.w	r0, #11
}
   1f6d8:	bd70      	pop	{r4, r5, r6, pc}
			ev->evt_type = USBD_EVT_EP;
   1f6da:	7406      	strb	r6, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
   1f6dc:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1f6de:	7306      	strb	r6, [r0, #12]
			usbd_evt_put(ev);
   1f6e0:	f7ff fa8e 	bl	1ec00 <usbd_evt_put>
			usbd_work_schedule();
   1f6e4:	f7ff fa92 	bl	1ec0c <usbd_work_schedule>
	k_mutex_unlock(&ctx->drv_lock);
   1f6e8:	4806      	ldr	r0, [pc, #24]	; (1f704 <usb_dc_ep_read_continue+0x80>)
   1f6ea:	f005 fca9 	bl	25040 <k_mutex_unlock.isra.0>
	return 0;
   1f6ee:	2000      	movs	r0, #0
   1f6f0:	e7f2      	b.n	1f6d8 <usb_dc_ep_read_continue+0x54>
		return -ENODEV;
   1f6f2:	f06f 0012 	mvn.w	r0, #18
   1f6f6:	e7ef      	b.n	1f6d8 <usb_dc_ep_read_continue+0x54>
		return -EINVAL;
   1f6f8:	f06f 0015 	mvn.w	r0, #21
   1f6fc:	e7ec      	b.n	1f6d8 <usb_dc_ep_read_continue+0x54>
   1f6fe:	bf00      	nop
   1f700:	2000a958 	.word	0x2000a958
   1f704:	2000a990 	.word	0x2000a990

0001f708 <usb_dc_ep_set_callback>:
{
   1f708:	b510      	push	{r4, lr}
	return get_usbd_ctx()->attached;
   1f70a:	4b08      	ldr	r3, [pc, #32]	; (1f72c <usb_dc_ep_set_callback+0x24>)
{
   1f70c:	460c      	mov	r4, r1
	if (!dev_attached()) {
   1f70e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1f712:	b12b      	cbz	r3, 1f720 <usb_dc_ep_set_callback+0x18>
	ep_ctx = endpoint_ctx(ep);
   1f714:	f7ff fa82 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f718:	b128      	cbz	r0, 1f726 <usb_dc_ep_set_callback+0x1e>
	ep_ctx->cfg.cb = cb;
   1f71a:	6004      	str	r4, [r0, #0]
	return 0;
   1f71c:	2000      	movs	r0, #0
}
   1f71e:	bd10      	pop	{r4, pc}
		return -ENODEV;
   1f720:	f06f 0012 	mvn.w	r0, #18
   1f724:	e7fb      	b.n	1f71e <usb_dc_ep_set_callback+0x16>
		return -EINVAL;
   1f726:	f06f 0015 	mvn.w	r0, #21
   1f72a:	e7f8      	b.n	1f71e <usb_dc_ep_set_callback+0x16>
   1f72c:	2000a958 	.word	0x2000a958

0001f730 <usb_dc_set_status_callback>:
	get_usbd_ctx()->status_cb = cb;
   1f730:	4b01      	ldr	r3, [pc, #4]	; (1f738 <usb_dc_set_status_callback+0x8>)
   1f732:	6018      	str	r0, [r3, #0]
}
   1f734:	4770      	bx	lr
   1f736:	bf00      	nop
   1f738:	2000a958 	.word	0x2000a958

0001f73c <usb_dc_ep_mps>:
{
   1f73c:	b508      	push	{r3, lr}
	return get_usbd_ctx()->attached;
   1f73e:	4b07      	ldr	r3, [pc, #28]	; (1f75c <usb_dc_ep_mps+0x20>)
	if (!dev_attached()) {
   1f740:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1f744:	b123      	cbz	r3, 1f750 <usb_dc_ep_mps+0x14>
	ep_ctx = endpoint_ctx(ep);
   1f746:	f7ff fa69 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   1f74a:	b120      	cbz	r0, 1f756 <usb_dc_ep_mps+0x1a>
	return ep_ctx->cfg.max_sz;
   1f74c:	6840      	ldr	r0, [r0, #4]
}
   1f74e:	bd08      	pop	{r3, pc}
		return -ENODEV;
   1f750:	f06f 0012 	mvn.w	r0, #18
   1f754:	e7fb      	b.n	1f74e <usb_dc_ep_mps+0x12>
		return -EINVAL;
   1f756:	f06f 0015 	mvn.w	r0, #21
   1f75a:	e7f8      	b.n	1f74e <usb_dc_ep_mps+0x12>
   1f75c:	2000a958 	.word	0x2000a958

0001f760 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
   1f760:	4b08      	ldr	r3, [pc, #32]	; (1f784 <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   1f762:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   1f764:	1ac3      	subs	r3, r0, r3
{
   1f766:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f768:	4907      	ldr	r1, [pc, #28]	; (1f788 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
   1f76a:	109b      	asrs	r3, r3, #2
{
   1f76c:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f76e:	4359      	muls	r1, r3
   1f770:	2240      	movs	r2, #64	; 0x40
   1f772:	4806      	ldr	r0, [pc, #24]	; (1f78c <onoff_stop+0x2c>)
   1f774:	f005 fcc2 	bl	250fc <stop>
	notify(mgr, res);
   1f778:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f77a:	4601      	mov	r1, r0
	notify(mgr, res);
   1f77c:	4620      	mov	r0, r4
}
   1f77e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   1f782:	4718      	bx	r3
   1f784:	2000b1fc 	.word	0x2000b1fc
   1f788:	b6db6db7 	.word	0xb6db6db7
   1f78c:	00026210 	.word	0x00026210

0001f790 <onoff_start>:
static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f790:	2340      	movs	r3, #64	; 0x40
{
   1f792:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   1f794:	4c0b      	ldr	r4, [pc, #44]	; (1f7c4 <onoff_start+0x34>)
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f796:	9300      	str	r3, [sp, #0]
	size_t offset = (size_t)(mgr - data->mgr);
   1f798:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f79a:	460b      	mov	r3, r1
{
   1f79c:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f79e:	490a      	ldr	r1, [pc, #40]	; (1f7c8 <onoff_start+0x38>)
	size_t offset = (size_t)(mgr - data->mgr);
   1f7a0:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f7a2:	4361      	muls	r1, r4
{
   1f7a4:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f7a6:	4a09      	ldr	r2, [pc, #36]	; (1f7cc <onoff_start+0x3c>)
   1f7a8:	4809      	ldr	r0, [pc, #36]	; (1f7d0 <onoff_start+0x40>)
   1f7aa:	f005 fcd4 	bl	25156 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
   1f7ae:	1e01      	subs	r1, r0, #0
   1f7b0:	da05      	bge.n	1f7be <onoff_start+0x2e>
		notify(mgr, err);
   1f7b2:	4630      	mov	r0, r6
   1f7b4:	462b      	mov	r3, r5
	}
}
   1f7b6:	b002      	add	sp, #8
   1f7b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
   1f7bc:	4718      	bx	r3
}
   1f7be:	b002      	add	sp, #8
   1f7c0:	bd70      	pop	{r4, r5, r6, pc}
   1f7c2:	bf00      	nop
   1f7c4:	2000b1fc 	.word	0x2000b1fc
   1f7c8:	b6db6db7 	.word	0xb6db6db7
   1f7cc:	000251c3 	.word	0x000251c3
   1f7d0:	00026210 	.word	0x00026210

0001f7d4 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   1f7d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f7d8:	2200      	movs	r2, #0
   1f7da:	2101      	movs	r1, #1
{
   1f7dc:	4606      	mov	r6, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f7de:	2005      	movs	r0, #5
   1f7e0:	f7fe fdae 	bl	1e340 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
   1f7e4:	4811      	ldr	r0, [pc, #68]	; (1f82c <clk_init+0x58>)
   1f7e6:	f001 fa17 	bl	20c18 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   1f7ea:	4b11      	ldr	r3, [pc, #68]	; (1f830 <clk_init+0x5c>)
   1f7ec:	4298      	cmp	r0, r3
   1f7ee:	d119      	bne.n	1f824 <clk_init+0x50>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   1f7f0:	f001 fa22 	bl	20c38 <nrfx_clock_enable>
   1f7f4:	2400      	movs	r4, #0
	return &data->mgr[type];
   1f7f6:	f04f 091c 	mov.w	r9, #28
					 &transitions);
		if (err < 0) {
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f7fa:	270c      	movs	r7, #12
		err = onoff_manager_init(get_onoff_manager(dev, i),
   1f7fc:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1f834 <clk_init+0x60>
	struct nrf_clock_control_data *data = dev->data;
   1f800:	6935      	ldr	r5, [r6, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   1f802:	4641      	mov	r1, r8
   1f804:	fb09 5004 	mla	r0, r9, r4, r5
   1f808:	f005 f87c 	bl	24904 <onoff_manager_init>
		if (err < 0) {
   1f80c:	2800      	cmp	r0, #0
   1f80e:	db07      	blt.n	1f820 <clk_init+0x4c>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f810:	2301      	movs	r3, #1
   1f812:	fb07 5504 	mla	r5, r7, r4, r5
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
   1f816:	441c      	add	r4, r3
   1f818:	2c04      	cmp	r4, #4
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f81a:	67ab      	str	r3, [r5, #120]	; 0x78
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
   1f81c:	d1f0      	bne.n	1f800 <clk_init+0x2c>
	}

	return 0;
   1f81e:	2000      	movs	r0, #0
}
   1f820:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EIO;
   1f824:	f06f 0004 	mvn.w	r0, #4
   1f828:	e7fa      	b.n	1f820 <clk_init+0x4c>
   1f82a:	bf00      	nop
   1f82c:	0001f86d 	.word	0x0001f86d
   1f830:	0bad0000 	.word	0x0bad0000
   1f834:	000266e0 	.word	0x000266e0

0001f838 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   1f838:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   1f83a:	230c      	movs	r3, #12
	sub_data->cb = NULL;
   1f83c:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
   1f83e:	434b      	muls	r3, r1
static void clkstarted_handle(const struct device *dev,
   1f840:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   1f842:	4808      	ldr	r0, [pc, #32]	; (1f864 <clkstarted_handle.constprop.0+0x2c>)
   1f844:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
   1f846:	3378      	adds	r3, #120	; 0x78
   1f848:	4418      	add	r0, r3
	void *user_data = sub_data->user_data;
   1f84a:	e9d4 561c 	ldrd	r5, r6, [r4, #112]	; 0x70
	sub_data->cb = NULL;
   1f84e:	6722      	str	r2, [r4, #112]	; 0x70
	set_on_state(&sub_data->flags);
   1f850:	f005 fc41 	bl	250d6 <set_on_state>
	if (callback) {
   1f854:	b12d      	cbz	r5, 1f862 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   1f856:	4632      	mov	r2, r6
   1f858:	462b      	mov	r3, r5
}
   1f85a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   1f85e:	4802      	ldr	r0, [pc, #8]	; (1f868 <clkstarted_handle.constprop.0+0x30>)
   1f860:	4718      	bx	r3
}
   1f862:	bd70      	pop	{r4, r5, r6, pc}
   1f864:	2000b1fc 	.word	0x2000b1fc
   1f868:	00026210 	.word	0x00026210

0001f86c <clock_event_handler>:
	switch (event) {
   1f86c:	2805      	cmp	r0, #5
   1f86e:	d811      	bhi.n	1f894 <clock_event_handler+0x28>
   1f870:	e8df f000 	tbb	[pc, r0]
   1f874:	10100e03 	.word	0x10100e03
   1f878:	0a0c      	.short	0x0a0c
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   1f87a:	4b07      	ldr	r3, [pc, #28]	; (1f898 <clock_event_handler+0x2c>)
   1f87c:	6f98      	ldr	r0, [r3, #120]	; 0x78
   1f87e:	f010 0007 	ands.w	r0, r0, #7
   1f882:	d107      	bne.n	1f894 <clock_event_handler+0x28>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1f884:	f7ff bfd8 	b.w	1f838 <clkstarted_handle.constprop.0>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK192M);
   1f888:	2002      	movs	r0, #2
   1f88a:	e7fb      	b.n	1f884 <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLKAUDIO);
   1f88c:	2003      	movs	r0, #3
   1f88e:	e7f9      	b.n	1f884 <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1f890:	2001      	movs	r0, #1
   1f892:	e7f7      	b.n	1f884 <clock_event_handler+0x18>
}
   1f894:	4770      	bx	lr
   1f896:	bf00      	nop
   1f898:	2000b1fc 	.word	0x2000b1fc

0001f89c <generic_hfclk_start>:
{
   1f89c:	b508      	push	{r3, lr}
	__asm__ volatile(
   1f89e:	f04f 0320 	mov.w	r3, #32
   1f8a2:	f3ef 8111 	mrs	r1, BASEPRI
   1f8a6:	f383 8812 	msr	BASEPRI_MAX, r3
   1f8aa:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   1f8ae:	4a11      	ldr	r2, [pc, #68]	; (1f8f4 <generic_hfclk_start+0x58>)
   1f8b0:	6813      	ldr	r3, [r2, #0]
   1f8b2:	f043 0002 	orr.w	r0, r3, #2
   1f8b6:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   1f8b8:	07da      	lsls	r2, r3, #31
   1f8ba:	d408      	bmi.n	1f8ce <generic_hfclk_start+0x32>
	__asm__ volatile(
   1f8bc:	f381 8811 	msr	BASEPRI, r1
   1f8c0:	f3bf 8f6f 	isb	sy
}
   1f8c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   1f8c8:	2001      	movs	r0, #1
   1f8ca:	f001 b9cd 	b.w	20c68 <nrfx_clock_start>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   1f8ce:	4b0a      	ldr	r3, [pc, #40]	; (1f8f8 <generic_hfclk_start+0x5c>)
   1f8d0:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   1f8d4:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   1f8d8:	07d3      	lsls	r3, r2, #31
   1f8da:	d5ef      	bpl.n	1f8bc <generic_hfclk_start+0x20>
			set_on_state(get_hf_flags());
   1f8dc:	4807      	ldr	r0, [pc, #28]	; (1f8fc <generic_hfclk_start+0x60>)
   1f8de:	f005 fbfa 	bl	250d6 <set_on_state>
   1f8e2:	f381 8811 	msr	BASEPRI, r1
   1f8e6:	f3bf 8f6f 	isb	sy
}
   1f8ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   1f8ee:	2000      	movs	r0, #0
   1f8f0:	f7ff bfa2 	b.w	1f838 <clkstarted_handle.constprop.0>
   1f8f4:	2000b29c 	.word	0x2000b29c
   1f8f8:	40005000 	.word	0x40005000
   1f8fc:	2000b274 	.word	0x2000b274

0001f900 <api_blocking_start>:
{
   1f900:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   1f902:	2200      	movs	r2, #0
   1f904:	2301      	movs	r3, #1
   1f906:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   1f90a:	466b      	mov	r3, sp
   1f90c:	4a08      	ldr	r2, [pc, #32]	; (1f930 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   1f90e:	f8cd d000 	str.w	sp, [sp]
   1f912:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   1f916:	f005 fc4d 	bl	251b4 <api_start>
	if (err < 0) {
   1f91a:	2800      	cmp	r0, #0
   1f91c:	db05      	blt.n	1f92a <api_blocking_start+0x2a>
	return z_impl_k_sem_take(sem, timeout);
   1f91e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1f922:	2300      	movs	r3, #0
   1f924:	4668      	mov	r0, sp
   1f926:	f003 fe2b 	bl	23580 <z_impl_k_sem_take>
}
   1f92a:	b005      	add	sp, #20
   1f92c:	f85d fb04 	ldr.w	pc, [sp], #4
   1f930:	000251f9 	.word	0x000251f9

0001f934 <generic_hfclk_stop>:
{
   1f934:	b510      	push	{r4, lr}
	__asm__ volatile(
   1f936:	f04f 0320 	mov.w	r3, #32
   1f93a:	f3ef 8411 	mrs	r4, BASEPRI
   1f93e:	f383 8812 	msr	BASEPRI_MAX, r3
   1f942:	f3bf 8f6f 	isb	sy
	hfclk_users &= ~HF_USER_GENERIC;
   1f946:	4a07      	ldr	r2, [pc, #28]	; (1f964 <generic_hfclk_stop+0x30>)
   1f948:	6813      	ldr	r3, [r2, #0]
   1f94a:	f023 0102 	bic.w	r1, r3, #2
	if (!(hfclk_users & HF_USER_BT)) {
   1f94e:	07db      	lsls	r3, r3, #31
	hfclk_users &= ~HF_USER_GENERIC;
   1f950:	6011      	str	r1, [r2, #0]
	if (!(hfclk_users & HF_USER_BT)) {
   1f952:	d402      	bmi.n	1f95a <generic_hfclk_stop+0x26>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   1f954:	2001      	movs	r0, #1
   1f956:	f005 ff62 	bl	2581e <nrfx_clock_stop>
	__asm__ volatile(
   1f95a:	f384 8811 	msr	BASEPRI, r4
   1f95e:	f3bf 8f6f 	isb	sy
}
   1f962:	bd10      	pop	{r4, pc}
   1f964:	2000b29c 	.word	0x2000b29c

0001f968 <z_nrf_clock_control_get_onoff>:
	return &data->mgr[type];
   1f968:	b2c3      	uxtb	r3, r0
}
   1f96a:	201c      	movs	r0, #28
   1f96c:	4a01      	ldr	r2, [pc, #4]	; (1f974 <z_nrf_clock_control_get_onoff+0xc>)
   1f96e:	fb03 2000 	mla	r0, r3, r0, r2
   1f972:	4770      	bx	lr
   1f974:	2000b1fc 	.word	0x2000b1fc

0001f978 <z_nrf_clock_control_lf_on>:
{
   1f978:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1f97c:	2201      	movs	r2, #1
   1f97e:	4607      	mov	r7, r0
   1f980:	4935      	ldr	r1, [pc, #212]	; (1fa58 <z_nrf_clock_control_lf_on+0xe0>)
   1f982:	e8d1 3fef 	ldaex	r3, [r1]
   1f986:	e8c1 2fe0 	stlex	r0, r2, [r1]
   1f98a:	2800      	cmp	r0, #0
   1f98c:	d1f9      	bne.n	1f982 <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
   1f98e:	b933      	cbnz	r3, 1f99e <z_nrf_clock_control_lf_on+0x26>
   1f990:	4932      	ldr	r1, [pc, #200]	; (1fa5c <z_nrf_clock_control_lf_on+0xe4>)
		err = onoff_request(mgr, &cli);
   1f992:	4833      	ldr	r0, [pc, #204]	; (1fa60 <z_nrf_clock_control_lf_on+0xe8>)
   1f994:	604b      	str	r3, [r1, #4]
   1f996:	60cb      	str	r3, [r1, #12]
   1f998:	608a      	str	r2, [r1, #8]
   1f99a:	f004 ffc6 	bl	2492a <onoff_request>
	switch (start_mode) {
   1f99e:	1e7b      	subs	r3, r7, #1
   1f9a0:	2b01      	cmp	r3, #1
   1f9a2:	d828      	bhi.n	1f9f6 <z_nrf_clock_control_lf_on+0x7e>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   1f9a4:	2f01      	cmp	r7, #1
   1f9a6:	d106      	bne.n	1f9b6 <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   1f9a8:	4b2e      	ldr	r3, [pc, #184]	; (1fa64 <z_nrf_clock_control_lf_on+0xec>)
   1f9aa:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   1f9ae:	f003 0303 	and.w	r3, r3, #3
   1f9b2:	2b02      	cmp	r3, #2
   1f9b4:	d01f      	beq.n	1f9f6 <z_nrf_clock_control_lf_on+0x7e>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   1f9b6:	f006 f8f6 	bl	25ba6 <k_is_in_isr>
   1f9ba:	4605      	mov	r5, r0
   1f9bc:	b9e8      	cbnz	r0, 1f9fa <z_nrf_clock_control_lf_on+0x82>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   1f9be:	4b2a      	ldr	r3, [pc, #168]	; (1fa68 <z_nrf_clock_control_lf_on+0xf0>)
   1f9c0:	781b      	ldrb	r3, [r3, #0]
   1f9c2:	b1d3      	cbz	r3, 1f9fa <z_nrf_clock_control_lf_on+0x82>
    p_reg->INTENCLR = mask;
   1f9c4:	2202      	movs	r2, #2
	int key = isr_mode ? irq_lock() : 0;
   1f9c6:	4606      	mov	r6, r0
   1f9c8:	4b26      	ldr	r3, [pc, #152]	; (1fa64 <z_nrf_clock_control_lf_on+0xec>)
   1f9ca:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   1f9ce:	4c25      	ldr	r4, [pc, #148]	; (1fa64 <z_nrf_clock_control_lf_on+0xec>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1f9d0:	f8df 8098 	ldr.w	r8, [pc, #152]	; 1fa6c <z_nrf_clock_control_lf_on+0xf4>
   1f9d4:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   1f9d8:	f8d4 2418 	ldr.w	r2, [r4, #1048]	; 0x418
   1f9dc:	03d2      	lsls	r2, r2, #15
   1f9de:	d516      	bpl.n	1fa0e <z_nrf_clock_control_lf_on+0x96>
	while (!(nrfx_clock_is_running(d, (void *)&type)
   1f9e0:	f003 0303 	and.w	r3, r3, #3
   1f9e4:	2b02      	cmp	r3, #2
   1f9e6:	d001      	beq.n	1f9ec <z_nrf_clock_control_lf_on+0x74>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   1f9e8:	2f01      	cmp	r7, #1
   1f9ea:	d110      	bne.n	1fa0e <z_nrf_clock_control_lf_on+0x96>
	if (isr_mode) {
   1f9ec:	b375      	cbz	r5, 1fa4c <z_nrf_clock_control_lf_on+0xd4>
   1f9ee:	f386 8811 	msr	BASEPRI, r6
   1f9f2:	f3bf 8f6f 	isb	sy
}
   1f9f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm__ volatile(
   1f9fa:	f04f 0320 	mov.w	r3, #32
   1f9fe:	f3ef 8611 	mrs	r6, BASEPRI
   1fa02:	f383 8812 	msr	BASEPRI_MAX, r3
   1fa06:	f3bf 8f6f 	isb	sy
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   1fa0a:	2501      	movs	r5, #1
   1fa0c:	e7df      	b.n	1f9ce <z_nrf_clock_control_lf_on+0x56>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   1fa0e:	b1c5      	cbz	r5, 1fa42 <z_nrf_clock_control_lf_on+0xca>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   1fa10:	4630      	mov	r0, r6
   1fa12:	f7fe fc53 	bl	1e2bc <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   1fa16:	f8d4 3518 	ldr.w	r3, [r4, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   1fa1a:	b2db      	uxtb	r3, r3
   1fa1c:	2b01      	cmp	r3, #1
   1fa1e:	d1d9      	bne.n	1f9d4 <z_nrf_clock_control_lf_on+0x5c>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1fa20:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
   1fa24:	2a00      	cmp	r2, #0
   1fa26:	d0d5      	beq.n	1f9d4 <z_nrf_clock_control_lf_on+0x5c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1fa28:	2200      	movs	r2, #0
   1fa2a:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
   1fa2e:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
   1fa32:	2202      	movs	r2, #2
   1fa34:	f8c4 2518 	str.w	r2, [r4, #1304]	; 0x518
   1fa38:	2220      	movs	r2, #32
   1fa3a:	f8c8 2180 	str.w	r2, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fa3e:	60a3      	str	r3, [r4, #8]
}
   1fa40:	e7c8      	b.n	1f9d4 <z_nrf_clock_control_lf_on+0x5c>
	return z_impl_k_sleep(timeout);
   1fa42:	2100      	movs	r1, #0
   1fa44:	2021      	movs	r0, #33	; 0x21
   1fa46:	f004 f9fb 	bl	23e40 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   1fa4a:	e7e4      	b.n	1fa16 <z_nrf_clock_control_lf_on+0x9e>
    p_reg->INTENSET = mask;
   1fa4c:	2202      	movs	r2, #2
   1fa4e:	4b05      	ldr	r3, [pc, #20]	; (1fa64 <z_nrf_clock_control_lf_on+0xec>)
   1fa50:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   1fa54:	e7cf      	b.n	1f9f6 <z_nrf_clock_control_lf_on+0x7e>
   1fa56:	bf00      	nop
   1fa58:	2000b1f8 	.word	0x2000b1f8
   1fa5c:	2000b1e8 	.word	0x2000b1e8
   1fa60:	2000b218 	.word	0x2000b218
   1fa64:	40005000 	.word	0x40005000
   1fa68:	2000b637 	.word	0x2000b637
   1fa6c:	e000e100 	.word	0xe000e100

0001fa70 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(void)
{
   1fa70:	b508      	push	{r3, lr}
   1fa72:	4807      	ldr	r0, [pc, #28]	; (1fa90 <uart_console_init+0x20>)
   1fa74:	f006 f82e 	bl	25ad4 <z_device_is_ready>
	if (!device_is_ready(uart_console_dev)) {
   1fa78:	b138      	cbz	r0, 1fa8a <uart_console_init+0x1a>
	__stdout_hook_install(console_out);
   1fa7a:	4806      	ldr	r0, [pc, #24]	; (1fa94 <uart_console_init+0x24>)
   1fa7c:	f7ff f8b2 	bl	1ebe4 <__stdout_hook_install>
	__printk_hook_install(console_out);
   1fa80:	4804      	ldr	r0, [pc, #16]	; (1fa94 <uart_console_init+0x24>)
   1fa82:	f7fc fd25 	bl	1c4d0 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   1fa86:	2000      	movs	r0, #0
}
   1fa88:	bd08      	pop	{r3, pc}
		return -ENODEV;
   1fa8a:	f06f 0012 	mvn.w	r0, #18
   1fa8e:	e7fb      	b.n	1fa88 <uart_console_init+0x18>
   1fa90:	00026270 	.word	0x00026270
   1fa94:	0001fa99 	.word	0x0001fa99

0001fa98 <console_out>:
	if ('\n' == c) {
   1fa98:	280a      	cmp	r0, #10
{
   1fa9a:	b538      	push	{r3, r4, r5, lr}
   1fa9c:	4604      	mov	r4, r0
   1fa9e:	4d07      	ldr	r5, [pc, #28]	; (1fabc <console_out+0x24>)
	if ('\n' == c) {
   1faa0:	d104      	bne.n	1faac <console_out+0x14>
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   1faa2:	68ab      	ldr	r3, [r5, #8]
   1faa4:	210d      	movs	r1, #13
   1faa6:	4628      	mov	r0, r5
   1faa8:	685b      	ldr	r3, [r3, #4]
   1faaa:	4798      	blx	r3
   1faac:	68ab      	ldr	r3, [r5, #8]
   1faae:	4803      	ldr	r0, [pc, #12]	; (1fabc <console_out+0x24>)
   1fab0:	685b      	ldr	r3, [r3, #4]
   1fab2:	b2e1      	uxtb	r1, r4
   1fab4:	4798      	blx	r3
}
   1fab6:	4620      	mov	r0, r4
   1fab8:	bd38      	pop	{r3, r4, r5, pc}
   1faba:	bf00      	nop
   1fabc:	00026270 	.word	0x00026270

0001fac0 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   1fac0:	b530      	push	{r4, r5, lr}
	return port->config;
   1fac2:	6840      	ldr	r0, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   1fac4:	f001 041f 	and.w	r4, r1, #31
   1fac8:	7b05      	ldrb	r5, [r0, #12]
	nrfx_err_t err;
	uint8_t ch;

	if (mode == GPIO_INT_MODE_DISABLED) {
   1faca:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
{
   1face:	b085      	sub	sp, #20
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   1fad0:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
   1fad4:	d105      	bne.n	1fae2 <gpio_nrfx_pin_interrupt_configure+0x22>
		nrfx_gpiote_trigger_disable(abs_pin);
   1fad6:	4620      	mov	r0, r4
   1fad8:	f001 fbba 	bl	21250 <nrfx_gpiote_trigger_disable>

		return 0;
   1fadc:	2000      	movs	r0, #0
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
}
   1fade:	b005      	add	sp, #20
   1fae0:	bd30      	pop	{r4, r5, pc}
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fae2:	2500      	movs	r5, #0
	if (mode == GPIO_INT_MODE_LEVEL) {
   1fae4:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fae8:	e9cd 5502 	strd	r5, r5, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   1faec:	d114      	bne.n	1fb18 <gpio_nrfx_pin_interrupt_configure+0x58>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   1faee:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
	nrfx_gpiote_trigger_config_t trigger_config = {
   1faf2:	bf0c      	ite	eq
   1faf4:	2304      	moveq	r3, #4
   1faf6:	2305      	movne	r3, #5
   1faf8:	f88d 3008 	strb.w	r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fafc:	2300      	movs	r3, #0
   1fafe:	4620      	mov	r0, r4
   1fb00:	4619      	mov	r1, r3
   1fb02:	aa02      	add	r2, sp, #8
   1fb04:	f001 f9e2 	bl	20ecc <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   1fb08:	4b1f      	ldr	r3, [pc, #124]	; (1fb88 <gpio_nrfx_pin_interrupt_configure+0xc8>)
   1fb0a:	4298      	cmp	r0, r3
   1fb0c:	d138      	bne.n	1fb80 <gpio_nrfx_pin_interrupt_configure+0xc0>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   1fb0e:	2101      	movs	r1, #1
   1fb10:	4620      	mov	r0, r4
   1fb12:	f001 fb57 	bl	211c4 <nrfx_gpiote_trigger_enable>
	return 0;
   1fb16:	e7e1      	b.n	1fadc <gpio_nrfx_pin_interrupt_configure+0x1c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   1fb18:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
   1fb1c:	d025      	beq.n	1fb6a <gpio_nrfx_pin_interrupt_configure+0xaa>
   1fb1e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   1fb22:	bf14      	ite	ne
   1fb24:	2301      	movne	r3, #1
   1fb26:	2302      	moveq	r3, #2
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fb28:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   1fb2c:	6883      	ldr	r3, [r0, #8]
   1fb2e:	40cb      	lsrs	r3, r1
   1fb30:	07d9      	lsls	r1, r3, #31
   1fb32:	d4e3      	bmi.n	1fafc <gpio_nrfx_pin_interrupt_configure+0x3c>
   1fb34:	f1b2 7fa0 	cmp.w	r2, #20971520	; 0x1400000
   1fb38:	d1e0      	bne.n	1fafc <gpio_nrfx_pin_interrupt_configure+0x3c>
        /* FALLTHROUGH */
        case 0: return NRF_P0;
#endif
#if defined(P1_FEATURE_PINS_PRESENT)
        /* FALLTHROUGH */
        case 1: return NRF_P1;
   1fb3a:	4a14      	ldr	r2, [pc, #80]	; (1fb8c <gpio_nrfx_pin_interrupt_configure+0xcc>)
   1fb3c:	4814      	ldr	r0, [pc, #80]	; (1fb90 <gpio_nrfx_pin_interrupt_configure+0xd0>)
NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;

    return pin_number >> 5;
   1fb3e:	0961      	lsrs	r1, r4, #5
        case 1: return NRF_P1;
   1fb40:	2901      	cmp	r1, #1
   1fb42:	bf08      	it	eq
   1fb44:	4602      	moveq	r2, r0
    *p_pin = pin_number & 0x1F;
   1fb46:	f004 031f 	and.w	r3, r4, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   1fb4a:	3380      	adds	r3, #128	; 0x80
   1fb4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   1fb50:	07db      	lsls	r3, r3, #31
   1fb52:	d4d3      	bmi.n	1fafc <gpio_nrfx_pin_interrupt_configure+0x3c>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fb54:	f10d 0507 	add.w	r5, sp, #7
   1fb58:	4629      	mov	r1, r5
   1fb5a:	4620      	mov	r0, r4
   1fb5c:	f001 fade 	bl	2111c <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   1fb60:	4b0c      	ldr	r3, [pc, #48]	; (1fb94 <gpio_nrfx_pin_interrupt_configure+0xd4>)
   1fb62:	4298      	cmp	r0, r3
   1fb64:	d003      	beq.n	1fb6e <gpio_nrfx_pin_interrupt_configure+0xae>
		trigger_config.p_in_channel = &ch;
   1fb66:	9503      	str	r5, [sp, #12]
   1fb68:	e7c8      	b.n	1fafc <gpio_nrfx_pin_interrupt_configure+0x3c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   1fb6a:	2303      	movs	r3, #3
   1fb6c:	e7dc      	b.n	1fb28 <gpio_nrfx_pin_interrupt_configure+0x68>
			err = nrfx_gpiote_channel_alloc(&ch);
   1fb6e:	4628      	mov	r0, r5
   1fb70:	f001 fb22 	bl	211b8 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   1fb74:	4b04      	ldr	r3, [pc, #16]	; (1fb88 <gpio_nrfx_pin_interrupt_configure+0xc8>)
   1fb76:	4298      	cmp	r0, r3
   1fb78:	d0f5      	beq.n	1fb66 <gpio_nrfx_pin_interrupt_configure+0xa6>
				return -ENOMEM;
   1fb7a:	f06f 000b 	mvn.w	r0, #11
   1fb7e:	e7ae      	b.n	1fade <gpio_nrfx_pin_interrupt_configure+0x1e>
		return -EINVAL;
   1fb80:	f06f 0015 	mvn.w	r0, #21
   1fb84:	e7ab      	b.n	1fade <gpio_nrfx_pin_interrupt_configure+0x1e>
   1fb86:	bf00      	nop
   1fb88:	0bad0000 	.word	0x0bad0000
   1fb8c:	40842500 	.word	0x40842500
   1fb90:	40842800 	.word	0x40842800
   1fb94:	0bad0004 	.word	0x0bad0004

0001fb98 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   1fb98:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   1fb9a:	f001 fafd 	bl	21198 <nrfx_gpiote_is_init>
   1fb9e:	4604      	mov	r4, r0
   1fba0:	b968      	cbnz	r0, 1fbbe <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   1fba2:	f001 fad1 	bl	21148 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   1fba6:	4b08      	ldr	r3, [pc, #32]	; (1fbc8 <gpio_nrfx_init+0x30>)
   1fba8:	4298      	cmp	r0, r3
   1fbaa:	d10a      	bne.n	1fbc2 <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   1fbac:	4621      	mov	r1, r4
   1fbae:	4807      	ldr	r0, [pc, #28]	; (1fbcc <gpio_nrfx_init+0x34>)
   1fbb0:	f001 faae 	bl	21110 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   1fbb4:	4622      	mov	r2, r4
   1fbb6:	2105      	movs	r1, #5
   1fbb8:	202f      	movs	r0, #47	; 0x2f
   1fbba:	f7fe fbc1 	bl	1e340 <z_arm_irq_priority_set>
		return 0;
   1fbbe:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   1fbc0:	bd10      	pop	{r4, pc}
		return -EIO;
   1fbc2:	f06f 0004 	mvn.w	r0, #4
   1fbc6:	e7fb      	b.n	1fbc0 <gpio_nrfx_init+0x28>
   1fbc8:	0bad0000 	.word	0x0bad0000
   1fbcc:	0001fbd1 	.word	0x0001fbd1

0001fbd0 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbd0:	0942      	lsrs	r2, r0, #5
{
   1fbd2:	4603      	mov	r3, r0
   1fbd4:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbd6:	d002      	beq.n	1fbde <nrfx_gpio_handler+0xe>
   1fbd8:	2a01      	cmp	r2, #1
   1fbda:	d017      	beq.n	1fc0c <nrfx_gpio_handler+0x3c>
}
   1fbdc:	bd70      	pop	{r4, r5, r6, pc}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbde:	4e0d      	ldr	r6, [pc, #52]	; (1fc14 <nrfx_gpio_handler+0x44>)
	gpio_fire_callbacks(list, port, BIT(pin));
   1fbe0:	6932      	ldr	r2, [r6, #16]
   1fbe2:	6851      	ldr	r1, [r2, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1fbe4:	2900      	cmp	r1, #0
   1fbe6:	d0f9      	beq.n	1fbdc <nrfx_gpio_handler+0xc>
   1fbe8:	2501      	movs	r5, #1
    *p_pin = pin_number & 0x1F;
   1fbea:	f003 031f 	and.w	r3, r3, #31
	return node->next;
   1fbee:	680c      	ldr	r4, [r1, #0]
   1fbf0:	409d      	lsls	r5, r3
   1fbf2:	2900      	cmp	r1, #0
   1fbf4:	d0f2      	beq.n	1fbdc <nrfx_gpio_handler+0xc>
		if (cb->pin_mask & pins) {
   1fbf6:	688a      	ldr	r2, [r1, #8]
   1fbf8:	402a      	ands	r2, r5
   1fbfa:	d002      	beq.n	1fc02 <nrfx_gpio_handler+0x32>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   1fbfc:	4630      	mov	r0, r6
   1fbfe:	684b      	ldr	r3, [r1, #4]
   1fc00:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1fc02:	b12c      	cbz	r4, 1fc10 <nrfx_gpio_handler+0x40>
   1fc04:	6823      	ldr	r3, [r4, #0]
   1fc06:	4621      	mov	r1, r4
   1fc08:	461c      	mov	r4, r3
   1fc0a:	e7f2      	b.n	1fbf2 <nrfx_gpio_handler+0x22>
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fc0c:	4e02      	ldr	r6, [pc, #8]	; (1fc18 <nrfx_gpio_handler+0x48>)
   1fc0e:	e7e7      	b.n	1fbe0 <nrfx_gpio_handler+0x10>
   1fc10:	4623      	mov	r3, r4
   1fc12:	e7f8      	b.n	1fc06 <nrfx_gpio_handler+0x36>
   1fc14:	00026240 	.word	0x00026240
   1fc18:	00026228 	.word	0x00026228

0001fc1c <gpio_nrfx_pin_configure>:
{
   1fc1c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return port->config;
   1fc20:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1fc22:	f001 051f 	and.w	r5, r1, #31
   1fc26:	7b3b      	ldrb	r3, [r7, #12]
{
   1fc28:	4614      	mov	r4, r2
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1fc2a:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
{
   1fc2e:	460e      	mov	r6, r1
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fc30:	4628      	mov	r0, r5
   1fc32:	f10d 0103 	add.w	r1, sp, #3
   1fc36:	f001 fa71 	bl	2111c <nrfx_gpiote_channel_get>
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
   1fc3a:	f414 3f40 	tst.w	r4, #196608	; 0x30000
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fc3e:	4680      	mov	r8, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
   1fc40:	d10b      	bne.n	1fc5a <gpio_nrfx_pin_configure+0x3e>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
   1fc42:	4628      	mov	r0, r5
   1fc44:	f001 fb2c 	bl	212a0 <nrfx_gpiote_pin_uninit>
		if (free_ch) {
   1fc48:	4b3c      	ldr	r3, [pc, #240]	; (1fd3c <gpio_nrfx_pin_configure+0x120>)
   1fc4a:	4598      	cmp	r8, r3
   1fc4c:	d103      	bne.n	1fc56 <gpio_nrfx_pin_configure+0x3a>
			err = nrfx_gpiote_channel_free(ch);
   1fc4e:	f89d 0003 	ldrb.w	r0, [sp, #3]
   1fc52:	f001 faab 	bl	211ac <nrfx_gpiote_channel_free>
		return 0;
   1fc56:	2000      	movs	r0, #0
   1fc58:	e00c      	b.n	1fc74 <gpio_nrfx_pin_configure+0x58>
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fc5a:	2300      	movs	r3, #0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fc5c:	4628      	mov	r0, r5
   1fc5e:	4619      	mov	r1, r3
   1fc60:	aa02      	add	r2, sp, #8
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fc62:	e9cd 3302 	strd	r3, r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fc66:	f001 f931 	bl	20ecc <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   1fc6a:	4b34      	ldr	r3, [pc, #208]	; (1fd3c <gpio_nrfx_pin_configure+0x120>)
   1fc6c:	4298      	cmp	r0, r3
   1fc6e:	d004      	beq.n	1fc7a <gpio_nrfx_pin_configure+0x5e>
		return NRF_GPIO_PIN_PULLUP;
   1fc70:	f06f 0015 	mvn.w	r0, #21
}
   1fc74:	b004      	add	sp, #16
   1fc76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (free_ch) {
   1fc7a:	4580      	cmp	r8, r0
   1fc7c:	d103      	bne.n	1fc86 <gpio_nrfx_pin_configure+0x6a>
		err = nrfx_gpiote_channel_free(ch);
   1fc7e:	f89d 0003 	ldrb.w	r0, [sp, #3]
   1fc82:	f001 fa93 	bl	211ac <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   1fc86:	03a3      	lsls	r3, r4, #14
   1fc88:	d549      	bpl.n	1fd1e <gpio_nrfx_pin_configure+0x102>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fc8a:	f240 3306 	movw	r3, #774	; 0x306
   1fc8e:	4023      	ands	r3, r4
   1fc90:	f5b3 7f83 	cmp.w	r3, #262	; 0x106
   1fc94:	d019      	beq.n	1fcca <gpio_nrfx_pin_configure+0xae>
   1fc96:	d80c      	bhi.n	1fcb2 <gpio_nrfx_pin_configure+0x96>
   1fc98:	2b06      	cmp	r3, #6
   1fc9a:	d017      	beq.n	1fccc <gpio_nrfx_pin_configure+0xb0>
   1fc9c:	d804      	bhi.n	1fca8 <gpio_nrfx_pin_configure+0x8c>
   1fc9e:	b1ab      	cbz	r3, 1fccc <gpio_nrfx_pin_configure+0xb0>
   1fca0:	2b02      	cmp	r3, #2
   1fca2:	d1e5      	bne.n	1fc70 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0S1;
   1fca4:	2304      	movs	r3, #4
   1fca6:	e011      	b.n	1fccc <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fca8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   1fcac:	d1e0      	bne.n	1fc70 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_H0S1;
   1fcae:	2301      	movs	r3, #1
   1fcb0:	e00c      	b.n	1fccc <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fcb2:	f240 2202 	movw	r2, #514	; 0x202
   1fcb6:	4293      	cmp	r3, r2
   1fcb8:	d026      	beq.n	1fd08 <gpio_nrfx_pin_configure+0xec>
   1fcba:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
   1fcbe:	d025      	beq.n	1fd0c <gpio_nrfx_pin_configure+0xf0>
   1fcc0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1fcc4:	d1d4      	bne.n	1fc70 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_S0H1;
   1fcc6:	2302      	movs	r3, #2
   1fcc8:	e000      	b.n	1fccc <gpio_nrfx_pin_configure+0xb0>
		*drive = NRF_GPIO_PIN_H0D1;
   1fcca:	2307      	movs	r3, #7
		nrfx_gpiote_output_config_t output_config = {
   1fccc:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   1fcd0:	f484 3380 	eor.w	r3, r4, #65536	; 0x10000
   1fcd4:	f3c3 4300 	ubfx	r3, r3, #16, #1
	if (flags & GPIO_PULL_UP) {
   1fcd8:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   1fcda:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
   1fcde:	bf4c      	ite	mi
   1fce0:	2303      	movmi	r3, #3
	} else if (flags & GPIO_PULL_DOWN) {
   1fce2:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   1fce6:	0321      	lsls	r1, r4, #12
		nrfx_gpiote_output_config_t output_config = {
   1fce8:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   1fcec:	d510      	bpl.n	1fd10 <gpio_nrfx_pin_configure+0xf4>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   1fcee:	2301      	movs	r3, #1
   1fcf0:	687a      	ldr	r2, [r7, #4]
   1fcf2:	40b3      	lsls	r3, r6
    p_reg->OUTSET = set_mask;
   1fcf4:	6093      	str	r3, [r2, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   1fcf6:	2200      	movs	r2, #0
   1fcf8:	4628      	mov	r0, r5
   1fcfa:	a901      	add	r1, sp, #4
   1fcfc:	f001 f994 	bl	21028 <nrfx_gpiote_output_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   1fd00:	4b0e      	ldr	r3, [pc, #56]	; (1fd3c <gpio_nrfx_pin_configure+0x120>)
   1fd02:	4298      	cmp	r0, r3
   1fd04:	d0a7      	beq.n	1fc56 <gpio_nrfx_pin_configure+0x3a>
   1fd06:	e7b3      	b.n	1fc70 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0H1;
   1fd08:	2305      	movs	r3, #5
   1fd0a:	e7df      	b.n	1fccc <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fd0c:	2303      	movs	r3, #3
   1fd0e:	e7dd      	b.n	1fccc <gpio_nrfx_pin_configure+0xb0>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   1fd10:	0362      	lsls	r2, r4, #13
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   1fd12:	bf41      	itttt	mi
   1fd14:	2301      	movmi	r3, #1
   1fd16:	687a      	ldrmi	r2, [r7, #4]
   1fd18:	40b3      	lslmi	r3, r6
    p_reg->OUTCLR = clr_mask;
   1fd1a:	60d3      	strmi	r3, [r2, #12]
}
   1fd1c:	e7eb      	b.n	1fcf6 <gpio_nrfx_pin_configure+0xda>
	if (flags & GPIO_PULL_UP) {
   1fd1e:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1fd20:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   1fd24:	bf4c      	ite	mi
   1fd26:	2403      	movmi	r4, #3
	} else if (flags & GPIO_PULL_DOWN) {
   1fd28:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1fd2c:	461a      	mov	r2, r3
   1fd2e:	4628      	mov	r0, r5
   1fd30:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
   1fd32:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1fd36:	f001 f8c9 	bl	20ecc <nrfx_gpiote_input_configure>
   1fd3a:	e7e1      	b.n	1fd00 <gpio_nrfx_pin_configure+0xe4>
   1fd3c:	0bad0000 	.word	0x0bad0000

0001fd40 <z_impl_hwinfo_get_device_id>:

static inline void soc_secure_read_deviceid(uint32_t deviceid[2])
{
	int err;

	err = soc_secure_mem_read(deviceid,
   1fd40:	2208      	movs	r2, #8
struct nrf_uid {
	uint32_t id[2];
};

ssize_t z_impl_hwinfo_get_device_id(uint8_t *buffer, size_t length)
{
   1fd42:	b530      	push	{r4, r5, lr}
   1fd44:	460c      	mov	r4, r1
   1fd46:	b085      	sub	sp, #20
   1fd48:	4605      	mov	r5, r0
   1fd4a:	490b      	ldr	r1, [pc, #44]	; (1fd78 <z_impl_hwinfo_get_device_id+0x38>)
   1fd4c:	eb0d 0002 	add.w	r0, sp, r2
   1fd50:	f004 ffe6 	bl	24d20 <soc_secure_mem_read>
	soc_secure_read_deviceid(deviceid);

	dev_id.id[0] = sys_cpu_to_be32(deviceid[1]);
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);

	if (length > sizeof(dev_id.id)) {
   1fd54:	2c08      	cmp	r4, #8
   1fd56:	bf28      	it	cs
   1fd58:	2408      	movcs	r4, #8
   1fd5a:	9b03      	ldr	r3, [sp, #12]
		length = sizeof(dev_id.id);
	}

	memcpy(buffer, dev_id.id, length);
   1fd5c:	4622      	mov	r2, r4
   1fd5e:	ba1b      	rev	r3, r3
	dev_id.id[0] = sys_cpu_to_be32(deviceid[1]);
   1fd60:	9300      	str	r3, [sp, #0]
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);
   1fd62:	9b02      	ldr	r3, [sp, #8]
	memcpy(buffer, dev_id.id, length);
   1fd64:	4669      	mov	r1, sp
   1fd66:	ba1b      	rev	r3, r3
   1fd68:	4628      	mov	r0, r5
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);
   1fd6a:	9301      	str	r3, [sp, #4]
	memcpy(buffer, dev_id.id, length);
   1fd6c:	f005 f939 	bl	24fe2 <memcpy>

	return length;
}
   1fd70:	4620      	mov	r0, r4
   1fd72:	b005      	add	sp, #20
   1fd74:	bd30      	pop	{r4, r5, pc}
   1fd76:	bf00      	nop
   1fd78:	00ff0204 	.word	0x00ff0204

0001fd7c <i2c_nrfx_twim_init>:
	return ret;
}
#endif /* CONFIG_PM_DEVICE */

static int i2c_nrfx_twim_init(const struct device *dev)
{
   1fd7c:	b538      	push	{r3, r4, r5, lr}
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   1fd7e:	6844      	ldr	r4, [r0, #4]
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   1fd80:	6905      	ldr	r5, [r0, #16]

	dev_config->irq_connect();
   1fd82:	69e3      	ldr	r3, [r4, #28]
   1fd84:	4798      	blx	r3

	int err = pinctrl_apply_state(dev_config->pcfg,
   1fd86:	6a20      	ldr	r0, [r4, #32]
   1fd88:	f005 faba 	bl	25300 <pinctrl_apply_state.constprop.0>
				      COND_CODE_1(CONFIG_PM_DEVICE_RUNTIME,
						  (PINCTRL_STATE_SLEEP),
						  (PINCTRL_STATE_DEFAULT)));
	if (err < 0) {
   1fd8c:	2800      	cmp	r0, #0
   1fd8e:	db0d      	blt.n	1fdac <i2c_nrfx_twim_init+0x30>
		return err;
	}

	if (nrfx_twim_init(&dev_config->twim, &dev_config->twim_config,
   1fd90:	462b      	mov	r3, r5
   1fd92:	4620      	mov	r0, r4
   1fd94:	4a07      	ldr	r2, [pc, #28]	; (1fdb4 <i2c_nrfx_twim_init+0x38>)
   1fd96:	f104 0108 	add.w	r1, r4, #8
   1fd9a:	f001 fe49 	bl	21a30 <nrfx_twim_init>
   1fd9e:	4b06      	ldr	r3, [pc, #24]	; (1fdb8 <i2c_nrfx_twim_init+0x3c>)
   1fda0:	4298      	cmp	r0, r3
   1fda2:	d104      	bne.n	1fdae <i2c_nrfx_twim_init+0x32>

#ifdef CONFIG_PM_DEVICE_RUNTIME
	pm_device_init_suspended(dev);
	pm_device_runtime_enable(dev);
#else
	nrfx_twim_enable(&dev_config->twim);
   1fda4:	4620      	mov	r0, r4
   1fda6:	f001 fee1 	bl	21b6c <nrfx_twim_enable>
#endif

	return 0;
   1fdaa:	2000      	movs	r0, #0
}
   1fdac:	bd38      	pop	{r3, r4, r5, pc}
		return -EIO;
   1fdae:	f06f 0004 	mvn.w	r0, #4
   1fdb2:	e7fb      	b.n	1fdac <i2c_nrfx_twim_init+0x30>
   1fdb4:	0001fdf9 	.word	0x0001fdf9
   1fdb8:	0bad0000 	.word	0x0bad0000

0001fdbc <i2c_nrfx_twim_recover_bus>:
{
   1fdbc:	b570      	push	{r4, r5, r6, lr}
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   1fdbe:	6844      	ldr	r4, [r0, #4]
	scl_pin = nrf_twim_scl_pin_get(dev_config->twim.p_twim);
   1fdc0:	6823      	ldr	r3, [r4, #0]
		nrfx_twim_disable(&dev_config->twim);
   1fdc2:	4620      	mov	r0, r4
    p_reg->PSEL.SDA = sda_pin;
}

NRF_STATIC_INLINE uint32_t nrf_twim_scl_pin_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->PSEL.SCL;
   1fdc4:	f8d3 5508 	ldr.w	r5, [r3, #1288]	; 0x508
}

NRF_STATIC_INLINE uint32_t nrf_twim_sda_pin_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->PSEL.SDA;
   1fdc8:	f8d3 650c 	ldr.w	r6, [r3, #1292]	; 0x50c
   1fdcc:	f001 fede 	bl	21b8c <nrfx_twim_disable>
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin);

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
    return nrfx_twi_twim_bus_recover(scl_pin, sda_pin);
   1fdd0:	4631      	mov	r1, r6
   1fdd2:	4628      	mov	r0, r5
   1fdd4:	f003 f860 	bl	22e98 <nrfx_twi_twim_bus_recover>
   1fdd8:	4605      	mov	r5, r0
		(void)pinctrl_apply_state(dev_config->pcfg,
   1fdda:	6a20      	ldr	r0, [r4, #32]
   1fddc:	f005 fa90 	bl	25300 <pinctrl_apply_state.constprop.0>
		nrfx_twim_enable(&dev_config->twim);
   1fde0:	4620      	mov	r0, r4
   1fde2:	f001 fec3 	bl	21b6c <nrfx_twim_enable>
	return (err == NRFX_SUCCESS ? 0 : -EBUSY);
   1fde6:	4b03      	ldr	r3, [pc, #12]	; (1fdf4 <i2c_nrfx_twim_recover_bus+0x38>)
   1fde8:	429d      	cmp	r5, r3
}
   1fdea:	bf14      	ite	ne
   1fdec:	f06f 000f 	mvnne.w	r0, #15
   1fdf0:	2000      	moveq	r0, #0
   1fdf2:	bd70      	pop	{r4, r5, r6, pc}
   1fdf4:	0bad0000 	.word	0x0bad0000

0001fdf8 <event_handler>:
	switch (p_event->type) {
   1fdf8:	7803      	ldrb	r3, [r0, #0]
   1fdfa:	2b01      	cmp	r3, #1
   1fdfc:	d008      	beq.n	1fe10 <event_handler+0x18>
   1fdfe:	2b02      	cmp	r3, #2
   1fe00:	d008      	beq.n	1fe14 <event_handler+0x1c>
   1fe02:	b94b      	cbnz	r3, 1fe18 <event_handler+0x20>
		dev_data->res = NRFX_SUCCESS;
   1fe04:	4b05      	ldr	r3, [pc, #20]	; (1fe1c <event_handler+0x24>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   1fe06:	620b      	str	r3, [r1, #32]
	z_impl_k_sem_give(sem);
   1fe08:	f101 0010 	add.w	r0, r1, #16
   1fe0c:	f003 bb98 	b.w	23540 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   1fe10:	4b03      	ldr	r3, [pc, #12]	; (1fe20 <event_handler+0x28>)
   1fe12:	e7f8      	b.n	1fe06 <event_handler+0xe>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   1fe14:	4b03      	ldr	r3, [pc, #12]	; (1fe24 <event_handler+0x2c>)
   1fe16:	e7f6      	b.n	1fe06 <event_handler+0xe>
		dev_data->res = NRFX_ERROR_INTERNAL;
   1fe18:	4b03      	ldr	r3, [pc, #12]	; (1fe28 <event_handler+0x30>)
   1fe1a:	e7f4      	b.n	1fe06 <event_handler+0xe>
   1fe1c:	0bad0000 	.word	0x0bad0000
   1fe20:	0bae0001 	.word	0x0bae0001
   1fe24:	0bae0002 	.word	0x0bae0002
   1fe28:	0bad0001 	.word	0x0bad0001

0001fe2c <i2c_nrfx_twim_transfer>:
{
   1fe2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1fe30:	4693      	mov	fp, r2
	nrfx_twim_xfer_desc_t cur_xfer = {
   1fe32:	2214      	movs	r2, #20
{
   1fe34:	461d      	mov	r5, r3
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   1fe36:	f8d0 a004 	ldr.w	sl, [r0, #4]
{
   1fe3a:	b08b      	sub	sp, #44	; 0x2c
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   1fe3c:	6906      	ldr	r6, [r0, #16]
	uint16_t concat_buf_size = dev_config->concat_buf_size;
   1fe3e:	f8ba 3018 	ldrh.w	r3, [sl, #24]
{
   1fe42:	4681      	mov	r9, r0
   1fe44:	460c      	mov	r4, r1
	nrfx_twim_xfer_desc_t cur_xfer = {
   1fe46:	eb0d 0002 	add.w	r0, sp, r2
   1fe4a:	2100      	movs	r1, #0
	uint8_t *msg_buf = dev_data->msg_buf;
   1fe4c:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
	uint16_t concat_buf_size = dev_config->concat_buf_size;
   1fe50:	9302      	str	r3, [sp, #8]
	nrfx_twim_xfer_desc_t cur_xfer = {
   1fe52:	f005 f8d1 	bl	24ff8 <memset>
   1fe56:	f88d 5015 	strb.w	r5, [sp, #21]
	return z_impl_k_sem_take(sem, timeout);
   1fe5a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1fe5e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1fe62:	4630      	mov	r0, r6
   1fe64:	f003 fb8c 	bl	23580 <z_impl_k_sem_take>
	k_sem_take(&dev_data->completion_sync, K_NO_WAIT);
   1fe68:	f106 0310 	add.w	r3, r6, #16
   1fe6c:	9301      	str	r3, [sp, #4]
	for (size_t i = 0; i < num_msgs; i++) {
   1fe6e:	2700      	movs	r7, #0
   1fe70:	2200      	movs	r2, #0
   1fe72:	2300      	movs	r3, #0
   1fe74:	f106 0010 	add.w	r0, r6, #16
   1fe78:	f003 fb82 	bl	23580 <z_impl_k_sem_take>
	uint16_t msg_buf_used = 0;
   1fe7c:	463d      	mov	r5, r7
	for (size_t i = 0; i < num_msgs; i++) {
   1fe7e:	455f      	cmp	r7, fp
   1fe80:	d301      	bcc.n	1fe86 <i2c_nrfx_twim_transfer+0x5a>
   1fe82:	2400      	movs	r4, #0
   1fe84:	e068      	b.n	1ff58 <i2c_nrfx_twim_transfer+0x12c>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   1fe86:	7a20      	ldrb	r0, [r4, #8]
   1fe88:	0702      	lsls	r2, r0, #28
   1fe8a:	f100 8089 	bmi.w	1ffa0 <i2c_nrfx_twim_transfer+0x174>
		bool concat_next = ((i + 1) < num_msgs)
   1fe8e:	3701      	adds	r7, #1
				&& ((msgs[i].flags & I2C_MSG_READ)
   1fe90:	455f      	cmp	r7, fp
   1fe92:	d20a      	bcs.n	1feaa <i2c_nrfx_twim_transfer+0x7e>
				&& !(msgs[i].flags & I2C_MSG_STOP)
   1fe94:	0783      	lsls	r3, r0, #30
   1fe96:	d408      	bmi.n	1feaa <i2c_nrfx_twim_transfer+0x7e>
				&& !(msgs[i + 1].flags & I2C_MSG_RESTART)
   1fe98:	7d23      	ldrb	r3, [r4, #20]
				    == (msgs[i + 1].flags & I2C_MSG_READ));
   1fe9a:	ea80 0203 	eor.w	r2, r0, r3
				&& ((msgs[i].flags & I2C_MSG_READ)
   1fe9e:	f002 0201 	and.w	r2, r2, #1
   1fea2:	f003 0304 	and.w	r3, r3, #4
   1fea6:	431a      	orrs	r2, r3
   1fea8:	d01a      	beq.n	1fee0 <i2c_nrfx_twim_transfer+0xb4>
		if (concat_next || (msg_buf_used != 0)) {
   1feaa:	b1dd      	cbz	r5, 1fee4 <i2c_nrfx_twim_transfer+0xb8>
		bool concat_next = ((i + 1) < num_msgs)
   1feac:	2300      	movs	r3, #0
			if ((msg_buf_used + msgs[i].len) > concat_buf_size) {
   1feae:	6862      	ldr	r2, [r4, #4]
   1feb0:	f8dd c008 	ldr.w	ip, [sp, #8]
   1feb4:	18a9      	adds	r1, r5, r2
   1feb6:	4561      	cmp	r1, ip
   1feb8:	d875      	bhi.n	1ffa6 <i2c_nrfx_twim_transfer+0x17a>
			if (!(msgs[i].flags & I2C_MSG_READ)) {
   1feba:	07c1      	lsls	r1, r0, #31
   1febc:	d406      	bmi.n	1fecc <i2c_nrfx_twim_transfer+0xa0>
				memcpy(msg_buf + msg_buf_used,
   1febe:	6821      	ldr	r1, [r4, #0]
   1fec0:	eb08 0005 	add.w	r0, r8, r5
   1fec4:	9303      	str	r3, [sp, #12]
   1fec6:	f005 f88c 	bl	24fe2 <memcpy>
   1feca:	9b03      	ldr	r3, [sp, #12]
			msg_buf_used += msgs[i].len;
   1fecc:	6862      	ldr	r2, [r4, #4]
   1fece:	442a      	add	r2, r5
   1fed0:	b295      	uxth	r5, r2
		if (concat_next) {
   1fed2:	2b00      	cmp	r3, #0
   1fed4:	d14f      	bne.n	1ff76 <i2c_nrfx_twim_transfer+0x14a>
		if (msg_buf_used == 0) {
   1fed6:	b14d      	cbz	r5, 1feec <i2c_nrfx_twim_transfer+0xc0>
			cur_xfer.primary_length = msg_buf_used;
   1fed8:	462b      	mov	r3, r5
			cur_xfer.p_primary_buf = msg_buf;
   1feda:	f8cd 8020 	str.w	r8, [sp, #32]
			cur_xfer.primary_length = msg_buf_used;
   1fede:	e009      	b.n	1fef4 <i2c_nrfx_twim_transfer+0xc8>
		bool concat_next = ((i + 1) < num_msgs)
   1fee0:	2301      	movs	r3, #1
   1fee2:	e7e4      	b.n	1feae <i2c_nrfx_twim_transfer+0x82>
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   1fee4:	07c0      	lsls	r0, r0, #31
			   !nrfx_is_in_ram(msgs[i].buf)) {
   1fee6:	e9d4 1200 	ldrd	r1, r2, [r4]
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   1feea:	d51b      	bpl.n	1ff24 <i2c_nrfx_twim_transfer+0xf8>
			cur_xfer.p_primary_buf = msgs[i].buf;
   1feec:	2500      	movs	r5, #0
   1feee:	6823      	ldr	r3, [r4, #0]
   1fef0:	9308      	str	r3, [sp, #32]
			cur_xfer.primary_length = msgs[i].len;
   1fef2:	6863      	ldr	r3, [r4, #4]
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   1fef4:	7a22      	ldrb	r2, [r4, #8]
			cur_xfer.primary_length = msgs[i].len;
   1fef6:	9306      	str	r3, [sp, #24]
			NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX;
   1fef8:	f002 0301 	and.w	r3, r2, #1
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   1fefc:	f082 0202 	eor.w	r2, r2, #2
   1ff00:	f3c2 0240 	ubfx	r2, r2, #1, #1
   1ff04:	4650      	mov	r0, sl
   1ff06:	0152      	lsls	r2, r2, #5
   1ff08:	a905      	add	r1, sp, #20
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   1ff0a:	f88d 3014 	strb.w	r3, [sp, #20]
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   1ff0e:	f001 fe5b 	bl	21bc8 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
   1ff12:	4b28      	ldr	r3, [pc, #160]	; (1ffb4 <i2c_nrfx_twim_transfer+0x188>)
   1ff14:	4298      	cmp	r0, r3
   1ff16:	d013      	beq.n	1ff40 <i2c_nrfx_twim_transfer+0x114>
			if (res == NRFX_ERROR_BUSY) {
   1ff18:	330b      	adds	r3, #11
   1ff1a:	4298      	cmp	r0, r3
   1ff1c:	d11a      	bne.n	1ff54 <i2c_nrfx_twim_transfer+0x128>
				ret = -EBUSY;
   1ff1e:	f06f 040f 	mvn.w	r4, #15
   1ff22:	e019      	b.n	1ff58 <i2c_nrfx_twim_transfer+0x12c>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   1ff24:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   1ff28:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   1ff2c:	d0de      	beq.n	1feec <i2c_nrfx_twim_transfer+0xc0>
			if (msgs[i].len > dev_config->flash_buf_max_size) {
   1ff2e:	f8ba 301a 	ldrh.w	r3, [sl, #26]
   1ff32:	4293      	cmp	r3, r2
   1ff34:	d33a      	bcc.n	1ffac <i2c_nrfx_twim_transfer+0x180>
			memcpy(msg_buf, msgs[i].buf, msgs[i].len);
   1ff36:	4640      	mov	r0, r8
   1ff38:	f005 f853 	bl	24fe2 <memcpy>
			msg_buf_used = msgs[i].len;
   1ff3c:	88a5      	ldrh	r5, [r4, #4]
		if (concat_next) {
   1ff3e:	e7ca      	b.n	1fed6 <i2c_nrfx_twim_transfer+0xaa>
   1ff40:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1ff44:	2300      	movs	r3, #0
   1ff46:	9801      	ldr	r0, [sp, #4]
   1ff48:	f003 fb1a 	bl	23580 <z_impl_k_sem_take>
		if (ret != 0) {
   1ff4c:	b158      	cbz	r0, 1ff66 <i2c_nrfx_twim_transfer+0x13a>
			(void)i2c_nrfx_twim_recover_bus(dev);
   1ff4e:	4648      	mov	r0, r9
   1ff50:	f7ff ff34 	bl	1fdbc <i2c_nrfx_twim_recover_bus>
				ret = -EIO;
   1ff54:	f06f 0404 	mvn.w	r4, #4
	z_impl_k_sem_give(sem);
   1ff58:	4630      	mov	r0, r6
   1ff5a:	f003 faf1 	bl	23540 <z_impl_k_sem_give>
}
   1ff5e:	4620      	mov	r0, r4
   1ff60:	b00b      	add	sp, #44	; 0x2c
   1ff62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		res = dev_data->res;
   1ff66:	6a33      	ldr	r3, [r6, #32]
		if (res != NRFX_SUCCESS) {
   1ff68:	4a12      	ldr	r2, [pc, #72]	; (1ffb4 <i2c_nrfx_twim_transfer+0x188>)
   1ff6a:	4293      	cmp	r3, r2
   1ff6c:	d1f2      	bne.n	1ff54 <i2c_nrfx_twim_transfer+0x128>
		if ((msgs[i].flags & I2C_MSG_READ)
   1ff6e:	7a23      	ldrb	r3, [r4, #8]
   1ff70:	07db      	lsls	r3, r3, #31
   1ff72:	d402      	bmi.n	1ff7a <i2c_nrfx_twim_transfer+0x14e>
		msg_buf_used = 0;
   1ff74:	2500      	movs	r5, #0
   1ff76:	340c      	adds	r4, #12
   1ff78:	e781      	b.n	1fe7e <i2c_nrfx_twim_transfer+0x52>
		    && cur_xfer.p_primary_buf == msg_buf) {
   1ff7a:	9b08      	ldr	r3, [sp, #32]
   1ff7c:	4598      	cmp	r8, r3
   1ff7e:	d1f9      	bne.n	1ff74 <i2c_nrfx_twim_transfer+0x148>
   1ff80:	4623      	mov	r3, r4
   1ff82:	e008      	b.n	1ff96 <i2c_nrfx_twim_transfer+0x16a>
				msg_buf_used -= msgs[j].len;
   1ff84:	1aa9      	subs	r1, r5, r2
				memcpy(msgs[j].buf,
   1ff86:	68d8      	ldr	r0, [r3, #12]
				msg_buf_used -= msgs[j].len;
   1ff88:	b28d      	uxth	r5, r1
				memcpy(msgs[j].buf,
   1ff8a:	fa18 f181 	uxtah	r1, r8, r1
   1ff8e:	9303      	str	r3, [sp, #12]
   1ff90:	f005 f827 	bl	24fe2 <memcpy>
				j--;
   1ff94:	9b03      	ldr	r3, [sp, #12]
			while (msg_buf_used >= msgs[j].len) {
   1ff96:	685a      	ldr	r2, [r3, #4]
   1ff98:	3b0c      	subs	r3, #12
   1ff9a:	4295      	cmp	r5, r2
   1ff9c:	d2f2      	bcs.n	1ff84 <i2c_nrfx_twim_transfer+0x158>
   1ff9e:	e7e9      	b.n	1ff74 <i2c_nrfx_twim_transfer+0x148>
			ret = -ENOTSUP;
   1ffa0:	f06f 0485 	mvn.w	r4, #133	; 0x85
   1ffa4:	e7d8      	b.n	1ff58 <i2c_nrfx_twim_transfer+0x12c>
				ret = -ENOSPC;
   1ffa6:	f06f 041b 	mvn.w	r4, #27
   1ffaa:	e7d5      	b.n	1ff58 <i2c_nrfx_twim_transfer+0x12c>
				ret = -EINVAL;
   1ffac:	f06f 0415 	mvn.w	r4, #21
   1ffb0:	e7d2      	b.n	1ff58 <i2c_nrfx_twim_transfer+0x12c>
   1ffb2:	bf00      	nop
   1ffb4:	0bad0000 	.word	0x0bad0000

0001ffb8 <pinctrl_configure_pins>:
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1ffb8:	f04f 0c01 	mov.w	ip, #1
#define NRF_PSEL_QSPI(reg, line) ((NRF_QSPI_Type *)reg)->PSEL.line
#endif

int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
			   uintptr_t reg)
{
   1ffbc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        case 1: return NRF_P1;
   1ffc0:	4e56      	ldr	r6, [pc, #344]	; (2011c <pinctrl_configure_pins+0x164>)
   1ffc2:	4f57      	ldr	r7, [pc, #348]	; (20120 <pinctrl_configure_pins+0x168>)
   1ffc4:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   1ffc8:	4281      	cmp	r1, r0
   1ffca:	d102      	bne.n	1ffd2 <pinctrl_configure_pins+0x1a>
			nrf_gpio_cfg(pin, dir, input, NRF_GET_PULL(pins[i]),
				     drive, NRF_GPIO_PIN_NOSENSE);
		}
	}

	return 0;
   1ffcc:	2000      	movs	r0, #0
}
   1ffce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
   1ffd2:	6804      	ldr	r4, [r0, #0]
		uint32_t pin = NRF_GET_PIN(pins[i]);
   1ffd4:	f004 037f 	and.w	r3, r4, #127	; 0x7f
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
   1ffd8:	f3c4 2543 	ubfx	r5, r4, #9, #4
		switch (NRF_GET_FUN(pins[i])) {
   1ffdc:	0c24      	lsrs	r4, r4, #16
			pin = 0xFFFFFFFFU;
   1ffde:	2b7f      	cmp	r3, #127	; 0x7f
		switch (NRF_GET_FUN(pins[i])) {
   1ffe0:	f1a4 0404 	sub.w	r4, r4, #4
			pin = 0xFFFFFFFFU;
   1ffe4:	bf08      	it	eq
   1ffe6:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
		switch (NRF_GET_FUN(pins[i])) {
   1ffea:	2c1e      	cmp	r4, #30
   1ffec:	f200 8092 	bhi.w	20114 <pinctrl_configure_pins+0x15c>
   1fff0:	e8df f004 	tbb	[pc, r4]
   1fff4:	90272310 	.word	0x90272310
   1fff8:	2b909090 	.word	0x2b909090
   1fffc:	90909058 	.word	0x90909058
   20000:	90909090 	.word	0x90909090
   20004:	725b9090 	.word	0x725b9090
   20008:	90907875 	.word	0x90907875
   2000c:	84817b90 	.word	0x84817b90
   20010:	8a87      	.short	0x8a87
   20012:	8d          	.byte	0x8d
   20013:	00          	.byte	0x00
			input = NRF_GPIO_PIN_INPUT_CONNECT;
   20014:	2400      	movs	r4, #0
			NRF_PSEL_SPIM(reg, SCK) = pin;
   20016:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    return pin_number >> 5;
   2001a:	ea4f 1953 	mov.w	r9, r3, lsr #5
        case 1: return NRF_P1;
   2001e:	f1b9 0f01 	cmp.w	r9, #1
   20022:	bf14      	ite	ne
   20024:	46b0      	movne	r8, r6
   20026:	46b8      	moveq	r8, r7
    *p_pin = pin_number & 0x1F;
   20028:	f003 0e1f 	and.w	lr, r3, #31
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   2002c:	fa0c fe0e 	lsl.w	lr, ip, lr
    p_reg->OUTCLR = clr_mask;
   20030:	f8c8 e00c 	str.w	lr, [r8, #12]
   20034:	f04f 0e01 	mov.w	lr, #1
   20038:	e00e      	b.n	20058 <pinctrl_configure_pins+0xa0>
			NRF_PSEL_SPIM(reg, MOSI) = pin;
   2003a:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
			pin = 0xFFFFFFFFU;
   2003e:	2401      	movs	r4, #1
   20040:	e7eb      	b.n	2001a <pinctrl_configure_pins+0x62>
			NRF_PSEL_SPIM(reg, MISO) = pin;
   20042:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
			input = NRF_GPIO_PIN_INPUT_CONNECT;
   20046:	2400      	movs	r4, #0
   20048:	e044      	b.n	200d4 <pinctrl_configure_pins+0x11c>
			NRF_PSEL_TWIM(reg, SCL) = pin;
   2004a:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
			if (drive == NRF_DRIVE_S0S1) {
   2004e:	2d00      	cmp	r5, #0
   20050:	d1f9      	bne.n	20046 <pinctrl_configure_pins+0x8e>
			input = NRF_GPIO_PIN_INPUT_CONNECT;
   20052:	2400      	movs	r4, #0
				drive = NRF_DRIVE_S0D1;
   20054:	2506      	movs	r5, #6
			dir = NRF_GPIO_PIN_DIR_INPUT;
   20056:	46a6      	mov	lr, r4
			if (NRF_GET_LP(pins[i]) == NRF_LP_ENABLE) {
   20058:	f850 ab04 	ldr.w	sl, [r0], #4
    *p_pin = pin_number & 0x1F;
   2005c:	f003 091f 	and.w	r9, r3, #31
   20060:	f40a 5800 	and.w	r8, sl, #8192	; 0x2000
				input = NRF_GPIO_PIN_INPUT_DISCONNECT;
   20064:	f1b8 0f00 	cmp.w	r8, #0
    return pin_number >> 5;
   20068:	ea4f 1353 	mov.w	r3, r3, lsr #5
   2006c:	bf1c      	itt	ne
   2006e:	2401      	movne	r4, #1
   20070:	f04f 0e00 	movne.w	lr, #0
        case 0: return NRF_P0;
   20074:	2b01      	cmp	r3, #1
   20076:	bf0c      	ite	eq
   20078:	46b8      	moveq	r8, r7
   2007a:	46b0      	movne	r8, r6
   2007c:	eb08 0889 	add.w	r8, r8, r9, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   20080:	f8d8 3200 	ldr.w	r3, [r8, #512]	; 0x200
			nrf_gpio_cfg(pin, dir, input, NRF_GET_PULL(pins[i]),
   20084:	f3ca 1ac1 	ubfx	sl, sl, #7, #2
   20088:	f003 49e0 	and.w	r9, r3, #1879048192	; 0x70000000
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   2008c:	022b      	lsls	r3, r5, #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   2008e:	ea43 038a 	orr.w	r3, r3, sl, lsl #2
   20092:	ea43 030e 	orr.w	r3, r3, lr
   20096:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   2009a:	ea43 0309 	orr.w	r3, r3, r9
    reg->PIN_CNF[pin_number] = cnf;
   2009e:	f8c8 3200 	str.w	r3, [r8, #512]	; 0x200
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   200a2:	e791      	b.n	1ffc8 <pinctrl_configure_pins+0x10>
			NRF_PSEL_TWIM(reg, SDA) = pin;
   200a4:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
			if (drive == NRF_DRIVE_S0S1) {
   200a8:	e7d1      	b.n	2004e <pinctrl_configure_pins+0x96>
			NRF_PSEL_PWM(reg, OUT[0]) = pin;
   200aa:	f8c2 3560 	str.w	r3, [r2, #1376]	; 0x560
			write = NRF_GET_INVERT(pins[i]);
   200ae:	6804      	ldr	r4, [r0, #0]
   200b0:	f3c4 3480 	ubfx	r4, r4, #14, #1
    if (value == 0)
   200b4:	2c00      	cmp	r4, #0
   200b6:	d0c2      	beq.n	2003e <pinctrl_configure_pins+0x86>
    return pin_number >> 5;
   200b8:	ea4f 1853 	mov.w	r8, r3, lsr #5
        case 1: return NRF_P1;
   200bc:	f1b8 0f01 	cmp.w	r8, #1
   200c0:	bf14      	ite	ne
   200c2:	46b6      	movne	lr, r6
   200c4:	46be      	moveq	lr, r7
    *p_pin = pin_number & 0x1F;
   200c6:	f003 041f 	and.w	r4, r3, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   200ca:	fa0c f404 	lsl.w	r4, ip, r4
    p_reg->OUTSET = set_mask;
   200ce:	f8ce 4008 	str.w	r4, [lr, #8]
   200d2:	2401      	movs	r4, #1
			dir = NRF_GPIO_PIN_DIR_INPUT;
   200d4:	46a6      	mov	lr, r4
   200d6:	e7bf      	b.n	20058 <pinctrl_configure_pins+0xa0>
			NRF_PSEL_PWM(reg, OUT[1]) = pin;
   200d8:	f8c2 3564 	str.w	r3, [r2, #1380]	; 0x564
			write = NRF_GET_INVERT(pins[i]);
   200dc:	e7e7      	b.n	200ae <pinctrl_configure_pins+0xf6>
			NRF_PSEL_PWM(reg, OUT[2]) = pin;
   200de:	f8c2 3568 	str.w	r3, [r2, #1384]	; 0x568
			write = NRF_GET_INVERT(pins[i]);
   200e2:	e7e4      	b.n	200ae <pinctrl_configure_pins+0xf6>
			NRF_PSEL_PWM(reg, OUT[3]) = pin;
   200e4:	f8c2 356c 	str.w	r3, [r2, #1388]	; 0x56c
   200e8:	e7e1      	b.n	200ae <pinctrl_configure_pins+0xf6>
			NRF_PSEL_QSPI(reg, SCK) = pin;
   200ea:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
			input = NRF_GPIO_PIN_INPUT_DISCONNECT;
   200ee:	2401      	movs	r4, #1
			dir = NRF_GPIO_PIN_DIR_INPUT;
   200f0:	f04f 0e00 	mov.w	lr, #0
   200f4:	e7b0      	b.n	20058 <pinctrl_configure_pins+0xa0>
			NRF_PSEL_QSPI(reg, CSN) = pin;
   200f6:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
    if (value == 0)
   200fa:	e7dd      	b.n	200b8 <pinctrl_configure_pins+0x100>
			NRF_PSEL_QSPI(reg, IO0) = pin;
   200fc:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
			if (write != NO_WRITE) {
   20100:	e7f5      	b.n	200ee <pinctrl_configure_pins+0x136>
			NRF_PSEL_QSPI(reg, IO1) = pin;
   20102:	f8c2 3534 	str.w	r3, [r2, #1332]	; 0x534
			if (write != NO_WRITE) {
   20106:	e7f2      	b.n	200ee <pinctrl_configure_pins+0x136>
			NRF_PSEL_QSPI(reg, IO2) = pin;
   20108:	f8c2 3538 	str.w	r3, [r2, #1336]	; 0x538
			if (write != NO_WRITE) {
   2010c:	e7ef      	b.n	200ee <pinctrl_configure_pins+0x136>
			NRF_PSEL_QSPI(reg, IO3) = pin;
   2010e:	f8c2 353c 	str.w	r3, [r2, #1340]	; 0x53c
			if (write != NO_WRITE) {
   20112:	e7ec      	b.n	200ee <pinctrl_configure_pins+0x136>
		switch (NRF_GET_FUN(pins[i])) {
   20114:	f06f 0085 	mvn.w	r0, #133	; 0x85
   20118:	e759      	b.n	1ffce <pinctrl_configure_pins+0x16>
   2011a:	bf00      	nop
   2011c:	40842500 	.word	0x40842500
   20120:	40842800 	.word	0x40842800

00020124 <regulator_fixed_enable>:
struct regulator_fixed_data {
	struct regulator_common_data common;
};

static int regulator_fixed_enable(const struct device *dev)
{
   20124:	b538      	push	{r3, r4, r5, lr}
	const struct regulator_fixed_config *cfg = dev->config;
   20126:	6844      	ldr	r4, [r0, #4]
	return gpio_pin_set(spec->port, spec->pin, value);
   20128:	2201      	movs	r2, #1
   2012a:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
   2012e:	6a60      	ldr	r0, [r4, #36]	; 0x24
   20130:	f005 f9ae 	bl	25490 <gpio_pin_set>
	int ret;

	ret = gpio_pin_set_dt(&cfg->enable, 1);
	if (ret < 0) {
   20134:	2800      	cmp	r0, #0
   20136:	db02      	blt.n	2013e <regulator_fixed_enable+0x1a>
		return ret;
	}

	if (cfg->off_on_delay_us > 0U) {
   20138:	6a24      	ldr	r4, [r4, #32]
   2013a:	b90c      	cbnz	r4, 20140 <regulator_fixed_enable+0x1c>
		k_sleep(K_USEC(cfg->off_on_delay_us));
	}

	return 0;
   2013c:	2000      	movs	r0, #0
}
   2013e:	bd38      	pop	{r3, r4, r5, pc}
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
   20140:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   20144:	2100      	movs	r1, #0
   20146:	4805      	ldr	r0, [pc, #20]	; (2015c <regulator_fixed_enable+0x38>)
   20148:	2300      	movs	r3, #0
   2014a:	fbe4 0105 	umlal	r0, r1, r4, r5
   2014e:	4a04      	ldr	r2, [pc, #16]	; (20160 <regulator_fixed_enable+0x3c>)
   20150:	f7fc f800 	bl	1c154 <__aeabi_uldivmod>
	return z_impl_k_sleep(timeout);
   20154:	f003 fe74 	bl	23e40 <z_impl_k_sleep>
   20158:	e7f0      	b.n	2013c <regulator_fixed_enable+0x18>
   2015a:	bf00      	nop
   2015c:	000f423f 	.word	0x000f423f
   20160:	000f4240 	.word	0x000f4240

00020164 <transfer_next_chunk>:
	spi_context_complete(ctx, dev, error);
	dev_data->busy = false;
}

static void transfer_next_chunk(const struct device *dev)
{
   20164:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct spi_nrfx_data *dev_data = dev->data;
   20166:	6904      	ldr	r4, [r0, #16]
{
   20168:	4606      	mov	r6, r0
 * directions have a continuous buffer, i.e. the maximum SPI transfer that
 * can be done with DMA that handles only non-scattered buffers.
 */
static inline size_t spi_context_max_continuous_chunk(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
   2016a:	6ca5      	ldr	r5, [r4, #72]	; 0x48
	const struct spi_nrfx_config *dev_config = dev->config;
   2016c:	6847      	ldr	r7, [r0, #4]
		return ctx->rx_len;
   2016e:	6d23      	ldr	r3, [r4, #80]	; 0x50
{
   20170:	b085      	sub	sp, #20
	if (!ctx->tx_len) {
   20172:	b93d      	cbnz	r5, 20184 <transfer_next_chunk+0x20>
	struct spi_context *ctx = &dev_data->ctx;
	int error = 0;

	size_t chunk_len = spi_context_max_continuous_chunk(ctx);

	if (chunk_len > 0) {
   20174:	bb6b      	cbnz	r3, 201d2 <transfer_next_chunk+0x6e>
	int error = 0;
   20176:	4619      	mov	r1, r3
			anomaly_58_workaround_clear(dev_data);
#endif
		}
	}

	finish_transaction(dev, error);
   20178:	6930      	ldr	r0, [r6, #16]
}
   2017a:	b005      	add	sp, #20
   2017c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	finish_transaction(dev, error);
   20180:	f005 baa3 	b.w	256ca <finish_transaction.isra.0>
		const uint8_t *tx_buf = ctx->tx_buf;
   20184:	6c61      	ldr	r1, [r4, #68]	; 0x44
	} else if (!ctx->rx_len) {
   20186:	bb03      	cbnz	r3, 201ca <transfer_next_chunk+0x66>
	return !!(ctx->tx_buf && ctx->tx_len);
   20188:	bb31      	cbnz	r1, 201d8 <transfer_next_chunk+0x74>
		if (chunk_len > dev_config->max_chunk_len) {
   2018a:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   2018c:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2018e:	42aa      	cmp	r2, r5
   20190:	bf28      	it	cs
   20192:	462a      	movcs	r2, r5
		xfer.p_tx_buffer = tx_buf;
   20194:	9100      	str	r1, [sp, #0]
		dev_data->chunk_len = chunk_len;
   20196:	65a2      	str	r2, [r4, #88]	; 0x58
   20198:	b11b      	cbz	r3, 201a2 <transfer_next_chunk+0x3e>
   2019a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   2019c:	2b00      	cmp	r3, #0
   2019e:	bf18      	it	ne
   201a0:	4613      	movne	r3, r2
   201a2:	9301      	str	r3, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
   201a4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   201a6:	9302      	str	r3, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
   201a8:	b11b      	cbz	r3, 201b2 <transfer_next_chunk+0x4e>
   201aa:	6d23      	ldr	r3, [r4, #80]	; 0x50
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   201ac:	2b00      	cmp	r3, #0
   201ae:	bf18      	it	ne
   201b0:	4613      	movne	r3, r2
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   201b2:	2200      	movs	r2, #0
   201b4:	4669      	mov	r1, sp
   201b6:	4638      	mov	r0, r7
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   201b8:	9303      	str	r3, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   201ba:	f001 fb99 	bl	218f0 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
   201be:	4b0e      	ldr	r3, [pc, #56]	; (201f8 <transfer_next_chunk+0x94>)
   201c0:	4298      	cmp	r0, r3
   201c2:	d017      	beq.n	201f4 <transfer_next_chunk+0x90>
			error = -EIO;
   201c4:	f06f 0104 	mvn.w	r1, #4
   201c8:	e7d6      	b.n	20178 <transfer_next_chunk+0x14>
		return ctx->tx_len;
	}

	return MIN(ctx->tx_len, ctx->rx_len);
   201ca:	429d      	cmp	r5, r3
   201cc:	bf28      	it	cs
   201ce:	461d      	movcs	r5, r3
   201d0:	e7da      	b.n	20188 <transfer_next_chunk+0x24>
		const uint8_t *tx_buf = ctx->tx_buf;
   201d2:	461d      	mov	r5, r3
   201d4:	6c61      	ldr	r1, [r4, #68]	; 0x44
	return !!(ctx->tx_buf && ctx->tx_len);
   201d6:	e7d8      	b.n	2018a <transfer_next_chunk+0x26>
   201d8:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		if (spi_context_tx_buf_on(ctx) && !nrfx_is_in_ram(tx_buf)) {
   201dc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   201e0:	d0d3      	beq.n	2018a <transfer_next_chunk+0x26>
			if (chunk_len > CONFIG_SPI_NRFX_RAM_BUFFER_SIZE) {
   201e2:	2d08      	cmp	r5, #8
   201e4:	bf28      	it	cs
   201e6:	2508      	movcs	r5, #8
			memcpy(dev_data->buffer, tx_buf, chunk_len);
   201e8:	6e20      	ldr	r0, [r4, #96]	; 0x60
   201ea:	462a      	mov	r2, r5
   201ec:	f004 fef9 	bl	24fe2 <memcpy>
			tx_buf = dev_data->buffer;
   201f0:	6e21      	ldr	r1, [r4, #96]	; 0x60
   201f2:	e7ca      	b.n	2018a <transfer_next_chunk+0x26>
}
   201f4:	b005      	add	sp, #20
   201f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   201f8:	0bad0000 	.word	0x0bad0000

000201fc <spi_nrfx_transceive>:

static int spi_nrfx_transceive(const struct device *dev,
			       const struct spi_config *spi_cfg,
			       const struct spi_buf_set *tx_bufs,
			       const struct spi_buf_set *rx_bufs)
{
   201fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20200:	469a      	mov	sl, r3
	const struct spi_nrfx_config *dev_config = dev->config;
   20202:	6843      	ldr	r3, [r0, #4]
{
   20204:	b08b      	sub	sp, #44	; 0x2c
	const struct spi_nrfx_config *dev_config = dev->config;
   20206:	9303      	str	r3, [sp, #12]
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
   20208:	888b      	ldrh	r3, [r1, #4]
{
   2020a:	4607      	mov	r7, r0
   2020c:	049b      	lsls	r3, r3, #18
   2020e:	460e      	mov	r6, r1
   20210:	4690      	mov	r8, r2
	struct spi_nrfx_data *dev_data = dev->data;
   20212:	6904      	ldr	r4, [r0, #16]
   20214:	f100 8106 	bmi.w	20424 <spi_nrfx_transceive+0x228>
	return z_impl_k_sem_take(sem, timeout);
   20218:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2021c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   20220:	f104 0010 	add.w	r0, r4, #16
   20224:	f003 f9ac 	bl	23580 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
   20228:	6066      	str	r6, [r4, #4]
	const struct spi_nrfx_config *dev_config = dev->config;
   2022a:	687b      	ldr	r3, [r7, #4]
	struct spi_nrfx_data *dev_data = dev->data;
   2022c:	f8d7 9010 	ldr.w	r9, [r7, #16]
	uint32_t max_freq = dev_config->max_freq;
   20230:	689d      	ldr	r5, [r3, #8]
	const struct spi_nrfx_config *dev_config = dev->config;
   20232:	9300      	str	r3, [sp, #0]
	if (dev_data->initialized && spi_context_configured(ctx, spi_cfg)) {
   20234:	f899 305d 	ldrb.w	r3, [r9, #93]	; 0x5d
   20238:	9301      	str	r3, [sp, #4]
   2023a:	b11b      	cbz	r3, 20244 <spi_nrfx_transceive+0x48>
   2023c:	f8d9 3000 	ldr.w	r3, [r9]
   20240:	429e      	cmp	r6, r3
   20242:	d07c      	beq.n	2033e <spi_nrfx_transceive+0x142>
	if (spi_cfg->operation & SPI_HALF_DUPLEX) {
   20244:	f8b6 c004 	ldrh.w	ip, [r6, #4]
   20248:	f41c 6f00 	tst.w	ip, #2048	; 0x800
   2024c:	f040 811f 	bne.w	2048e <spi_nrfx_transceive+0x292>
	if (spi_cfg->operation & SPI_MODE_LOOP) {
   20250:	f01c 0f09 	tst.w	ip, #9
   20254:	f040 8118 	bne.w	20488 <spi_nrfx_transceive+0x28c>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
   20258:	f3cc 1345 	ubfx	r3, ip, #5, #6
   2025c:	2b08      	cmp	r3, #8
   2025e:	f040 8113 	bne.w	20488 <spi_nrfx_transceive+0x28c>
	if (spi_cfg->frequency < 125000) {
   20262:	6833      	ldr	r3, [r6, #0]
   20264:	9302      	str	r3, [sp, #8]
   20266:	9a02      	ldr	r2, [sp, #8]
   20268:	4b9a      	ldr	r3, [pc, #616]	; (204d4 <spi_nrfx_transceive+0x2d8>)
   2026a:	429a      	cmp	r2, r3
   2026c:	f240 810c 	bls.w	20488 <spi_nrfx_transceive+0x28c>
	if (max_freq > 16000000 &&
   20270:	4b99      	ldr	r3, [pc, #612]	; (204d8 <spi_nrfx_transceive+0x2dc>)
   20272:	429d      	cmp	r5, r3
   20274:	d906      	bls.n	20284 <spi_nrfx_transceive+0x88>
                        CLOCK_HFCLKCTRL_HCLK_Msk);
}

NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk_div_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_hfclk_div_t)((p_reg->HFCLKCTRL & CLOCK_HFCLKCTRL_HCLK_Msk)
   20276:	4a99      	ldr	r2, [pc, #612]	; (204dc <spi_nrfx_transceive+0x2e0>)
   20278:	f8d2 2558 	ldr.w	r2, [r2, #1368]	; 0x558
		max_freq = 16000000;
   2027c:	f012 0f03 	tst.w	r2, #3
   20280:	bf18      	it	ne
   20282:	461d      	movne	r5, r3
	config = dev_config->def_config;
   20284:	9b00      	ldr	r3, [sp, #0]
   20286:	f10d 0e10 	add.w	lr, sp, #16
   2028a:	f103 0b0c 	add.w	fp, r3, #12
   2028e:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
   20292:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
   20296:	9b02      	ldr	r3, [sp, #8]
	config = dev_config->def_config;
   20298:	e89b 0003 	ldmia.w	fp, {r0, r1}
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
   2029c:	42ab      	cmp	r3, r5
   2029e:	bf28      	it	cs
   202a0:	462b      	movcs	r3, r5
   202a2:	461d      	mov	r5, r3
	if (frequency < 250000) {
   202a4:	4b8e      	ldr	r3, [pc, #568]	; (204e0 <spi_nrfx_transceive+0x2e4>)
	config = dev_config->def_config;
   202a6:	e88e 0003 	stmia.w	lr, {r0, r1}
	if (frequency < 250000) {
   202aa:	429d      	cmp	r5, r3
   202ac:	f240 80c3 	bls.w	20436 <spi_nrfx_transceive+0x23a>
	} else if (frequency < 500000) {
   202b0:	4b8c      	ldr	r3, [pc, #560]	; (204e4 <spi_nrfx_transceive+0x2e8>)
   202b2:	429d      	cmp	r5, r3
   202b4:	f240 80c2 	bls.w	2043c <spi_nrfx_transceive+0x240>
	} else if (frequency < 1000000) {
   202b8:	4b8b      	ldr	r3, [pc, #556]	; (204e8 <spi_nrfx_transceive+0x2ec>)
   202ba:	429d      	cmp	r5, r3
   202bc:	f240 80c1 	bls.w	20442 <spi_nrfx_transceive+0x246>
	} else if (frequency < 2000000) {
   202c0:	4b8a      	ldr	r3, [pc, #552]	; (204ec <spi_nrfx_transceive+0x2f0>)
   202c2:	429d      	cmp	r5, r3
   202c4:	f240 80c0 	bls.w	20448 <spi_nrfx_transceive+0x24c>
	} else if (frequency < 4000000) {
   202c8:	4b89      	ldr	r3, [pc, #548]	; (204f0 <spi_nrfx_transceive+0x2f4>)
   202ca:	429d      	cmp	r5, r3
   202cc:	f240 80bf 	bls.w	2044e <spi_nrfx_transceive+0x252>
	} else if (frequency < 8000000) {
   202d0:	4b88      	ldr	r3, [pc, #544]	; (204f4 <spi_nrfx_transceive+0x2f8>)
   202d2:	429d      	cmp	r5, r3
   202d4:	f0c0 80be 	bcc.w	20454 <spi_nrfx_transceive+0x258>
	} else if (frequency < 16000000) {
   202d8:	4b7f      	ldr	r3, [pc, #508]	; (204d8 <spi_nrfx_transceive+0x2dc>)
   202da:	429d      	cmp	r5, r3
   202dc:	f0c0 80bd 	bcc.w	2045a <spi_nrfx_transceive+0x25e>
		return NRF_SPIM_FREQ_16M;
   202e0:	4b85      	ldr	r3, [pc, #532]	; (204f8 <spi_nrfx_transceive+0x2fc>)
   202e2:	429d      	cmp	r5, r3
   202e4:	bf2c      	ite	cs
   202e6:	f04f 55a0 	movcs.w	r5, #335544320	; 0x14000000
   202ea:	f04f 6520 	movcc.w	r5, #167772160	; 0xa000000
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   202ee:	f01c 0f02 	tst.w	ip, #2
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
   202f2:	9506      	str	r5, [sp, #24]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   202f4:	f00c 0304 	and.w	r3, ip, #4
   202f8:	f000 80b2 	beq.w	20460 <spi_nrfx_transceive+0x264>
			return NRF_SPIM_MODE_2;
   202fc:	2b00      	cmp	r3, #0
   202fe:	bf14      	ite	ne
   20300:	2303      	movne	r3, #3
   20302:	2302      	moveq	r3, #2
	config.mode      = get_nrf_spim_mode(spi_cfg->operation);
   20304:	f88d 301c 	strb.w	r3, [sp, #28]
	if (dev_data->initialized) {
   20308:	9b01      	ldr	r3, [sp, #4]
	if (operation & SPI_TRANSFER_LSB) {
   2030a:	f3cc 1c00 	ubfx	ip, ip, #4, #1
	config.bit_order = get_nrf_spim_bit_order(spi_cfg->operation);
   2030e:	f88d c01d 	strb.w	ip, [sp, #29]
	if (dev_data->initialized) {
   20312:	b12b      	cbz	r3, 20320 <spi_nrfx_transceive+0x124>
		nrfx_spim_uninit(&dev_config->spim);
   20314:	9800      	ldr	r0, [sp, #0]
   20316:	f001 fa97 	bl	21848 <nrfx_spim_uninit>
		dev_data->initialized = false;
   2031a:	2300      	movs	r3, #0
   2031c:	f889 305d 	strb.w	r3, [r9, #93]	; 0x5d
	result = nrfx_spim_init(&dev_config->spim, &config,
   20320:	464b      	mov	r3, r9
   20322:	4a76      	ldr	r2, [pc, #472]	; (204fc <spi_nrfx_transceive+0x300>)
   20324:	9800      	ldr	r0, [sp, #0]
   20326:	a904      	add	r1, sp, #16
   20328:	f001 f956 	bl	215d8 <nrfx_spim_init>
	if (result != NRFX_SUCCESS) {
   2032c:	4b74      	ldr	r3, [pc, #464]	; (20500 <spi_nrfx_transceive+0x304>)
   2032e:	4298      	cmp	r0, r3
   20330:	f040 809a 	bne.w	20468 <spi_nrfx_transceive+0x26c>
	dev_data->initialized = true;
   20334:	2301      	movs	r3, #1
	ctx->config = spi_cfg;
   20336:	f8c9 6000 	str.w	r6, [r9]
	dev_data->initialized = true;
   2033a:	f889 305d 	strb.w	r3, [r9, #93]	; 0x5d
		dev_data->busy = true;
   2033e:	2301      	movs	r3, #1
   20340:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
   20344:	f1b8 0f00 	cmp.w	r8, #0
   20348:	f040 80a4 	bne.w	20494 <spi_nrfx_transceive+0x298>
   2034c:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
   20350:	2300      	movs	r3, #0
   20352:	63a3      	str	r3, [r4, #56]	; 0x38
		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
   20354:	f104 0248 	add.w	r2, r4, #72	; 0x48
   20358:	f104 0138 	add.w	r1, r4, #56	; 0x38
   2035c:	f104 0034 	add.w	r0, r4, #52	; 0x34
   20360:	f005 f8f2 	bl	25548 <spi_context_get_next_buf.constprop.0>
	ctx->tx_buf = (const uint8_t *)
   20364:	6460      	str	r0, [r4, #68]	; 0x44
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
   20366:	f1ba 0f00 	cmp.w	sl, #0
   2036a:	f040 809c 	bne.w	204a6 <spi_nrfx_transceive+0x2aa>
   2036e:	f8c4 a03c 	str.w	sl, [r4, #60]	; 0x3c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
   20372:	2300      	movs	r3, #0
   20374:	6423      	str	r3, [r4, #64]	; 0x40
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
   20376:	f104 0250 	add.w	r2, r4, #80	; 0x50
   2037a:	f104 0140 	add.w	r1, r4, #64	; 0x40
   2037e:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   20382:	f005 f8e1 	bl	25548 <spi_context_get_next_buf.constprop.0>
	ctx->sync_status = 0;
   20386:	2500      	movs	r5, #0
	_spi_context_cs_control(ctx, on, false);
   20388:	2101      	movs	r1, #1
   2038a:	462a      	mov	r2, r5
	ctx->rx_buf = (uint8_t *)
   2038c:	64e0      	str	r0, [r4, #76]	; 0x4c
	ctx->sync_status = 0;
   2038e:	6325      	str	r5, [r4, #48]	; 0x30
	_spi_context_cs_control(ctx, on, false);
   20390:	4620      	mov	r0, r4
   20392:	f005 f900 	bl	25596 <_spi_context_cs_control>
		transfer_next_chunk(dev);
   20396:	4638      	mov	r0, r7
   20398:	f7ff fee4 	bl	20164 <transfer_next_chunk>
}

static inline size_t spi_context_total_tx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
   2039c:	462a      	mov	r2, r5

	for (n = 0; n < ctx->tx_count; ++n) {
   2039e:	462b      	mov	r3, r5
   203a0:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   203a2:	4283      	cmp	r3, r0
   203a4:	f040 8088 	bne.w	204b8 <spi_nrfx_transceive+0x2bc>
}

static inline size_t spi_context_total_rx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
   203a8:	2300      	movs	r3, #0

	for (n = 0; n < ctx->rx_count; ++n) {
   203aa:	4619      	mov	r1, r3
   203ac:	6c25      	ldr	r5, [r4, #64]	; 0x40
   203ae:	42a9      	cmp	r1, r5
   203b0:	f040 8089 	bne.w	204c6 <spi_nrfx_transceive+0x2ca>
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
   203b4:	4293      	cmp	r3, r2
   203b6:	bf38      	it	cc
   203b8:	4613      	movcc	r3, r2
				     ctx->config->frequency;
   203ba:	4626      	mov	r6, r4
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
   203bc:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
   203c0:	f04f 0800 	mov.w	r8, #0
   203c4:	fb02 f503 	mul.w	r5, r2, r3
				     ctx->config->frequency;
   203c8:	f856 3b20 	ldr.w	r3, [r6], #32
   203cc:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
   203d0:	681b      	ldr	r3, [r3, #0]
   203d2:	4641      	mov	r1, r8
   203d4:	fbb5 f5f3 	udiv	r5, r5, r3
   203d8:	f240 30e7 	movw	r0, #999	; 0x3e7
			timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
   203dc:	35c8      	adds	r5, #200	; 0xc8
   203de:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   203e2:	2300      	movs	r3, #0
   203e4:	fbe5 010c 	umlal	r0, r1, r5, ip
   203e8:	f7fb feb4 	bl	1c154 <__aeabi_uldivmod>
   203ec:	4602      	mov	r2, r0
   203ee:	460b      	mov	r3, r1
   203f0:	4630      	mov	r0, r6
   203f2:	f003 f8c5 	bl	23580 <z_impl_k_sem_take>
		if (k_sem_take(&ctx->sync, timeout)) {
   203f6:	b918      	cbnz	r0, 20400 <spi_nrfx_transceive+0x204>
		status = ctx->sync_status;
   203f8:	6b25      	ldr	r5, [r4, #48]	; 0x30
		if (error == -ETIMEDOUT) {
   203fa:	f115 0f74 	cmn.w	r5, #116	; 0x74
   203fe:	d135      	bne.n	2046c <spi_nrfx_transceive+0x270>
			nrfx_spim_uninit(&dev_config->spim);
   20400:	9803      	ldr	r0, [sp, #12]
			dev_data->chunk_len = 0;
   20402:	f8c4 8058 	str.w	r8, [r4, #88]	; 0x58
			nrfx_spim_uninit(&dev_config->spim);
   20406:	f001 fa1f 	bl	21848 <nrfx_spim_uninit>
			dev_data->initialized = false;
   2040a:	f884 805d 	strb.w	r8, [r4, #93]	; 0x5d
			finish_transaction(dev, -ETIMEDOUT);
   2040e:	f06f 0173 	mvn.w	r1, #115	; 0x73
   20412:	6938      	ldr	r0, [r7, #16]
   20414:	f005 f959 	bl	256ca <finish_transaction.isra.0>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_RESET);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_reset(sem);
   20418:	4630      	mov	r0, r6
   2041a:	f003 f8d9 	bl	235d0 <z_impl_k_sem_reset>
		error = spi_context_wait_for_completion(&dev_data->ctx);
   2041e:	f06f 0573 	mvn.w	r5, #115	; 0x73
}
   20422:	e023      	b.n	2046c <spi_nrfx_transceive+0x270>
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
   20424:	69a3      	ldr	r3, [r4, #24]
   20426:	2b00      	cmp	r3, #0
   20428:	f47f aef6 	bne.w	20218 <spi_nrfx_transceive+0x1c>
		(k_sem_count_get(&ctx->lock) == 0) &&
   2042c:	6863      	ldr	r3, [r4, #4]
   2042e:	4299      	cmp	r1, r3
   20430:	f47f aef2 	bne.w	20218 <spi_nrfx_transceive+0x1c>
   20434:	e6f9      	b.n	2022a <spi_nrfx_transceive+0x2e>
		return NRF_SPIM_FREQ_125K;
   20436:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
   2043a:	e758      	b.n	202ee <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_250K;
   2043c:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
   20440:	e755      	b.n	202ee <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_500K;
   20442:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   20446:	e752      	b.n	202ee <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_1M;
   20448:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   2044c:	e74f      	b.n	202ee <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_2M;
   2044e:	f04f 5500 	mov.w	r5, #536870912	; 0x20000000
   20452:	e74c      	b.n	202ee <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_4M;
   20454:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
   20458:	e749      	b.n	202ee <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_8M;
   2045a:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
   2045e:	e746      	b.n	202ee <spi_nrfx_transceive+0xf2>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
   20460:	3b00      	subs	r3, #0
   20462:	bf18      	it	ne
   20464:	2301      	movne	r3, #1
   20466:	e74d      	b.n	20304 <spi_nrfx_transceive+0x108>
		return -EIO;
   20468:	f06f 0504 	mvn.w	r5, #4
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
   2046c:	6823      	ldr	r3, [r4, #0]
   2046e:	889b      	ldrh	r3, [r3, #4]
   20470:	f413 5300 	ands.w	r3, r3, #8192	; 0x2000
   20474:	d104      	bne.n	20480 <spi_nrfx_transceive+0x284>
		ctx->owner = NULL;
   20476:	6063      	str	r3, [r4, #4]
	z_impl_k_sem_give(sem);
   20478:	f104 0010 	add.w	r0, r4, #16
   2047c:	f003 f860 	bl	23540 <z_impl_k_sem_give>
	return transceive(dev, spi_cfg, tx_bufs, rx_bufs, false, NULL, NULL);
}
   20480:	4628      	mov	r0, r5
   20482:	b00b      	add	sp, #44	; 0x2c
   20484:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -EINVAL;
   20488:	f06f 0515 	mvn.w	r5, #21
   2048c:	e7ee      	b.n	2046c <spi_nrfx_transceive+0x270>
		return -ENOTSUP;
   2048e:	f06f 0585 	mvn.w	r5, #133	; 0x85
   20492:	e7eb      	b.n	2046c <spi_nrfx_transceive+0x270>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
   20494:	f8d8 3000 	ldr.w	r3, [r8]
   20498:	6363      	str	r3, [r4, #52]	; 0x34
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
   2049a:	2b00      	cmp	r3, #0
   2049c:	f43f af58 	beq.w	20350 <spi_nrfx_transceive+0x154>
   204a0:	f8d8 3004 	ldr.w	r3, [r8, #4]
   204a4:	e755      	b.n	20352 <spi_nrfx_transceive+0x156>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
   204a6:	f8da 3000 	ldr.w	r3, [sl]
   204aa:	63e3      	str	r3, [r4, #60]	; 0x3c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
   204ac:	2b00      	cmp	r3, #0
   204ae:	f43f af60 	beq.w	20372 <spi_nrfx_transceive+0x176>
   204b2:	f8da 3004 	ldr.w	r3, [sl, #4]
   204b6:	e75d      	b.n	20374 <spi_nrfx_transceive+0x178>
		total_len += ctx->current_tx[n].len;
   204b8:	6b61      	ldr	r1, [r4, #52]	; 0x34
   204ba:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   204be:	6849      	ldr	r1, [r1, #4]
	for (n = 0; n < ctx->tx_count; ++n) {
   204c0:	3301      	adds	r3, #1
		total_len += ctx->current_tx[n].len;
   204c2:	440a      	add	r2, r1
	for (n = 0; n < ctx->tx_count; ++n) {
   204c4:	e76d      	b.n	203a2 <spi_nrfx_transceive+0x1a6>
		total_len += ctx->current_rx[n].len;
   204c6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   204c8:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   204cc:	6840      	ldr	r0, [r0, #4]
	for (n = 0; n < ctx->rx_count; ++n) {
   204ce:	3101      	adds	r1, #1
		total_len += ctx->current_rx[n].len;
   204d0:	4403      	add	r3, r0
	for (n = 0; n < ctx->rx_count; ++n) {
   204d2:	e76c      	b.n	203ae <spi_nrfx_transceive+0x1b2>
   204d4:	0001e847 	.word	0x0001e847
   204d8:	00f42400 	.word	0x00f42400
   204dc:	40005000 	.word	0x40005000
   204e0:	0003d08f 	.word	0x0003d08f
   204e4:	0007a11f 	.word	0x0007a11f
   204e8:	000f423f 	.word	0x000f423f
   204ec:	001e847f 	.word	0x001e847f
   204f0:	003d08ff 	.word	0x003d08ff
   204f4:	007a1200 	.word	0x007a1200
   204f8:	01e84800 	.word	0x01e84800
   204fc:	000256eb 	.word	0x000256eb
   20500:	0bad0000 	.word	0x0bad0000

00020504 <compare_int_lock>:
#endif
}

static bool compare_int_lock(int32_t chan)
{
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   20504:	2301      	movs	r3, #1
   20506:	4083      	lsls	r3, r0
{
   20508:	b570      	push	{r4, r5, r6, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   2050a:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   2050c:	4a0b      	ldr	r2, [pc, #44]	; (2053c <compare_int_lock+0x38>)
   2050e:	e8d2 1fef 	ldaex	r1, [r2]
   20512:	ea01 0504 	and.w	r5, r1, r4
   20516:	e8c2 5fe6 	stlex	r6, r5, [r2]
   2051a:	2e00      	cmp	r6, #0
   2051c:	d1f7      	bne.n	2050e <compare_int_lock+0xa>

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   2051e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   20522:	4082      	lsls	r2, r0
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_int_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
   20524:	4806      	ldr	r0, [pc, #24]	; (20540 <compare_int_lock+0x3c>)
   20526:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
   2052a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   2052e:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
   20532:	420b      	tst	r3, r1
}
   20534:	bf14      	ite	ne
   20536:	2001      	movne	r0, #1
   20538:	2000      	moveq	r0, #0
   2053a:	bd70      	pop	{r4, r5, r6, pc}
   2053c:	2000b2ec 	.word	0x2000b2ec
   20540:	40015000 	.word	0x40015000

00020544 <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
   20544:	b470      	push	{r4, r5, r6}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint32_t dticks = (uint32_t)(expire_time - last_count) / CYC_PER_TICK;
   20546:	490e      	ldr	r1, [pc, #56]	; (20580 <sys_clock_timeout_handler+0x3c>)
	return absolute_time & COUNTER_MAX;
   20548:	f022 467f 	bic.w	r6, r2, #4278190080	; 0xff000000
	uint32_t dticks = (uint32_t)(expire_time - last_count) / CYC_PER_TICK;
   2054c:	e9d1 3400 	ldrd	r3, r4, [r1]
   20550:	1ad0      	subs	r0, r2, r3

	last_count += dticks * CYC_PER_TICK;
   20552:	18c3      	adds	r3, r0, r3
   20554:	f144 0400 	adc.w	r4, r4, #0
   20558:	e9c1 3400 	strd	r3, r4, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   2055c:	f5a6 1300 	sub.w	r3, r6, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   20560:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   20564:	d209      	bcs.n	2057a <sys_clock_timeout_handler+0x36>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   20566:	4b07      	ldr	r3, [pc, #28]	; (20584 <sys_clock_timeout_handler+0x40>)
   20568:	681b      	ldr	r3, [r3, #0]
   2056a:	0a1a      	lsrs	r2, r3, #8
   2056c:	061b      	lsls	r3, r3, #24
   2056e:	199c      	adds	r4, r3, r6
   20570:	4b05      	ldr	r3, [pc, #20]	; (20588 <sys_clock_timeout_handler+0x44>)
   20572:	f142 0500 	adc.w	r5, r2, #0
   20576:	e9c3 4500 	strd	r4, r5, [r3]
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(dticks);
}
   2057a:	bc70      	pop	{r4, r5, r6}
	sys_clock_announce(dticks);
   2057c:	f003 bde2 	b.w	24144 <sys_clock_announce>
   20580:	2000a560 	.word	0x2000a560
   20584:	2000b2f0 	.word	0x2000b2f0
   20588:	2000a568 	.word	0x2000a568

0002058c <compare_int_unlock>:
	if (key) {
   2058c:	b1d9      	cbz	r1, 205c6 <compare_int_unlock+0x3a>
		atomic_or(&int_mask, BIT(chan));
   2058e:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   20590:	4a0d      	ldr	r2, [pc, #52]	; (205c8 <compare_int_unlock+0x3c>)
   20592:	4083      	lsls	r3, r0
   20594:	e8d2 cfef 	ldaex	ip, [r2]
   20598:	ea4c 0c03 	orr.w	ip, ip, r3
   2059c:	e8c2 cfe1 	stlex	r1, ip, [r2]
   205a0:	2900      	cmp	r1, #0
   205a2:	d1f7      	bne.n	20594 <compare_int_unlock+0x8>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   205a4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
   205a8:	4a08      	ldr	r2, [pc, #32]	; (205cc <compare_int_unlock+0x40>)
   205aa:	4083      	lsls	r3, r0
   205ac:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   205b0:	4b07      	ldr	r3, [pc, #28]	; (205d0 <compare_int_unlock+0x44>)
   205b2:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   205b6:	40c3      	lsrs	r3, r0
   205b8:	07db      	lsls	r3, r3, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   205ba:	bf42      	ittt	mi
   205bc:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   205c0:	4b04      	ldrmi	r3, [pc, #16]	; (205d4 <compare_int_unlock+0x48>)
   205c2:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   205c6:	4770      	bx	lr
   205c8:	2000b2ec 	.word	0x2000b2ec
   205cc:	40015000 	.word	0x40015000
   205d0:	2000b2e8 	.word	0x2000b2e8
   205d4:	e000e100 	.word	0xe000e100

000205d8 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   205d8:	4b0d      	ldr	r3, [pc, #52]	; (20610 <z_nrf_rtc_timer_read+0x38>)
   205da:	6818      	ldr	r0, [r3, #0]
   205dc:	0a01      	lsrs	r1, r0, #8
   205de:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
   205e0:	f3bf 8f5f 	dmb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
   205e4:	4b0b      	ldr	r3, [pc, #44]	; (20614 <z_nrf_rtc_timer_read+0x3c>)
   205e6:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   205ea:	1818      	adds	r0, r3, r0
   205ec:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   205f0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   205f4:	d20a      	bcs.n	2060c <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   205f6:	4b08      	ldr	r3, [pc, #32]	; (20618 <z_nrf_rtc_timer_read+0x40>)
   205f8:	e9d3 2300 	ldrd	r2, r3, [r3]
   205fc:	4290      	cmp	r0, r2
   205fe:	eb71 0303 	sbcs.w	r3, r1, r3
   20602:	d203      	bcs.n	2060c <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   20604:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   20608:	f141 0100 	adc.w	r1, r1, #0
}
   2060c:	4770      	bx	lr
   2060e:	bf00      	nop
   20610:	2000b2f0 	.word	0x2000b2f0
   20614:	40015000 	.word	0x40015000
   20618:	2000a568 	.word	0x2000a568

0002061c <compare_set>:
{
   2061c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20620:	4616      	mov	r6, r2
   20622:	461f      	mov	r7, r3
   20624:	4604      	mov	r4, r0
	key = compare_int_lock(chan);
   20626:	f7ff ff6d 	bl	20504 <compare_int_lock>
   2062a:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   2062c:	f7ff ffd4 	bl	205d8 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   20630:	42b0      	cmp	r0, r6
   20632:	eb71 0307 	sbcs.w	r3, r1, r7
   20636:	d250      	bcs.n	206da <compare_set+0xbe>
		if (target_time - curr_time > COUNTER_HALF_SPAN) {
   20638:	4b38      	ldr	r3, [pc, #224]	; (2071c <compare_set+0x100>)
   2063a:	1a30      	subs	r0, r6, r0
   2063c:	eb67 0101 	sbc.w	r1, r7, r1
   20640:	4298      	cmp	r0, r3
   20642:	f171 0100 	sbcs.w	r1, r1, #0
   20646:	d265      	bcs.n	20714 <compare_set+0xf8>
		if (target_time != cc_data[chan].target_time) {
   20648:	4b35      	ldr	r3, [pc, #212]	; (20720 <compare_set+0x104>)
   2064a:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   2064e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   20652:	429f      	cmp	r7, r3
   20654:	bf08      	it	eq
   20656:	4296      	cmpeq	r6, r2
   20658:	d049      	beq.n	206ee <compare_set+0xd2>
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   2065a:	f44f 3980 	mov.w	r9, #65536	; 0x10000
    p_reg->EVTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   2065e:	4931      	ldr	r1, [pc, #196]	; (20724 <compare_set+0x108>)
   20660:	fa09 f904 	lsl.w	r9, r9, r4
	event_clear(chan);
   20664:	4620      	mov	r0, r4
	return absolute_time & COUNTER_MAX;
   20666:	f026 4b7f 	bic.w	fp, r6, #4278190080	; 0xff000000
   2066a:	f8c1 9348 	str.w	r9, [r1, #840]	; 0x348
	event_clear(chan);
   2066e:	f005 f889 	bl	25784 <event_clear>
	uint32_t cc_inc = MIN_CYCLES_FROM_NOW;
   20672:	f04f 0a03 	mov.w	sl, #3
	uint32_t cc_val = req_cc;
   20676:	4658      	mov	r0, fp
	return nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   20678:	f104 0550 	add.w	r5, r4, #80	; 0x50
   2067c:	00ad      	lsls	r5, r5, #2
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2067e:	b2ad      	uxth	r5, r5
   20680:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
    p_reg->CC[ch] = cc_val;
   20684:	f504 73a8 	add.w	r3, r4, #336	; 0x150
		if (counter_sub(cc_val, now + MIN_CYCLES_FROM_NOW) >
   20688:	4a27      	ldr	r2, [pc, #156]	; (20728 <compare_set+0x10c>)
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2068a:	f505 35a8 	add.w	r5, r5, #86016	; 0x15000
    p_reg->CC[ch] = cc_val;
   2068e:	9301      	str	r3, [sp, #4]
   20690:	f8dd c004 	ldr.w	ip, [sp, #4]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   20694:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
   20698:	f841 302c 	str.w	r3, [r1, ip, lsl #2]
    p_reg->EVTENSET = mask;
   2069c:	f8c1 9344 	str.w	r9, [r1, #836]	; 0x344
     return p_reg->COUNTER;
   206a0:	f8d1 8504 	ldr.w	r8, [r1, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   206a4:	eba0 0008 	sub.w	r0, r0, r8
   206a8:	3803      	subs	r0, #3
   206aa:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		if (counter_sub(cc_val, now + MIN_CYCLES_FROM_NOW) >
   206ae:	4290      	cmp	r0, r2
   206b0:	d91d      	bls.n	206ee <compare_set+0xd2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   206b2:	6828      	ldr	r0, [r5, #0]
			if (event_check(chan)) {
   206b4:	b160      	cbz	r0, 206d0 <compare_set+0xb4>
     return p_reg->COUNTER;
   206b6:	f8d1 8504 	ldr.w	r8, [r1, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   206ba:	eba8 000b 	sub.w	r0, r8, fp
   206be:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
				if (counter_sub(now, req_cc) > COUNTER_HALF_SPAN) {
   206c2:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   206c6:	d912      	bls.n	206ee <compare_set+0xd2>
					event_clear(chan);
   206c8:	4620      	mov	r0, r4
   206ca:	f005 f85b 	bl	25784 <event_clear>
   206ce:	4a16      	ldr	r2, [pc, #88]	; (20728 <compare_set+0x10c>)
			cc_val = now + cc_inc;
   206d0:	eb0a 0008 	add.w	r0, sl, r8
			cc_inc++;
   206d4:	f10a 0a01 	add.w	sl, sl, #1
	for (;;) {
   206d8:	e7da      	b.n	20690 <compare_set+0x74>
		atomic_or(&force_isr_mask, BIT(chan));
   206da:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   206dc:	4a13      	ldr	r2, [pc, #76]	; (2072c <compare_set+0x110>)
   206de:	40a3      	lsls	r3, r4
   206e0:	e8d2 0fef 	ldaex	r0, [r2]
   206e4:	4318      	orrs	r0, r3
   206e6:	e8c2 0fe1 	stlex	r1, r0, [r2]
   206ea:	2900      	cmp	r1, #0
   206ec:	d1f8      	bne.n	206e0 <compare_set+0xc4>
	return ret;
   206ee:	2500      	movs	r5, #0
	cc_data[chan].target_time = target_time;
   206f0:	490b      	ldr	r1, [pc, #44]	; (20720 <compare_set+0x104>)
	cc_data[chan].callback = handler;
   206f2:	980c      	ldr	r0, [sp, #48]	; 0x30
	cc_data[chan].target_time = target_time;
   206f4:	0123      	lsls	r3, r4, #4
   206f6:	eb01 1204 	add.w	r2, r1, r4, lsl #4
	cc_data[chan].callback = handler;
   206fa:	50c8      	str	r0, [r1, r3]
	cc_data[chan].target_time = target_time;
   206fc:	e9c2 6702 	strd	r6, r7, [r2, #8]
	cc_data[chan].user_context = user_data;
   20700:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   20702:	6053      	str	r3, [r2, #4]
	compare_int_unlock(chan, key);
   20704:	4620      	mov	r0, r4
   20706:	9900      	ldr	r1, [sp, #0]
   20708:	f7ff ff40 	bl	2058c <compare_int_unlock>
}
   2070c:	4628      	mov	r0, r5
   2070e:	b003      	add	sp, #12
   20710:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return -EINVAL;
   20714:	f06f 0515 	mvn.w	r5, #21
   20718:	e7f4      	b.n	20704 <compare_set+0xe8>
   2071a:	bf00      	nop
   2071c:	00800001 	.word	0x00800001
   20720:	2000a550 	.word	0x2000a550
   20724:	40015000 	.word	0x40015000
   20728:	007ffffd 	.word	0x007ffffd
   2072c:	2000b2e8 	.word	0x2000b2e8

00020730 <sys_clock_driver_init>:
	int_event_disable_rtc();
	NVIC_ClearPendingIRQ(RTC_IRQn);
}

static int sys_clock_driver_init(void)
{
   20730:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
   20732:	2500      	movs	r5, #0
	int_event_disable_rtc();

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   20734:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   20738:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    p_reg->INTENCLR = mask;
   2073c:	4c18      	ldr	r4, [pc, #96]	; (207a0 <sys_clock_driver_init+0x70>)
   2073e:	4b19      	ldr	r3, [pc, #100]	; (207a4 <sys_clock_driver_init+0x74>)
    p_reg->INTENSET = mask;
   20740:	2602      	movs	r6, #2
    p_reg->INTENCLR = mask;
   20742:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    p_reg->EVTENCLR = mask;
   20746:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
   2074a:	4b17      	ldr	r3, [pc, #92]	; (207a8 <sys_clock_driver_init+0x78>)
    p_reg->PRESCALER = val;
   2074c:	f8c4 5508 	str.w	r5, [r4, #1288]	; 0x508
   20750:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   20754:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20758:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   2075c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   20760:	4b12      	ldr	r3, [pc, #72]	; (207ac <sys_clock_driver_init+0x7c>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   20762:	2101      	movs	r1, #1
   20764:	f8c4 6304 	str.w	r6, [r4, #772]	; 0x304
   20768:	2015      	movs	r0, #21
   2076a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   2076e:	462a      	mov	r2, r5
   20770:	f7fd fde6 	bl	1e340 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   20774:	2015      	movs	r0, #21
   20776:	f7fd fdb3 	bl	1e2e0 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   2077a:	2301      	movs	r3, #1

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
   2077c:	4a0c      	ldr	r2, [pc, #48]	; (207b0 <sys_clock_driver_init+0x80>)
   2077e:	60a3      	str	r3, [r4, #8]
   20780:	6023      	str	r3, [r4, #0]
   20782:	6013      	str	r3, [r2, #0]
	}

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		MAX_CYCLES : CYC_PER_TICK;

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   20784:	4b0b      	ldr	r3, [pc, #44]	; (207b4 <sys_clock_driver_init+0x84>)
   20786:	4a0c      	ldr	r2, [pc, #48]	; (207b8 <sys_clock_driver_init+0x88>)
   20788:	9300      	str	r3, [sp, #0]
   2078a:	4628      	mov	r0, r5
   2078c:	2300      	movs	r3, #0
   2078e:	9501      	str	r5, [sp, #4]
   20790:	f7ff ff44 	bl	2061c <compare_set>

	z_nrf_clock_control_lf_on(mode);
   20794:	4630      	mov	r0, r6
   20796:	f7ff f8ef 	bl	1f978 <z_nrf_clock_control_lf_on>

	return 0;
}
   2079a:	4628      	mov	r0, r5
   2079c:	b002      	add	sp, #8
   2079e:	bd70      	pop	{r4, r5, r6, pc}
   207a0:	40015000 	.word	0x40015000
   207a4:	000f0003 	.word	0x000f0003
   207a8:	2000a550 	.word	0x2000a550
   207ac:	e000e100 	.word	0xe000e100
   207b0:	2000b2ec 	.word	0x2000b2ec
   207b4:	00020545 	.word	0x00020545
   207b8:	007fffff 	.word	0x007fffff

000207bc <rtc_nrf_isr>:
{
   207bc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    return p_reg->INTENSET & mask;
   207c0:	4b2e      	ldr	r3, [pc, #184]	; (2087c <rtc_nrf_isr+0xc0>)
   207c2:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   207c6:	0790      	lsls	r0, r2, #30
   207c8:	d50b      	bpl.n	207e2 <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   207ca:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   207ce:	b142      	cbz	r2, 207e2 <rtc_nrf_isr+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   207d0:	2200      	movs	r2, #0
   207d2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		overflow_cnt++;
   207d6:	4a2a      	ldr	r2, [pc, #168]	; (20880 <rtc_nrf_isr+0xc4>)
   207d8:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   207dc:	6813      	ldr	r3, [r2, #0]
   207de:	3301      	adds	r3, #1
   207e0:	6013      	str	r3, [r2, #0]
    return p_reg->INTENSET & mask;
   207e2:	4a26      	ldr	r2, [pc, #152]	; (2087c <rtc_nrf_isr+0xc0>)
   207e4:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   207e8:	03d9      	lsls	r1, r3, #15
   207ea:	d527      	bpl.n	2083c <rtc_nrf_isr+0x80>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   207ec:	4b25      	ldr	r3, [pc, #148]	; (20884 <rtc_nrf_isr+0xc8>)
   207ee:	e8d3 1fef 	ldaex	r1, [r3]
   207f2:	f021 0001 	bic.w	r0, r1, #1
   207f6:	e8c3 0fe4 	stlex	r4, r0, [r3]
   207fa:	2c00      	cmp	r4, #0
   207fc:	d1f7      	bne.n	207ee <rtc_nrf_isr+0x32>
		if ((atomic_and(&force_isr_mask, ~BIT(chan)) & BIT(chan)) ||
   207fe:	07cb      	lsls	r3, r1, #31
   20800:	d402      	bmi.n	20808 <rtc_nrf_isr+0x4c>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   20802:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
   20806:	b1cb      	cbz	r3, 2083c <rtc_nrf_isr+0x80>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   20808:	2500      	movs	r5, #0
   2080a:	4c1c      	ldr	r4, [pc, #112]	; (2087c <rtc_nrf_isr+0xc0>)
   2080c:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
   20810:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		curr_time = z_nrf_rtc_timer_read();
   20814:	f7ff fee0 	bl	205d8 <z_nrf_rtc_timer_read>
   20818:	f04f 0320 	mov.w	r3, #32
   2081c:	f3ef 8211 	mrs	r2, BASEPRI
   20820:	f383 8812 	msr	BASEPRI_MAX, r3
   20824:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   20828:	4b17      	ldr	r3, [pc, #92]	; (20888 <rtc_nrf_isr+0xcc>)
   2082a:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
		if (curr_time >= expire_time) {
   2082e:	42b0      	cmp	r0, r6
   20830:	41b9      	sbcs	r1, r7
   20832:	d206      	bcs.n	20842 <rtc_nrf_isr+0x86>
	__asm__ volatile(
   20834:	f382 8811 	msr	BASEPRI, r2
   20838:	f3bf 8f6f 	isb	sy
}
   2083c:	b003      	add	sp, #12
   2083e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   20842:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
			user_context = cc_data[chan].user_context;
   20846:	e9d3 1000 	ldrd	r1, r0, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   2084a:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			cc_data[chan].callback = NULL;
   2084e:	601d      	str	r5, [r3, #0]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   20850:	e9c3 8902 	strd	r8, r9, [r3, #8]
    p_reg->EVTENCLR = mask;
   20854:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   20858:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   2085c:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
   20860:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
   20864:	f382 8811 	msr	BASEPRI, r2
   20868:	f3bf 8f6f 	isb	sy
		if (handler) {
   2086c:	2900      	cmp	r1, #0
   2086e:	d0e5      	beq.n	2083c <rtc_nrf_isr+0x80>
			handler(chan, expire_time, user_context);
   20870:	9000      	str	r0, [sp, #0]
   20872:	4632      	mov	r2, r6
   20874:	463b      	mov	r3, r7
   20876:	4628      	mov	r0, r5
   20878:	4788      	blx	r1
   2087a:	e7df      	b.n	2083c <rtc_nrf_isr+0x80>
   2087c:	40015000 	.word	0x40015000
   20880:	2000b2f0 	.word	0x2000b2f0
   20884:	2000b2e8 	.word	0x2000b2e8
   20888:	2000a550 	.word	0x2000a550

0002088c <sys_clock_set_timeout>:
	if (ticks == K_TICKS_FOREVER) {
   2088c:	1c43      	adds	r3, r0, #1
{
   2088e:	b513      	push	{r0, r1, r4, lr}
	if (ticks == K_TICKS_FOREVER) {
   20890:	d021      	beq.n	208d6 <sys_clock_set_timeout+0x4a>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
   20892:	2801      	cmp	r0, #1
   20894:	dd21      	ble.n	208da <sys_clock_set_timeout+0x4e>
   20896:	4a12      	ldr	r2, [pc, #72]	; (208e0 <sys_clock_set_timeout+0x54>)
   20898:	4b12      	ldr	r3, [pc, #72]	; (208e4 <sys_clock_set_timeout+0x58>)
   2089a:	4290      	cmp	r0, r2
   2089c:	bfd4      	ite	le
   2089e:	4604      	movle	r4, r0
   208a0:	461c      	movgt	r4, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   208a2:	f7ff fe99 	bl	205d8 <z_nrf_rtc_timer_read>
   208a6:	4b10      	ldr	r3, [pc, #64]	; (208e8 <sys_clock_set_timeout+0x5c>)
	if (cyc > MAX_CYCLES) {
   208a8:	490e      	ldr	r1, [pc, #56]	; (208e4 <sys_clock_set_timeout+0x58>)
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   208aa:	e9d3 2300 	ldrd	r2, r3, [r3]
   208ae:	1a80      	subs	r0, r0, r2
		cyc = 0;
   208b0:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   208b4:	bf28      	it	cs
   208b6:	2400      	movcs	r4, #0
	cyc += unannounced;
   208b8:	4404      	add	r4, r0
	if (cyc > MAX_CYCLES) {
   208ba:	428c      	cmp	r4, r1
   208bc:	bf28      	it	cs
   208be:	460c      	movcs	r4, r1
	uint64_t target_time = cyc + last_count;
   208c0:	2000      	movs	r0, #0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   208c2:	490a      	ldr	r1, [pc, #40]	; (208ec <sys_clock_set_timeout+0x60>)
	uint64_t target_time = cyc + last_count;
   208c4:	18a2      	adds	r2, r4, r2
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   208c6:	9001      	str	r0, [sp, #4]
   208c8:	9100      	str	r1, [sp, #0]
   208ca:	f143 0300 	adc.w	r3, r3, #0
   208ce:	f7ff fea5 	bl	2061c <compare_set>
}
   208d2:	b002      	add	sp, #8
   208d4:	bd10      	pop	{r4, pc}
		cyc = MAX_TICKS * CYC_PER_TICK;
   208d6:	4c03      	ldr	r4, [pc, #12]	; (208e4 <sys_clock_set_timeout+0x58>)
   208d8:	e7e3      	b.n	208a2 <sys_clock_set_timeout+0x16>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
   208da:	2401      	movs	r4, #1
   208dc:	e7e1      	b.n	208a2 <sys_clock_set_timeout+0x16>
   208de:	bf00      	nop
   208e0:	007ffffe 	.word	0x007ffffe
   208e4:	007fffff 	.word	0x007fffff
   208e8:	2000a560 	.word	0x2000a560
   208ec:	00020545 	.word	0x00020545

000208f0 <sys_clock_elapsed>:
{
   208f0:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   208f2:	f7ff fe71 	bl	205d8 <z_nrf_rtc_timer_read>
   208f6:	4b02      	ldr	r3, [pc, #8]	; (20900 <sys_clock_elapsed+0x10>)
   208f8:	681b      	ldr	r3, [r3, #0]
}
   208fa:	1ac0      	subs	r0, r0, r3
   208fc:	bd08      	pop	{r3, pc}
   208fe:	bf00      	nop
   20900:	2000a560 	.word	0x2000a560

00020904 <tfm_ns_interface_dispatch>:
K_MUTEX_DEFINE(tfm_mutex);

int32_t tfm_ns_interface_dispatch(veneer_fn fn,
				  uint32_t arg0, uint32_t arg1,
				  uint32_t arg2, uint32_t arg3)
{
   20904:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20908:	461f      	mov	r7, r3
	return !z_sys_post_kernel;
   2090a:	4b15      	ldr	r3, [pc, #84]	; (20960 <tfm_ns_interface_dispatch+0x5c>)
   2090c:	4604      	mov	r4, r0
   2090e:	f893 8000 	ldrb.w	r8, [r3]
   20912:	460d      	mov	r5, r1
   20914:	4616      	mov	r6, r2
   20916:	b0a2      	sub	sp, #136	; 0x88
	int32_t result;
	bool is_pre_kernel = k_is_pre_kernel();
	int tfm_ns_saved_prio;

	if (!is_pre_kernel) {
   20918:	f1b8 0f00 	cmp.w	r8, #0
   2091c:	d115      	bne.n	2094a <tfm_ns_interface_dispatch+0x46>
#endif
	}

	struct fpu_ctx_full context_buffer;

	z_arm_save_fp_context(&context_buffer);
   2091e:	4668      	mov	r0, sp
   20920:	f004 fb27 	bl	24f72 <z_arm_save_fp_context>

	result = fn(arg0, arg1, arg2, arg3);
   20924:	463a      	mov	r2, r7
   20926:	4631      	mov	r1, r6
   20928:	4628      	mov	r0, r5
   2092a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
   2092c:	47a0      	blx	r4
   2092e:	4604      	mov	r4, r0

	z_arm_restore_fp_context(&context_buffer);
   20930:	4668      	mov	r0, sp
   20932:	f004 fb1f 	bl	24f74 <z_arm_restore_fp_context>

	if (!is_pre_kernel) {
   20936:	f1b8 0f00 	cmp.w	r8, #0
   2093a:	d002      	beq.n	20942 <tfm_ns_interface_dispatch+0x3e>
	return z_impl_k_mutex_unlock(mutex);
   2093c:	4809      	ldr	r0, [pc, #36]	; (20964 <tfm_ns_interface_dispatch+0x60>)
   2093e:	f002 fd8f 	bl	23460 <z_impl_k_mutex_unlock>

		k_mutex_unlock(&tfm_mutex);
	}

	return result;
}
   20942:	4620      	mov	r0, r4
   20944:	b022      	add	sp, #136	; 0x88
   20946:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return z_impl_k_mutex_lock(mutex, timeout);
   2094a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2094e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   20952:	4804      	ldr	r0, [pc, #16]	; (20964 <tfm_ns_interface_dispatch+0x60>)
   20954:	f002 fd0a 	bl	2336c <z_impl_k_mutex_lock>
		if (k_mutex_lock(&tfm_mutex, K_FOREVER) != 0) {
   20958:	2800      	cmp	r0, #0
   2095a:	d0e0      	beq.n	2091e <tfm_ns_interface_dispatch+0x1a>
			return (int32_t)TFM_ERROR_GENERIC;
   2095c:	241f      	movs	r4, #31
   2095e:	e7f0      	b.n	20942 <tfm_ns_interface_dispatch+0x3e>
   20960:	2000b637 	.word	0x2000b637
   20964:	2000a2f4 	.word	0x2000a2f4

00020968 <tfm_platform_ioctl>:
enum tfm_platform_err_t
tfm_platform_ioctl(tfm_platform_ioctl_req_t request,
                   psa_invec *input, psa_outvec *output)
{
    tfm_platform_ioctl_req_t req = request;
    struct psa_invec in_vec[2] = { {0} };
   20968:	2300      	movs	r3, #0
{
   2096a:	b500      	push	{lr}
   2096c:	b089      	sub	sp, #36	; 0x24
    struct psa_invec in_vec[2] = { {0} };
   2096e:	e9cd 3306 	strd	r3, r3, [sp, #24]
    size_t inlen, outlen;
    psa_status_t status = PSA_ERROR_CONNECTION_REFUSED;

    in_vec[0].base = &req;
   20972:	ab03      	add	r3, sp, #12
   20974:	9304      	str	r3, [sp, #16]
    in_vec[0].len = sizeof(req);
   20976:	2304      	movs	r3, #4
    tfm_platform_ioctl_req_t req = request;
   20978:	9003      	str	r0, [sp, #12]
    in_vec[0].len = sizeof(req);
   2097a:	9305      	str	r3, [sp, #20]
    if (input != NULL) {
   2097c:	b1a9      	cbz	r1, 209aa <tfm_platform_ioctl+0x42>
        in_vec[1].base = input->base;
   2097e:	680b      	ldr	r3, [r1, #0]
   20980:	9306      	str	r3, [sp, #24]
        in_vec[1].len = input->len;
   20982:	684b      	ldr	r3, [r1, #4]
   20984:	9307      	str	r3, [sp, #28]
        inlen = 2;
   20986:	2302      	movs	r3, #2
    } else {
        inlen = 1;
    }

    if (output != NULL) {
   20988:	1e11      	subs	r1, r2, #0
   2098a:	bf18      	it	ne
   2098c:	2101      	movne	r1, #1
        outlen = 1;
    } else {
        outlen = 0;
    }

    status = psa_call(TFM_PLATFORM_SERVICE_HANDLE,
   2098e:	4808      	ldr	r0, [pc, #32]	; (209b0 <tfm_platform_ioctl+0x48>)
   20990:	e9cd 2100 	strd	r2, r1, [sp]
   20994:	f240 31f5 	movw	r1, #1013	; 0x3f5
   20998:	aa04      	add	r2, sp, #16
   2099a:	f000 f82b 	bl	209f4 <psa_call>
                      TFM_PLATFORM_API_ID_IOCTL,
                      in_vec, inlen,
                      output, outlen);

    if (status < PSA_SUCCESS) {
   2099e:	2800      	cmp	r0, #0
        return TFM_PLATFORM_ERR_SYSTEM_ERROR;
    } else {
        return (enum tfm_platform_err_t)status;
    }
}
   209a0:	bfb8      	it	lt
   209a2:	2001      	movlt	r0, #1
   209a4:	b009      	add	sp, #36	; 0x24
   209a6:	f85d fb04 	ldr.w	pc, [sp], #4
        inlen = 1;
   209aa:	2301      	movs	r3, #1
   209ac:	e7ec      	b.n	20988 <tfm_platform_ioctl+0x20>
   209ae:	bf00      	nop
   209b0:	40000105 	.word	0x40000105

000209b4 <psa_generate_random>:
    return API_DISPATCH_NO_OUTVEC(in_vec);
}

psa_status_t psa_generate_random(uint8_t *output,
                                 size_t output_size)
{
   209b4:	b570      	push	{r4, r5, r6, lr}
    struct tfm_crypto_pack_iovec iov = {
   209b6:	2630      	movs	r6, #48	; 0x30
{
   209b8:	b092      	sub	sp, #72	; 0x48
    struct tfm_crypto_pack_iovec iov = {
   209ba:	ab06      	add	r3, sp, #24
{
   209bc:	4605      	mov	r5, r0
   209be:	460c      	mov	r4, r1
    struct tfm_crypto_pack_iovec iov = {
   209c0:	4632      	mov	r2, r6
   209c2:	2100      	movs	r1, #0
   209c4:	4618      	mov	r0, r3
   209c6:	f004 fb17 	bl	24ff8 <memset>

    psa_invec in_vec[] = {
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    psa_outvec out_vec[] = {
   209ca:	e9cd 5404 	strd	r5, r4, [sp, #16]
    psa_invec in_vec[] = {
   209ce:	e9cd 0602 	strd	r0, r6, [sp, #8]
        {.base = output, .len = output_size},
    };

    if (output_size == 0) {
   209d2:	b154      	cbz	r4, 209ea <psa_generate_random+0x36>
        return PSA_SUCCESS;
    }

    return API_DISPATCH(in_vec, out_vec);
   209d4:	2301      	movs	r3, #1
   209d6:	aa04      	add	r2, sp, #16
   209d8:	9200      	str	r2, [sp, #0]
   209da:	2100      	movs	r1, #0
   209dc:	4804      	ldr	r0, [pc, #16]	; (209f0 <psa_generate_random+0x3c>)
   209de:	9301      	str	r3, [sp, #4]
   209e0:	aa02      	add	r2, sp, #8
   209e2:	f000 f807 	bl	209f4 <psa_call>
}
   209e6:	b012      	add	sp, #72	; 0x48
   209e8:	bd70      	pop	{r4, r5, r6, pc}
        return PSA_SUCCESS;
   209ea:	4620      	mov	r0, r4
   209ec:	e7fb      	b.n	209e6 <psa_generate_random+0x32>
   209ee:	bf00      	nop
   209f0:	40000100 	.word	0x40000100

000209f4 <psa_call>:
psa_status_t psa_call(psa_handle_t handle, int32_t type,
                      const psa_invec *in_vec,
                      size_t in_len,
                      psa_outvec *out_vec,
                      size_t out_len)
{
   209f4:	b430      	push	{r4, r5}
    if ((type > INT16_MAX) ||
   209f6:	f501 4500 	add.w	r5, r1, #32768	; 0x8000
   209fa:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
{
   209fe:	9c03      	ldr	r4, [sp, #12]
    if ((type > INT16_MAX) ||
   20a00:	d20d      	bcs.n	20a1e <psa_call+0x2a>
        (type < INT16_MIN) ||
   20a02:	ea43 0504 	orr.w	r5, r3, r4
   20a06:	2dff      	cmp	r5, #255	; 0xff
   20a08:	d809      	bhi.n	20a1e <psa_call+0x2a>
    }

    return tfm_ns_interface_dispatch(
                                (veneer_fn)tfm_psa_call_veneer,
                                (uint32_t)handle,
                                PARAM_PACK(type, in_len, out_len),
   20a0a:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
    return tfm_ns_interface_dispatch(
   20a0e:	4613      	mov	r3, r2
   20a10:	ea44 4201 	orr.w	r2, r4, r1, lsl #16
   20a14:	4601      	mov	r1, r0
                                (uint32_t)in_vec,
                                (uint32_t)out_vec);
}
   20a16:	bc30      	pop	{r4, r5}
    return tfm_ns_interface_dispatch(
   20a18:	4803      	ldr	r0, [pc, #12]	; (20a28 <psa_call+0x34>)
   20a1a:	f7ff bf73 	b.w	20904 <tfm_ns_interface_dispatch>
}
   20a1e:	f06f 0080 	mvn.w	r0, #128	; 0x80
   20a22:	bc30      	pop	{r4, r5}
   20a24:	4770      	bx	lr
   20a26:	bf00      	nop
   20a28:	00017c11 	.word	0x00017c11

00020a2c <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   20a2c:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   20a2e:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   20a30:	6802      	ldr	r2, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   20a32:	fab2 f382 	clz	r3, r2
   20a36:	f1c3 031f 	rsb	r3, r3, #31
   20a3a:	b2db      	uxtb	r3, r3
        new_mask = prev_mask & ~NRFX_BIT(idx);
   20a3c:	fa05 f403 	lsl.w	r4, r5, r3
   20a40:	ea22 0404 	bic.w	r4, r2, r4
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   20a44:	e8d0 6fef 	ldaex	r6, [r0]
   20a48:	4296      	cmp	r6, r2
   20a4a:	d104      	bne.n	20a56 <nrfx_flag32_alloc+0x2a>
   20a4c:	e8c0 4fec 	stlex	ip, r4, [r0]
   20a50:	f1bc 0f00 	cmp.w	ip, #0
   20a54:	d1f6      	bne.n	20a44 <nrfx_flag32_alloc+0x18>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   20a56:	d1eb      	bne.n	20a30 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
}
   20a58:	4801      	ldr	r0, [pc, #4]	; (20a60 <nrfx_flag32_alloc+0x34>)
    *p_flag = idx;
   20a5a:	700b      	strb	r3, [r1, #0]
}
   20a5c:	bd70      	pop	{r4, r5, r6, pc}
   20a5e:	bf00      	nop
   20a60:	0bad0000 	.word	0x0bad0000

00020a64 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
   20a64:	b510      	push	{r4, lr}
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   20a66:	6803      	ldr	r3, [r0, #0]
   20a68:	40cb      	lsrs	r3, r1
   20a6a:	07db      	lsls	r3, r3, #31
   20a6c:	d410      	bmi.n	20a90 <nrfx_flag32_free+0x2c>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   20a6e:	2301      	movs	r3, #1
   20a70:	408b      	lsls	r3, r1
        prev_mask = *p_mask;
   20a72:	6802      	ldr	r2, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   20a74:	ea43 0102 	orr.w	r1, r3, r2
   20a78:	e8d0 4fef 	ldaex	r4, [r0]
   20a7c:	4294      	cmp	r4, r2
   20a7e:	d104      	bne.n	20a8a <nrfx_flag32_free+0x26>
   20a80:	e8c0 1fec 	stlex	ip, r1, [r0]
   20a84:	f1bc 0f00 	cmp.w	ip, #0
   20a88:	d1f6      	bne.n	20a78 <nrfx_flag32_free+0x14>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   20a8a:	d1f2      	bne.n	20a72 <nrfx_flag32_free+0xe>

    return NRFX_SUCCESS;
   20a8c:	4801      	ldr	r0, [pc, #4]	; (20a94 <nrfx_flag32_free+0x30>)
}
   20a8e:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   20a90:	4801      	ldr	r0, [pc, #4]	; (20a98 <nrfx_flag32_free+0x34>)
   20a92:	e7fc      	b.n	20a8e <nrfx_flag32_free+0x2a>
   20a94:	0bad0000 	.word	0x0bad0000
   20a98:	0bad0004 	.word	0x0bad0004

00020a9c <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
   20a9c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch (domain)
   20a9e:	2803      	cmp	r0, #3
   20aa0:	f200 80a0 	bhi.w	20be4 <clock_stop+0x148>
   20aa4:	e8df f000 	tbb	[pc, r0]
   20aa8:	32251802 	.word	0x32251802
    p_reg->INTENCLR = mask;
   20aac:	2202      	movs	r2, #2
   20aae:	4b59      	ldr	r3, [pc, #356]	; (20c14 <clock_stop+0x178>)
   20ab0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20ab4:	2200      	movs	r2, #0
   20ab6:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   20aba:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20abe:	2201      	movs	r2, #1
   20ac0:	60da      	str	r2, [r3, #12]
            return;
    }

    bool stopped;
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   20ac2:	2400      	movs	r4, #0
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
   20ac4:	2301      	movs	r3, #1
   20ac6:	f88d 3007 	strb.w	r3, [sp, #7]
    switch (domain)
   20aca:	2803      	cmp	r0, #3
   20acc:	f200 808a 	bhi.w	20be4 <clock_stop+0x148>
   20ad0:	e8df f000 	tbb	[pc, r0]
   20ad4:	94736529 	.word	0x94736529
    p_reg->INTENCLR = mask;
   20ad8:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20ada:	2100      	movs	r1, #0
    p_reg->INTENCLR = mask;
   20adc:	4b4d      	ldr	r3, [pc, #308]	; (20c14 <clock_stop+0x178>)
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   20ade:	f10d 0407 	add.w	r4, sp, #7
   20ae2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20ae6:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
   20aea:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20aee:	605a      	str	r2, [r3, #4]
   20af0:	e7e8      	b.n	20ac4 <clock_stop+0x28>
    p_reg->INTENCLR = mask;
   20af2:	f44f 7200 	mov.w	r2, #512	; 0x200
   20af6:	4b47      	ldr	r3, [pc, #284]	; (20c14 <clock_stop+0x178>)
   20af8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20afc:	2200      	movs	r2, #0
   20afe:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   20b02:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20b06:	2201      	movs	r2, #1
   20b08:	625a      	str	r2, [r3, #36]	; 0x24
   20b0a:	e7da      	b.n	20ac2 <clock_stop+0x26>
    p_reg->INTENCLR = mask;
   20b0c:	f44f 7280 	mov.w	r2, #256	; 0x100
   20b10:	4b40      	ldr	r3, [pc, #256]	; (20c14 <clock_stop+0x178>)
   20b12:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20b16:	2200      	movs	r2, #0
   20b18:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   20b1c:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20b20:	2201      	movs	r2, #1
   20b22:	61da      	str	r2, [r3, #28]
   20b24:	e7cd      	b.n	20ac2 <clock_stop+0x26>
    switch (domain)
   20b26:	f242 7510 	movw	r5, #10000	; 0x2710
   20b2a:	4e3a      	ldr	r6, [pc, #232]	; (20c14 <clock_stop+0x178>)
            if (p_clk_src != NULL)
   20b2c:	b36c      	cbz	r4, 20b8a <clock_stop+0xee>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20b2e:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   20b32:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
   20b36:	7023      	strb	r3, [r4, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20b38:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   20b3c:	03d9      	lsls	r1, r3, #15
   20b3e:	d551      	bpl.n	20be4 <clock_stop+0x148>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   20b40:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20b44:	2801      	cmp	r0, #1
   20b46:	d14d      	bne.n	20be4 <clock_stop+0x148>
   20b48:	f004 fe67 	bl	2581a <nrfx_busy_wait>
   20b4c:	3d01      	subs	r5, #1
   20b4e:	d1ed      	bne.n	20b2c <clock_stop+0x90>
   20b50:	e048      	b.n	20be4 <clock_stop+0x148>
   20b52:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20b56:	2801      	cmp	r0, #1
   20b58:	d144      	bne.n	20be4 <clock_stop+0x148>
   20b5a:	f004 fe5e 	bl	2581a <nrfx_busy_wait>
   20b5e:	3d01      	subs	r5, #1
   20b60:	d14f      	bne.n	20c02 <clock_stop+0x166>
   20b62:	e03f      	b.n	20be4 <clock_stop+0x148>
   20b64:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20b68:	2801      	cmp	r0, #1
   20b6a:	d13b      	bne.n	20be4 <clock_stop+0x148>
   20b6c:	f004 fe55 	bl	2581a <nrfx_busy_wait>
   20b70:	3d01      	subs	r5, #1
   20b72:	d037      	beq.n	20be4 <clock_stop+0x148>
            if (p_clk_src != NULL)
   20b74:	b1bc      	cbz	r4, 20ba6 <clock_stop+0x10a>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   20b76:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   20b7a:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
   20b7e:	7023      	strb	r3, [r4, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   20b80:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   20b84:	03db      	lsls	r3, r3, #15
   20b86:	d52d      	bpl.n	20be4 <clock_stop+0x148>
   20b88:	e7ec      	b.n	20b64 <clock_stop+0xc8>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20b8a:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   20b8e:	03da      	lsls	r2, r3, #15
   20b90:	d528      	bpl.n	20be4 <clock_stop+0x148>
   20b92:	2001      	movs	r0, #1
   20b94:	f004 fe41 	bl	2581a <nrfx_busy_wait>
   20b98:	3d01      	subs	r5, #1
   20b9a:	d1f6      	bne.n	20b8a <clock_stop+0xee>
   20b9c:	e022      	b.n	20be4 <clock_stop+0x148>
    switch (domain)
   20b9e:	f242 7510 	movw	r5, #10000	; 0x2710
   20ba2:	4e1c      	ldr	r6, [pc, #112]	; (20c14 <clock_stop+0x178>)
   20ba4:	e7e6      	b.n	20b74 <clock_stop+0xd8>
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   20ba6:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   20baa:	03d8      	lsls	r0, r3, #15
   20bac:	d51a      	bpl.n	20be4 <clock_stop+0x148>
   20bae:	2001      	movs	r0, #1
   20bb0:	f004 fe33 	bl	2581a <nrfx_busy_wait>
   20bb4:	3d01      	subs	r5, #1
   20bb6:	d1f6      	bne.n	20ba6 <clock_stop+0x10a>
   20bb8:	e014      	b.n	20be4 <clock_stop+0x148>
    switch (domain)
   20bba:	f242 7510 	movw	r5, #10000	; 0x2710
   20bbe:	4e15      	ldr	r6, [pc, #84]	; (20c14 <clock_stop+0x178>)
            if (p_clk_src != NULL)
   20bc0:	b194      	cbz	r4, 20be8 <clock_stop+0x14c>
                    (nrf_clock_hfclk_t)((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_SRC_Msk)
   20bc2:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
   20bc6:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
   20bca:	7023      	strb	r3, [r4, #0]
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
   20bcc:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
   20bd0:	03d9      	lsls	r1, r3, #15
   20bd2:	d507      	bpl.n	20be4 <clock_stop+0x148>
   20bd4:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20bd8:	2801      	cmp	r0, #1
   20bda:	d103      	bne.n	20be4 <clock_stop+0x148>
   20bdc:	f004 fe1d 	bl	2581a <nrfx_busy_wait>
   20be0:	3d01      	subs	r5, #1
   20be2:	d1ed      	bne.n	20bc0 <clock_stop+0x124>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   20be4:	b002      	add	sp, #8
   20be6:	bd70      	pop	{r4, r5, r6, pc}
   20be8:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
   20bec:	03da      	lsls	r2, r3, #15
   20bee:	d5f9      	bpl.n	20be4 <clock_stop+0x148>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   20bf0:	2001      	movs	r0, #1
   20bf2:	f004 fe12 	bl	2581a <nrfx_busy_wait>
   20bf6:	3d01      	subs	r5, #1
   20bf8:	d1f6      	bne.n	20be8 <clock_stop+0x14c>
   20bfa:	e7f3      	b.n	20be4 <clock_stop+0x148>
    switch (domain)
   20bfc:	f242 7510 	movw	r5, #10000	; 0x2710
            return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
   20c00:	4e04      	ldr	r6, [pc, #16]	; (20c14 <clock_stop+0x178>)
   20c02:	f8d6 3454 	ldr.w	r3, [r6, #1108]	; 0x454
   20c06:	03db      	lsls	r3, r3, #15
   20c08:	d5ec      	bpl.n	20be4 <clock_stop+0x148>
   20c0a:	2c00      	cmp	r4, #0
   20c0c:	d1a1      	bne.n	20b52 <clock_stop+0xb6>
   20c0e:	2001      	movs	r0, #1
   20c10:	e7a3      	b.n	20b5a <clock_stop+0xbe>
   20c12:	bf00      	nop
   20c14:	40005000 	.word	0x40005000

00020c18 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   20c18:	4b04      	ldr	r3, [pc, #16]	; (20c2c <nrfx_clock_init+0x14>)
   20c1a:	791a      	ldrb	r2, [r3, #4]
   20c1c:	b922      	cbnz	r2, 20c28 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   20c1e:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   20c20:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   20c22:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   20c24:	4802      	ldr	r0, [pc, #8]	; (20c30 <nrfx_clock_init+0x18>)
   20c26:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   20c28:	4802      	ldr	r0, [pc, #8]	; (20c34 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   20c2a:	4770      	bx	lr
   20c2c:	2000b2f4 	.word	0x2000b2f4
   20c30:	0bad0000 	.word	0x0bad0000
   20c34:	0bad000c 	.word	0x0bad000c

00020c38 <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
   20c38:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   20c3a:	2005      	movs	r0, #5
   20c3c:	f7fd fb72 	bl	1e324 <arch_irq_is_enabled>
   20c40:	b910      	cbnz	r0, 20c48 <nrfx_clock_enable+0x10>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   20c42:	2005      	movs	r0, #5
   20c44:	f7fd fb4c 	bl	1e2e0 <arch_irq_enable>
    p_reg->LFCLKSRC = (uint32_t)(source);
   20c48:	2301      	movs	r3, #1
   20c4a:	4a05      	ldr	r2, [pc, #20]	; (20c60 <nrfx_clock_enable+0x28>)
   20c4c:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    p_reg->HFCLKSRC = (uint32_t)(source);
   20c50:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
                                   >> CLOCK_HFCLK192MCTRL_HCLK192M_Pos);
}

NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLK192MSRC = (uint32_t)(source);
   20c54:	f8c2 3580 	str.w	r3, [r2, #1408]	; 0x580
#endif
#if NRF_CLOCK_HAS_HFCLK192M
    nrf_clock_hfclk192m_src_set(NRF_CLOCK, (nrf_clock_hfclk_t)NRFX_CLOCK_CONFIG_HFCLK192M_SRC);
#endif
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
   20c58:	4a02      	ldr	r2, [pc, #8]	; (20c64 <nrfx_clock_enable+0x2c>)
   20c5a:	7013      	strb	r3, [r2, #0]
#endif

    NRFX_LOG_INFO("Module enabled.");
}
   20c5c:	bd08      	pop	{r3, pc}
   20c5e:	bf00      	nop
   20c60:	40005000 	.word	0x40005000
   20c64:	2000b631 	.word	0x2000b631

00020c68 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
   20c68:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   20c6a:	2803      	cmp	r0, #3
   20c6c:	d818      	bhi.n	20ca0 <nrfx_clock_start+0x38>
   20c6e:	e8df f000 	tbb	[pc, r0]
   20c72:	3002      	.short	0x3002
   20c74:	483b      	.short	0x483b
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20c76:	4a29      	ldr	r2, [pc, #164]	; (20d1c <nrfx_clock_start+0xb4>)
   20c78:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20c7c:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   20c80:	03c9      	lsls	r1, r1, #15
   20c82:	d40e      	bmi.n	20ca2 <nrfx_clock_start+0x3a>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
   20c84:	f8d2 3414 	ldr.w	r3, [r2, #1044]	; 0x414
                    // LF clock is already running. Inspect its source.
                    // If LF clock source is inappropriate then it will be stopped and modified.
                    // Ignore return value as LF clock will be started again regardless of the result.
                    (void)clock_lfclksrc_tweak(&lfclksrc);
                }
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
   20c88:	07db      	lsls	r3, r3, #31
   20c8a:	d513      	bpl.n	20cb4 <nrfx_clock_start+0x4c>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   20c8c:	f8d2 341c 	ldr.w	r3, [r2, #1052]	; 0x41c
   20c90:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   20c94:	3b01      	subs	r3, #1
   20c96:	2b01      	cmp	r3, #1
   20c98:	d809      	bhi.n	20cae <nrfx_clock_start+0x46>
    p_reg->INTENSET = mask;
   20c9a:	2302      	movs	r3, #2
   20c9c:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   20ca0:	bd08      	pop	{r3, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20ca2:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   20ca6:	2b02      	cmp	r3, #2
   20ca8:	d005      	beq.n	20cb6 <nrfx_clock_start+0x4e>
   20caa:	2b01      	cmp	r3, #1
   20cac:	d002      	beq.n	20cb4 <nrfx_clock_start+0x4c>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   20cae:	2000      	movs	r0, #0
   20cb0:	f7ff fef4 	bl	20a9c <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
   20cb4:	2301      	movs	r3, #1
    p_reg->LFCLKSRC = (uint32_t)(source);
   20cb6:	4a19      	ldr	r2, [pc, #100]	; (20d1c <nrfx_clock_start+0xb4>)
   20cb8:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20cbc:	2300      	movs	r3, #0
   20cbe:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
   20cc2:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    p_reg->INTENSET = mask;
   20cc6:	2302      	movs	r3, #2
   20cc8:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20ccc:	2301      	movs	r3, #1
   20cce:	6093      	str	r3, [r2, #8]
}
   20cd0:	e7e6      	b.n	20ca0 <nrfx_clock_start+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20cd2:	2200      	movs	r2, #0
   20cd4:	4b11      	ldr	r3, [pc, #68]	; (20d1c <nrfx_clock_start+0xb4>)
   20cd6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   20cda:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   20cde:	2201      	movs	r2, #1
   20ce0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20ce4:	601a      	str	r2, [r3, #0]
}
   20ce6:	e7db      	b.n	20ca0 <nrfx_clock_start+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20ce8:	2200      	movs	r2, #0
   20cea:	4b0c      	ldr	r3, [pc, #48]	; (20d1c <nrfx_clock_start+0xb4>)
   20cec:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   20cf0:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENSET = mask;
   20cf4:	f44f 7200 	mov.w	r2, #512	; 0x200
   20cf8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20cfc:	2201      	movs	r2, #1
   20cfe:	621a      	str	r2, [r3, #32]
}
   20d00:	e7ce      	b.n	20ca0 <nrfx_clock_start+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d02:	2200      	movs	r2, #0
   20d04:	4b05      	ldr	r3, [pc, #20]	; (20d1c <nrfx_clock_start+0xb4>)
   20d06:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   20d0a:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENSET = mask;
   20d0e:	f44f 7280 	mov.w	r2, #256	; 0x100
   20d12:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20d16:	2201      	movs	r2, #1
   20d18:	619a      	str	r2, [r3, #24]
}
   20d1a:	e7c1      	b.n	20ca0 <nrfx_clock_start+0x38>
   20d1c:	40005000 	.word	0x40005000

00020d20 <nrfx_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   20d20:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d22:	4b28      	ldr	r3, [pc, #160]	; (20dc4 <nrfx_clock_irq_handler+0xa4>)
   20d24:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   20d28:	b152      	cbz	r2, 20d40 <nrfx_clock_irq_handler+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d2a:	2000      	movs	r0, #0
   20d2c:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
   20d30:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
   20d34:	2201      	movs	r2, #1
   20d36:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   20d3a:	4b23      	ldr	r3, [pc, #140]	; (20dc8 <nrfx_clock_irq_handler+0xa8>)
   20d3c:	681b      	ldr	r3, [r3, #0]
   20d3e:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d40:	4b20      	ldr	r3, [pc, #128]	; (20dc4 <nrfx_clock_irq_handler+0xa4>)
   20d42:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   20d46:	b18a      	cbz	r2, 20d6c <nrfx_clock_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d48:	2200      	movs	r2, #0
   20d4a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   20d4e:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20d52:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20d56:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   20d5a:	f002 0203 	and.w	r2, r2, #3
   20d5e:	2a01      	cmp	r2, #1
   20d60:	f04f 0102 	mov.w	r1, #2
   20d64:	d126      	bne.n	20db4 <nrfx_clock_irq_handler+0x94>
    p_reg->LFCLKSRC = (uint32_t)(source);
   20d66:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20d6a:	609a      	str	r2, [r3, #8]
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d6c:	4b15      	ldr	r3, [pc, #84]	; (20dc4 <nrfx_clock_irq_handler+0xa4>)
   20d6e:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_CAL_DONE);
    }
#endif // NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)

#if NRF_CLOCK_HAS_HFCLKAUDIO
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED))
   20d72:	b162      	cbz	r2, 20d8e <nrfx_clock_irq_handler+0x6e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d74:	2200      	movs	r2, #0
   20d76:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   20d7a:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENCLR = mask;
   20d7e:	f44f 7280 	mov.w	r2, #256	; 0x100
   20d82:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLKAUDIO_STARTED);
   20d86:	4b10      	ldr	r3, [pc, #64]	; (20dc8 <nrfx_clock_irq_handler+0xa8>)
   20d88:	2004      	movs	r0, #4
   20d8a:	681b      	ldr	r3, [r3, #0]
   20d8c:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d8e:	4b0d      	ldr	r3, [pc, #52]	; (20dc4 <nrfx_clock_irq_handler+0xa4>)
   20d90:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    }
#endif

#if NRF_CLOCK_HAS_HFCLK192M
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED))
   20d94:	b1aa      	cbz	r2, 20dc2 <nrfx_clock_irq_handler+0xa2>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d96:	2200      	movs	r2, #0
   20d98:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   20d9c:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENCLR = mask;
   20da0:	f44f 7200 	mov.w	r2, #512	; 0x200
   20da4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLK192MSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
   20da8:	4b07      	ldr	r3, [pc, #28]	; (20dc8 <nrfx_clock_irq_handler+0xa8>)
   20daa:	2005      	movs	r0, #5
    }
#endif
}
   20dac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
   20db0:	681b      	ldr	r3, [r3, #0]
   20db2:	4718      	bx	r3
   20db4:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   20db8:	4b03      	ldr	r3, [pc, #12]	; (20dc8 <nrfx_clock_irq_handler+0xa8>)
   20dba:	2001      	movs	r0, #1
   20dbc:	681b      	ldr	r3, [r3, #0]
   20dbe:	4798      	blx	r3
   20dc0:	e7d4      	b.n	20d6c <nrfx_clock_irq_handler+0x4c>
}
   20dc2:	bd10      	pop	{r4, pc}
   20dc4:	40005000 	.word	0x40005000
   20dc8:	2000b2f4 	.word	0x2000b2f4

00020dcc <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
   20dcc:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
   20dce:	f003 021f 	and.w	r2, r3, #31
   20dd2:	6002      	str	r2, [r0, #0]
}
   20dd4:	4a03      	ldr	r2, [pc, #12]	; (20de4 <nrf_gpio_pin_port_decode+0x18>)
   20dd6:	4804      	ldr	r0, [pc, #16]	; (20de8 <nrf_gpio_pin_port_decode+0x1c>)
    return pin_number >> 5;
   20dd8:	095b      	lsrs	r3, r3, #5
}
   20dda:	2b01      	cmp	r3, #1
   20ddc:	bf18      	it	ne
   20dde:	4610      	movne	r0, r2
   20de0:	4770      	bx	lr
   20de2:	bf00      	nop
   20de4:	40842500 	.word	0x40842500
   20de8:	40842800 	.word	0x40842800

00020dec <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   20dec:	4b03      	ldr	r3, [pc, #12]	; (20dfc <pin_in_use_by_te+0x10>)
   20dee:	3008      	adds	r0, #8
   20df0:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   20df4:	f3c0 1040 	ubfx	r0, r0, #5, #1
   20df8:	4770      	bx	lr
   20dfa:	bf00      	nop
   20dfc:	2000a208 	.word	0x2000a208

00020e00 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   20e00:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e02:	4c0d      	ldr	r4, [pc, #52]	; (20e38 <call_handler+0x38>)
   20e04:	f100 0308 	add.w	r3, r0, #8
   20e08:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
   20e0c:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e0e:	05da      	lsls	r2, r3, #23
{
   20e10:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e12:	d507      	bpl.n	20e24 <call_handler+0x24>
   20e14:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   20e18:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   20e1c:	6852      	ldr	r2, [r2, #4]
   20e1e:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   20e22:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   20e24:	68a3      	ldr	r3, [r4, #8]
   20e26:	b12b      	cbz	r3, 20e34 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   20e28:	4631      	mov	r1, r6
   20e2a:	4628      	mov	r0, r5
   20e2c:	68e2      	ldr	r2, [r4, #12]
    }
}
   20e2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   20e32:	4718      	bx	r3
}
   20e34:	bd70      	pop	{r4, r5, r6, pc}
   20e36:	bf00      	nop
   20e38:	2000a208 	.word	0x2000a208

00020e3c <release_handler>:
{
   20e3c:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e3e:	4a12      	ldr	r2, [pc, #72]	; (20e88 <release_handler+0x4c>)
   20e40:	3008      	adds	r0, #8
   20e42:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
   20e46:	05d9      	lsls	r1, r3, #23
   20e48:	d51b      	bpl.n	20e82 <release_handler+0x46>
   20e4a:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   20e4e:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   20e52:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   20e56:	2000      	movs	r0, #0
   20e58:	f102 040e 	add.w	r4, r2, #14
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   20e5c:	f834 3f02 	ldrh.w	r3, [r4, #2]!
   20e60:	f413 7f80 	tst.w	r3, #256	; 0x100
   20e64:	d003      	beq.n	20e6e <release_handler+0x32>
   20e66:	f3c3 2343 	ubfx	r3, r3, #9, #4
   20e6a:	4299      	cmp	r1, r3
   20e6c:	d009      	beq.n	20e82 <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   20e6e:	3001      	adds	r0, #1
   20e70:	2830      	cmp	r0, #48	; 0x30
   20e72:	d1f3      	bne.n	20e5c <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   20e74:	2300      	movs	r3, #0
   20e76:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   20e7a:	4804      	ldr	r0, [pc, #16]	; (20e8c <release_handler+0x50>)
}
   20e7c:	bc10      	pop	{r4}
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   20e7e:	f7ff bdf1 	b.w	20a64 <nrfx_flag32_free>
}
   20e82:	bc10      	pop	{r4}
   20e84:	4770      	bx	lr
   20e86:	bf00      	nop
   20e88:	2000a208 	.word	0x2000a208
   20e8c:	2000a27c 	.word	0x2000a27c

00020e90 <pin_handler_trigger_uninit>:
{
   20e90:	b538      	push	{r3, r4, r5, lr}
   20e92:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   20e94:	f7ff ffaa 	bl	20dec <pin_in_use_by_te>
   20e98:	4c0b      	ldr	r4, [pc, #44]	; (20ec8 <pin_handler_trigger_uninit+0x38>)
   20e9a:	f102 0508 	add.w	r5, r2, #8
   20e9e:	b160      	cbz	r0, 20eba <pin_handler_trigger_uninit+0x2a>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   20ea0:	2100      	movs	r1, #0
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   20ea2:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   20ea6:	0b5b      	lsrs	r3, r3, #13
   20ea8:	009b      	lsls	r3, r3, #2
   20eaa:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   20eae:	f503 333c 	add.w	r3, r3, #192512	; 0x2f000
   20eb2:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
#if defined(NRF53_SERIES) || defined(NRF91_SERIES)
    p_reg->CONFIG[idx] = 0;
   20eb6:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
    release_handler(pin);
   20eba:	4610      	mov	r0, r2
   20ebc:	f7ff ffbe 	bl	20e3c <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   20ec0:	2300      	movs	r3, #0
   20ec2:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   20ec6:	bd38      	pop	{r3, r4, r5, pc}
   20ec8:	2000a208 	.word	0x2000a208

00020ecc <nrfx_gpiote_input_configure>:
{
   20ecc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   20ed0:	4604      	mov	r4, r0
   20ed2:	4690      	mov	r8, r2
   20ed4:	461d      	mov	r5, r3
    if (p_input_config)
   20ed6:	b301      	cbz	r1, 20f1a <nrfx_gpiote_input_configure+0x4e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   20ed8:	4e4f      	ldr	r6, [pc, #316]	; (21018 <nrfx_gpiote_input_configure+0x14c>)
   20eda:	f100 0708 	add.w	r7, r0, #8
    return pin_is_output(pin) && pin_in_use_by_te(pin);
   20ede:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   20ee2:	079b      	lsls	r3, r3, #30
   20ee4:	d502      	bpl.n	20eec <nrfx_gpiote_input_configure+0x20>
   20ee6:	f7ff ff81 	bl	20dec <pin_in_use_by_te>
   20eea:	bb28      	cbnz	r0, 20f38 <nrfx_gpiote_input_configure+0x6c>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
   20eec:	2300      	movs	r3, #0
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
   20eee:	4620      	mov	r0, r4
   20ef0:	e9cd 3300 	strd	r3, r3, [sp]
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
   20ef4:	f88d 300e 	strb.w	r3, [sp, #14]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
   20ef8:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
   20efc:	f10d 020f 	add.w	r2, sp, #15
   20f00:	460b      	mov	r3, r1
   20f02:	f10d 010e 	add.w	r1, sp, #14
   20f06:	f004 fc8c 	bl	25822 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   20f0a:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   20f0e:	f023 0302 	bic.w	r3, r3, #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   20f12:	f043 0301 	orr.w	r3, r3, #1
   20f16:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_trigger_config)
   20f1a:	f1b8 0f00 	cmp.w	r8, #0
   20f1e:	d02d      	beq.n	20f7c <nrfx_gpiote_input_configure+0xb0>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   20f20:	4e3d      	ldr	r6, [pc, #244]	; (21018 <nrfx_gpiote_input_configure+0x14c>)
   20f22:	f104 0708 	add.w	r7, r4, #8
   20f26:	f836 1017 	ldrh.w	r1, [r6, r7, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   20f2a:	f898 0000 	ldrb.w	r0, [r8]
        if (pin_is_output(pin))
   20f2e:	078a      	lsls	r2, r1, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   20f30:	f8d8 3004 	ldr.w	r3, [r8, #4]
        if (pin_is_output(pin))
   20f34:	d502      	bpl.n	20f3c <nrfx_gpiote_input_configure+0x70>
            if (use_evt)
   20f36:	b1cb      	cbz	r3, 20f6c <nrfx_gpiote_input_configure+0xa0>
            return NRFX_ERROR_INVALID_PARAM;
   20f38:	4838      	ldr	r0, [pc, #224]	; (2101c <nrfx_gpiote_input_configure+0x150>)
   20f3a:	e021      	b.n	20f80 <nrfx_gpiote_input_configure+0xb4>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   20f3c:	f021 0120 	bic.w	r1, r1, #32
   20f40:	04c9      	lsls	r1, r1, #19
   20f42:	0cc9      	lsrs	r1, r1, #19
   20f44:	f826 1017 	strh.w	r1, [r6, r7, lsl #1]
            if (use_evt)
   20f48:	b183      	cbz	r3, 20f6c <nrfx_gpiote_input_configure+0xa0>
                if (!edge)
   20f4a:	2803      	cmp	r0, #3
   20f4c:	d8f4      	bhi.n	20f38 <nrfx_gpiote_input_configure+0x6c>
                uint8_t ch = *p_trigger_config->p_in_channel;
   20f4e:	f8d8 3004 	ldr.w	r3, [r8, #4]
   20f52:	f893 c000 	ldrb.w	ip, [r3]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   20f56:	4662      	mov	r2, ip
   20f58:	0092      	lsls	r2, r2, #2
   20f5a:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   20f5e:	f502 323c 	add.w	r2, r2, #192512	; 0x2f000
   20f62:	b980      	cbnz	r0, 20f86 <nrfx_gpiote_input_configure+0xba>
    p_reg->CONFIG[idx] = 0;
   20f64:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
   20f68:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   20f6c:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   20f70:	f023 031c 	bic.w	r3, r3, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   20f74:	ea43 0380 	orr.w	r3, r3, r0, lsl #2
   20f78:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_handler_config)
   20f7c:	bb1d      	cbnz	r5, 20fc6 <nrfx_gpiote_input_configure+0xfa>
        err = NRFX_SUCCESS;
   20f7e:	4828      	ldr	r0, [pc, #160]	; (21020 <nrfx_gpiote_input_configure+0x154>)
}
   20f80:	b004      	add	sp, #16
   20f82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   20f86:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   20f8a:	ea41 314c 	orr.w	r1, r1, ip, lsl #13
   20f8e:	f023 0303 	bic.w	r3, r3, #3
   20f92:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   20f96:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
   20f9a:	f041 0120 	orr.w	r1, r1, #32
   20f9e:	f423 334f 	bic.w	r3, r3, #211968	; 0x33c00
   20fa2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   20fa6:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   20faa:	0223      	lsls	r3, r4, #8
   20fac:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
   20fb0:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
   20fb4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   20fb8:	ea43 030e 	orr.w	r3, r3, lr
   20fbc:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
   20fc0:	f826 1017 	strh.w	r1, [r6, r7, lsl #1]
   20fc4:	e7d2      	b.n	20f6c <nrfx_gpiote_input_configure+0xa0>
    release_handler(pin);
   20fc6:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   20fc8:	e9d5 6700 	ldrd	r6, r7, [r5]
    release_handler(pin);
   20fcc:	f7ff ff36 	bl	20e3c <release_handler>
    if (!handler)
   20fd0:	2e00      	cmp	r6, #0
   20fd2:	d0d4      	beq.n	20f7e <nrfx_gpiote_input_configure+0xb2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   20fd4:	4d10      	ldr	r5, [pc, #64]	; (21018 <nrfx_gpiote_input_configure+0x14c>)
   20fd6:	e9d5 2300 	ldrd	r2, r3, [r5]
   20fda:	4296      	cmp	r6, r2
   20fdc:	d101      	bne.n	20fe2 <nrfx_gpiote_input_configure+0x116>
   20fde:	429f      	cmp	r7, r3
   20fe0:	d018      	beq.n	21014 <nrfx_gpiote_input_configure+0x148>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   20fe2:	4810      	ldr	r0, [pc, #64]	; (21024 <nrfx_gpiote_input_configure+0x158>)
   20fe4:	f10d 010f 	add.w	r1, sp, #15
   20fe8:	f7ff fd20 	bl	20a2c <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   20fec:	4b0c      	ldr	r3, [pc, #48]	; (21020 <nrfx_gpiote_input_configure+0x154>)
   20fee:	4298      	cmp	r0, r3
   20ff0:	d1c6      	bne.n	20f80 <nrfx_gpiote_input_configure+0xb4>
        handler_id = (int32_t)id;
   20ff2:	f89d 200f 	ldrb.w	r2, [sp, #15]
    m_cb.handlers[handler_id].p_context = p_context;
   20ff6:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   20ffa:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   20ffc:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   20ffe:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
   21002:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   21006:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   2100a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   2100e:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
    return NRFX_SUCCESS;
   21012:	e7b4      	b.n	20f7e <nrfx_gpiote_input_configure+0xb2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   21014:	2200      	movs	r2, #0
   21016:	e7ee      	b.n	20ff6 <nrfx_gpiote_input_configure+0x12a>
   21018:	2000a208 	.word	0x2000a208
   2101c:	0bad0004 	.word	0x0bad0004
   21020:	0bad0000 	.word	0x0bad0000
   21024:	2000a27c 	.word	0x2000a27c

00021028 <nrfx_gpiote_output_configure>:
{
   21028:	b5f0      	push	{r4, r5, r6, r7, lr}
   2102a:	4604      	mov	r4, r0
   2102c:	4615      	mov	r5, r2
   2102e:	b085      	sub	sp, #20
    if (p_config)
   21030:	b319      	cbz	r1, 2107a <nrfx_gpiote_output_configure+0x52>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   21032:	4e34      	ldr	r6, [pc, #208]	; (21104 <nrfx_gpiote_output_configure+0xdc>)
   21034:	f100 0708 	add.w	r7, r0, #8
   21038:	f836 2017 	ldrh.w	r2, [r6, r7, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   2103c:	0793      	lsls	r3, r2, #30
   2103e:	d403      	bmi.n	21048 <nrfx_gpiote_output_configure+0x20>
   21040:	f7ff fed4 	bl	20dec <pin_in_use_by_te>
   21044:	2800      	cmp	r0, #0
   21046:	d15a      	bne.n	210fe <nrfx_gpiote_output_configure+0xd6>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   21048:	f012 0f1c 	tst.w	r2, #28
   2104c:	d002      	beq.n	21054 <nrfx_gpiote_output_configure+0x2c>
   2104e:	784b      	ldrb	r3, [r1, #1]
   21050:	2b01      	cmp	r3, #1
   21052:	d054      	beq.n	210fe <nrfx_gpiote_output_configure+0xd6>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
   21054:	2301      	movs	r3, #1
   21056:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
   2105a:	2300      	movs	r3, #0
   2105c:	1c4a      	adds	r2, r1, #1
   2105e:	e9cd 1300 	strd	r1, r3, [sp]
   21062:	4620      	mov	r0, r4
   21064:	1c8b      	adds	r3, r1, #2
   21066:	f10d 010f 	add.w	r1, sp, #15
   2106a:	f004 fbda 	bl	25822 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   2106e:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   21072:	f043 0303 	orr.w	r3, r3, #3
   21076:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_task_config)
   2107a:	b915      	cbnz	r5, 21082 <nrfx_gpiote_output_configure+0x5a>
    return NRFX_SUCCESS;
   2107c:	4822      	ldr	r0, [pc, #136]	; (21108 <nrfx_gpiote_output_configure+0xe0>)
}
   2107e:	b005      	add	sp, #20
   21080:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   21082:	4e20      	ldr	r6, [pc, #128]	; (21104 <nrfx_gpiote_output_configure+0xdc>)
   21084:	f104 0708 	add.w	r7, r4, #8
   21088:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
        if (pin_is_input(pin))
   2108c:	0783      	lsls	r3, r0, #30
   2108e:	d536      	bpl.n	210fe <nrfx_gpiote_output_configure+0xd6>
        uint32_t ch = p_task_config->task_ch;
   21090:	f895 c000 	ldrb.w	ip, [r5]
    p_reg->CONFIG[idx] = 0;
   21094:	2300      	movs	r3, #0
   21096:	4661      	mov	r1, ip
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   21098:	f020 0020 	bic.w	r0, r0, #32
   2109c:	0089      	lsls	r1, r1, #2
   2109e:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   210a2:	04c0      	lsls	r0, r0, #19
   210a4:	f501 313c 	add.w	r1, r1, #192512	; 0x2f000
   210a8:	0cc0      	lsrs	r0, r0, #19
   210aa:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   210ae:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
    p_reg->CONFIG[idx] = 0;
   210b2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   210b6:	786a      	ldrb	r2, [r5, #1]
   210b8:	2a00      	cmp	r2, #0
   210ba:	d0df      	beq.n	2107c <nrfx_gpiote_output_configure+0x54>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   210bc:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
                                      p_task_config->init_val);
   210c0:	78ad      	ldrb	r5, [r5, #2]
   210c2:	f423 1399 	bic.w	r3, r3, #1253376	; 0x132000
   210c6:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   210ca:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   210ce:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   210d2:	0223      	lsls	r3, r4, #8
   210d4:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   210d8:	0412      	lsls	r2, r2, #16
   210da:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   210de:	ea43 030e 	orr.w	r3, r3, lr
   210e2:	4313      	orrs	r3, r2
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   210e4:	052a      	lsls	r2, r5, #20
   210e6:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   210ea:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   210ee:	4313      	orrs	r3, r2
   210f0:	f040 0020 	orr.w	r0, r0, #32
   210f4:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   210f8:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
   210fc:	e7be      	b.n	2107c <nrfx_gpiote_output_configure+0x54>
{
   210fe:	4803      	ldr	r0, [pc, #12]	; (2110c <nrfx_gpiote_output_configure+0xe4>)
   21100:	e7bd      	b.n	2107e <nrfx_gpiote_output_configure+0x56>
   21102:	bf00      	nop
   21104:	2000a208 	.word	0x2000a208
   21108:	0bad0000 	.word	0x0bad0000
   2110c:	0bad0004 	.word	0x0bad0004

00021110 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   21110:	4b01      	ldr	r3, [pc, #4]	; (21118 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   21112:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   21116:	4770      	bx	lr
   21118:	2000a208 	.word	0x2000a208

0002111c <nrfx_gpiote_channel_get>:
{
   2111c:	b508      	push	{r3, lr}
   2111e:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   21120:	f7ff fe64 	bl	20dec <pin_in_use_by_te>
   21124:	b138      	cbz	r0, 21136 <nrfx_gpiote_channel_get+0x1a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   21126:	4b05      	ldr	r3, [pc, #20]	; (2113c <nrfx_gpiote_channel_get+0x20>)
   21128:	3208      	adds	r2, #8
   2112a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
        return NRFX_SUCCESS;
   2112e:	4804      	ldr	r0, [pc, #16]	; (21140 <nrfx_gpiote_channel_get+0x24>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   21130:	0b5b      	lsrs	r3, r3, #13
   21132:	700b      	strb	r3, [r1, #0]
}
   21134:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
   21136:	4803      	ldr	r0, [pc, #12]	; (21144 <nrfx_gpiote_channel_get+0x28>)
   21138:	e7fc      	b.n	21134 <nrfx_gpiote_channel_get+0x18>
   2113a:	bf00      	nop
   2113c:	2000a208 	.word	0x2000a208
   21140:	0bad0000 	.word	0x0bad0000
   21144:	0bad0004 	.word	0x0bad0004

00021148 <nrfx_gpiote_init>:
{
   21148:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   2114a:	4c0f      	ldr	r4, [pc, #60]	; (21188 <nrfx_gpiote_init+0x40>)
   2114c:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
   21150:	b9bd      	cbnz	r5, 21182 <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   21152:	2260      	movs	r2, #96	; 0x60
   21154:	4629      	mov	r1, r5
   21156:	f104 0010 	add.w	r0, r4, #16
   2115a:	f003 ff4d 	bl	24ff8 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   2115e:	202f      	movs	r0, #47	; 0x2f
   21160:	f7fd f8be 	bl	1e2e0 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   21164:	4b09      	ldr	r3, [pc, #36]	; (2118c <nrfx_gpiote_init+0x44>)
    return err_code;
   21166:	480a      	ldr	r0, [pc, #40]	; (21190 <nrfx_gpiote_init+0x48>)
   21168:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
   2116c:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
   21170:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   21174:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   21178:	2301      	movs	r3, #1
   2117a:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   2117e:	6763      	str	r3, [r4, #116]	; 0x74
}
   21180:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   21182:	4804      	ldr	r0, [pc, #16]	; (21194 <nrfx_gpiote_init+0x4c>)
   21184:	e7fc      	b.n	21180 <nrfx_gpiote_init+0x38>
   21186:	bf00      	nop
   21188:	2000a208 	.word	0x2000a208
   2118c:	4002f000 	.word	0x4002f000
   21190:	0bad0000 	.word	0x0bad0000
   21194:	0bad0005 	.word	0x0bad0005

00021198 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   21198:	4b03      	ldr	r3, [pc, #12]	; (211a8 <nrfx_gpiote_is_init+0x10>)
   2119a:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
   2119e:	3800      	subs	r0, #0
   211a0:	bf18      	it	ne
   211a2:	2001      	movne	r0, #1
   211a4:	4770      	bx	lr
   211a6:	bf00      	nop
   211a8:	2000a208 	.word	0x2000a208

000211ac <nrfx_gpiote_channel_free>:
{
   211ac:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   211ae:	4801      	ldr	r0, [pc, #4]	; (211b4 <nrfx_gpiote_channel_free+0x8>)
   211b0:	f7ff bc58 	b.w	20a64 <nrfx_flag32_free>
   211b4:	2000a278 	.word	0x2000a278

000211b8 <nrfx_gpiote_channel_alloc>:
{
   211b8:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   211ba:	4801      	ldr	r0, [pc, #4]	; (211c0 <nrfx_gpiote_channel_alloc+0x8>)
   211bc:	f7ff bc36 	b.w	20a2c <nrfx_flag32_alloc>
   211c0:	2000a278 	.word	0x2000a278

000211c4 <nrfx_gpiote_trigger_enable>:
{
   211c4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   211c6:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   211c8:	f7ff fe10 	bl	20dec <pin_in_use_by_te>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   211cc:	4b1d      	ldr	r3, [pc, #116]	; (21244 <nrfx_gpiote_trigger_enable+0x80>)
   211ce:	f104 0208 	add.w	r2, r4, #8
   211d2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   211d6:	b1d0      	cbz	r0, 2120e <nrfx_gpiote_trigger_enable+0x4a>
   211d8:	f013 0502 	ands.w	r5, r3, #2
   211dc:	d117      	bne.n	2120e <nrfx_gpiote_trigger_enable+0x4a>
    return ((uint32_t)p_reg + event);
   211de:	481a      	ldr	r0, [pc, #104]	; (21248 <nrfx_gpiote_trigger_enable+0x84>)
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   211e0:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   211e2:	009a      	lsls	r2, r3, #2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   211e4:	5085      	str	r5, [r0, r2]
   211e6:	5880      	ldr	r0, [r0, r2]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   211e8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   211ec:	f502 323c 	add.w	r2, r2, #192512	; 0x2f000
   211f0:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   211f4:	f040 0001 	orr.w	r0, r0, #1
   211f8:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   211fc:	b129      	cbz	r1, 2120a <nrfx_gpiote_trigger_enable+0x46>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   211fe:	2201      	movs	r2, #1
   21200:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   21204:	4a11      	ldr	r2, [pc, #68]	; (2124c <nrfx_gpiote_trigger_enable+0x88>)
   21206:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   2120a:	b003      	add	sp, #12
   2120c:	bd30      	pop	{r4, r5, pc}
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   2120e:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   21212:	2b04      	cmp	r3, #4
   21214:	d011      	beq.n	2123a <nrfx_gpiote_trigger_enable+0x76>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   21216:	2b05      	cmp	r3, #5
   21218:	d011      	beq.n	2123e <nrfx_gpiote_trigger_enable+0x7a>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2121a:	a801      	add	r0, sp, #4
   2121c:	9401      	str	r4, [sp, #4]
   2121e:	f7ff fdd5 	bl	20dcc <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   21222:	9b01      	ldr	r3, [sp, #4]
    return p_reg->IN;
   21224:	6901      	ldr	r1, [r0, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   21226:	40d9      	lsrs	r1, r3
   21228:	f001 0101 	and.w	r1, r1, #1
   2122c:	3102      	adds	r1, #2
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   2122e:	4620      	mov	r0, r4
}
   21230:	b003      	add	sp, #12
   21232:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   21236:	f004 bb3d 	b.w	258b4 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   2123a:	2103      	movs	r1, #3
   2123c:	e7f7      	b.n	2122e <nrfx_gpiote_trigger_enable+0x6a>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   2123e:	2102      	movs	r1, #2
   21240:	e7f5      	b.n	2122e <nrfx_gpiote_trigger_enable+0x6a>
   21242:	bf00      	nop
   21244:	2000a208 	.word	0x2000a208
   21248:	4002f100 	.word	0x4002f100
   2124c:	4002f000 	.word	0x4002f000

00021250 <nrfx_gpiote_trigger_disable>:
{
   21250:	b508      	push	{r3, lr}
   21252:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   21254:	f7ff fdca 	bl	20dec <pin_in_use_by_te>
   21258:	b1c0      	cbz	r0, 2128c <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   2125a:	4b0f      	ldr	r3, [pc, #60]	; (21298 <nrfx_gpiote_trigger_disable+0x48>)
   2125c:	f102 0108 	add.w	r1, r2, #8
   21260:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   21264:	0799      	lsls	r1, r3, #30
   21266:	d411      	bmi.n	2128c <nrfx_gpiote_trigger_disable+0x3c>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   21268:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   2126a:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   2126c:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   2126e:	490b      	ldr	r1, [pc, #44]	; (2129c <nrfx_gpiote_trigger_disable+0x4c>)
   21270:	009b      	lsls	r3, r3, #2
   21272:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   21276:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   2127a:	f503 333c 	add.w	r3, r3, #192512	; 0x2f000
   2127e:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   21282:	f022 0203 	bic.w	r2, r2, #3
   21286:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   2128a:	bd08      	pop	{r3, pc}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   2128c:	2100      	movs	r1, #0
}
   2128e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   21292:	4610      	mov	r0, r2
   21294:	f004 bb0e 	b.w	258b4 <nrf_gpio_cfg_sense_set>
   21298:	2000a208 	.word	0x2000a208
   2129c:	4002f000 	.word	0x4002f000

000212a0 <nrfx_gpiote_pin_uninit>:
{
   212a0:	b513      	push	{r0, r1, r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   212a2:	4b10      	ldr	r3, [pc, #64]	; (212e4 <nrfx_gpiote_pin_uninit+0x44>)
   212a4:	f100 0208 	add.w	r2, r0, #8
   212a8:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
   212ac:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   212ae:	07db      	lsls	r3, r3, #31
   212b0:	d516      	bpl.n	212e0 <nrfx_gpiote_pin_uninit+0x40>
    nrfx_gpiote_trigger_disable(pin);
   212b2:	f7ff ffcd 	bl	21250 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   212b6:	4620      	mov	r0, r4
   212b8:	f7ff fdea 	bl	20e90 <pin_handler_trigger_uninit>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   212bc:	a801      	add	r0, sp, #4
   212be:	9401      	str	r4, [sp, #4]
   212c0:	f7ff fd84 	bl	20dcc <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   212c4:	9b01      	ldr	r3, [sp, #4]
   212c6:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   212ca:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   212ce:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   212d2:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
   212d6:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    nrf_gpio_cfg(
   212da:	4803      	ldr	r0, [pc, #12]	; (212e8 <nrfx_gpiote_pin_uninit+0x48>)
}
   212dc:	b002      	add	sp, #8
   212de:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   212e0:	4802      	ldr	r0, [pc, #8]	; (212ec <nrfx_gpiote_pin_uninit+0x4c>)
   212e2:	e7fb      	b.n	212dc <nrfx_gpiote_pin_uninit+0x3c>
   212e4:	2000a208 	.word	0x2000a208
   212e8:	0bad0000 	.word	0x0bad0000
   212ec:	0bad0004 	.word	0x0bad0004

000212f0 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   212f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
   212f4:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   212f6:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   212f8:	4634      	mov	r4, r6
{
   212fa:	4b63      	ldr	r3, [pc, #396]	; (21488 <nrfx_gpiote_irq_handler+0x198>)
    return p_reg->INTENSET & mask;
   212fc:	4863      	ldr	r0, [pc, #396]	; (2148c <nrfx_gpiote_irq_handler+0x19c>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   212fe:	4964      	ldr	r1, [pc, #400]	; (21490 <nrfx_gpiote_irq_handler+0x1a0>)
{
   21300:	b087      	sub	sp, #28
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21302:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   21304:	b135      	cbz	r5, 21314 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   21306:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   2130a:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   2130c:	bf1e      	ittt	ne
   2130e:	601c      	strne	r4, [r3, #0]
   21310:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   21312:	4316      	orrne	r6, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   21314:	3304      	adds	r3, #4
   21316:	428b      	cmp	r3, r1
        }
        mask <<= 1;
   21318:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   2131c:	d1f1      	bne.n	21302 <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2131e:	f8df a16c 	ldr.w	sl, [pc, #364]	; 2148c <nrfx_gpiote_irq_handler+0x19c>
   21322:	f8da 317c 	ldr.w	r3, [sl, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   21326:	2b00      	cmp	r3, #0
   21328:	f000 8091 	beq.w	2144e <nrfx_gpiote_irq_handler+0x15e>
        *p_masks = gpio_regs[i]->LATCH;
   2132c:	f8df 8164 	ldr.w	r8, [pc, #356]	; 21494 <nrfx_gpiote_irq_handler+0x1a4>
   21330:	f8d8 3020 	ldr.w	r3, [r8, #32]
   21334:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
   21336:	f8c8 3020 	str.w	r3, [r8, #32]
        *p_masks = gpio_regs[i]->LATCH;
   2133a:	4b57      	ldr	r3, [pc, #348]	; (21498 <nrfx_gpiote_irq_handler+0x1a8>)
   2133c:	6a1a      	ldr	r2, [r3, #32]
   2133e:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
   21340:	621a      	str	r2, [r3, #32]
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   21342:	f04f 0900 	mov.w	r9, #0
            while (latch[i])
   21346:	f10d 0b10 	add.w	fp, sp, #16
   2134a:	ea4f 1349 	mov.w	r3, r9, lsl #5
   2134e:	9300      	str	r3, [sp, #0]
   21350:	e048      	b.n	213e4 <nrfx_gpiote_irq_handler+0xf4>
                uint32_t pin = NRF_CTZ(latch[i]);
   21352:	fa94 f4a4 	rbit	r4, r4
   21356:	fab4 f484 	clz	r4, r4
                pin += 32 * i;
   2135a:	9b00      	ldr	r3, [sp, #0]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   2135c:	4a4f      	ldr	r2, [pc, #316]	; (2149c <nrfx_gpiote_irq_handler+0x1ac>)
                pin += 32 * i;
   2135e:	441c      	add	r4, r3
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   21360:	f104 0308 	add.w	r3, r4, #8
   21364:	f832 7013 	ldrh.w	r7, [r2, r3, lsl #1]
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   21368:	2301      	movs	r3, #1
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   2136a:	08e0      	lsrs	r0, r4, #3
    bit = BITMASK_RELBIT_GET(bit);
   2136c:	f004 0207 	and.w	r2, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   21370:	fa03 f202 	lsl.w	r2, r3, r2
   21374:	f81b 3000 	ldrb.w	r3, [fp, r0]
   21378:	9403      	str	r4, [sp, #12]
   2137a:	ea23 0302 	bic.w	r3, r3, r2
   2137e:	f80b 3000 	strb.w	r3, [fp, r0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   21382:	a803      	add	r0, sp, #12
   21384:	f7ff fd22 	bl	20dcc <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   21388:	9b03      	ldr	r3, [sp, #12]
   2138a:	08b9      	lsrs	r1, r7, #2
   2138c:	3380      	adds	r3, #128	; 0x80
   2138e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   21392:	f3c7 0582 	ubfx	r5, r7, #2, #3
    if (is_level(trigger))
   21396:	074a      	lsls	r2, r1, #29
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   21398:	462f      	mov	r7, r5
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   2139a:	f3c3 4301 	ubfx	r3, r3, #16, #2
    if (is_level(trigger))
   2139e:	d52b      	bpl.n	213f8 <nrfx_gpiote_irq_handler+0x108>
        call_handler(pin, trigger);
   213a0:	4620      	mov	r0, r4
   213a2:	4639      	mov	r1, r7
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   213a4:	b2dd      	uxtb	r5, r3
   213a6:	f7ff fd2b 	bl	20e00 <call_handler>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   213aa:	a803      	add	r0, sp, #12
   213ac:	9403      	str	r4, [sp, #12]
   213ae:	f7ff fd0d 	bl	20dcc <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   213b2:	9b03      	ldr	r3, [sp, #12]
   213b4:	3380      	adds	r3, #128	; 0x80
   213b6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
        if (nrf_gpio_pin_sense_get(pin) == sense)
   213ba:	f3c3 4301 	ubfx	r3, r3, #16, #2
   213be:	429d      	cmp	r5, r3
   213c0:	d107      	bne.n	213d2 <nrfx_gpiote_irq_handler+0xe2>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   213c2:	2100      	movs	r1, #0
   213c4:	4620      	mov	r0, r4
   213c6:	f004 fa75 	bl	258b4 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   213ca:	4629      	mov	r1, r5
   213cc:	4620      	mov	r0, r4
   213ce:	f004 fa71 	bl	258b4 <nrf_gpio_cfg_sense_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   213d2:	a803      	add	r0, sp, #12
   213d4:	9403      	str	r4, [sp, #12]
   213d6:	f7ff fcf9 	bl	20dcc <nrf_gpio_pin_port_decode>
    reg->LATCH = (1 << pin_number);
   213da:	2201      	movs	r2, #1
   213dc:	9b03      	ldr	r3, [sp, #12]
   213de:	fa02 f303 	lsl.w	r3, r2, r3
   213e2:	6203      	str	r3, [r0, #32]
            while (latch[i])
   213e4:	f85b 4029 	ldr.w	r4, [fp, r9, lsl #2]
   213e8:	2c00      	cmp	r4, #0
   213ea:	d1b2      	bne.n	21352 <nrfx_gpiote_irq_handler+0x62>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   213ec:	f1b9 0f00 	cmp.w	r9, #0
   213f0:	d11d      	bne.n	2142e <nrfx_gpiote_irq_handler+0x13e>
   213f2:	f04f 0901 	mov.w	r9, #1
   213f6:	e7a8      	b.n	2134a <nrfx_gpiote_irq_handler+0x5a>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   213f8:	2b02      	cmp	r3, #2
   213fa:	d10c      	bne.n	21416 <nrfx_gpiote_irq_handler+0x126>
        nrf_gpio_cfg_sense_set(pin, next_sense);
   213fc:	2103      	movs	r1, #3
   213fe:	4620      	mov	r0, r4
   21400:	f004 fa58 	bl	258b4 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   21404:	f005 0305 	and.w	r3, r5, #5
   21408:	2b01      	cmp	r3, #1
   2140a:	d1e2      	bne.n	213d2 <nrfx_gpiote_irq_handler+0xe2>
            call_handler(pin, trigger);
   2140c:	4639      	mov	r1, r7
   2140e:	4620      	mov	r0, r4
   21410:	f7ff fcf6 	bl	20e00 <call_handler>
   21414:	e7dd      	b.n	213d2 <nrfx_gpiote_irq_handler+0xe2>
        nrf_gpio_cfg_sense_set(pin, next_sense);
   21416:	2102      	movs	r1, #2
   21418:	4620      	mov	r0, r4
   2141a:	9301      	str	r3, [sp, #4]
   2141c:	f004 fa4a 	bl	258b4 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   21420:	2d03      	cmp	r5, #3
   21422:	d0f3      	beq.n	2140c <nrfx_gpiote_irq_handler+0x11c>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   21424:	9b01      	ldr	r3, [sp, #4]
   21426:	2b03      	cmp	r3, #3
   21428:	d1d3      	bne.n	213d2 <nrfx_gpiote_irq_handler+0xe2>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   2142a:	2d02      	cmp	r5, #2
   2142c:	e7ed      	b.n	2140a <nrfx_gpiote_irq_handler+0x11a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   2142e:	f8ca 417c 	str.w	r4, [sl, #380]	; 0x17c
   21432:	f8da 317c 	ldr.w	r3, [sl, #380]	; 0x17c
        *p_masks = gpio_regs[i]->LATCH;
   21436:	f8d8 3020 	ldr.w	r3, [r8, #32]
   2143a:	4917      	ldr	r1, [pc, #92]	; (21498 <nrfx_gpiote_irq_handler+0x1a8>)
   2143c:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
   2143e:	f8c8 3020 	str.w	r3, [r8, #32]
        *p_masks = gpio_regs[i]->LATCH;
   21442:	6a0a      	ldr	r2, [r1, #32]
        if (latch[port_idx])
   21444:	4313      	orrs	r3, r2
   21446:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
   21448:	620a      	str	r2, [r1, #32]
   2144a:	f47f af7a 	bne.w	21342 <nrfx_gpiote_irq_handler+0x52>
        mask &= ~NRFX_BIT(ch);
   2144e:	2401      	movs	r4, #1
    while (mask)
   21450:	b916      	cbnz	r6, 21458 <nrfx_gpiote_irq_handler+0x168>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   21452:	b007      	add	sp, #28
   21454:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        uint32_t ch = NRF_CTZ(mask);
   21458:	fa96 f3a6 	rbit	r3, r6
   2145c:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   21460:	fa04 f203 	lsl.w	r2, r4, r3
   21464:	009b      	lsls	r3, r3, #2
   21466:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2146a:	f503 333c 	add.w	r3, r3, #192512	; 0x2f000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   2146e:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   21472:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   21476:	f3c0 2005 	ubfx	r0, r0, #8, #6
   2147a:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
   2147e:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   21482:	f7ff fcbd 	bl	20e00 <call_handler>
   21486:	e7e3      	b.n	21450 <nrfx_gpiote_irq_handler+0x160>
   21488:	4002f100 	.word	0x4002f100
   2148c:	4002f000 	.word	0x4002f000
   21490:	4002f120 	.word	0x4002f120
   21494:	40842500 	.word	0x40842500
   21498:	40842800 	.word	0x40842800
   2149c:	2000a208 	.word	0x2000a208

000214a0 <nrfx_power_init>:
    return m_usbevt_handler;
}
#endif

nrfx_err_t nrfx_power_init(nrfx_power_config_t const * p_config)
{
   214a0:	b510      	push	{r4, lr}
    NRFX_ASSERT(p_config);
    if (m_initialized)
   214a2:	4c0e      	ldr	r4, [pc, #56]	; (214dc <nrfx_power_init+0x3c>)
   214a4:	7823      	ldrb	r3, [r4, #0]
   214a6:	b9b3      	cbnz	r3, 214d6 <nrfx_power_init+0x36>
#endif // NRF_REGULATORS_HAS_POFCON_VDDH

#if NRF_REGULATORS_HAS_DCDCEN_VDDH
NRF_STATIC_INLINE void nrf_regulators_dcdcen_vddh_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
    p_reg->VREGH.DCDCEN = (enable) ? REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled :
   214a8:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    }

#if NRF_POWER_HAS_DCDCEN_VDDH
    nrf_power_dcdcen_vddh_set(NRF_POWER, p_config->dcdcenhv);
#elif NRF_REGULATORS_HAS_DCDCEN_VDDH
    nrf_regulators_dcdcen_vddh_set(NRF_REGULATORS, p_config->dcdcenhv);
   214ac:	7803      	ldrb	r3, [r0, #0]
   214ae:	f3c3 0340 	ubfx	r3, r3, #1, #1
   214b2:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
#endif

#if NRF_POWER_HAS_DCDCEN
    nrf_power_dcdcen_set(NRF_POWER, p_config->dcdcen);
#elif defined(REGULATORS_PRESENT)
    nrf_regulators_dcdcen_set(NRF_REGULATORS, p_config->dcdcen);
   214b6:	7803      	ldrb	r3, [r0, #0]
    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   214b8:	2005      	movs	r0, #5
    p_reg->VREGMAIN.DCDCEN = (enable ? REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Msk : 0);
   214ba:	f003 0301 	and.w	r3, r3, #1
   214be:	f8c2 3704 	str.w	r3, [r2, #1796]	; 0x704
   214c2:	f7fc ff2f 	bl	1e324 <arch_irq_is_enabled>
   214c6:	b910      	cbnz	r0, 214ce <nrfx_power_init+0x2e>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   214c8:	2005      	movs	r0, #5
   214ca:	f7fc ff09 	bl	1e2e0 <arch_irq_enable>
#endif
#endif // defined(REGULATORS_PRESENT)

    nrfx_power_clock_irq_init();

    m_initialized = true;
   214ce:	2301      	movs	r3, #1
    return NRFX_SUCCESS;
   214d0:	4803      	ldr	r0, [pc, #12]	; (214e0 <nrfx_power_init+0x40>)
    m_initialized = true;
   214d2:	7023      	strb	r3, [r4, #0]
}
   214d4:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   214d6:	4803      	ldr	r0, [pc, #12]	; (214e4 <nrfx_power_init+0x44>)
   214d8:	e7fc      	b.n	214d4 <nrfx_power_init+0x34>
   214da:	bf00      	nop
   214dc:	2000b632 	.word	0x2000b632
   214e0:	0bad0000 	.word	0x0bad0000
   214e4:	0bad000c 	.word	0x0bad000c

000214e8 <nrfx_power_irq_handler>:

#endif /* NRF_POWER_HAS_USBREG */


void nrfx_power_irq_handler(void)
{
   214e8:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
}

NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg)
{
    return p_reg->INTENSET;
   214ea:	4b18      	ldr	r3, [pc, #96]	; (2154c <nrfx_power_irq_handler+0x64>)
   214ec:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
    uint32_t enabled = nrf_power_int_enable_get(NRF_POWER);
    /* Prevent "unused variable" warning when all below blocks are disabled. */
    (void)enabled;

#if NRFX_POWER_SUPPORTS_POFCON
    if ((0 != (enabled & NRF_POWER_INT_POFWARN_MASK)) &&
   214f0:	0761      	lsls	r1, r4, #29
   214f2:	d50a      	bpl.n	2150a <nrfx_power_irq_handler+0x22>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   214f4:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    if (ret)
   214f8:	b13a      	cbz	r2, 2150a <nrfx_power_irq_handler+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   214fa:	2200      	movs	r2, #0
   214fc:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   21500:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_POFWARN))
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_pofwarn_handler != NULL);
        m_pofwarn_handler();
   21504:	4b12      	ldr	r3, [pc, #72]	; (21550 <nrfx_power_irq_handler+0x68>)
   21506:	681b      	ldr	r3, [r3, #0]
   21508:	4798      	blx	r3
    }
#endif
#if NRF_POWER_HAS_SLEEPEVT
    if ((0 != (enabled & NRF_POWER_INT_SLEEPENTER_MASK)) &&
   2150a:	06a2      	lsls	r2, r4, #26
   2150c:	d50b      	bpl.n	21526 <nrfx_power_irq_handler+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2150e:	4b0f      	ldr	r3, [pc, #60]	; (2154c <nrfx_power_irq_handler+0x64>)
   21510:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
    if (ret)
   21514:	b13a      	cbz	r2, 21526 <nrfx_power_irq_handler+0x3e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21516:	2000      	movs	r0, #0
   21518:	f8c3 0114 	str.w	r0, [r3, #276]	; 0x114
   2151c:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPENTER))
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_ENTER);
   21520:	4b0c      	ldr	r3, [pc, #48]	; (21554 <nrfx_power_irq_handler+0x6c>)
   21522:	681b      	ldr	r3, [r3, #0]
   21524:	4798      	blx	r3
    }
    if ((0 != (enabled & NRF_POWER_INT_SLEEPEXIT_MASK)) &&
   21526:	0663      	lsls	r3, r4, #25
   21528:	d50e      	bpl.n	21548 <nrfx_power_irq_handler+0x60>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2152a:	4b08      	ldr	r3, [pc, #32]	; (2154c <nrfx_power_irq_handler+0x64>)
   2152c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (ret)
   21530:	b152      	cbz	r2, 21548 <nrfx_power_irq_handler+0x60>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21532:	2200      	movs	r2, #0
   21534:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   21538:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPEXIT))
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_EXIT);
   2153c:	4b05      	ldr	r3, [pc, #20]	; (21554 <nrfx_power_irq_handler+0x6c>)
   2153e:	2001      	movs	r0, #1
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_usbevt_handler != NULL);
        m_usbevt_handler(NRFX_POWER_USB_EVT_READY);
    }
#endif
}
   21540:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_EXIT);
   21544:	681b      	ldr	r3, [r3, #0]
   21546:	4718      	bx	r3
}
   21548:	bd10      	pop	{r4, pc}
   2154a:	bf00      	nop
   2154c:	40005000 	.word	0x40005000
   21550:	2000b300 	.word	0x2000b300
   21554:	2000b2fc 	.word	0x2000b2fc

00021558 <nrf_gpio_pin_clear>:
        case 0: return NRF_P0;
   21558:	4a05      	ldr	r2, [pc, #20]	; (21570 <nrf_gpio_pin_clear+0x18>)
   2155a:	4b06      	ldr	r3, [pc, #24]	; (21574 <nrf_gpio_pin_clear+0x1c>)
    *p_pin = pin_number & 0x1F;
   2155c:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
   21560:	0940      	lsrs	r0, r0, #5
        case 0: return NRF_P0;
   21562:	2801      	cmp	r0, #1
   21564:	bf18      	it	ne
   21566:	4613      	movne	r3, r2
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   21568:	2201      	movs	r2, #1
   2156a:	408a      	lsls	r2, r1
    p_reg->OUTCLR = clr_mask;
   2156c:	60da      	str	r2, [r3, #12]
}
   2156e:	4770      	bx	lr
   21570:	40842500 	.word	0x40842500
   21574:	40842800 	.word	0x40842800

00021578 <nrf_gpio_cfg.constprop.0>:
NRF_STATIC_INLINE void nrf_gpio_cfg(
   21578:	b570      	push	{r4, r5, r6, lr}
        case 0: return NRF_P0;
   2157a:	4c0d      	ldr	r4, [pc, #52]	; (215b0 <nrf_gpio_cfg.constprop.0+0x38>)
   2157c:	4e0d      	ldr	r6, [pc, #52]	; (215b4 <nrf_gpio_cfg.constprop.0+0x3c>)
    *p_pin = pin_number & 0x1F;
   2157e:	f000 051f 	and.w	r5, r0, #31
    return pin_number >> 5;
   21582:	0940      	lsrs	r0, r0, #5
        case 0: return NRF_P0;
   21584:	2801      	cmp	r0, #1
   21586:	bf18      	it	ne
   21588:	4634      	movne	r4, r6
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   2158a:	f89d 0010 	ldrb.w	r0, [sp, #16]
   2158e:	eb04 0485 	add.w	r4, r4, r5, lsl #2
   21592:	0200      	lsls	r0, r0, #8
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21594:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   21598:	ea40 0083 	orr.w	r0, r0, r3, lsl #2
   2159c:	4308      	orrs	r0, r1
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   2159e:	f005 45e0 	and.w	r5, r5, #1879048192	; 0x70000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   215a2:	ea40 0042 	orr.w	r0, r0, r2, lsl #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   215a6:	4328      	orrs	r0, r5
    reg->PIN_CNF[pin_number] = cnf;
   215a8:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
}
   215ac:	bd70      	pop	{r4, r5, r6, pc}
   215ae:	bf00      	nop
   215b0:	40842800 	.word	0x40842800
   215b4:	40842500 	.word	0x40842500

000215b8 <nrf_gpio_pin_set>:
        case 0: return NRF_P0;
   215b8:	4a05      	ldr	r2, [pc, #20]	; (215d0 <nrf_gpio_pin_set+0x18>)
   215ba:	4b06      	ldr	r3, [pc, #24]	; (215d4 <nrf_gpio_pin_set+0x1c>)
    *p_pin = pin_number & 0x1F;
   215bc:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
   215c0:	0940      	lsrs	r0, r0, #5
        case 0: return NRF_P0;
   215c2:	2801      	cmp	r0, #1
   215c4:	bf18      	it	ne
   215c6:	4613      	movne	r3, r2
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   215c8:	2201      	movs	r2, #1
   215ca:	408a      	lsls	r2, r1
    p_reg->OUTSET = set_mask;
   215cc:	609a      	str	r2, [r3, #8]
}
   215ce:	4770      	bx	lr
   215d0:	40842500 	.word	0x40842500
   215d4:	40842800 	.word	0x40842800

000215d8 <nrfx_spim_init>:

nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
                          nrfx_spim_config_t const * p_config,
                          nrfx_spim_evt_handler_t    handler,
                          void *                     p_context)
{
   215d8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   215dc:	4607      	mov	r7, r0
   215de:	460c      	mov	r4, r1
    NRFX_ASSERT(p_config);
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   215e0:	4e93      	ldr	r6, [pc, #588]	; (21830 <nrfx_spim_init+0x258>)
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   215e2:	7939      	ldrb	r1, [r7, #4]
{
   215e4:	4610      	mov	r0, r2
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   215e6:	eb06 1241 	add.w	r2, r6, r1, lsl #5
   215ea:	f892 a01c 	ldrb.w	sl, [r2, #28]
   215ee:	ea4f 1941 	mov.w	r9, r1, lsl #5
   215f2:	f1ba 0f00 	cmp.w	sl, #0
   215f6:	f040 8116 	bne.w	21826 <nrfx_spim_init+0x24e>
        return err_code;
    }

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // Check if SPIM instance supports the extended features.
    if (
   215fa:	b949      	cbnz	r1, 21610 <nrfx_spim_init+0x38>
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   215fc:	68a2      	ldr	r2, [r4, #8]
   215fe:	f1b2 6f20 	cmp.w	r2, #167772160	; 0xa000000
   21602:	d003      	beq.n	2160c <nrfx_spim_init+0x34>
   21604:	f1b2 5fa0 	cmp.w	r2, #335544320	; 0x14000000
   21608:	f040 80ee 	bne.w	217e8 <nrfx_spim_init+0x210>
    {
        err_code = NRFX_ERROR_NOT_SUPPORTED;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
   2160c:	4889      	ldr	r0, [pc, #548]	; (21834 <nrfx_spim_init+0x25c>)
   2160e:	e0e8      	b.n	217e2 <nrfx_spim_init+0x20a>
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   21610:	2901      	cmp	r1, #1
   21612:	d1fb      	bne.n	2160c <nrfx_spim_init+0x34>
        ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
   21614:	7be1      	ldrb	r1, [r4, #15]

#if NRF_SPIM_HAS_32_MHZ_FREQ && defined(NRF5340_XXAA_APPLICATION)
    // Check if dedicated SPIM pins are used, unless both GPIO configuration
    // and pin selection are to be skipped (pin numbers may be not specified
    // in such case).
    if (!(p_config->skip_gpio_cfg && p_config->skip_psel_cfg) &&
   21616:	7ce2      	ldrb	r2, [r4, #19]
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   21618:	f8d7 8000 	ldr.w	r8, [r7]
    if (!(p_config->skip_gpio_cfg && p_config->skip_psel_cfg) &&
   2161c:	b10a      	cbz	r2, 21622 <nrfx_spim_init+0x4a>
   2161e:	7d22      	ldrb	r2, [r4, #20]
   21620:	bb1a      	cbnz	r2, 2166a <nrfx_spim_init+0x92>
   21622:	4a85      	ldr	r2, [pc, #532]	; (21838 <nrfx_spim_init+0x260>)
   21624:	4590      	cmp	r8, r2
   21626:	d120      	bne.n	2166a <nrfx_spim_init+0x92>
        (p_spim == NRF_SPIM4) && (p_config->frequency == NRF_SPIM_FREQ_32M))
   21628:	68a2      	ldr	r2, [r4, #8]
   2162a:	f1b2 5fa0 	cmp.w	r2, #335544320	; 0x14000000
   2162e:	d11c      	bne.n	2166a <nrfx_spim_init+0x92>
            SPIM_MISO_DEDICATED = NRF_GPIO_PIN_MAP(0, 10),
            SPIM_CSN_DEDICATED  = NRF_GPIO_PIN_MAP(0, 11),
            SPIM_DCX_DEDICATED  = NRF_GPIO_PIN_MAP(0, 12),
        };

        if (!SPIM_DEDICATED_PIN_VALIDATE(p_config->sck_pin, SPIM_SCK_DEDICATED) ||
   21630:	7822      	ldrb	r2, [r4, #0]
   21632:	2aff      	cmp	r2, #255	; 0xff
   21634:	d002      	beq.n	2163c <nrfx_spim_init+0x64>
   21636:	2a08      	cmp	r2, #8
   21638:	f040 80f7 	bne.w	2182a <nrfx_spim_init+0x252>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->ss_pin,  SPIM_CSN_DEDICATED) ||
   2163c:	78e2      	ldrb	r2, [r4, #3]
        if (!SPIM_DEDICATED_PIN_VALIDATE(p_config->sck_pin, SPIM_SCK_DEDICATED) ||
   2163e:	2aff      	cmp	r2, #255	; 0xff
   21640:	d002      	beq.n	21648 <nrfx_spim_init+0x70>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->ss_pin,  SPIM_CSN_DEDICATED) ||
   21642:	2a0b      	cmp	r2, #11
   21644:	f040 80f1 	bne.w	2182a <nrfx_spim_init+0x252>
   21648:	29ff      	cmp	r1, #255	; 0xff
   2164a:	d002      	beq.n	21652 <nrfx_spim_init+0x7a>
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->dcx_pin, SPIM_DCX_DEDICATED) ||
   2164c:	290c      	cmp	r1, #12
   2164e:	f040 80ec 	bne.w	2182a <nrfx_spim_init+0x252>
#endif
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
   21652:	7862      	ldrb	r2, [r4, #1]
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->dcx_pin, SPIM_DCX_DEDICATED) ||
   21654:	2aff      	cmp	r2, #255	; 0xff
   21656:	d002      	beq.n	2165e <nrfx_spim_init+0x86>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
   21658:	2a09      	cmp	r2, #9
   2165a:	f040 80e6 	bne.w	2182a <nrfx_spim_init+0x252>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->miso_pin, SPIM_MISO_DEDICATED))
   2165e:	78a2      	ldrb	r2, [r4, #2]
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
   21660:	2aff      	cmp	r2, #255	; 0xff
   21662:	d002      	beq.n	2166a <nrfx_spim_init+0x92>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->miso_pin, SPIM_MISO_DEDICATED))
   21664:	2a0a      	cmp	r2, #10
   21666:	f040 80e0 	bne.w	2182a <nrfx_spim_init+0x252>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
   2166a:	eb06 0209 	add.w	r2, r6, r9
   2166e:	f846 0009 	str.w	r0, [r6, r9]
    p_cb->p_context = p_context;
   21672:	6053      	str	r3, [r2, #4]

    p_cb->skip_gpio_cfg = p_config->skip_gpio_cfg;
   21674:	7ce0      	ldrb	r0, [r4, #19]
   21676:	7f91      	ldrb	r1, [r2, #30]
   21678:	f360 0100 	bfi	r1, r0, #0, #1
   2167c:	7791      	strb	r1, [r2, #30]
    p_cb->ss_active_high = p_config->ss_active_high;
   2167e:	7920      	ldrb	r0, [r4, #4]
   21680:	b2c9      	uxtb	r1, r1
   21682:	f360 0141 	bfi	r1, r0, #1, #1
   21686:	7791      	strb	r1, [r2, #30]
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    p_cb->use_hw_ss = p_config->use_hw_ss;
   21688:	7c60      	ldrb	r0, [r4, #17]
   2168a:	b2c9      	uxtb	r1, r1
   2168c:	f360 0182 	bfi	r1, r0, #2, #1
   21690:	7791      	strb	r1, [r2, #30]
#endif
    p_cb->ss_pin = p_config->ss_pin;
   21692:	78e3      	ldrb	r3, [r4, #3]
   21694:	77d3      	strb	r3, [r2, #31]
    if (!p_config->skip_gpio_cfg)
   21696:	7ce3      	ldrb	r3, [r4, #19]
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   21698:	683d      	ldr	r5, [r7, #0]
    if (!p_config->skip_gpio_cfg)
   2169a:	2b00      	cmp	r3, #0
   2169c:	d148      	bne.n	21730 <nrfx_spim_init+0x158>
                    : NRF_GPIO_PIN_S0S1;
   2169e:	68a3      	ldr	r3, [r4, #8]
        nrf_gpio_pin_write(p_config->sck_pin,
   216a0:	7820      	ldrb	r0, [r4, #0]
                    : NRF_GPIO_PIN_S0S1;
   216a2:	f1b3 5fa0 	cmp.w	r3, #335544320	; 0x14000000
    if (value == 0)
   216a6:	7b23      	ldrb	r3, [r4, #12]
   216a8:	bf08      	it	eq
   216aa:	f04f 0a03 	moveq.w	sl, #3
   216ae:	2b01      	cmp	r3, #1
   216b0:	f200 80a3 	bhi.w	217fa <nrfx_spim_init+0x222>
        nrf_gpio_pin_clear(pin_number);
   216b4:	f7ff ff50 	bl	21558 <nrf_gpio_pin_clear>
        nrf_gpio_cfg(p_config->sck_pin,
   216b8:	2300      	movs	r3, #0
   216ba:	f8cd a000 	str.w	sl, [sp]
   216be:	7820      	ldrb	r0, [r4, #0]
   216c0:	461a      	mov	r2, r3
   216c2:	2101      	movs	r1, #1
   216c4:	f7ff ff58 	bl	21578 <nrf_gpio_cfg.constprop.0>
        if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   216c8:	7860      	ldrb	r0, [r4, #1]
   216ca:	28ff      	cmp	r0, #255	; 0xff
   216cc:	d009      	beq.n	216e2 <nrfx_spim_init+0x10a>
   216ce:	f7ff ff43 	bl	21558 <nrf_gpio_pin_clear>
            nrf_gpio_cfg(p_config->mosi_pin,
   216d2:	2201      	movs	r2, #1
   216d4:	f8cd a000 	str.w	sl, [sp]
   216d8:	2300      	movs	r3, #0
   216da:	4611      	mov	r1, r2
   216dc:	7860      	ldrb	r0, [r4, #1]
   216de:	f7ff ff4b 	bl	21578 <nrf_gpio_cfg.constprop.0>
        if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   216e2:	78a0      	ldrb	r0, [r4, #2]
   216e4:	28ff      	cmp	r0, #255	; 0xff
   216e6:	d006      	beq.n	216f6 <nrfx_spim_init+0x11e>
            nrf_gpio_cfg(p_config->miso_pin,
   216e8:	2200      	movs	r2, #0
   216ea:	f8cd a000 	str.w	sl, [sp]
   216ee:	4611      	mov	r1, r2
   216f0:	7ba3      	ldrb	r3, [r4, #14]
   216f2:	f7ff ff41 	bl	21578 <nrf_gpio_cfg.constprop.0>
        if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   216f6:	78e0      	ldrb	r0, [r4, #3]
   216f8:	28ff      	cmp	r0, #255	; 0xff
   216fa:	d00c      	beq.n	21716 <nrfx_spim_init+0x13e>
    if (value == 0)
   216fc:	7923      	ldrb	r3, [r4, #4]
   216fe:	2b00      	cmp	r3, #0
   21700:	d07e      	beq.n	21800 <nrfx_spim_init+0x228>
        nrf_gpio_pin_clear(pin_number);
   21702:	f7ff ff29 	bl	21558 <nrf_gpio_pin_clear>
            nrf_gpio_cfg(p_config->ss_pin,
   21706:	2201      	movs	r2, #1
   21708:	f8cd a000 	str.w	sl, [sp]
   2170c:	2300      	movs	r3, #0
   2170e:	4611      	mov	r1, r2
   21710:	78e0      	ldrb	r0, [r4, #3]
   21712:	f7ff ff31 	bl	21578 <nrf_gpio_cfg.constprop.0>
        if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
   21716:	7be0      	ldrb	r0, [r4, #15]
   21718:	28ff      	cmp	r0, #255	; 0xff
   2171a:	d009      	beq.n	21730 <nrfx_spim_init+0x158>
        nrf_gpio_pin_set(pin_number);
   2171c:	f7ff ff4c 	bl	215b8 <nrf_gpio_pin_set>
            nrf_gpio_cfg(p_config->dcx_pin,
   21720:	2201      	movs	r2, #1
   21722:	f8cd a000 	str.w	sl, [sp]
   21726:	2300      	movs	r3, #0
   21728:	4611      	mov	r1, r2
   2172a:	7be0      	ldrb	r0, [r4, #15]
   2172c:	f7ff ff24 	bl	21578 <nrf_gpio_cfg.constprop.0>
    if (!p_config->skip_psel_cfg)
   21730:	7d23      	ldrb	r3, [r4, #20]
   21732:	bb6b      	cbnz	r3, 21790 <nrfx_spim_init+0x1b8>
        uint32_t mosi_pin = (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   21734:	7863      	ldrb	r3, [r4, #1]
        nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
   21736:	7821      	ldrb	r1, [r4, #0]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   21738:	2bff      	cmp	r3, #255	; 0xff
   2173a:	bf18      	it	ne
   2173c:	461a      	movne	r2, r3
        uint32_t miso_pin = (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   2173e:	78a3      	ldrb	r3, [r4, #2]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   21740:	bf08      	it	eq
   21742:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   21746:	2bff      	cmp	r3, #255	; 0xff
   21748:	bf08      	it	eq
   2174a:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
NRF_STATIC_INLINE void nrf_spim_pins_set(NRF_SPIM_Type * p_reg,
                                         uint32_t        sck_pin,
                                         uint32_t        mosi_pin,
                                         uint32_t        miso_pin)
{
    p_reg->PSEL.SCK  = sck_pin;
   2174e:	f8c5 1508 	str.w	r1, [r5, #1288]	; 0x508
    p_reg->PSEL.MOSI = mosi_pin;
   21752:	f8c5 250c 	str.w	r2, [r5, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   21756:	f8c5 3510 	str.w	r3, [r5, #1296]	; 0x510
        if (SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx))
   2175a:	793b      	ldrb	r3, [r7, #4]
   2175c:	2b01      	cmp	r3, #1
   2175e:	d117      	bne.n	21790 <nrfx_spim_init+0x1b8>
            if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED &&
   21760:	78e3      	ldrb	r3, [r4, #3]
   21762:	2bff      	cmp	r3, #255	; 0xff
   21764:	d04f      	beq.n	21806 <nrfx_spim_init+0x22e>
   21766:	7c62      	ldrb	r2, [r4, #17]
   21768:	2a00      	cmp	r2, #0
   2176a:	d04c      	beq.n	21806 <nrfx_spim_init+0x22e>
                                    (p_config->ss_active_high == true
   2176c:	7921      	ldrb	r1, [r4, #4]
                nrf_spim_csn_configure(p_spim,
   2176e:	7ca2      	ldrb	r2, [r4, #18]
NRF_STATIC_INLINE void nrf_spim_csn_configure(NRF_SPIM_Type *    p_reg,
                                              uint32_t           pin,
                                              nrf_spim_csn_pol_t polarity,
                                              uint32_t           duration)
{
    p_reg->PSEL.CSN = pin;
   21770:	f8c5 3514 	str.w	r3, [r5, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
   21774:	f8c5 1568 	str.w	r1, [r5, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
   21778:	f8c5 2564 	str.w	r2, [r5, #1380]	; 0x564
        if (SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
   2177c:	793b      	ldrb	r3, [r7, #4]
   2177e:	2b01      	cmp	r3, #1
   21780:	d106      	bne.n	21790 <nrfx_spim_init+0x1b8>
            uint32_t dcx_pin = (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
   21782:	7be3      	ldrb	r3, [r4, #15]
                               : NRF_SPIM_PIN_NOT_CONNECTED;
   21784:	2bff      	cmp	r3, #255	; 0xff
   21786:	bf08      	it	eq
   21788:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff

#if NRF_SPIM_DCX_PRESENT
NRF_STATIC_INLINE void nrf_spim_dcx_pin_set(NRF_SPIM_Type * p_reg,
                                            uint32_t        dcx_pin)
{
    p_reg->PSELDCX = dcx_pin;
   2178c:	f8c5 356c 	str.w	r3, [r5, #1388]	; 0x56c

    configure_pins(p_instance, p_config);

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // Change rx delay
    nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
   21790:	7c23      	ldrb	r3, [r4, #16]

#if NRF_SPIM_RXDELAY_PRESENT
NRF_STATIC_INLINE void nrf_spim_iftiming_set(NRF_SPIM_Type * p_reg,
                                             uint32_t        rxdelay)
{
    p_reg->IFTIMING.RXDELAY = rxdelay;
   21792:	f8c8 3560 	str.w	r3, [r8, #1376]	; 0x560
#endif // defined(SPIM_STALLSTAT_TX_Msk)

NRF_STATIC_INLINE void nrf_spim_frequency_set(NRF_SPIM_Type *      p_reg,
                                              nrf_spim_frequency_t frequency)
{
    p_reg->FREQUENCY = (uint32_t)frequency;
   21796:	68a3      	ldr	r3, [r4, #8]
   21798:	f8c8 3524 	str.w	r3, [r8, #1316]	; 0x524
NRF_STATIC_INLINE void nrf_spim_configure(NRF_SPIM_Type *      p_reg,
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
   2179c:	7b63      	ldrb	r3, [r4, #13]
#endif

    nrf_spim_frequency_set(p_spim, p_config->frequency);
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
   2179e:	7b22      	ldrb	r2, [r4, #12]
   217a0:	3b00      	subs	r3, #0
   217a2:	bf18      	it	ne
   217a4:	2301      	movne	r3, #1
    switch (spi_mode)
   217a6:	2a02      	cmp	r2, #2
   217a8:	d037      	beq.n	2181a <nrfx_spim_init+0x242>
   217aa:	2a03      	cmp	r2, #3
   217ac:	d038      	beq.n	21820 <nrfx_spim_init+0x248>
   217ae:	2a01      	cmp	r2, #1
   217b0:	d101      	bne.n	217b6 <nrfx_spim_init+0x1de>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   217b2:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   217b6:	f8c8 3554 	str.w	r3, [r8, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
   217ba:	79a3      	ldrb	r3, [r4, #6]
   217bc:	f8c8 35c0 	str.w	r3, [r8, #1472]	; 0x5c0
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
   217c0:	2307      	movs	r3, #7
   217c2:	f8c8 3500 	str.w	r3, [r8, #1280]	; 0x500

    nrf_spim_orc_set(p_spim, p_config->orc);

    nrf_spim_enable(p_spim);

    if (p_cb->handler)
   217c6:	f856 3009 	ldr.w	r3, [r6, r9]
   217ca:	b123      	cbz	r3, 217d6 <nrfx_spim_init+0x1fe>
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   217cc:	6838      	ldr	r0, [r7, #0]
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   217ce:	f340 3007 	sbfx	r0, r0, #12, #8
   217d2:	f7fc fd85 	bl	1e2e0 <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
   217d6:	2300      	movs	r3, #0
   217d8:	444e      	add	r6, r9
   217da:	7773      	strb	r3, [r6, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   217dc:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   217de:	4817      	ldr	r0, [pc, #92]	; (2183c <nrfx_spim_init+0x264>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   217e0:	7733      	strb	r3, [r6, #28]
}
   217e2:	b002      	add	sp, #8
   217e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   217e8:	7c62      	ldrb	r2, [r4, #17]
   217ea:	2a00      	cmp	r2, #0
   217ec:	f47f af0e 	bne.w	2160c <nrfx_spim_init+0x34>
        ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
   217f0:	7be1      	ldrb	r1, [r4, #15]
         !SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx)) ||
   217f2:	29ff      	cmp	r1, #255	; 0xff
   217f4:	f47f af0a 	bne.w	2160c <nrfx_spim_init+0x34>
   217f8:	e70d      	b.n	21616 <nrfx_spim_init+0x3e>
   217fa:	f7ff fedd 	bl	215b8 <nrf_gpio_pin_set>
   217fe:	e75b      	b.n	216b8 <nrfx_spim_init+0xe0>
   21800:	f7ff feda 	bl	215b8 <nrf_gpio_pin_set>
   21804:	e77f      	b.n	21706 <nrfx_spim_init+0x12e>
    p_reg->PSEL.CSN = pin;
   21806:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2180a:	f8c5 3514 	str.w	r3, [r5, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
   2180e:	2300      	movs	r3, #0
   21810:	f8c5 3568 	str.w	r3, [r5, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
   21814:	f8c5 3564 	str.w	r3, [r5, #1380]	; 0x564
}
   21818:	e7b0      	b.n	2177c <nrfx_spim_init+0x1a4>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   2181a:	f043 0304 	orr.w	r3, r3, #4
        break;
   2181e:	e7ca      	b.n	217b6 <nrfx_spim_init+0x1de>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   21820:	f043 0306 	orr.w	r3, r3, #6
        break;
   21824:	e7c7      	b.n	217b6 <nrfx_spim_init+0x1de>
        return err_code;
   21826:	4806      	ldr	r0, [pc, #24]	; (21840 <nrfx_spim_init+0x268>)
   21828:	e7db      	b.n	217e2 <nrfx_spim_init+0x20a>
            return err_code;
   2182a:	4806      	ldr	r0, [pc, #24]	; (21844 <nrfx_spim_init+0x26c>)
   2182c:	e7d9      	b.n	217e2 <nrfx_spim_init+0x20a>
   2182e:	bf00      	nop
   21830:	2000b304 	.word	0x2000b304
   21834:	0bad0003 	.word	0x0bad0003
   21838:	4000a000 	.word	0x4000a000
   2183c:	0bad0000 	.word	0x0bad0000
   21840:	0bad0005 	.word	0x0bad0005
   21844:	0bad0004 	.word	0x0bad0004

00021848 <nrfx_spim_uninit>:

    nrf_gpio_cfg_default(pin);
}

void nrfx_spim_uninit(nrfx_spim_t const * p_instance)
{
   21848:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2184c:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
    NRF_SPIM_Type * p_spim = p_instance->p_reg;

    if (p_cb->handler)
   2184e:	4d26      	ldr	r5, [pc, #152]	; (218e8 <nrfx_spim_uninit+0xa0>)
   21850:	015e      	lsls	r6, r3, #5
   21852:	eb05 1843 	add.w	r8, r5, r3, lsl #5
   21856:	59ab      	ldr	r3, [r5, r6]
{
   21858:	4607      	mov	r7, r0
    NRF_SPIM_Type * p_spim = p_instance->p_reg;
   2185a:	6804      	ldr	r4, [r0, #0]
    if (p_cb->handler)
   2185c:	b1cb      	cbz	r3, 21892 <nrfx_spim_uninit+0x4a>
    {
        NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
   2185e:	f344 3007 	sbfx	r0, r4, #12, #8
   21862:	f7fc fd4b 	bl	1e2fc <arch_irq_disable>
    p_reg->INTENCLR = mask;
   21866:	4b21      	ldr	r3, [pc, #132]	; (218ec <nrfx_spim_uninit+0xa4>)
   21868:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
        nrf_spim_int_disable(p_spim, NRF_SPIM_ALL_INTS_MASK);
        if (p_cb->transfer_in_progress)
   2186c:	f898 301d 	ldrb.w	r3, [r8, #29]
   21870:	b17b      	cbz	r3, 21892 <nrfx_spim_uninit+0x4a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21872:	2301      	movs	r3, #1
   21874:	f04f 0864 	mov.w	r8, #100	; 0x64
   21878:	6163      	str	r3, [r4, #20]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2187a:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    NRFX_WAIT_FOR(nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STOPPED), 100, 1, stopped);
   2187e:	b92b      	cbnz	r3, 2188c <nrfx_spim_uninit+0x44>
   21880:	2001      	movs	r0, #1
   21882:	f003 ffca 	bl	2581a <nrfx_busy_wait>
   21886:	f1b8 0801 	subs.w	r8, r8, #1
   2188a:	d1f6      	bne.n	2187a <nrfx_spim_uninit+0x32>
    p_cb->transfer_in_progress = false;
   2188c:	2200      	movs	r2, #0
   2188e:	19ab      	adds	r3, r5, r6
   21890:	775a      	strb	r2, [r3, #29]
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Disabled << SPIM_ENABLE_ENABLE_Pos);
   21892:	2300      	movs	r3, #0
   21894:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
        }
    }

    nrf_spim_disable(p_spim);

    if (!p_cb->skip_gpio_cfg)
   21898:	19ab      	adds	r3, r5, r6
   2189a:	7f9b      	ldrb	r3, [r3, #30]
   2189c:	07db      	lsls	r3, r3, #31
   2189e:	d41c      	bmi.n	218da <nrfx_spim_uninit+0x92>
    return p_reg->PSEL.SCK;
   218a0:	f8d4 0508 	ldr.w	r0, [r4, #1288]	; 0x508
    {
        spim_pin_uninit(nrf_spim_sck_pin_get(p_spim));
   218a4:	f004 f81c 	bl	258e0 <spim_pin_uninit>
    return p_reg->PSEL.MISO;
   218a8:	f8d4 0510 	ldr.w	r0, [r4, #1296]	; 0x510
        spim_pin_uninit(nrf_spim_miso_pin_get(p_spim));
   218ac:	f004 f818 	bl	258e0 <spim_pin_uninit>
    return p_reg->PSEL.MOSI;
   218b0:	f8d4 050c 	ldr.w	r0, [r4, #1292]	; 0x50c
        spim_pin_uninit(nrf_spim_mosi_pin_get(p_spim));
   218b4:	f004 f814 	bl	258e0 <spim_pin_uninit>
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
   218b8:	793b      	ldrb	r3, [r7, #4]
   218ba:	2b01      	cmp	r3, #1
   218bc:	d103      	bne.n	218c6 <nrfx_spim_uninit+0x7e>
    return p_reg->PSELDCX;
   218be:	f8d4 056c 	ldr.w	r0, [r4, #1388]	; 0x56c
        {
            spim_pin_uninit(nrf_spim_dcx_pin_get(p_spim));
   218c2:	f004 f80d 	bl	258e0 <spim_pin_uninit>
        }
#endif
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   218c6:	19ab      	adds	r3, r5, r6
   218c8:	7fd8      	ldrb	r0, [r3, #31]
   218ca:	28ff      	cmp	r0, #255	; 0xff
   218cc:	d005      	beq.n	218da <nrfx_spim_uninit+0x92>
    nrf_gpio_cfg(
   218ce:	2300      	movs	r3, #0
   218d0:	2201      	movs	r2, #1
   218d2:	4619      	mov	r1, r3
   218d4:	9300      	str	r3, [sp, #0]
   218d6:	f7ff fe4f 	bl	21578 <nrf_gpio_cfg.constprop.0>

#if NRFX_CHECK(NRFX_PRS_ENABLED)
    nrfx_prs_release(p_instance->p_reg);
#endif

    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
   218da:	2300      	movs	r3, #0
   218dc:	4435      	add	r5, r6
   218de:	772b      	strb	r3, [r5, #28]
}
   218e0:	b002      	add	sp, #8
   218e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   218e6:	bf00      	nop
   218e8:	2000b304 	.word	0x2000b304
   218ec:	00080152 	.word	0x00080152

000218f0 <nrfx_spim_xfer>:
}

nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
                          nrfx_spim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   218f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   218f4:	4f38      	ldr	r7, [pc, #224]	; (219d8 <nrfx_spim_xfer+0xe8>)
   218f6:	7903      	ldrb	r3, [r0, #4]
{
   218f8:	4615      	mov	r5, r2
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   218fa:	eb07 1843 	add.w	r8, r7, r3, lsl #5
#endif
                (p_cb->ss_pin == NRFX_SPIM_PIN_NOT_USED));

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
   218fe:	f898 201d 	ldrb.w	r2, [r8, #29]
{
   21902:	4681      	mov	r9, r0
   21904:	460c      	mov	r4, r1
    if (p_cb->transfer_in_progress)
   21906:	015e      	lsls	r6, r3, #5
   21908:	2a00      	cmp	r2, #0
   2190a:	d163      	bne.n	219d4 <nrfx_spim_xfer+0xe4>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
   2190c:	59ba      	ldr	r2, [r7, r6]
   2190e:	b12a      	cbz	r2, 2191c <nrfx_spim_xfer+0x2c>
   21910:	f015 0f14 	tst.w	r5, #20
                                        NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
        {
            p_cb->transfer_in_progress = true;
   21914:	bf04      	itt	eq
   21916:	2201      	moveq	r2, #1
   21918:	f888 201d 	strbeq.w	r2, [r8, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
   2191c:	eb07 0c06 	add.w	ip, r7, r6
   21920:	f10c 0c0c 	add.w	ip, ip, #12
   21924:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   21928:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    set_ss_pin_state(p_cb, true);
   2192c:	2101      	movs	r1, #1
   2192e:	4640      	mov	r0, r8
   21930:	f003 ffe2 	bl	258f8 <set_ss_pin_state>
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   21934:	6821      	ldr	r1, [r4, #0]

    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   21936:	f8d9 3000 	ldr.w	r3, [r9]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   2193a:	b121      	cbz	r1, 21946 <nrfx_spim_xfer+0x56>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   2193c:	f001 4260 	and.w	r2, r1, #3758096384	; 0xe0000000
   21940:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   21944:	d106      	bne.n	21954 <nrfx_spim_xfer+0x64>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   21946:	68a2      	ldr	r2, [r4, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   21948:	b152      	cbz	r2, 21960 <nrfx_spim_xfer+0x70>
   2194a:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   2194e:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   21952:	d005      	beq.n	21960 <nrfx_spim_xfer+0x70>
        p_cb->transfer_in_progress = false;
   21954:	2300      	movs	r3, #0
   21956:	443e      	add	r6, r7
        return err_code;
   21958:	4820      	ldr	r0, [pc, #128]	; (219dc <nrfx_spim_xfer+0xec>)
        p_cb->transfer_in_progress = false;
   2195a:	7773      	strb	r3, [r6, #29]
}
   2195c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   21960:	6862      	ldr	r2, [r4, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21962:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21966:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   2196a:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
   2196e:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   21972:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21976:	2200      	movs	r2, #0
   21978:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   2197c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   21980:	f015 0201 	ands.w	r2, r5, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   21984:	bf18      	it	ne
   21986:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   21988:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   2198c:	f015 0202 	ands.w	r2, r5, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   21990:	bf18      	it	ne
   21992:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   21994:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   21998:	072a      	lsls	r2, r5, #28
   2199a:	d507      	bpl.n	219ac <nrfx_spim_xfer+0xbc>
    if (!p_cb->handler)
   2199c:	59ba      	ldr	r2, [r7, r6]
   2199e:	b972      	cbnz	r2, 219be <nrfx_spim_xfer+0xce>
        set_ss_pin_state(p_cb, false);
   219a0:	2100      	movs	r1, #0
   219a2:	4640      	mov	r0, r8
   219a4:	f003 ffa8 	bl	258f8 <set_ss_pin_state>
    return err_code;
   219a8:	480d      	ldr	r0, [pc, #52]	; (219e0 <nrfx_spim_xfer+0xf0>)
   219aa:	e7d7      	b.n	2195c <nrfx_spim_xfer+0x6c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   219ac:	2201      	movs	r2, #1
   219ae:	611a      	str	r2, [r3, #16]
    if (!p_cb->handler)
   219b0:	59ba      	ldr	r2, [r7, r6]
   219b2:	b922      	cbnz	r2, 219be <nrfx_spim_xfer+0xce>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   219b4:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
            while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   219b8:	2a00      	cmp	r2, #0
   219ba:	d0fb      	beq.n	219b4 <nrfx_spim_xfer+0xc4>
   219bc:	e7f0      	b.n	219a0 <nrfx_spim_xfer+0xb0>
    if (!enable)
   219be:	f015 0f04 	tst.w	r5, #4
   219c2:	f04f 0240 	mov.w	r2, #64	; 0x40
   219c6:	d002      	beq.n	219ce <nrfx_spim_xfer+0xde>
    p_reg->INTENCLR = mask;
   219c8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   219cc:	e7ec      	b.n	219a8 <nrfx_spim_xfer+0xb8>
    p_reg->INTENSET = mask;
   219ce:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   219d2:	e7e9      	b.n	219a8 <nrfx_spim_xfer+0xb8>
        return err_code;
   219d4:	4803      	ldr	r0, [pc, #12]	; (219e4 <nrfx_spim_xfer+0xf4>)
   219d6:	e7c1      	b.n	2195c <nrfx_spim_xfer+0x6c>
   219d8:	2000b304 	.word	0x2000b304
   219dc:	0bad000a 	.word	0x0bad000a
   219e0:	0bad0000 	.word	0x0bad0000
   219e4:	0bad000b 	.word	0x0bad000b

000219e8 <nrfx_spim_3_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   219e8:	4b06      	ldr	r3, [pc, #24]	; (21a04 <nrfx_spim_3_irq_handler+0x1c>)
   219ea:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
        nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
        return;
    }
#endif

    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   219ee:	b13a      	cbz	r2, 21a00 <nrfx_spim_3_irq_handler+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   219f0:	2200      	movs	r2, #0
   219f2:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   219f6:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        }
#endif
        nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
        NRFX_ASSERT(p_cb->handler);
        NRFX_LOG_DEBUG("Event: NRF_SPIM_EVENT_END.");
        finish_transfer(p_cb);
   219fa:	4803      	ldr	r0, [pc, #12]	; (21a08 <nrfx_spim_3_irq_handler+0x20>)
   219fc:	f003 bf8c 	b.w	25918 <finish_transfer>

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
}
   21a00:	4770      	bx	lr
   21a02:	bf00      	nop
   21a04:	4000c000 	.word	0x4000c000
   21a08:	2000b304 	.word	0x2000b304

00021a0c <nrfx_spim_4_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21a0c:	4b06      	ldr	r3, [pc, #24]	; (21a28 <nrfx_spim_4_irq_handler+0x1c>)
   21a0e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   21a12:	b13a      	cbz	r2, 21a24 <nrfx_spim_4_irq_handler+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21a14:	2200      	movs	r2, #0
   21a16:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   21a1a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        finish_transfer(p_cb);
   21a1e:	4803      	ldr	r0, [pc, #12]	; (21a2c <nrfx_spim_4_irq_handler+0x20>)
   21a20:	f003 bf7a 	b.w	25918 <finish_transfer>

#if NRFX_CHECK(NRFX_SPIM4_ENABLED)
void nrfx_spim_4_irq_handler(void)
{
    irq_handler(NRF_SPIM4, &m_cb[NRFX_SPIM4_INST_IDX]);
}
   21a24:	4770      	bx	lr
   21a26:	bf00      	nop
   21a28:	4000a000 	.word	0x4000a000
   21a2c:	2000b324 	.word	0x2000b324

00021a30 <nrfx_twim_init>:
    NRFX_ASSERT(p_config);
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   21a30:	f04f 0c34 	mov.w	ip, #52	; 0x34
{
   21a34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   21a38:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   21a3a:	4d46      	ldr	r5, [pc, #280]	; (21b54 <nrfx_twim_init+0x124>)
   21a3c:	fb0c fc06 	mul.w	ip, ip, r6
   21a40:	eb05 040c 	add.w	r4, r5, ip
{
   21a44:	469e      	mov	lr, r3
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   21a46:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   21a4a:	2b00      	cmp	r3, #0
   21a4c:	d17d      	bne.n	21b4a <nrfx_twim_init+0x11a>
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   21a4e:	6807      	ldr	r7, [r0, #0]
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler         = event_handler;
    p_cb->p_context       = p_context;
    p_cb->int_mask        = 0;
   21a50:	60a3      	str	r3, [r4, #8]
    p_cb->handler         = event_handler;
   21a52:	f845 200c 	str.w	r2, [r5, ip]
    p_cb->p_context       = p_context;
   21a56:	f8c4 e004 	str.w	lr, [r4, #4]
    p_cb->repeated        = false;
   21a5a:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    p_cb->busy            = false;
   21a5e:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   21a62:	7b4b      	ldrb	r3, [r1, #13]
   21a64:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
    p_cb->skip_gpio_cfg   = p_config->skip_gpio_cfg;
   21a68:	f891 c00e 	ldrb.w	ip, [r1, #14]
   21a6c:	f884 c033 	strb.w	ip, [r4, #51]	; 0x33
    if (p_config->skip_gpio_cfg && p_config->skip_psel_cfg)
   21a70:	688b      	ldr	r3, [r1, #8]
   21a72:	f1bc 0f00 	cmp.w	ip, #0
   21a76:	d01c      	beq.n	21ab2 <nrfx_twim_init+0x82>
   21a78:	7bcc      	ldrb	r4, [r1, #15]
   21a7a:	b944      	cbnz	r4, 21a8e <nrfx_twim_init+0x5e>
    if (p_config->frequency >= NRF_TWIM_FREQ_1000K)
   21a7c:	f1b3 6f7f 	cmp.w	r3, #267386880	; 0xff00000
   21a80:	d24d      	bcs.n	21b1e <nrfx_twim_init+0xee>
        nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
   21a82:	e9d1 4300 	ldrd	r4, r3, [r1]
    p_reg->PSEL.SCL = scl_pin;
   21a86:	f8c7 4508 	str.w	r4, [r7, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   21a8a:	f8c7 350c 	str.w	r3, [r7, #1292]	; 0x50c
    if (!twim_pins_configure(p_twim, p_config))
    {
        return NRFX_ERROR_INVALID_PARAM;
    }

    nrf_twim_frequency_set(p_twim, (nrf_twim_frequency_t)p_config->frequency);
   21a8e:	688b      	ldr	r3, [r1, #8]
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   21a90:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524

    if (p_cb->handler)
   21a94:	b122      	cbz	r2, 21aa0 <nrfx_twim_init+0x70>
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   21a96:	6800      	ldr	r0, [r0, #0]
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_twim),
            p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   21a98:	f340 3007 	sbfx	r0, r0, #12, #8
   21a9c:	f7fc fc20 	bl	1e2e0 <arch_irq_enable>
    }

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21aa0:	2334      	movs	r3, #52	; 0x34
   21aa2:	fb03 5506 	mla	r5, r3, r6, r5
   21aa6:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   21aa8:	482b      	ldr	r0, [pc, #172]	; (21b58 <nrfx_twim_init+0x128>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21aaa:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
}
   21aae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (p_config->frequency >= NRF_TWIM_FREQ_1000K)
   21ab2:	f1b3 6f7f 	cmp.w	r3, #267386880	; 0xff00000
   21ab6:	d345      	bcc.n	21b44 <nrfx_twim_init+0x114>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   21ab8:	680b      	ldr	r3, [r1, #0]
   21aba:	2b22      	cmp	r3, #34	; 0x22
   21abc:	d139      	bne.n	21b32 <nrfx_twim_init+0x102>
   21abe:	684b      	ldr	r3, [r1, #4]
   21ac0:	2b23      	cmp	r3, #35	; 0x23
   21ac2:	d144      	bne.n	21b4e <nrfx_twim_init+0x11e>
   21ac4:	f04f 0c0b 	mov.w	ip, #11
        TWIM_PIN_INIT(p_config->scl, drive);
   21ac8:	680c      	ldr	r4, [r1, #0]
        case 0: return NRF_P0;
   21aca:	4b24      	ldr	r3, [pc, #144]	; (21b5c <nrfx_twim_init+0x12c>)
   21acc:	f8df 8090 	ldr.w	r8, [pc, #144]	; 21b60 <nrfx_twim_init+0x130>
    *p_pin = pin_number & 0x1F;
   21ad0:	f004 091f 	and.w	r9, r4, #31
    return pin_number >> 5;
   21ad4:	0964      	lsrs	r4, r4, #5
        case 0: return NRF_P0;
   21ad6:	2c01      	cmp	r4, #1
   21ad8:	bf0c      	ite	eq
   21ada:	469e      	moveq	lr, r3
   21adc:	46c6      	movne	lr, r8
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21ade:	eb0e 0e89 	add.w	lr, lr, r9, lsl #2
   21ae2:	f8de 4200 	ldr.w	r4, [lr, #512]	; 0x200
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   21ae6:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   21aea:	f04c 0c0c 	orr.w	ip, ip, #12
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21aee:	f004 44e0 	and.w	r4, r4, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   21af2:	ea44 040c 	orr.w	r4, r4, ip
    reg->PIN_CNF[pin_number] = cnf;
   21af6:	f8ce 4200 	str.w	r4, [lr, #512]	; 0x200
        TWIM_PIN_INIT(p_config->sda, drive);
   21afa:	684c      	ldr	r4, [r1, #4]
    *p_pin = pin_number & 0x1F;
   21afc:	f004 0e1f 	and.w	lr, r4, #31
    return pin_number >> 5;
   21b00:	0964      	lsrs	r4, r4, #5
        case 0: return NRF_P0;
   21b02:	2c01      	cmp	r4, #1
   21b04:	bf18      	it	ne
   21b06:	4643      	movne	r3, r8
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21b08:	eb03 038e 	add.w	r3, r3, lr, lsl #2
   21b0c:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
   21b10:	f004 44e0 	and.w	r4, r4, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   21b14:	ea44 040c 	orr.w	r4, r4, ip
    reg->PIN_CNF[pin_number] = cnf;
   21b18:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
   21b1c:	e005      	b.n	21b2a <nrfx_twim_init+0xfa>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   21b1e:	680b      	ldr	r3, [r1, #0]
   21b20:	2b22      	cmp	r3, #34	; 0x22
   21b22:	d106      	bne.n	21b32 <nrfx_twim_init+0x102>
   21b24:	684b      	ldr	r3, [r1, #4]
   21b26:	2b23      	cmp	r3, #35	; 0x23
   21b28:	d111      	bne.n	21b4e <nrfx_twim_init+0x11e>
    if (!p_config->skip_psel_cfg)
   21b2a:	7bcb      	ldrb	r3, [r1, #15]
   21b2c:	2b00      	cmp	r3, #0
   21b2e:	d1ae      	bne.n	21a8e <nrfx_twim_init+0x5e>
   21b30:	e7a7      	b.n	21a82 <nrfx_twim_init+0x52>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   21b32:	2b23      	cmp	r3, #35	; 0x23
   21b34:	d10b      	bne.n	21b4e <nrfx_twim_init+0x11e>
            ((p_config->scl != e0e1_pin_2) || (p_config->sda != e0e1_pin_1)))
   21b36:	684b      	ldr	r3, [r1, #4]
   21b38:	2b22      	cmp	r3, #34	; 0x22
   21b3a:	d108      	bne.n	21b4e <nrfx_twim_init+0x11e>
    if (!p_config->skip_gpio_cfg)
   21b3c:	f1bc 0f00 	cmp.w	ip, #0
   21b40:	d1f3      	bne.n	21b2a <nrfx_twim_init+0xfa>
   21b42:	e7bf      	b.n	21ac4 <nrfx_twim_init+0x94>
        drive = NRF_GPIO_PIN_S0D1;
   21b44:	f04f 0c06 	mov.w	ip, #6
   21b48:	e7be      	b.n	21ac8 <nrfx_twim_init+0x98>
        return err_code;
   21b4a:	4806      	ldr	r0, [pc, #24]	; (21b64 <nrfx_twim_init+0x134>)
   21b4c:	e7af      	b.n	21aae <nrfx_twim_init+0x7e>
        return NRFX_ERROR_INVALID_PARAM;
   21b4e:	4806      	ldr	r0, [pc, #24]	; (21b68 <nrfx_twim_init+0x138>)
   21b50:	e7ad      	b.n	21aae <nrfx_twim_init+0x7e>
   21b52:	bf00      	nop
   21b54:	2000b344 	.word	0x2000b344
   21b58:	0bad0000 	.word	0x0bad0000
   21b5c:	40842800 	.word	0x40842800
   21b60:	40842500 	.word	0x40842500
   21b64:	0bad0005 	.word	0x0bad0005
   21b68:	0bad0004 	.word	0x0bad0004

00021b6c <nrfx_twim_enable>:
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   21b6c:	2106      	movs	r1, #6
void nrfx_twim_enable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);

    nrf_twim_enable(p_instance->p_twim);
   21b6e:	6803      	ldr	r3, [r0, #0]
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21b70:	7902      	ldrb	r2, [r0, #4]
   21b72:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500

    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   21b76:	2134      	movs	r1, #52	; 0x34
   21b78:	4b03      	ldr	r3, [pc, #12]	; (21b88 <nrfx_twim_enable+0x1c>)
   21b7a:	fb01 3302 	mla	r3, r1, r2, r3
   21b7e:	2202      	movs	r2, #2
   21b80:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance enabled: %d.", p_instance->drv_inst_idx);
}
   21b84:	4770      	bx	lr
   21b86:	bf00      	nop
   21b88:	2000b344 	.word	0x2000b344

00021b8c <nrfx_twim_disable>:

void nrfx_twim_disable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21b8c:	7901      	ldrb	r1, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   21b8e:	6802      	ldr	r2, [r0, #0]
    p_cb->int_mask = 0;
   21b90:	2034      	movs	r0, #52	; 0x34
   21b92:	4b0b      	ldr	r3, [pc, #44]	; (21bc0 <nrfx_twim_disable+0x34>)
   21b94:	fb00 3301 	mla	r3, r0, r1, r3
   21b98:	2100      	movs	r1, #0
    p_reg->INTENCLR = mask;
   21b9a:	480a      	ldr	r0, [pc, #40]	; (21bc4 <nrfx_twim_disable+0x38>)
   21b9c:	6099      	str	r1, [r3, #8]
   21b9e:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   21ba2:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
   21ba6:	f420 50bc 	bic.w	r0, r0, #6016	; 0x1780
   21baa:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   21bae:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    nrf_twim_shorts_disable(p_twim, NRF_TWIM_ALL_SHORTS_MASK);
    nrf_twim_disable(p_twim);

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21bb2:	2201      	movs	r2, #1
    p_cb->busy = false;
   21bb4:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21bb8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance disabled: %d.", p_instance->drv_inst_idx);
}
   21bbc:	4770      	bx	lr
   21bbe:	bf00      	nop
   21bc0:	2000b344 	.word	0x2000b344
   21bc4:	019c0202 	.word	0x019c0202

00021bc8 <nrfx_twim_xfer>:
                            nrfx_twim_xfer_desc_t const * p_xfer_desc,
                            uint32_t                      flags)
{
    nrfx_err_t err_code = NRFX_SUCCESS;
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
    p_cb->error = false;
   21bc8:	2334      	movs	r3, #52	; 0x34


nrfx_err_t nrfx_twim_xfer(nrfx_twim_t           const * p_instance,
                          nrfx_twim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   21bca:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21bce:	4617      	mov	r7, r2
    p_cb->error = false;
   21bd0:	2200      	movs	r2, #0
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
                                     p_xfer_desc->primary_length,
                                     p_xfer_desc->secondary_length));

    nrfx_err_t err_code = NRFX_SUCCESS;
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21bd2:	f890 e004 	ldrb.w	lr, [r0, #4]
    p_cb->error = false;
   21bd6:	f8df c2e4 	ldr.w	ip, [pc, #740]	; 21ebc <nrfx_twim_xfer+0x2f4>
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   21bda:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
   21bdc:	fb03 c30e 	mla	r3, r3, lr, ip
   21be0:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   21be4:	684b      	ldr	r3, [r1, #4]
{
   21be6:	460d      	mov	r5, r1
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   21be8:	b14b      	cbz	r3, 21bfe <nrfx_twim_xfer+0x36>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   21bea:	68cb      	ldr	r3, [r1, #12]
   21bec:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   21bf0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   21bf4:	d003      	beq.n	21bfe <nrfx_twim_xfer+0x36>
        return err_code;
   21bf6:	4eb2      	ldr	r6, [pc, #712]	; (21ec0 <nrfx_twim_xfer+0x2f8>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   21bf8:	4630      	mov	r0, r6
   21bfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (p_cb->busy)
   21bfe:	2634      	movs	r6, #52	; 0x34
   21c00:	fb06 c60e 	mla	r6, r6, lr, ip
    p_reg->INTENCLR = mask;
   21c04:	4baf      	ldr	r3, [pc, #700]	; (21ec4 <nrfx_twim_xfer+0x2fc>)
   21c06:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
   21c0a:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
   21c0e:	f003 0aff 	and.w	sl, r3, #255	; 0xff
   21c12:	b123      	cbz	r3, 21c1e <nrfx_twim_xfer+0x56>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   21c14:	68b3      	ldr	r3, [r6, #8]
        return err_code;
   21c16:	4eac      	ldr	r6, [pc, #688]	; (21ec8 <nrfx_twim_xfer+0x300>)
    p_reg->INTENSET = mask;
   21c18:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   21c1c:	e7ec      	b.n	21bf8 <nrfx_twim_xfer+0x30>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   21c1e:	f017 0f14 	tst.w	r7, #20
   21c22:	bf0c      	ite	eq
   21c24:	2301      	moveq	r3, #1
   21c26:	2300      	movne	r3, #0
    p_cb->xfer_desc = *p_xfer_desc;
   21c28:	46a9      	mov	r9, r5
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   21c2a:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
   21c2e:	f106 080c 	add.w	r8, r6, #12
   21c32:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
   21c36:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
   21c3a:	f8d9 3000 	ldr.w	r3, [r9]
    p_cb->flags = flags;
   21c3e:	6237      	str	r7, [r6, #32]
    p_cb->xfer_desc = *p_xfer_desc;
   21c40:	f8c8 3000 	str.w	r3, [r8]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   21c44:	f3c7 1300 	ubfx	r3, r7, #4, #1
   21c48:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   21c4c:	786b      	ldrb	r3, [r5, #1]
   21c4e:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21c52:	f8c4 a104 	str.w	sl, [r4, #260]	; 0x104
   21c56:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   21c5a:	f8c4 a124 	str.w	sl, [r4, #292]	; 0x124
   21c5e:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
   21c62:	f8c4 a160 	str.w	sl, [r4, #352]	; 0x160
   21c66:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
   21c6a:	f8c4 a148 	str.w	sl, [r4, #328]	; 0x148
   21c6e:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   21c72:	f017 0301 	ands.w	r3, r7, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   21c76:	bf18      	it	ne
   21c78:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   21c7a:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   21c7e:	f017 0302 	ands.w	r3, r7, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   21c82:	bf18      	it	ne
   21c84:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   21c86:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
   21c8a:	782b      	ldrb	r3, [r5, #0]
   21c8c:	2b03      	cmp	r3, #3
   21c8e:	f200 80b9 	bhi.w	21e04 <nrfx_twim_xfer+0x23c>
   21c92:	e8df f003 	tbb	[pc, r3]
   21c96:	a48b      	.short	0xa48b
   21c98:	026d      	.short	0x026d
   21c9a:	692b      	ldr	r3, [r5, #16]
   21c9c:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   21ca0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   21ca4:	d1a7      	bne.n	21bf6 <nrfx_twim_xfer+0x2e>
    p_reg->SHORTS = mask;
   21ca6:	f44f 7380 	mov.w	r3, #256	; 0x100
   21caa:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21cae:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21cb0:	68ea      	ldr	r2, [r5, #12]
   21cb2:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21cb6:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21cba:	2300      	movs	r3, #0
   21cbc:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   21cc0:	f8d4 2150 	ldr.w	r2, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21cc4:	2201      	movs	r2, #1
   21cc6:	6222      	str	r2, [r4, #32]
   21cc8:	60a2      	str	r2, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21cca:	f8d4 2150 	ldr.w	r2, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   21cce:	2a00      	cmp	r2, #0
   21cd0:	d0fb      	beq.n	21cca <nrfx_twim_xfer+0x102>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21cd2:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   21cd6:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21cda:	692a      	ldr	r2, [r5, #16]
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   21cdc:	68ab      	ldr	r3, [r5, #8]
   21cde:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21ce2:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   21ce6:	2334      	movs	r3, #52	; 0x34
   21ce8:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   21cec:	fb03 c30e 	mla	r3, r3, lr, ip
   21cf0:	609a      	str	r2, [r3, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   21cf2:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   21cf4:	4e75      	ldr	r6, [pc, #468]	; (21ecc <nrfx_twim_xfer+0x304>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   21cf6:	0738      	lsls	r0, r7, #28
   21cf8:	d407      	bmi.n	21d0a <nrfx_twim_xfer+0x142>
   21cfa:	782a      	ldrb	r2, [r5, #0]
   21cfc:	2a03      	cmp	r2, #3
   21cfe:	d004      	beq.n	21d0a <nrfx_twim_xfer+0x142>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21d00:	2201      	movs	r2, #1
   21d02:	50e2      	str	r2, [r4, r3]
        if (p_xfer_desc->primary_length == 0)
   21d04:	686b      	ldr	r3, [r5, #4]
   21d06:	b903      	cbnz	r3, 21d0a <nrfx_twim_xfer+0x142>
   21d08:	6162      	str	r2, [r4, #20]
    if (p_cb->handler)
   21d0a:	2334      	movs	r3, #52	; 0x34
   21d0c:	fb03 f30e 	mul.w	r3, r3, lr
   21d10:	f85c 1003 	ldr.w	r1, [ip, r3]
   21d14:	eb0c 0203 	add.w	r2, ip, r3
   21d18:	2900      	cmp	r1, #0
   21d1a:	d176      	bne.n	21e0a <nrfx_twim_xfer+0x242>
   21d1c:	2001      	movs	r0, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21d1e:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   21d22:	2b00      	cmp	r3, #0
   21d24:	f000 8089 	beq.w	21e3a <nrfx_twim_xfer+0x272>
   21d28:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21d2c:	2b00      	cmp	r3, #0
   21d2e:	f040 8087 	bne.w	21e40 <nrfx_twim_xfer+0x278>
   21d32:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   21d36:	2b00      	cmp	r3, #0
   21d38:	f000 8095 	beq.w	21e66 <nrfx_twim_xfer+0x29e>
                transmission_finished = true;
   21d3c:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21d3e:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
   21d42:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21d46:	f8d4 5160 	ldr.w	r5, [r4, #352]	; 0x160
    return p_reg->SHORTS;
   21d4a:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   21d4e:	2d00      	cmp	r5, #0
   21d50:	f000 8081 	beq.w	21e56 <nrfx_twim_xfer+0x28e>
   21d54:	f412 7f00 	tst.w	r2, #512	; 0x200
   21d58:	f402 7280 	and.w	r2, r2, #256	; 0x100
   21d5c:	d17e      	bne.n	21e5c <nrfx_twim_xfer+0x294>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21d5e:	6220      	str	r0, [r4, #32]
   21d60:	6160      	str	r0, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   21d62:	2a00      	cmp	r2, #0
   21d64:	d0db      	beq.n	21d1e <nrfx_twim_xfer+0x156>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21d66:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
   21d6a:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
                    transmission_finished = false;
   21d6e:	e7d6      	b.n	21d1e <nrfx_twim_xfer+0x156>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21d70:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21d72:	68ea      	ldr	r2, [r5, #12]
   21d74:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21d78:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   21d7c:	692b      	ldr	r3, [r5, #16]
   21d7e:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   21d82:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   21d86:	f47f af36 	bne.w	21bf6 <nrfx_twim_xfer+0x2e>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   21d8a:	68aa      	ldr	r2, [r5, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   21d8c:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
   21d90:	f44f 5384 	mov.w	r3, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
   21d94:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   21d98:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21d9c:	2334      	movs	r3, #52	; 0x34
   21d9e:	2202      	movs	r2, #2
   21da0:	fb03 c30e 	mla	r3, r3, lr, ip
   21da4:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21da6:	2301      	movs	r3, #1
   21da8:	6223      	str	r3, [r4, #32]
   21daa:	e7a2      	b.n	21cf2 <nrfx_twim_xfer+0x12a>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21dac:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21dae:	68ea      	ldr	r2, [r5, #12]
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   21db0:	f017 0f20 	tst.w	r7, #32
   21db4:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21db8:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   21dbc:	f04f 0334 	mov.w	r3, #52	; 0x34
   21dc0:	d008      	beq.n	21dd4 <nrfx_twim_xfer+0x20c>
    p_reg->SHORTS = mask;
   21dc2:	f44f 7280 	mov.w	r2, #256	; 0x100
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   21dc6:	fb03 c30e 	mla	r3, r3, lr, ip
   21dca:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
   21dce:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   21dd2:	e7e7      	b.n	21da4 <nrfx_twim_xfer+0x1dc>
   21dd4:	f44f 7200 	mov.w	r2, #512	; 0x200
   21dd8:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21ddc:	e7df      	b.n	21d9e <nrfx_twim_xfer+0x1d6>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21dde:	686b      	ldr	r3, [r5, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   21de0:	68ea      	ldr	r2, [r5, #12]
   21de2:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   21de6:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   21dea:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   21dee:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21df2:	2334      	movs	r3, #52	; 0x34
   21df4:	2202      	movs	r2, #2
   21df6:	fb03 c30e 	mla	r3, r3, lr, ip
   21dfa:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21dfc:	2301      	movs	r3, #1
   21dfe:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
   21e00:	2300      	movs	r3, #0
   21e02:	e777      	b.n	21cf4 <nrfx_twim_xfer+0x12c>
    switch (p_xfer_desc->type)
   21e04:	2308      	movs	r3, #8
   21e06:	4e32      	ldr	r6, [pc, #200]	; (21ed0 <nrfx_twim_xfer+0x308>)
   21e08:	e775      	b.n	21cf6 <nrfx_twim_xfer+0x12e>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   21e0a:	0779      	lsls	r1, r7, #29
            p_cb->int_mask = 0;
   21e0c:	bf44      	itt	mi
   21e0e:	2300      	movmi	r3, #0
   21e10:	6093      	strmi	r3, [r2, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   21e12:	067a      	lsls	r2, r7, #25
   21e14:	d406      	bmi.n	21e24 <nrfx_twim_xfer+0x25c>
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   21e16:	2334      	movs	r3, #52	; 0x34
   21e18:	fb03 c30e 	mla	r3, r3, lr, ip
   21e1c:	689a      	ldr	r2, [r3, #8]
   21e1e:	f042 0202 	orr.w	r2, r2, #2
   21e22:	609a      	str	r2, [r3, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   21e24:	2334      	movs	r3, #52	; 0x34
   21e26:	fb03 c30e 	mla	r3, r3, lr, ip
   21e2a:	689a      	ldr	r2, [r3, #8]
   21e2c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
   21e30:	609a      	str	r2, [r3, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   21e32:	689b      	ldr	r3, [r3, #8]
    p_reg->INTENSET = mask;
   21e34:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   21e38:	e6de      	b.n	21bf8 <nrfx_twim_xfer+0x30>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21e3a:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21e3e:	b123      	cbz	r3, 21e4a <nrfx_twim_xfer+0x282>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21e40:	f8c4 1104 	str.w	r1, [r4, #260]	; 0x104
   21e44:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21e48:	e773      	b.n	21d32 <nrfx_twim_xfer+0x16a>
   21e4a:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   21e4e:	2a00      	cmp	r2, #0
   21e50:	f43f af65 	beq.w	21d1e <nrfx_twim_xfer+0x156>
   21e54:	e773      	b.n	21d3e <nrfx_twim_xfer+0x176>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21e56:	6220      	str	r0, [r4, #32]
   21e58:	6160      	str	r0, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   21e5a:	e760      	b.n	21d1e <nrfx_twim_xfer+0x156>
   21e5c:	2a00      	cmp	r2, #0
   21e5e:	d182      	bne.n	21d66 <nrfx_twim_xfer+0x19e>
        } while (!transmission_finished);
   21e60:	2b00      	cmp	r3, #0
   21e62:	f43f af5c 	beq.w	21d1e <nrfx_twim_xfer+0x156>
        p_cb->busy = false;
   21e66:	2134      	movs	r1, #52	; 0x34
   21e68:	2000      	movs	r0, #0
   21e6a:	fb01 c20e 	mla	r2, r1, lr, ip
    uint32_t error_source = p_reg->ERRORSRC;
   21e6e:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   21e72:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
   21e76:	f882 002f 	strb.w	r0, [r2, #47]	; 0x2f
        if (errorsrc)
   21e7a:	b18b      	cbz	r3, 21ea0 <nrfx_twim_xfer+0x2d8>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   21e7c:	4a15      	ldr	r2, [pc, #84]	; (21ed4 <nrfx_twim_xfer+0x30c>)
   21e7e:	f013 0f01 	tst.w	r3, #1
   21e82:	4e15      	ldr	r6, [pc, #84]	; (21ed8 <nrfx_twim_xfer+0x310>)
   21e84:	bf18      	it	ne
   21e86:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   21e88:	f013 0f02 	tst.w	r3, #2
   21e8c:	f102 0201 	add.w	r2, r2, #1
   21e90:	bf18      	it	ne
   21e92:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   21e94:	f013 0f04 	tst.w	r3, #4
   21e98:	4b10      	ldr	r3, [pc, #64]	; (21edc <nrfx_twim_xfer+0x314>)
   21e9a:	bf18      	it	ne
   21e9c:	461e      	movne	r6, r3
   21e9e:	e6ab      	b.n	21bf8 <nrfx_twim_xfer+0x30>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   21ea0:	067b      	lsls	r3, r7, #25
   21ea2:	f53f aea9 	bmi.w	21bf8 <nrfx_twim_xfer+0x30>
                !xfer_completeness_check(p_twim, p_cb))
   21ea6:	4620      	mov	r0, r4
   21ea8:	fb0e c101 	mla	r1, lr, r1, ip
   21eac:	f003 fd43 	bl	25936 <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
   21eb0:	4b09      	ldr	r3, [pc, #36]	; (21ed8 <nrfx_twim_xfer+0x310>)
   21eb2:	2800      	cmp	r0, #0
   21eb4:	bf08      	it	eq
   21eb6:	461e      	moveq	r6, r3
   21eb8:	e69e      	b.n	21bf8 <nrfx_twim_xfer+0x30>
   21eba:	bf00      	nop
   21ebc:	2000b344 	.word	0x2000b344
   21ec0:	0bad000a 	.word	0x0bad000a
   21ec4:	019c0202 	.word	0x019c0202
   21ec8:	0bad000b 	.word	0x0bad000b
   21ecc:	0bad0000 	.word	0x0bad0000
   21ed0:	0bad0004 	.word	0x0bad0004
   21ed4:	0bae0000 	.word	0x0bae0000
   21ed8:	0bad0001 	.word	0x0bad0001
   21edc:	0bae0002 	.word	0x0bae0002

00021ee0 <nrfx_twim_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
   21ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21ee2:	4d5a      	ldr	r5, [pc, #360]	; (2204c <nrfx_twim_1_irq_handler+0x16c>)
   21ee4:	4c5a      	ldr	r4, [pc, #360]	; (22050 <nrfx_twim_1_irq_handler+0x170>)
   21ee6:	f8d5 3124 	ldr.w	r3, [r5, #292]	; 0x124
   21eea:	b087      	sub	sp, #28
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   21eec:	b1fb      	cbz	r3, 21f2e <nrfx_twim_1_irq_handler+0x4e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21eee:	2300      	movs	r3, #0
   21ef0:	f8c5 3124 	str.w	r3, [r5, #292]	; 0x124
   21ef4:	f8d5 3124 	ldr.w	r3, [r5, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21ef8:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21efc:	b9bb      	cbnz	r3, 21f2e <nrfx_twim_1_irq_handler+0x4e>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   21efe:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   21f00:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21f04:	2302      	movs	r3, #2
   21f06:	60a3      	str	r3, [r4, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   21f08:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   21f0a:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21f0e:	f8d5 3160 	ldr.w	r3, [r5, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   21f12:	b11b      	cbz	r3, 21f1c <nrfx_twim_1_irq_handler+0x3c>
    return p_reg->SHORTS;
   21f14:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
   21f18:	059e      	lsls	r6, r3, #22
   21f1a:	d403      	bmi.n	21f24 <nrfx_twim_1_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21f1c:	2201      	movs	r2, #1
   21f1e:	4b4b      	ldr	r3, [pc, #300]	; (2204c <nrfx_twim_1_irq_handler+0x16c>)
   21f20:	621a      	str	r2, [r3, #32]
   21f22:	615a      	str	r2, [r3, #20]
            p_cb->error = true;
   21f24:	2301      	movs	r3, #1
   21f26:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
}
   21f2a:	b007      	add	sp, #28
   21f2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21f2e:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21f32:	2b00      	cmp	r3, #0
   21f34:	d05a      	beq.n	21fec <nrfx_twim_1_irq_handler+0x10c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21f36:	2300      	movs	r3, #0
   21f38:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   21f3c:	6a27      	ldr	r7, [r4, #32]
   21f3e:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
   21f42:	067d      	lsls	r5, r7, #25
   21f44:	d40a      	bmi.n	21f5c <nrfx_twim_1_irq_handler+0x7c>
   21f46:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   21f4a:	b93b      	cbnz	r3, 21f5c <nrfx_twim_1_irq_handler+0x7c>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   21f4c:	4940      	ldr	r1, [pc, #256]	; (22050 <nrfx_twim_1_irq_handler+0x170>)
   21f4e:	483f      	ldr	r0, [pc, #252]	; (2204c <nrfx_twim_1_irq_handler+0x16c>)
   21f50:	f003 fcf1 	bl	25936 <xfer_completeness_check>
   21f54:	f080 0001 	eor.w	r0, r0, #1
   21f58:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   21f5c:	f017 0704 	ands.w	r7, r7, #4
            if (!p_cb->repeated || p_cb->error)
   21f60:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   21f64:	d120      	bne.n	21fa8 <nrfx_twim_1_irq_handler+0xc8>
            event.xfer_desc = p_cb->xfer_desc;
   21f66:	4e3b      	ldr	r6, [pc, #236]	; (22054 <nrfx_twim_1_irq_handler+0x174>)
   21f68:	ad01      	add	r5, sp, #4
   21f6a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   21f6c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   21f6e:	6833      	ldr	r3, [r6, #0]
   21f70:	602b      	str	r3, [r5, #0]
   21f72:	4b36      	ldr	r3, [pc, #216]	; (2204c <nrfx_twim_1_irq_handler+0x16c>)
   21f74:	f8c3 7160 	str.w	r7, [r3, #352]	; 0x160
   21f78:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
   21f7c:	f8c3 715c 	str.w	r7, [r3, #348]	; 0x15c
   21f80:	f8d3 215c 	ldr.w	r2, [r3, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
   21f84:	f1bc 0f00 	cmp.w	ip, #0
   21f88:	d002      	beq.n	21f90 <nrfx_twim_1_irq_handler+0xb0>
   21f8a:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
   21f8e:	b15a      	cbz	r2, 21fa8 <nrfx_twim_1_irq_handler+0xc8>
    p_reg->SHORTS = mask;
   21f90:	2200      	movs	r2, #0
   21f92:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                p_cb->int_mask = 0;
   21f96:	60a2      	str	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   21f98:	4a2f      	ldr	r2, [pc, #188]	; (22058 <nrfx_twim_1_irq_handler+0x178>)
   21f9a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   21f9e:	f44f 7200 	mov.w	r2, #512	; 0x200
   21fa2:	4b2e      	ldr	r3, [pc, #184]	; (2205c <nrfx_twim_1_irq_handler+0x17c>)
   21fa4:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    uint32_t error_source = p_reg->ERRORSRC;
   21fa8:	4a28      	ldr	r2, [pc, #160]	; (2204c <nrfx_twim_1_irq_handler+0x16c>)
   21faa:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   21fae:	0798      	lsls	r0, r3, #30
    p_reg->ERRORSRC = error_source;
   21fb0:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
   21fb4:	d443      	bmi.n	2203e <nrfx_twim_1_irq_handler+0x15e>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   21fb6:	0759      	lsls	r1, r3, #29
   21fb8:	d443      	bmi.n	22042 <nrfx_twim_1_irq_handler+0x162>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   21fba:	07da      	lsls	r2, r3, #31
   21fbc:	d443      	bmi.n	22046 <nrfx_twim_1_irq_handler+0x166>
    else if (p_cb->error)
   21fbe:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   21fc2:	009b      	lsls	r3, r3, #2
   21fc4:	b2db      	uxtb	r3, r3
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   21fc6:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
   21fca:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   21fce:	b90b      	cbnz	r3, 21fd4 <nrfx_twim_1_irq_handler+0xf4>
        p_cb->busy = false;
   21fd0:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   21fd4:	6a23      	ldr	r3, [r4, #32]
   21fd6:	075b      	lsls	r3, r3, #29
   21fd8:	d503      	bpl.n	21fe2 <nrfx_twim_1_irq_handler+0x102>
   21fda:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   21fde:	2b00      	cmp	r3, #0
   21fe0:	d0a3      	beq.n	21f2a <nrfx_twim_1_irq_handler+0x4a>
        p_cb->handler(&event, p_cb->p_context);
   21fe2:	e9d4 3100 	ldrd	r3, r1, [r4]
   21fe6:	4668      	mov	r0, sp
   21fe8:	4798      	blx	r3
}
   21fea:	e79e      	b.n	21f2a <nrfx_twim_1_irq_handler+0x4a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21fec:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
   21ff0:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   21ff4:	7b23      	ldrb	r3, [r4, #12]
   21ff6:	b983      	cbnz	r3, 2201a <nrfx_twim_1_irq_handler+0x13a>
            event.xfer_desc = p_cb->xfer_desc;
   21ff8:	4f16      	ldr	r7, [pc, #88]	; (22054 <nrfx_twim_1_irq_handler+0x174>)
   21ffa:	ae01      	add	r6, sp, #4
   21ffc:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   21ffe:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   22000:	683b      	ldr	r3, [r7, #0]
   22002:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
   22004:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   22008:	2b00      	cmp	r3, #0
   2200a:	d1cd      	bne.n	21fa8 <nrfx_twim_1_irq_handler+0xc8>
    p_reg->SHORTS = mask;
   2200c:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
                p_cb->int_mask = 0;
   22010:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   22012:	4b11      	ldr	r3, [pc, #68]	; (22058 <nrfx_twim_1_irq_handler+0x178>)
   22014:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
   22018:	e7c1      	b.n	21f9e <nrfx_twim_1_irq_handler+0xbe>
    p_reg->SHORTS = mask;
   2201a:	f44f 7300 	mov.w	r3, #512	; 0x200
   2201e:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   22022:	f240 2302 	movw	r3, #514	; 0x202
   22026:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   22028:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   2202c:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   22030:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   22032:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   22036:	2301      	movs	r3, #1
   22038:	60ab      	str	r3, [r5, #8]
   2203a:	622b      	str	r3, [r5, #32]
            return;
   2203c:	e775      	b.n	21f2a <nrfx_twim_1_irq_handler+0x4a>
   2203e:	2301      	movs	r3, #1
   22040:	e7c1      	b.n	21fc6 <nrfx_twim_1_irq_handler+0xe6>
   22042:	2302      	movs	r3, #2
   22044:	e7bf      	b.n	21fc6 <nrfx_twim_1_irq_handler+0xe6>
   22046:	2303      	movs	r3, #3
   22048:	e7bd      	b.n	21fc6 <nrfx_twim_1_irq_handler+0xe6>
   2204a:	bf00      	nop
   2204c:	40009000 	.word	0x40009000
   22050:	2000b344 	.word	0x2000b344
   22054:	2000b350 	.word	0x2000b350
   22058:	019c0202 	.word	0x019c0202
   2205c:	e000e100 	.word	0xe000e100

00022060 <ep_state_access>:
 * @param ep Endpoint number.
 */
static inline usbd_ep_state_t* ep_state_access(nrfx_usbd_ep_t ep)
{
    NRFX_USBD_ASSERT_EP_VALID(ep);
    return ((NRF_USBD_EPIN_CHECK(ep) ? m_ep_state.ep_in : m_ep_state.ep_out) +
   22060:	4b05      	ldr	r3, [pc, #20]	; (22078 <ep_state_access+0x18>)
   22062:	f010 0f80 	tst.w	r0, #128	; 0x80
   22066:	f1a3 0290 	sub.w	r2, r3, #144	; 0x90
   2206a:	bf08      	it	eq
   2206c:	4613      	moveq	r3, r2
        NRF_USBD_EP_NR_GET(ep));
   2206e:	f000 000f 	and.w	r0, r0, #15
}
   22072:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   22076:	4770      	bx	lr
   22078:	2000b520 	.word	0x2000b520

0002207c <ev_usbreset_handler>:
 * @{
 */

static void ev_usbreset_handler(void)
{
    m_bus_suspend = false;
   2207c:	2300      	movs	r3, #0
{
   2207e:	b507      	push	{r0, r1, r2, lr}
    m_bus_suspend = false;
   22080:	4a06      	ldr	r2, [pc, #24]	; (2209c <ev_usbreset_handler+0x20>)

    const nrfx_usbd_evt_t evt = {
            .type = NRFX_USBD_EVT_RESET
    };

    m_event_handler(&evt);
   22082:	a801      	add	r0, sp, #4
    m_bus_suspend = false;
   22084:	7013      	strb	r3, [r2, #0]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   22086:	4a06      	ldr	r2, [pc, #24]	; (220a0 <ev_usbreset_handler+0x24>)
   22088:	7013      	strb	r3, [r2, #0]
    const nrfx_usbd_evt_t evt = {
   2208a:	2301      	movs	r3, #1
   2208c:	9301      	str	r3, [sp, #4]
    m_event_handler(&evt);
   2208e:	4b05      	ldr	r3, [pc, #20]	; (220a4 <ev_usbreset_handler+0x28>)
   22090:	681b      	ldr	r3, [r3, #0]
   22092:	4798      	blx	r3
}
   22094:	b003      	add	sp, #12
   22096:	f85d fb04 	ldr.w	pc, [sp], #4
   2209a:	bf00      	nop
   2209c:	2000b635 	.word	0x2000b635
   220a0:	2000b634 	.word	0x2000b634
   220a4:	2000b5b8 	.word	0x2000b5b8

000220a8 <ev_usbevent_handler>:
    };
    m_event_handler(&evt);
}

static void ev_usbevent_handler(void)
{
   220a8:	b513      	push	{r0, r1, r4, lr}
    return p_reg->EVENTCAUSE;
   220aa:	4b19      	ldr	r3, [pc, #100]	; (22110 <ev_usbevent_handler+0x68>)
   220ac:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
    p_reg->EVENTCAUSE = flags;
   220b0:	f8c3 4400 	str.w	r4, [r3, #1024]	; 0x400
    if (event & NRF_USBD_EVENTCAUSE_ISOOUTCRC_MASK)
    {
        NRFX_LOG_DEBUG("USBD event: ISOOUTCRC");
        /* Currently no support */
    }
    if (event & NRF_USBD_EVENTCAUSE_SUSPEND_MASK)
   220b4:	05e1      	lsls	r1, r4, #23
    (void) p_reg->EVENTCAUSE;
   220b6:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   220ba:	d508      	bpl.n	220ce <ev_usbevent_handler+0x26>
    {
        NRFX_LOG_DEBUG("USBD event: SUSPEND");
        m_bus_suspend = true;
   220bc:	2201      	movs	r2, #1
   220be:	4b15      	ldr	r3, [pc, #84]	; (22114 <ev_usbevent_handler+0x6c>)
        const nrfx_usbd_evt_t evt = {
                .type = NRFX_USBD_EVT_SUSPEND
        };
        m_event_handler(&evt);
   220c0:	a801      	add	r0, sp, #4
        m_bus_suspend = true;
   220c2:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
   220c4:	2302      	movs	r3, #2
   220c6:	9301      	str	r3, [sp, #4]
        m_event_handler(&evt);
   220c8:	4b13      	ldr	r3, [pc, #76]	; (22118 <ev_usbevent_handler+0x70>)
   220ca:	681b      	ldr	r3, [r3, #0]
   220cc:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   220ce:	05a2      	lsls	r2, r4, #22
   220d0:	d508      	bpl.n	220e4 <ev_usbevent_handler+0x3c>
    {
        NRFX_LOG_DEBUG("USBD event: RESUME");
        m_bus_suspend = false;
   220d2:	2200      	movs	r2, #0
   220d4:	4b0f      	ldr	r3, [pc, #60]	; (22114 <ev_usbevent_handler+0x6c>)
        const nrfx_usbd_evt_t evt = {
                .type = NRFX_USBD_EVT_RESUME
        };
        m_event_handler(&evt);
   220d6:	a801      	add	r0, sp, #4
        m_bus_suspend = false;
   220d8:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
   220da:	2303      	movs	r3, #3
   220dc:	9301      	str	r3, [sp, #4]
        m_event_handler(&evt);
   220de:	4b0e      	ldr	r3, [pc, #56]	; (22118 <ev_usbevent_handler+0x70>)
   220e0:	681b      	ldr	r3, [r3, #0]
   220e2:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_WUREQ_MASK)
   220e4:	0563      	lsls	r3, r4, #21
   220e6:	d510      	bpl.n	2210a <ev_usbevent_handler+0x62>
    {
        NRFX_LOG_DEBUG("USBD event: WUREQ (%s)", m_bus_suspend ? "In Suspend" : "Active");
        if (m_bus_suspend)
   220e8:	4b0a      	ldr	r3, [pc, #40]	; (22114 <ev_usbevent_handler+0x6c>)
   220ea:	781a      	ldrb	r2, [r3, #0]
   220ec:	b16a      	cbz	r2, 2210a <ev_usbevent_handler+0x62>
        {
            NRFX_ASSERT(!nrf_usbd_lowpower_check(NRF_USBD));
            m_bus_suspend = false;
   220ee:	2200      	movs	r2, #0
   220f0:	701a      	strb	r2, [r3, #0]
    p_reg->DPDMVALUE = ((uint32_t)val) << USBD_DPDMVALUE_STATE_Pos;
   220f2:	2201      	movs	r2, #1
   220f4:	4b06      	ldr	r3, [pc, #24]	; (22110 <ev_usbevent_handler+0x68>)
            nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_DRIVEDPDM);

            const nrfx_usbd_evt_t evt = {
                    .type = NRFX_USBD_EVT_WUREQ
            };
            m_event_handler(&evt);
   220f6:	a801      	add	r0, sp, #4
   220f8:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   220fc:	659a      	str	r2, [r3, #88]	; 0x58
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   220fe:	6d9b      	ldr	r3, [r3, #88]	; 0x58
            const nrfx_usbd_evt_t evt = {
   22100:	2304      	movs	r3, #4
   22102:	9301      	str	r3, [sp, #4]
            m_event_handler(&evt);
   22104:	4b04      	ldr	r3, [pc, #16]	; (22118 <ev_usbevent_handler+0x70>)
   22106:	681b      	ldr	r3, [r3, #0]
   22108:	4798      	blx	r3
        }
    }
}
   2210a:	b002      	add	sp, #8
   2210c:	bd10      	pop	{r4, pc}
   2210e:	bf00      	nop
   22110:	40036000 	.word	0x40036000
   22114:	2000b635 	.word	0x2000b635
   22118:	2000b5b8 	.word	0x2000b5b8

0002211c <nrfx_usbd_feeder_flash>:
{
   2211c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2211e:	684b      	ldr	r3, [r1, #4]
   22120:	4606      	mov	r6, r0
   22122:	429a      	cmp	r2, r3
   22124:	bf28      	it	cs
   22126:	461a      	movcs	r2, r3
   22128:	4615      	mov	r5, r2
   2212a:	460c      	mov	r4, r1
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   2212c:	4f08      	ldr	r7, [pc, #32]	; (22150 <nrfx_usbd_feeder_flash+0x34>)
   2212e:	6809      	ldr	r1, [r1, #0]
   22130:	4638      	mov	r0, r7
   22132:	f002 ff56 	bl	24fe2 <memcpy>
    p_next->size = tx_size;
   22136:	e9c6 7500 	strd	r7, r5, [r6]
    p_transfer->size -= tx_size;
   2213a:	6860      	ldr	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
   2213c:	6823      	ldr	r3, [r4, #0]
    p_transfer->size -= tx_size;
   2213e:	1b40      	subs	r0, r0, r5
    p_transfer->p_data.addr += tx_size;
   22140:	442b      	add	r3, r5
    p_transfer->size -= tx_size;
   22142:	6060      	str	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
   22144:	6023      	str	r3, [r4, #0]
}
   22146:	3800      	subs	r0, #0
   22148:	bf18      	it	ne
   2214a:	2001      	movne	r0, #1
   2214c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2214e:	bf00      	nop
   22150:	2000b378 	.word	0x2000b378

00022154 <nrfx_usbd_feeder_flash_zlp>:
{
   22154:	b570      	push	{r4, r5, r6, lr}
   22156:	684b      	ldr	r3, [r1, #4]
   22158:	4606      	mov	r6, r0
   2215a:	429a      	cmp	r2, r3
   2215c:	bf28      	it	cs
   2215e:	461a      	movcs	r2, r3
   22160:	460d      	mov	r5, r1
   22162:	4614      	mov	r4, r2
    if (tx_size != 0)
   22164:	b18a      	cbz	r2, 2218a <nrfx_usbd_feeder_flash_zlp+0x36>
        memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   22166:	6809      	ldr	r1, [r1, #0]
   22168:	4809      	ldr	r0, [pc, #36]	; (22190 <nrfx_usbd_feeder_flash_zlp+0x3c>)
   2216a:	f002 ff3a 	bl	24fe2 <memcpy>
        p_next->p_data.tx = p_buffer;
   2216e:	4b08      	ldr	r3, [pc, #32]	; (22190 <nrfx_usbd_feeder_flash_zlp+0x3c>)
    p_next->size = tx_size;
   22170:	e9c6 3400 	strd	r3, r4, [r6]
    p_transfer->size -= tx_size;
   22174:	686b      	ldr	r3, [r5, #4]
}
   22176:	1e20      	subs	r0, r4, #0
    p_transfer->size -= tx_size;
   22178:	eba3 0304 	sub.w	r3, r3, r4
   2217c:	606b      	str	r3, [r5, #4]
    p_transfer->p_data.addr += tx_size;
   2217e:	682b      	ldr	r3, [r5, #0]
}
   22180:	bf18      	it	ne
   22182:	2001      	movne	r0, #1
    p_transfer->p_data.addr += tx_size;
   22184:	4423      	add	r3, r4
   22186:	602b      	str	r3, [r5, #0]
}
   22188:	bd70      	pop	{r4, r5, r6, pc}
   2218a:	4613      	mov	r3, r2
   2218c:	e7f0      	b.n	22170 <nrfx_usbd_feeder_flash_zlp+0x1c>
   2218e:	bf00      	nop
   22190:	2000b378 	.word	0x2000b378

00022194 <ev_sof_handler>:
    nrfx_usbd_evt_t evt =  {
   22194:	2300      	movs	r3, #0
{
   22196:	b507      	push	{r0, r1, r2, lr}
    nrfx_usbd_evt_t evt =  {
   22198:	f88d 3004 	strb.w	r3, [sp, #4]
    return p_reg->FRAMECNTR;
   2219c:	4b0b      	ldr	r3, [pc, #44]	; (221cc <ev_sof_handler+0x38>)
    m_event_handler(&evt);
   2219e:	a801      	add	r0, sp, #4
   221a0:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
            .data = { .sof = { .framecnt = (uint16_t)nrf_usbd_framecntr_get(NRF_USBD) }}
   221a4:	f8ad 2006 	strh.w	r2, [sp, #6]
    size_t size_isoout = p_reg->SIZE.ISOOUT;
   221a8:	f8d3 34c0 	ldr.w	r3, [r3, #1216]	; 0x4c0
    m_ep_ready |= iso_ready_mask;
   221ac:	4a08      	ldr	r2, [pc, #32]	; (221d0 <ev_sof_handler+0x3c>)
    uint32_t iso_ready_mask = (1U << ep2bit(NRFX_USBD_EPIN8));
   221ae:	2b00      	cmp	r3, #0
   221b0:	bf14      	ite	ne
   221b2:	f04f 2101 	movne.w	r1, #16777472	; 0x1000100
   221b6:	f44f 7180 	moveq.w	r1, #256	; 0x100
    m_ep_ready |= iso_ready_mask;
   221ba:	6813      	ldr	r3, [r2, #0]
   221bc:	430b      	orrs	r3, r1
   221be:	6013      	str	r3, [r2, #0]
    m_event_handler(&evt);
   221c0:	4b04      	ldr	r3, [pc, #16]	; (221d4 <ev_sof_handler+0x40>)
   221c2:	681b      	ldr	r3, [r3, #0]
   221c4:	4798      	blx	r3
}
   221c6:	b003      	add	sp, #12
   221c8:	f85d fb04 	ldr.w	pc, [sp], #4
   221cc:	40036000 	.word	0x40036000
   221d0:	2000b5b4 	.word	0x2000b5b4
   221d4:	2000b5b8 	.word	0x2000b5b8

000221d8 <atomic_and.constprop.0.isra.0>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   221d8:	4b04      	ldr	r3, [pc, #16]	; (221ec <atomic_and.constprop.0.isra.0+0x14>)
   221da:	e8d3 1fef 	ldaex	r1, [r3]
   221de:	4001      	ands	r1, r0
   221e0:	e8c3 1fe2 	stlex	r2, r1, [r3]
   221e4:	2a00      	cmp	r2, #0
   221e6:	d1f8      	bne.n	221da <atomic_and.constprop.0.isra.0+0x2>
}
   221e8:	4770      	bx	lr
   221ea:	bf00      	nop
   221ec:	2000b5b0 	.word	0x2000b5b0

000221f0 <nrf_usbd_epin_dma_handler>:
    m_dma_pending = false;
   221f0:	2200      	movs	r2, #0
{
   221f2:	b508      	push	{r3, lr}
    m_dma_pending = false;
   221f4:	4b0b      	ldr	r3, [pc, #44]	; (22224 <nrf_usbd_epin_dma_handler+0x34>)
{
   221f6:	4601      	mov	r1, r0
    m_dma_pending = false;
   221f8:	701a      	strb	r2, [r3, #0]
    usbd_ep_state_t * p_state = ep_state_access(ep);
   221fa:	f7ff ff31 	bl	22060 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   221fe:	7b83      	ldrb	r3, [r0, #14]
   22200:	2b03      	cmp	r3, #3
   22202:	d10a      	bne.n	2221a <nrf_usbd_epin_dma_handler+0x2a>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22204:	4608      	mov	r0, r1
   22206:	f003 fc05 	bl	25a14 <ep2bit>
   2220a:	2301      	movs	r3, #1
   2220c:	fa03 f000 	lsl.w	r0, r3, r0
   22210:	43c0      	mvns	r0, r0
}
   22212:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22216:	f7ff bfdf 	b.w	221d8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   2221a:	6803      	ldr	r3, [r0, #0]
   2221c:	2b00      	cmp	r3, #0
   2221e:	d0f1      	beq.n	22204 <nrf_usbd_epin_dma_handler+0x14>
}
   22220:	bd08      	pop	{r3, pc}
   22222:	bf00      	nop
   22224:	2000b633 	.word	0x2000b633

00022228 <nrf_usbd_ep0in_dma_handler>:
    m_dma_pending = false;
   22228:	2200      	movs	r2, #0
   2222a:	4b08      	ldr	r3, [pc, #32]	; (2224c <nrf_usbd_ep0in_dma_handler+0x24>)
   2222c:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   2222e:	4b08      	ldr	r3, [pc, #32]	; (22250 <nrf_usbd_ep0in_dma_handler+0x28>)
   22230:	f893 209e 	ldrb.w	r2, [r3, #158]	; 0x9e
   22234:	2a03      	cmp	r2, #3
   22236:	d103      	bne.n	22240 <nrf_usbd_ep0in_dma_handler+0x18>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22238:	f06f 0001 	mvn.w	r0, #1
   2223c:	f7ff bfcc 	b.w	221d8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   22240:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   22244:	2b00      	cmp	r3, #0
   22246:	d0f7      	beq.n	22238 <nrf_usbd_ep0in_dma_handler+0x10>
}
   22248:	4770      	bx	lr
   2224a:	bf00      	nop
   2224c:	2000b633 	.word	0x2000b633
   22250:	2000b490 	.word	0x2000b490

00022254 <usbd_ep_data_handler>:
    m_ep_ready |= (1U << bitpos);
   22254:	2201      	movs	r2, #1
{
   22256:	b573      	push	{r0, r1, r4, r5, r6, lr}
    m_ep_ready |= (1U << bitpos);
   22258:	fa02 f501 	lsl.w	r5, r2, r1
   2225c:	491c      	ldr	r1, [pc, #112]	; (222d0 <usbd_ep_data_handler+0x7c>)
    if (NRF_USBD_EPIN_CHECK(ep))
   2225e:	f010 0f80 	tst.w	r0, #128	; 0x80
    m_ep_ready |= (1U << bitpos);
   22262:	680b      	ldr	r3, [r1, #0]
{
   22264:	4604      	mov	r4, r0
    m_ep_ready |= (1U << bitpos);
   22266:	ea43 0305 	orr.w	r3, r3, r5
   2226a:	4e1a      	ldr	r6, [pc, #104]	; (222d4 <usbd_ep_data_handler+0x80>)
   2226c:	600b      	str	r3, [r1, #0]
    if (NRF_USBD_EPIN_CHECK(ep))
   2226e:	d024      	beq.n	222ba <usbd_ep_data_handler+0x66>
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   22270:	4b19      	ldr	r3, [pc, #100]	; (222d8 <usbd_ep_data_handler+0x84>)
   22272:	f000 020f 	and.w	r2, r0, #15
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   22276:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   2227a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2227e:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   22282:	681a      	ldr	r2, [r3, #0]
    if (ret)
   22284:	b132      	cbz	r2, 22294 <usbd_ep_data_handler+0x40>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   22286:	2200      	movs	r2, #0
            if (ep != NRFX_USBD_EPIN0)
   22288:	2880      	cmp	r0, #128	; 0x80
   2228a:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   2228c:	681b      	ldr	r3, [r3, #0]
   2228e:	d011      	beq.n	222b4 <usbd_ep_data_handler+0x60>
                nrf_usbd_epin_dma_handler(ep);
   22290:	f7ff ffae 	bl	221f0 <nrf_usbd_epin_dma_handler>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   22294:	6833      	ldr	r3, [r6, #0]
   22296:	402b      	ands	r3, r5
   22298:	d10a      	bne.n	222b0 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2229a:	2206      	movs	r2, #6
   2229c:	f88d 4006 	strb.w	r4, [sp, #6]
   222a0:	f88d 2004 	strb.w	r2, [sp, #4]
   222a4:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
   222a8:	4b0c      	ldr	r3, [pc, #48]	; (222dc <usbd_ep_data_handler+0x88>)
   222aa:	a801      	add	r0, sp, #4
   222ac:	681b      	ldr	r3, [r3, #0]
   222ae:	4798      	blx	r3
}
   222b0:	b002      	add	sp, #8
   222b2:	bd70      	pop	{r4, r5, r6, pc}
                nrf_usbd_ep0in_dma_handler();
   222b4:	f7ff ffb8 	bl	22228 <nrf_usbd_ep0in_dma_handler>
   222b8:	e7ec      	b.n	22294 <usbd_ep_data_handler+0x40>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   222ba:	6833      	ldr	r3, [r6, #0]
   222bc:	421d      	tst	r5, r3
   222be:	d1f7      	bne.n	222b0 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_WAITING);
   222c0:	2306      	movs	r3, #6
   222c2:	f88d 0006 	strb.w	r0, [sp, #6]
   222c6:	f88d 3004 	strb.w	r3, [sp, #4]
   222ca:	f88d 2007 	strb.w	r2, [sp, #7]
   222ce:	e7eb      	b.n	222a8 <usbd_ep_data_handler+0x54>
   222d0:	2000b5b4 	.word	0x2000b5b4
   222d4:	2000b5b0 	.word	0x2000b5b0
   222d8:	000269aa 	.word	0x000269aa
   222dc:	2000b5b8 	.word	0x2000b5b8

000222e0 <ev_setup_data_handler>:
{
   222e0:	b508      	push	{r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   222e2:	4b05      	ldr	r3, [pc, #20]	; (222f8 <ev_setup_data_handler+0x18>)
   222e4:	781a      	ldrb	r2, [r3, #0]
   222e6:	4610      	mov	r0, r2
   222e8:	f003 fb94 	bl	25a14 <ep2bit>
}
   222ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   222f0:	4601      	mov	r1, r0
   222f2:	4610      	mov	r0, r2
   222f4:	f7ff bfae 	b.w	22254 <usbd_ep_data_handler>
   222f8:	2000b634 	.word	0x2000b634

000222fc <ev_dma_epout8_handler>:
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   222fc:	b507      	push	{r0, r1, r2, lr}
    m_dma_pending = false;
   222fe:	2200      	movs	r2, #0
   22300:	4b0d      	ldr	r3, [pc, #52]	; (22338 <ev_dma_epout8_handler+0x3c>)
   22302:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   22304:	4b0d      	ldr	r3, [pc, #52]	; (2233c <ev_dma_epout8_handler+0x40>)
   22306:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
   2230a:	2a03      	cmp	r2, #3
   2230c:	d010      	beq.n	22330 <ev_dma_epout8_handler+0x34>
    else if (p_state->handler.consumer == NULL)
   2230e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   22312:	b96b      	cbnz	r3, 22330 <ev_dma_epout8_handler+0x34>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22314:	f06f 7080 	mvn.w	r0, #16777216	; 0x1000000
   22318:	f7ff ff5e 	bl	221d8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2231c:	2306      	movs	r3, #6
   2231e:	f88d 3004 	strb.w	r3, [sp, #4]
   22322:	2308      	movs	r3, #8
   22324:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   22328:	4b05      	ldr	r3, [pc, #20]	; (22340 <ev_dma_epout8_handler+0x44>)
   2232a:	a801      	add	r0, sp, #4
   2232c:	681b      	ldr	r3, [r3, #0]
   2232e:	4798      	blx	r3
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   22330:	b003      	add	sp, #12
   22332:	f85d fb04 	ldr.w	pc, [sp], #4
   22336:	bf00      	nop
   22338:	2000b633 	.word	0x2000b633
   2233c:	2000b490 	.word	0x2000b490
   22340:	2000b5b8 	.word	0x2000b5b8

00022344 <ev_dma_epin8_handler>:
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   22344:	b507      	push	{r0, r1, r2, lr}
    m_dma_pending = false;
   22346:	2200      	movs	r2, #0
   22348:	4b10      	ldr	r3, [pc, #64]	; (2238c <ev_dma_epin8_handler+0x48>)
   2234a:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   2234c:	4b10      	ldr	r3, [pc, #64]	; (22390 <ev_dma_epin8_handler+0x4c>)
   2234e:	f893 211e 	ldrb.w	r2, [r3, #286]	; 0x11e
   22352:	2a03      	cmp	r2, #3
   22354:	d106      	bne.n	22364 <ev_dma_epin8_handler+0x20>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22356:	f46f 7080 	mvn.w	r0, #256	; 0x100
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   2235a:	b003      	add	sp, #12
   2235c:	f85d eb04 	ldr.w	lr, [sp], #4
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22360:	f7ff bf3a 	b.w	221d8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   22364:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
   22368:	b96b      	cbnz	r3, 22386 <ev_dma_epin8_handler+0x42>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2236a:	f46f 7080 	mvn.w	r0, #256	; 0x100
   2236e:	f7ff ff33 	bl	221d8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22372:	2306      	movs	r3, #6
   22374:	f88d 3004 	strb.w	r3, [sp, #4]
   22378:	2388      	movs	r3, #136	; 0x88
   2237a:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   2237e:	4b05      	ldr	r3, [pc, #20]	; (22394 <ev_dma_epin8_handler+0x50>)
   22380:	a801      	add	r0, sp, #4
   22382:	681b      	ldr	r3, [r3, #0]
   22384:	4798      	blx	r3
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   22386:	b003      	add	sp, #12
   22388:	f85d fb04 	ldr.w	pc, [sp], #4
   2238c:	2000b633 	.word	0x2000b633
   22390:	2000b490 	.word	0x2000b490
   22394:	2000b5b8 	.word	0x2000b5b8

00022398 <nrfx_usbd_uninit>:

void nrfx_usbd_uninit(void)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_INITIALIZED);

    m_event_handler = NULL;
   22398:	2300      	movs	r3, #0
   2239a:	4a02      	ldr	r2, [pc, #8]	; (223a4 <nrfx_usbd_uninit+0xc>)
   2239c:	6013      	str	r3, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_UNINITIALIZED;
   2239e:	4a02      	ldr	r2, [pc, #8]	; (223a8 <nrfx_usbd_uninit+0x10>)
   223a0:	7013      	strb	r3, [r2, #0]
    return;
}
   223a2:	4770      	bx	lr
   223a4:	2000b5b8 	.word	0x2000b5b8
   223a8:	2000b636 	.word	0x2000b636

000223ac <nrfx_usbd_enable>:
    p_reg->EVENTCAUSE = flags;
   223ac:	f44f 6200 	mov.w	r2, #2048	; 0x800
   223b0:	4b13      	ldr	r3, [pc, #76]	; (22400 <nrfx_usbd_enable+0x54>)
   223b2:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   223b6:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Enabled << USBD_ENABLE_ENABLE_Pos;
   223ba:	2201      	movs	r2, #1
   223bc:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   223c0:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
    return p_reg->EVENTCAUSE;
   223c4:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    while (0 == (eventcause & nrf_usbd_eventcause_get(NRF_USBD)))
   223c8:	0512      	lsls	r2, r2, #20
   223ca:	d5fb      	bpl.n	223c4 <nrfx_usbd_enable+0x18>
    p_reg->EVENTCAUSE = flags;
   223cc:	f44f 6200 	mov.w	r2, #2048	; 0x800
   223d0:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   223d4:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    p_reg->ISOSPLIT = split << USBD_ISOSPLIT_SPLIT_Pos;
   223d8:	2280      	movs	r2, #128	; 0x80
   223da:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
    p_reg->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
   223de:	2200      	movs	r2, #0
    else
    {
        nrfx_usbd_isoinconfig_set(NRF_USBD_ISOINCONFIG_NORESP);
    }

    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   223e0:	f240 11ff 	movw	r1, #511	; 0x1ff
   223e4:	f8c3 2530 	str.w	r2, [r3, #1328]	; 0x530
   223e8:	4b06      	ldr	r3, [pc, #24]	; (22404 <nrfx_usbd_enable+0x58>)
   223ea:	6019      	str	r1, [r3, #0]
    m_ep_dma_waiting = 0;
   223ec:	4b06      	ldr	r3, [pc, #24]	; (22408 <nrfx_usbd_enable+0x5c>)
   223ee:	601a      	str	r2, [r3, #0]
    m_dma_pending = false;
   223f0:	4b06      	ldr	r3, [pc, #24]	; (2240c <nrfx_usbd_enable+0x60>)
   223f2:	701a      	strb	r2, [r3, #0]
    usbd_dma_pending_clear();
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   223f4:	4b06      	ldr	r3, [pc, #24]	; (22410 <nrfx_usbd_enable+0x64>)
   223f6:	701a      	strb	r2, [r3, #0]

    m_drv_state = NRFX_DRV_STATE_POWERED_ON;
   223f8:	2202      	movs	r2, #2
   223fa:	4b06      	ldr	r3, [pc, #24]	; (22414 <nrfx_usbd_enable+0x68>)
   223fc:	701a      	strb	r2, [r3, #0]
    if (nrfx_usbd_errata_187())
#endif
    {
        usbd_errata_187_211_end();
    }
}
   223fe:	4770      	bx	lr
   22400:	40036000 	.word	0x40036000
   22404:	2000b5b4 	.word	0x2000b5b4
   22408:	2000b5b0 	.word	0x2000b5b0
   2240c:	2000b633 	.word	0x2000b633
   22410:	2000b634 	.word	0x2000b634
   22414:	2000b636 	.word	0x2000b636

00022418 <nrfx_usbd_start>:
}

void nrfx_usbd_start(bool enable_sof)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    m_bus_suspend = false;
   22418:	2200      	movs	r2, #0
   2241a:	4b0a      	ldr	r3, [pc, #40]	; (22444 <nrfx_usbd_start+0x2c>)
{
   2241c:	b510      	push	{r4, lr}
    m_bus_suspend = false;
   2241e:	701a      	strb	r2, [r3, #0]

    uint32_t ints_to_enable =
   22420:	4a09      	ldr	r2, [pc, #36]	; (22448 <nrfx_usbd_start+0x30>)
   22422:	4b0a      	ldr	r3, [pc, #40]	; (2244c <nrfx_usbd_start+0x34>)
    p_reg->INTENSET = mask;
   22424:	4c0a      	ldr	r4, [pc, #40]	; (22450 <nrfx_usbd_start+0x38>)
   22426:	2800      	cmp	r0, #0
   22428:	bf08      	it	eq
   2242a:	4613      	moveq	r3, r2
   /* Enable all required interrupts */
   nrf_usbd_int_enable(NRF_USBD, ints_to_enable);

   /* Enable interrupt globally */
   NRFX_IRQ_PRIORITY_SET(USBD_IRQn, NRFX_USBD_DEFAULT_CONFIG_IRQ_PRIORITY);
   NRFX_IRQ_ENABLE(USBD_IRQn);
   2242c:	2036      	movs	r0, #54	; 0x36
   2242e:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   22432:	f7fb ff55 	bl	1e2e0 <arch_irq_enable>
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Enabled << USBD_USBPULLUP_CONNECT_Pos;
   22436:	2301      	movs	r3, #1
   22438:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    (void) p_reg->USBPULLUP;
   2243c:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504

   /* Enable pullups */
   nrf_usbd_pullup_enable(NRF_USBD);
}
   22440:	bd10      	pop	{r4, pc}
   22442:	bf00      	nop
   22444:	2000b635 	.word	0x2000b635
   22448:	01c01407 	.word	0x01c01407
   2244c:	01e01407 	.word	0x01e01407
   22450:	40036000 	.word	0x40036000

00022454 <nrfx_usbd_is_enabled>:
    return (m_drv_state >= NRFX_DRV_STATE_INITIALIZED);
}

bool nrfx_usbd_is_enabled(void)
{
    return (m_drv_state >= NRFX_DRV_STATE_POWERED_ON);
   22454:	4b03      	ldr	r3, [pc, #12]	; (22464 <nrfx_usbd_is_enabled+0x10>)
   22456:	7818      	ldrb	r0, [r3, #0]
}
   22458:	2801      	cmp	r0, #1
   2245a:	bf94      	ite	ls
   2245c:	2000      	movls	r0, #0
   2245e:	2001      	movhi	r0, #1
   22460:	4770      	bx	lr
   22462:	bf00      	nop
   22464:	2000b636 	.word	0x2000b636

00022468 <nrfx_usbd_suspend>:
{
    return (nrfx_usbd_is_enabled() && NRFX_IRQ_IS_ENABLED(USBD_IRQn));
}

bool nrfx_usbd_suspend(void)
{
   22468:	b510      	push	{r4, lr}
	__asm__ volatile(
   2246a:	f04f 0320 	mov.w	r3, #32
   2246e:	f3ef 8111 	mrs	r1, BASEPRI
   22472:	f383 8812 	msr	BASEPRI_MAX, r3
   22476:	f3bf 8f6f 	isb	sy
    bool suspended = false;

    NRFX_CRITICAL_SECTION_ENTER();
    if (m_bus_suspend)
   2247a:	4b0f      	ldr	r3, [pc, #60]	; (224b8 <nrfx_usbd_suspend+0x50>)
   2247c:	781b      	ldrb	r3, [r3, #0]
   2247e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   22482:	b193      	cbz	r3, 224aa <nrfx_usbd_suspend+0x42>
    return p_reg->EVENTCAUSE;
   22484:	4b0d      	ldr	r3, [pc, #52]	; (224bc <nrfx_usbd_suspend+0x54>)
   22486:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    {
        if (!(nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK))
   2248a:	f412 7200 	ands.w	r2, r2, #512	; 0x200
   2248e:	d10c      	bne.n	224aa <nrfx_usbd_suspend+0x42>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_LowPower << USBD_LOWPOWER_LOWPOWER_Pos;
   22490:	2401      	movs	r4, #1
   22492:	f8c3 452c 	str.w	r4, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   22496:	f8d3 452c 	ldr.w	r4, [r3, #1324]	; 0x52c
    return p_reg->EVENTCAUSE;
   2249a:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
        {
            nrf_usbd_lowpower_enable(NRF_USBD);
            if (nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   2249e:	05a4      	lsls	r4, r4, #22
   224a0:	d504      	bpl.n	224ac <nrfx_usbd_suspend+0x44>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos;
   224a2:	f8c3 252c 	str.w	r2, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   224a6:	f8d3 352c 	ldr.w	r3, [r3, #1324]	; 0x52c
    bool suspended = false;
   224aa:	2000      	movs	r0, #0
	__asm__ volatile(
   224ac:	f381 8811 	msr	BASEPRI, r1
   224b0:	f3bf 8f6f 	isb	sy
        }
    }
    NRFX_CRITICAL_SECTION_EXIT();

    return suspended;
}
   224b4:	bd10      	pop	{r4, pc}
   224b6:	bf00      	nop
   224b8:	2000b635 	.word	0x2000b635
   224bc:	40036000 	.word	0x40036000

000224c0 <nrfx_usbd_init>:
{
   224c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (m_drv_state != NRFX_DRV_STATE_UNINITIALIZED)
   224c2:	4b1c      	ldr	r3, [pc, #112]	; (22534 <nrfx_usbd_init+0x74>)
   224c4:	781c      	ldrb	r4, [r3, #0]
   224c6:	bb94      	cbnz	r4, 2252e <nrfx_usbd_init+0x6e>
    m_event_handler = event_handler;
   224c8:	4a1b      	ldr	r2, [pc, #108]	; (22538 <nrfx_usbd_init+0x78>)
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224ca:	f240 17ff 	movw	r7, #511	; 0x1ff
    m_event_handler = event_handler;
   224ce:	6010      	str	r0, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   224d0:	2201      	movs	r2, #1
        p_state->status = NRFX_USBD_EP_OK;
   224d2:	4626      	mov	r6, r4
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   224d4:	701a      	strb	r2, [r3, #0]
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   224d6:	f064 057f 	orn	r5, r4, #127	; 0x7f
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224da:	f014 0f08 	tst.w	r4, #8
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   224de:	b2ed      	uxtb	r5, r5
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224e0:	bf14      	ite	ne
   224e2:	4639      	movne	r1, r7
   224e4:	2140      	moveq	r1, #64	; 0x40
   224e6:	4628      	mov	r0, r5
   224e8:	f003 fab4 	bl	25a54 <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   224ec:	4628      	mov	r0, r5
   224ee:	f7ff fdb7 	bl	22060 <ep_state_access>
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   224f2:	3401      	adds	r4, #1
   224f4:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
   224f6:	7386      	strb	r6, [r0, #14]
        p_state->handler.feeder = NULL;
   224f8:	6006      	str	r6, [r0, #0]
        p_state->transfer_cnt = 0;
   224fa:	6086      	str	r6, [r0, #8]
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   224fc:	d1eb      	bne.n	224d6 <nrfx_usbd_init+0x16>
   224fe:	2400      	movs	r4, #0
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   22500:	f240 17ff 	movw	r7, #511	; 0x1ff
        p_state->status = NRFX_USBD_EP_OK;
   22504:	4625      	mov	r5, r4
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   22506:	f014 0f08 	tst.w	r4, #8
   2250a:	b2e6      	uxtb	r6, r4
   2250c:	bf14      	ite	ne
   2250e:	4639      	movne	r1, r7
   22510:	2140      	moveq	r1, #64	; 0x40
   22512:	4630      	mov	r0, r6
   22514:	f003 fa9e 	bl	25a54 <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   22518:	4630      	mov	r0, r6
   2251a:	f7ff fda1 	bl	22060 <ep_state_access>
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   2251e:	3401      	adds	r4, #1
   22520:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
   22522:	7385      	strb	r5, [r0, #14]
        p_state->handler.consumer = NULL;
   22524:	6005      	str	r5, [r0, #0]
        p_state->transfer_cnt = 0;
   22526:	6085      	str	r5, [r0, #8]
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   22528:	d1ed      	bne.n	22506 <nrfx_usbd_init+0x46>
    return NRFX_SUCCESS;
   2252a:	4804      	ldr	r0, [pc, #16]	; (2253c <nrfx_usbd_init+0x7c>)
}
   2252c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return NRFX_ERROR_INVALID_STATE;
   2252e:	4804      	ldr	r0, [pc, #16]	; (22540 <nrfx_usbd_init+0x80>)
   22530:	e7fc      	b.n	2252c <nrfx_usbd_init+0x6c>
   22532:	bf00      	nop
   22534:	2000b636 	.word	0x2000b636
   22538:	2000b5b8 	.word	0x2000b5b8
   2253c:	0bad0000 	.word	0x0bad0000
   22540:	0bad0005 	.word	0x0bad0005

00022544 <nrfx_usbd_ep_transfer>:
}

nrfx_err_t nrfx_usbd_ep_transfer(
    nrfx_usbd_ep_t               ep,
    nrfx_usbd_transfer_t const * p_transfer)
{
   22544:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   22548:	4604      	mov	r4, r0
	__asm__ volatile(
   2254a:	f04f 0320 	mov.w	r3, #32
   2254e:	f3ef 8611 	mrs	r6, BASEPRI
   22552:	f383 8812 	msr	BASEPRI_MAX, r3
   22556:	f3bf 8f6f 	isb	sy
    const uint8_t ep_bitpos = ep2bit(ep);
    NRFX_ASSERT(NULL != p_transfer);

    NRFX_CRITICAL_SECTION_ENTER();
    /* Setup data transaction can go only in one direction at a time */
    if ((NRF_USBD_EP_NR_GET(ep) == 0) && (ep != m_last_setup_dir))
   2255a:	f010 090f 	ands.w	r9, r0, #15
   2255e:	d103      	bne.n	22568 <nrfx_usbd_ep_transfer+0x24>
   22560:	4b28      	ldr	r3, [pc, #160]	; (22604 <nrfx_usbd_ep_transfer+0xc0>)
   22562:	781b      	ldrb	r3, [r3, #0]
   22564:	4283      	cmp	r3, r0
   22566:	d148      	bne.n	225fa <nrfx_usbd_ep_transfer+0xb6>
            (NRFX_USBD_ISO_DEBUG || (!NRF_USBD_EPISO_CHECK(ep))))
        {
            NRFX_LOG_DEBUG("Transfer failed: Invalid EPr\n");
        }
    }
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   22568:	4b27      	ldr	r3, [pc, #156]	; (22608 <nrfx_usbd_ep_transfer+0xc4>)
   2256a:	4f28      	ldr	r7, [pc, #160]	; (2260c <nrfx_usbd_ep_transfer+0xc8>)
   2256c:	681a      	ldr	r2, [r3, #0]
   2256e:	683b      	ldr	r3, [r7, #0]
   22570:	43d2      	mvns	r2, r2
    const uint8_t ep_bitpos = ep2bit(ep);
   22572:	4620      	mov	r0, r4
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   22574:	b292      	uxth	r2, r2
   22576:	431a      	orrs	r2, r3
   22578:	f04f 0801 	mov.w	r8, #1
    const uint8_t ep_bitpos = ep2bit(ep);
   2257c:	f003 fa4a 	bl	25a14 <ep2bit>
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   22580:	fa08 f800 	lsl.w	r8, r8, r0
   22584:	ea12 0f08 	tst.w	r2, r8
   22588:	d139      	bne.n	225fe <nrfx_usbd_ep_transfer+0xba>
            NRFX_LOG_DEBUG("Transfer failed: EP is busy");
        }
    }
    else
    {
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   2258a:	4620      	mov	r0, r4
   2258c:	f7ff fd68 	bl	22060 <ep_state_access>
        /* Prepare transfer context and handler description */
        nrfx_usbd_transfer_t * p_context;
        if (NRF_USBD_EPIN_CHECK(ep))
        {
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   22590:	230c      	movs	r3, #12
        if (NRF_USBD_EPIN_CHECK(ep))
   22592:	0622      	lsls	r2, r4, #24
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   22594:	4605      	mov	r5, r0
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   22596:	fb03 f309 	mul.w	r3, r3, r9
        if (NRF_USBD_EPIN_CHECK(ep))
   2259a:	d52a      	bpl.n	225f2 <nrfx_usbd_ep_transfer+0xae>
   2259c:	680a      	ldr	r2, [r1, #0]
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
            {
                /* RAM */
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   2259e:	6888      	ldr	r0, [r1, #8]
   225a0:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
   225a4:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   225a8:	f000 0001 	and.w	r0, r0, #1
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
   225ac:	d11e      	bne.n	225ec <nrfx_usbd_ep_transfer+0xa8>
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   225ae:	4a18      	ldr	r2, [pc, #96]	; (22610 <nrfx_usbd_ep_transfer+0xcc>)
   225b0:	4c18      	ldr	r4, [pc, #96]	; (22614 <nrfx_usbd_ep_transfer+0xd0>)
   225b2:	2800      	cmp	r0, #0
   225b4:	bf08      	it	eq
   225b6:	4622      	moveq	r2, r4
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   225b8:	4817      	ldr	r0, [pc, #92]	; (22618 <nrfx_usbd_ep_transfer+0xd4>)
   225ba:	4403      	add	r3, r0
        }
        else
        {
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT((p_transfer->p_data.rx == NULL) || (nrfx_is_in_ram(p_transfer->p_data.rx)));
            p_state->handler.consumer = nrfx_usbd_consumer;
   225bc:	602a      	str	r2, [r5, #0]
        }
        *p_context = *p_transfer;
   225be:	c907      	ldmia	r1, {r0, r1, r2}
   225c0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        p_state->p_context = p_context;
   225c4:	606b      	str	r3, [r5, #4]

        p_state->transfer_cnt = 0;
   225c6:	2300      	movs	r3, #0
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   225c8:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
   225cc:	60ab      	str	r3, [r5, #8]
        p_state->status    =  NRFX_USBD_EP_OK;
   225ce:	73ab      	strb	r3, [r5, #14]
        m_ep_dma_waiting   |= 1U << ep_bitpos;
   225d0:	683b      	ldr	r3, [r7, #0]
        ret = NRFX_SUCCESS;
   225d2:	4812      	ldr	r0, [pc, #72]	; (2261c <nrfx_usbd_ep_transfer+0xd8>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
   225d4:	ea43 0308 	orr.w	r3, r3, r8
   225d8:	603b      	str	r3, [r7, #0]
   225da:	4b11      	ldr	r3, [pc, #68]	; (22620 <nrfx_usbd_ep_transfer+0xdc>)
   225dc:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	__asm__ volatile(
   225e0:	f386 8811 	msr	BASEPRI, r6
   225e4:	f3bf 8f6f 	isb	sy
        usbd_int_rise();
    }
    NRFX_CRITICAL_SECTION_EXIT();
    return ret;
}
   225e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   225ec:	4a0d      	ldr	r2, [pc, #52]	; (22624 <nrfx_usbd_ep_transfer+0xe0>)
   225ee:	4c0e      	ldr	r4, [pc, #56]	; (22628 <nrfx_usbd_ep_transfer+0xe4>)
   225f0:	e7df      	b.n	225b2 <nrfx_usbd_ep_transfer+0x6e>
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
   225f2:	4a0e      	ldr	r2, [pc, #56]	; (2262c <nrfx_usbd_ep_transfer+0xe8>)
   225f4:	4413      	add	r3, r2
            p_state->handler.consumer = nrfx_usbd_consumer;
   225f6:	4a0e      	ldr	r2, [pc, #56]	; (22630 <nrfx_usbd_ep_transfer+0xec>)
   225f8:	e7e0      	b.n	225bc <nrfx_usbd_ep_transfer+0x78>
        ret = NRFX_ERROR_INVALID_ADDR;
   225fa:	480e      	ldr	r0, [pc, #56]	; (22634 <nrfx_usbd_ep_transfer+0xf0>)
   225fc:	e7f0      	b.n	225e0 <nrfx_usbd_ep_transfer+0x9c>
        ret = NRFX_ERROR_BUSY;
   225fe:	480e      	ldr	r0, [pc, #56]	; (22638 <nrfx_usbd_ep_transfer+0xf4>)
   22600:	e7ee      	b.n	225e0 <nrfx_usbd_ep_transfer+0x9c>
   22602:	bf00      	nop
   22604:	2000b634 	.word	0x2000b634
   22608:	2000b5b4 	.word	0x2000b5b4
   2260c:	2000b5b0 	.word	0x2000b5b0
   22610:	000259eb 	.word	0x000259eb
   22614:	000259c9 	.word	0x000259c9
   22618:	2000b424 	.word	0x2000b424
   2261c:	0bad0000 	.word	0x0bad0000
   22620:	e000e100 	.word	0xe000e100
   22624:	00022155 	.word	0x00022155
   22628:	0002211d 	.word	0x0002211d
   2262c:	2000b3b8 	.word	0x2000b3b8
   22630:	00025997 	.word	0x00025997
   22634:	0bad000a 	.word	0x0bad000a
   22638:	0bad000b 	.word	0x0bad000b

0002263c <nrfx_usbd_epout_size_get>:
    if (NRF_USBD_EPISO_CHECK(ep))
   2263c:	f010 0f08 	tst.w	r0, #8
   22640:	4b07      	ldr	r3, [pc, #28]	; (22660 <nrfx_usbd_epout_size_get+0x24>)
   22642:	d006      	beq.n	22652 <nrfx_usbd_epout_size_get+0x16>
        size_t size_isoout = p_reg->SIZE.ISOOUT;
   22644:	f8d3 04c0 	ldr.w	r0, [r3, #1216]	; 0x4c0
            size_isoout = 0;
   22648:	f410 3f80 	tst.w	r0, #65536	; 0x10000
   2264c:	bf18      	it	ne
   2264e:	2000      	movne	r0, #0
   22650:	4770      	bx	lr
    return p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   22652:	f000 000f 	and.w	r0, r0, #15
   22656:	f500 7094 	add.w	r0, r0, #296	; 0x128
   2265a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}

size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_epout_size_get(NRF_USBD, ep_to_hal(ep));
}
   2265e:	4770      	bx	lr
   22660:	40036000 	.word	0x40036000

00022664 <usbd_dmareq_process>:
{
   22664:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (!m_dma_pending)
   22668:	4e54      	ldr	r6, [pc, #336]	; (227bc <usbd_dmareq_process+0x158>)
{
   2266a:	b085      	sub	sp, #20
    if (!m_dma_pending)
   2266c:	7833      	ldrb	r3, [r6, #0]
   2266e:	2b00      	cmp	r3, #0
   22670:	d169      	bne.n	22746 <usbd_dmareq_process+0xe2>
        while (0 != (req = m_ep_dma_waiting & m_ep_ready))
   22672:	f8df 814c 	ldr.w	r8, [pc, #332]	; 227c0 <usbd_dmareq_process+0x15c>
   22676:	4d53      	ldr	r5, [pc, #332]	; (227c4 <usbd_dmareq_process+0x160>)
   22678:	f8d8 4000 	ldr.w	r4, [r8]
   2267c:	682b      	ldr	r3, [r5, #0]
   2267e:	401c      	ands	r4, r3
   22680:	d061      	beq.n	22746 <usbd_dmareq_process+0xe2>
            if (NRFX_USBD_CONFIG_DMASCHEDULER_ISO_BOOST && ((req & USBD_EPISO_BIT_MASK) != 0))
   22682:	f014 2301 	ands.w	r3, r4, #16777472	; 0x1000100
    return NRF_CTZ(req);
   22686:	bf14      	ite	ne
   22688:	fa93 f4a3 	rbitne	r4, r3
   2268c:	fa94 f4a4 	rbiteq	r4, r4
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   22690:	f04f 0901 	mov.w	r9, #1
    return NRF_CTZ(req);
   22694:	fab4 f484 	clz	r4, r4
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   22698:	fa09 f904 	lsl.w	r9, r9, r4
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   2269c:	2c0f      	cmp	r4, #15
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   2269e:	ea6f 0909 	mvn.w	r9, r9
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   226a2:	d953      	bls.n	2274c <usbd_dmareq_process+0xe8>
   226a4:	3c10      	subs	r4, #16
   226a6:	b2e4      	uxtb	r4, r4
            usbd_ep_state_t * p_state = ep_state_access(ep);
   226a8:	4620      	mov	r0, r4
   226aa:	f7ff fcd9 	bl	22060 <ep_state_access>
   226ae:	4682      	mov	sl, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   226b0:	4620      	mov	r0, r4
   226b2:	f7ff ffc3 	bl	2263c <nrfx_usbd_epout_size_get>
                continue_transfer = p_state->handler.consumer(
   226b6:	f8da 7000 	ldr.w	r7, [sl]
   226ba:	4603      	mov	r3, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   226bc:	4683      	mov	fp, r0
                continue_transfer = p_state->handler.consumer(
   226be:	f8ba 200c 	ldrh.w	r2, [sl, #12]
   226c2:	f8da 1004 	ldr.w	r1, [sl, #4]
   226c6:	a802      	add	r0, sp, #8
   226c8:	47b8      	blx	r7
                if (transfer.p_data.rx == NULL)
   226ca:	9b02      	ldr	r3, [sp, #8]
   226cc:	2b00      	cmp	r3, #0
   226ce:	d149      	bne.n	22764 <usbd_dmareq_process+0x100>
                if (!continue_transfer)
   226d0:	b908      	cbnz	r0, 226d6 <usbd_dmareq_process+0x72>
                    p_state->handler.consumer = NULL;
   226d2:	f8ca 0000 	str.w	r0, [sl]
    m_dma_pending = true;
   226d6:	2301      	movs	r3, #1
   226d8:	7033      	strb	r3, [r6, #0]
            m_ep_ready &= ~(1U << pos);
   226da:	682b      	ldr	r3, [r5, #0]
            p_state->transfer_cnt += transfer.size;
   226dc:	9a03      	ldr	r2, [sp, #12]
            m_ep_ready &= ~(1U << pos);
   226de:	ea03 0309 	and.w	r3, r3, r9
   226e2:	602b      	str	r3, [r5, #0]
            p_state->transfer_cnt += transfer.size;
   226e4:	f8da 3008 	ldr.w	r3, [sl, #8]
            if (NRF_USBD_EPIN_CHECK(ep))
   226e8:	b261      	sxtb	r1, r4
            p_state->transfer_cnt += transfer.size;
   226ea:	4413      	add	r3, r2
    if (NRF_USBD_EPIN_CHECK(ep))
   226ec:	2900      	cmp	r1, #0
   226ee:	f8ca 3008 	str.w	r3, [sl, #8]
            nrf_usbd_ep_easydma_set(NRF_USBD, ep, transfer.p_data.addr, (uint32_t)transfer.size);
   226f2:	f004 0508 	and.w	r5, r4, #8
   226f6:	9802      	ldr	r0, [sp, #8]
   226f8:	4b33      	ldr	r3, [pc, #204]	; (227c8 <usbd_dmareq_process+0x164>)
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   226fa:	f004 040f 	and.w	r4, r4, #15
    if (NRF_USBD_EPIN_CHECK(ep))
   226fe:	da4e      	bge.n	2279e <usbd_dmareq_process+0x13a>
        if (NRF_USBD_EPISO_CHECK(ep))
   22700:	2d00      	cmp	r5, #0
   22702:	d044      	beq.n	2278e <usbd_dmareq_process+0x12a>
            p_reg->ISOIN.PTR    = ptr;
   22704:	f8c3 06a0 	str.w	r0, [r3, #1696]	; 0x6a0
            p_reg->ISOIN.MAXCNT = maxcnt;
   22708:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
    return (nrf_usbd_task_t)(
   2270c:	2304      	movs	r3, #4
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   2270e:	2201      	movs	r2, #1
   22710:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    return (volatile uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   22714:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   22718:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   2271c:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   2271e:	681b      	ldr	r3, [r3, #0]
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   22720:	4a2a      	ldr	r2, [pc, #168]	; (227cc <usbd_dmareq_process+0x168>)
   22722:	4b2b      	ldr	r3, [pc, #172]	; (227d0 <usbd_dmareq_process+0x16c>)
   22724:	ea13 0321 	ands.w	r3, r3, r1, asr #32
   22728:	bf38      	it	cc
   2272a:	4613      	movcc	r3, r2
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   2272c:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
   22730:	4925      	ldr	r1, [pc, #148]	; (227c8 <usbd_dmareq_process+0x164>)
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   22732:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   22736:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   2273a:	681a      	ldr	r2, [r3, #0]
            while (!nrf_usbd_event_check(NRF_USBD, nrfx_usbd_ep_to_endevent(ep)) &&
   2273c:	b91a      	cbnz	r2, 22746 <usbd_dmareq_process+0xe2>
   2273e:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
   22742:	2a00      	cmp	r2, #0
   22744:	d0f9      	beq.n	2273a <usbd_dmareq_process+0xd6>
}
   22746:	b005      	add	sp, #20
   22748:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   2274c:	f044 0480 	orr.w	r4, r4, #128	; 0x80
            usbd_ep_state_t * p_state = ep_state_access(ep);
   22750:	4620      	mov	r0, r4
   22752:	f7ff fc85 	bl	22060 <ep_state_access>
   22756:	4682      	mov	sl, r0
                continue_transfer = p_state->handler.feeder(
   22758:	6803      	ldr	r3, [r0, #0]
   2275a:	8982      	ldrh	r2, [r0, #12]
   2275c:	6841      	ldr	r1, [r0, #4]
   2275e:	a802      	add	r0, sp, #8
   22760:	4798      	blx	r3
   22762:	e7b5      	b.n	226d0 <usbd_dmareq_process+0x6c>
                else if (transfer.size < rx_size)
   22764:	9b03      	ldr	r3, [sp, #12]
   22766:	459b      	cmp	fp, r3
   22768:	d9b2      	bls.n	226d0 <usbd_dmareq_process+0x6c>
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   2276a:	2702      	movs	r7, #2
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   2276c:	4648      	mov	r0, r9
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   2276e:	f88a 700e 	strb.w	r7, [sl, #14]
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   22772:	f7ff fd31 	bl	221d8 <atomic_and.constprop.0.isra.0>
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   22776:	2306      	movs	r3, #6
   22778:	f88d 3004 	strb.w	r3, [sp, #4]
                    m_event_handler(&evt);
   2277c:	4b15      	ldr	r3, [pc, #84]	; (227d4 <usbd_dmareq_process+0x170>)
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   2277e:	f88d 4006 	strb.w	r4, [sp, #6]
                    m_event_handler(&evt);
   22782:	681b      	ldr	r3, [r3, #0]
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   22784:	f88d 7007 	strb.w	r7, [sp, #7]
                    m_event_handler(&evt);
   22788:	a801      	add	r0, sp, #4
   2278a:	4798      	blx	r3
                    continue;
   2278c:	e774      	b.n	22678 <usbd_dmareq_process+0x14>
            p_reg->EPIN[epnr].PTR    = ptr;
   2278e:	2514      	movs	r5, #20
   22790:	fb05 3304 	mla	r3, r5, r4, r3
   22794:	f8c3 0600 	str.w	r0, [r3, #1536]	; 0x600
            p_reg->EPIN[epnr].MAXCNT = maxcnt;
   22798:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    return (nrf_usbd_task_t)(
   2279c:	e7b6      	b.n	2270c <usbd_dmareq_process+0xa8>
        if (NRF_USBD_EPISO_CHECK(ep))
   2279e:	b12d      	cbz	r5, 227ac <usbd_dmareq_process+0x148>
            p_reg->ISOOUT.PTR    = ptr;
   227a0:	f8c3 07a0 	str.w	r0, [r3, #1952]	; 0x7a0
            p_reg->ISOOUT.MAXCNT = maxcnt;
   227a4:	f8c3 27a4 	str.w	r2, [r3, #1956]	; 0x7a4
   227a8:	2328      	movs	r3, #40	; 0x28
   227aa:	e7b0      	b.n	2270e <usbd_dmareq_process+0xaa>
            p_reg->EPOUT[epnr].PTR    = ptr;
   227ac:	2514      	movs	r5, #20
   227ae:	fb05 3304 	mla	r3, r5, r4, r3
   227b2:	f8c3 0700 	str.w	r0, [r3, #1792]	; 0x700
            p_reg->EPOUT[epnr].MAXCNT = maxcnt;
   227b6:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
   227ba:	e7f5      	b.n	227a8 <usbd_dmareq_process+0x144>
   227bc:	2000b633 	.word	0x2000b633
   227c0:	2000b5b0 	.word	0x2000b5b0
   227c4:	2000b5b4 	.word	0x2000b5b4
   227c8:	40036000 	.word	0x40036000
   227cc:	00026998 	.word	0x00026998
   227d0:	000269aa 	.word	0x000269aa
   227d4:	2000b5b8 	.word	0x2000b5b8

000227d8 <ev_epdata_handler>:
{
   227d8:	b538      	push	{r3, r4, r5, lr}
        dataepstatus &= ~(1UL << bitpos);
   227da:	2501      	movs	r5, #1
    return p_reg->EPDATASTATUS;
   227dc:	4b0e      	ldr	r3, [pc, #56]	; (22818 <ev_epdata_handler+0x40>)
   227de:	f8d3 446c 	ldr.w	r4, [r3, #1132]	; 0x46c
    p_reg->EPDATASTATUS = flags;
   227e2:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
    while (dataepstatus)
   227e6:	b91c      	cbnz	r4, 227f0 <ev_epdata_handler+0x18>
}
   227e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        usbd_dmareq_process();
   227ec:	f7ff bf3a 	b.w	22664 <usbd_dmareq_process>
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
   227f0:	fa94 f3a4 	rbit	r3, r4
   227f4:	fab3 f383 	clz	r3, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   227f8:	2b0f      	cmp	r3, #15
   227fa:	bfc8      	it	gt
   227fc:	f1a3 0010 	subgt.w	r0, r3, #16
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
   22800:	4619      	mov	r1, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   22802:	bfd4      	ite	le
   22804:	f043 0080 	orrle.w	r0, r3, #128	; 0x80
   22808:	b2c0      	uxtbgt	r0, r0
        dataepstatus &= ~(1UL << bitpos);
   2280a:	fa05 f303 	lsl.w	r3, r5, r3
   2280e:	ea24 0403 	bic.w	r4, r4, r3
        (void)(usbd_ep_data_handler(ep, bitpos));
   22812:	f7ff fd1f 	bl	22254 <usbd_ep_data_handler>
   22816:	e7e6      	b.n	227e6 <ev_epdata_handler+0xe>
   22818:	40036000 	.word	0x40036000

0002281c <nrf_usbd_epout_dma_handler>:
{
   2281c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    m_dma_pending = false;
   2281e:	2200      	movs	r2, #0
   22820:	4b16      	ldr	r3, [pc, #88]	; (2287c <nrf_usbd_epout_dma_handler+0x60>)
{
   22822:	4604      	mov	r4, r0
    m_dma_pending = false;
   22824:	701a      	strb	r2, [r3, #0]
    usbd_ep_state_t * p_state = ep_state_access(ep);
   22826:	f7ff fc1b 	bl	22060 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   2282a:	7b83      	ldrb	r3, [r0, #14]
   2282c:	2b03      	cmp	r3, #3
   2282e:	d10d      	bne.n	2284c <nrf_usbd_epout_dma_handler+0x30>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22830:	4620      	mov	r0, r4
   22832:	f003 f8ef 	bl	25a14 <ep2bit>
   22836:	2301      	movs	r3, #1
   22838:	fa03 f000 	lsl.w	r0, r3, r0
   2283c:	43c0      	mvns	r0, r0
   2283e:	f7ff fccb 	bl	221d8 <atomic_and.constprop.0.isra.0>
}
   22842:	b003      	add	sp, #12
   22844:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    usbd_dmareq_process();
   22848:	f7ff bf0c 	b.w	22664 <usbd_dmareq_process>
    else if (p_state->handler.consumer == NULL)
   2284c:	6805      	ldr	r5, [r0, #0]
   2284e:	2d00      	cmp	r5, #0
   22850:	d1f7      	bne.n	22842 <nrf_usbd_epout_dma_handler+0x26>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22852:	4620      	mov	r0, r4
   22854:	f003 f8de 	bl	25a14 <ep2bit>
   22858:	2301      	movs	r3, #1
   2285a:	fa03 f000 	lsl.w	r0, r3, r0
   2285e:	43c0      	mvns	r0, r0
   22860:	f7ff fcba 	bl	221d8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22864:	2306      	movs	r3, #6
   22866:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   2286a:	4b05      	ldr	r3, [pc, #20]	; (22880 <nrf_usbd_epout_dma_handler+0x64>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2286c:	f88d 4006 	strb.w	r4, [sp, #6]
        m_event_handler(&evt);
   22870:	681b      	ldr	r3, [r3, #0]
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22872:	f88d 5007 	strb.w	r5, [sp, #7]
        m_event_handler(&evt);
   22876:	a801      	add	r0, sp, #4
   22878:	4798      	blx	r3
   2287a:	e7e2      	b.n	22842 <nrf_usbd_epout_dma_handler+0x26>
   2287c:	2000b633 	.word	0x2000b633
   22880:	2000b5b8 	.word	0x2000b5b8

00022884 <nrfx_usbd_ep_stall>:
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_Stall << USBD_EPSTALL_STALL_Pos) | ep;
   22884:	4b02      	ldr	r3, [pc, #8]	; (22890 <nrfx_usbd_ep_stall+0xc>)
   22886:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   2288a:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518

void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep)
{
    NRFX_LOG_DEBUG("USB: EP %x stalled.", ep);
    nrf_usbd_ep_stall(NRF_USBD, ep_to_hal(ep));
}
   2288e:	4770      	bx	lr
   22890:	40036000 	.word	0x40036000

00022894 <nrfx_usbd_ep_stall_check>:
    if (NRF_USBD_EPISO_CHECK(ep))
   22894:	0702      	lsls	r2, r0, #28
   22896:	d413      	bmi.n	228c0 <nrfx_usbd_ep_stall_check+0x2c>
        return p_reg->HALTED.EPIN[epnr];
   22898:	f000 030f 	and.w	r3, r0, #15
    if (NRF_USBD_EPIN_CHECK(ep))
   2289c:	f010 0f80 	tst.w	r0, #128	; 0x80
   228a0:	4a08      	ldr	r2, [pc, #32]	; (228c4 <nrfx_usbd_ep_stall_check+0x30>)
        return p_reg->HALTED.EPOUT[epnr];
   228a2:	bf0b      	itete	eq
   228a4:	f503 7388 	addeq.w	r3, r3, #272	; 0x110
        return p_reg->HALTED.EPIN[epnr];
   228a8:	f503 7384 	addne.w	r3, r3, #264	; 0x108
        return p_reg->HALTED.EPOUT[epnr];
   228ac:	eb02 0283 	addeq.w	r2, r2, r3, lsl #2
        return p_reg->HALTED.EPIN[epnr];
   228b0:	f852 0023 	ldrne.w	r0, [r2, r3, lsl #2]
        return p_reg->HALTED.EPOUT[epnr];
   228b4:	bf08      	it	eq
   228b6:	6850      	ldreq	r0, [r2, #4]
    return USBD_HALTED_EPOUT_GETSTATUS_Halted == nrf_usbd_halted_get(p_reg, ep);
   228b8:	1e43      	subs	r3, r0, #1
   228ba:	4258      	negs	r0, r3
   228bc:	4158      	adcs	r0, r3
   228be:	4770      	bx	lr
        return false;
   228c0:	2000      	movs	r0, #0
}

bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_ep_is_stall(NRF_USBD, ep_to_hal(ep));
}
   228c2:	4770      	bx	lr
   228c4:	40036000 	.word	0x40036000

000228c8 <nrfx_usbd_ep_dtoggle_clear>:
    p_reg->DTOGGLE = ep | (NRF_USBD_DTOGGLE_NOP << USBD_DTOGGLE_VALUE_Pos);
   228c8:	4b04      	ldr	r3, [pc, #16]	; (228dc <nrfx_usbd_ep_dtoggle_clear+0x14>)
   228ca:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->DTOGGLE = ep | (op << USBD_DTOGGLE_VALUE_Pos);
   228ce:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   228d2:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    (void) p_reg->DTOGGLE;
   228d6:	f8d3 350c 	ldr.w	r3, [r3, #1292]	; 0x50c

void nrfx_usbd_ep_dtoggle_clear(nrfx_usbd_ep_t ep)
{
    nrf_usbd_dtoggle_set(NRF_USBD, ep, NRF_USBD_DTOGGLE_DATA0);
}
   228da:	4770      	bx	lr
   228dc:	40036000 	.word	0x40036000

000228e0 <nrfx_usbd_setup_get>:

void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup)
{
   228e0:	b510      	push	{r4, lr}
   228e2:	4604      	mov	r4, r0
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
   228e4:	2208      	movs	r2, #8
   228e6:	2100      	movs	r1, #0
   228e8:	f002 fb86 	bl	24ff8 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   228ec:	4b0e      	ldr	r3, [pc, #56]	; (22928 <nrfx_usbd_setup_get+0x48>)
   228ee:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
   228f2:	7022      	strb	r2, [r4, #0]
    return (uint8_t)(p_reg->BREQUEST);
   228f4:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
   228f8:	7062      	strb	r2, [r4, #1]
    const uint16_t val = p_reg->WVALUEL;
   228fa:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
   228fe:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
   22902:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->bmRequestType = nrf_usbd_setup_bmrequesttype_get(NRF_USBD);
    p_setup->bRequest      = nrf_usbd_setup_brequest_get(NRF_USBD);
    p_setup->wValue        = nrf_usbd_setup_wvalue_get(NRF_USBD);
   22906:	8062      	strh	r2, [r4, #2]
    const uint16_t val = p_reg->WINDEXL;
   22908:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
   2290c:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
   22910:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->wIndex        = nrf_usbd_setup_windex_get(NRF_USBD);
   22914:	80a2      	strh	r2, [r4, #4]
    const uint16_t val = p_reg->WLENGTHL;
   22916:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
   2291a:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
   2291e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    p_setup->wLength       = nrf_usbd_setup_wlength_get(NRF_USBD);
   22922:	80e3      	strh	r3, [r4, #6]
}
   22924:	bd10      	pop	{r4, pc}
   22926:	bf00      	nop
   22928:	40036000 	.word	0x40036000

0002292c <nrfx_usbd_setup_data_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   2292c:	2201      	movs	r2, #1
   2292e:	4b02      	ldr	r3, [pc, #8]	; (22938 <nrfx_usbd_setup_data_clear+0xc>)
   22930:	64da      	str	r2, [r3, #76]	; 0x4c
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   22932:	6cdb      	ldr	r3, [r3, #76]	; 0x4c

void nrfx_usbd_setup_data_clear(void)
{
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0RCVOUT);
}
   22934:	4770      	bx	lr
   22936:	bf00      	nop
   22938:	40036000 	.word	0x40036000

0002293c <ev_dma_epout0_handler>:
    m_dma_pending = false;
   2293c:	2200      	movs	r2, #0
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   2293e:	b513      	push	{r0, r1, r4, lr}
    m_dma_pending = false;
   22940:	4b11      	ldr	r3, [pc, #68]	; (22988 <ev_dma_epout0_handler+0x4c>)
   22942:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   22944:	4b11      	ldr	r3, [pc, #68]	; (2298c <ev_dma_epout0_handler+0x50>)
   22946:	7b9a      	ldrb	r2, [r3, #14]
   22948:	2a03      	cmp	r2, #3
   2294a:	d106      	bne.n	2295a <ev_dma_epout0_handler+0x1e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2294c:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   22950:	b002      	add	sp, #8
   22952:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22956:	f7ff bc3f 	b.w	221d8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.consumer == NULL)
   2295a:	681c      	ldr	r4, [r3, #0]
   2295c:	b974      	cbnz	r4, 2297c <ev_dma_epout0_handler+0x40>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2295e:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
   22962:	f7ff fc39 	bl	221d8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22966:	2306      	movs	r3, #6
   22968:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   2296c:	4b08      	ldr	r3, [pc, #32]	; (22990 <ev_dma_epout0_handler+0x54>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2296e:	f8ad 4006 	strh.w	r4, [sp, #6]
        m_event_handler(&evt);
   22972:	681b      	ldr	r3, [r3, #0]
   22974:	a801      	add	r0, sp, #4
   22976:	4798      	blx	r3
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   22978:	b002      	add	sp, #8
   2297a:	bd10      	pop	{r4, pc}
   2297c:	b002      	add	sp, #8
   2297e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        nrfx_usbd_setup_data_clear();
   22982:	f7ff bfd3 	b.w	2292c <nrfx_usbd_setup_data_clear>
   22986:	bf00      	nop
   22988:	2000b633 	.word	0x2000b633
   2298c:	2000b490 	.word	0x2000b490
   22990:	2000b5b8 	.word	0x2000b5b8

00022994 <nrfx_usbd_setup_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   22994:	2201      	movs	r2, #1
   22996:	4b02      	ldr	r3, [pc, #8]	; (229a0 <nrfx_usbd_setup_clear+0xc>)
   22998:	651a      	str	r2, [r3, #80]	; 0x50
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   2299a:	6d1b      	ldr	r3, [r3, #80]	; 0x50

void nrfx_usbd_setup_clear(void)
{
    NRFX_LOG_DEBUG(">> ep0status >>");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STATUS);
}
   2299c:	4770      	bx	lr
   2299e:	bf00      	nop
   229a0:	40036000 	.word	0x40036000

000229a4 <nrfx_usbd_setup_stall>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   229a4:	2201      	movs	r2, #1
   229a6:	4b02      	ldr	r3, [pc, #8]	; (229b0 <nrfx_usbd_setup_stall+0xc>)
   229a8:	655a      	str	r2, [r3, #84]	; 0x54
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   229aa:	6d5b      	ldr	r3, [r3, #84]	; 0x54

void nrfx_usbd_setup_stall(void)
{
    NRFX_LOG_DEBUG("Setup stalled.");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STALL);
}
   229ac:	4770      	bx	lr
   229ae:	bf00      	nop
   229b0:	40036000 	.word	0x40036000

000229b4 <nrfx_usbd_last_setup_dir_get>:

nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void)
{
    return m_last_setup_dir;
}
   229b4:	4b01      	ldr	r3, [pc, #4]	; (229bc <nrfx_usbd_last_setup_dir_get+0x8>)
   229b6:	7818      	ldrb	r0, [r3, #0]
   229b8:	4770      	bx	lr
   229ba:	bf00      	nop
   229bc:	2000b634 	.word	0x2000b634

000229c0 <nrfx_usbd_transfer_out_drop>:

void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep)
{
   229c0:	4602      	mov	r2, r0
   229c2:	b510      	push	{r4, lr}
	__asm__ volatile(
   229c4:	f04f 0320 	mov.w	r3, #32
   229c8:	f3ef 8411 	mrs	r4, BASEPRI
   229cc:	f383 8812 	msr	BASEPRI_MAX, r3
   229d0:	f3bf 8f6f 	isb	sy
    NRFX_ASSERT(NRF_USBD_EPOUT_CHECK(ep));

    NRFX_CRITICAL_SECTION_ENTER();
    m_ep_ready &= ~(1U << ep2bit(ep));
   229d4:	f003 f81e 	bl	25a14 <ep2bit>
   229d8:	2301      	movs	r3, #1
   229da:	490d      	ldr	r1, [pc, #52]	; (22a10 <nrfx_usbd_transfer_out_drop+0x50>)
   229dc:	fa03 f000 	lsl.w	r0, r3, r0
   229e0:	680b      	ldr	r3, [r1, #0]
   229e2:	ea23 0300 	bic.w	r3, r3, r0
   229e6:	600b      	str	r3, [r1, #0]
    if (!NRF_USBD_EPISO_CHECK(ep))
   229e8:	f012 0108 	ands.w	r1, r2, #8
   229ec:	d10a      	bne.n	22a04 <nrfx_usbd_transfer_out_drop+0x44>
    p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)] = 0;
   229ee:	f002 030f 	and.w	r3, r2, #15
   229f2:	009b      	lsls	r3, r3, #2
   229f4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   229f8:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
   229fc:	f8c3 14a0 	str.w	r1, [r3, #1184]	; 0x4a0
    (void) p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   22a00:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
	__asm__ volatile(
   22a04:	f384 8811 	msr	BASEPRI, r4
   22a08:	f3bf 8f6f 	isb	sy
    {
        nrf_usbd_epout_clear(NRF_USBD, ep);
    }
    NRFX_CRITICAL_SECTION_EXIT();
}
   22a0c:	bd10      	pop	{r4, pc}
   22a0e:	bf00      	nop
   22a10:	2000b5b4 	.word	0x2000b5b4

00022a14 <usbd_ep_abort>:
{
   22a14:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   22a16:	4601      	mov	r1, r0
	__asm__ volatile(
   22a18:	f04f 0320 	mov.w	r3, #32
   22a1c:	f3ef 8511 	mrs	r5, BASEPRI
   22a20:	f383 8812 	msr	BASEPRI_MAX, r3
   22a24:	f3bf 8f6f 	isb	sy
    usbd_ep_state_t * p_state = ep_state_access(ep);
   22a28:	f7ff fb1a 	bl	22060 <ep_state_access>
   22a2c:	4606      	mov	r6, r0
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   22a2e:	4608      	mov	r0, r1
   22a30:	f002 fff0 	bl	25a14 <ep2bit>
   22a34:	2201      	movs	r2, #1
    if (NRF_USBD_EPOUT_CHECK(ep))
   22a36:	f011 0f80 	tst.w	r1, #128	; 0x80
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   22a3a:	fa02 f200 	lsl.w	r2, r2, r0
   22a3e:	482e      	ldr	r0, [pc, #184]	; (22af8 <usbd_ep_abort+0xe4>)
    if (NRF_USBD_EPOUT_CHECK(ep))
   22a40:	d119      	bne.n	22a76 <usbd_ep_abort+0x62>
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   22a42:	6803      	ldr	r3, [r0, #0]
   22a44:	ea32 0303 	bics.w	r3, r2, r3
   22a48:	d00a      	beq.n	22a60 <usbd_ep_abort+0x4c>
            nrfx_usbd_transfer_out_drop(ep);
   22a4a:	4608      	mov	r0, r1
   22a4c:	f7ff ffb8 	bl	229c0 <nrfx_usbd_transfer_out_drop>
        p_state->status = NRFX_USBD_EP_ABORTED;
   22a50:	2303      	movs	r3, #3
   22a52:	73b3      	strb	r3, [r6, #14]
	__asm__ volatile(
   22a54:	f385 8811 	msr	BASEPRI, r5
   22a58:	f3bf 8f6f 	isb	sy
}
   22a5c:	b003      	add	sp, #12
   22a5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            p_state->handler.consumer = NULL;
   22a60:	6033      	str	r3, [r6, #0]
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22a62:	6803      	ldr	r3, [r0, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
   22a64:	4925      	ldr	r1, [pc, #148]	; (22afc <usbd_ep_abort+0xe8>)
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22a66:	ea23 0302 	bic.w	r3, r3, r2
   22a6a:	6003      	str	r3, [r0, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
   22a6c:	680b      	ldr	r3, [r1, #0]
   22a6e:	ea23 0302 	bic.w	r3, r3, r2
   22a72:	600b      	str	r3, [r1, #0]
   22a74:	e7ec      	b.n	22a50 <usbd_ep_abort+0x3c>
        if(!NRF_USBD_EPISO_CHECK(ep))
   22a76:	070b      	lsls	r3, r1, #28
   22a78:	d415      	bmi.n	22aa6 <usbd_ep_abort+0x92>
            if(ep != NRFX_USBD_EPIN0)
   22a7a:	2980      	cmp	r1, #128	; 0x80
   22a7c:	4b20      	ldr	r3, [pc, #128]	; (22b00 <usbd_ep_abort+0xec>)
   22a7e:	d02f      	beq.n	22ae0 <usbd_ep_abort+0xcc>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B6 + (2u * (NRF_USBD_EP_NR_GET(ep) - 1));
   22a80:	f001 040f 	and.w	r4, r1, #15
   22a84:	f204 34da 	addw	r4, r4, #986	; 0x3da
   22a88:	0064      	lsls	r4, r4, #1
   22a8a:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22a8e:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22a92:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22a96:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22a98:	f044 0402 	orr.w	r4, r4, #2
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22a9c:	433c      	orrs	r4, r7
   22a9e:	f8c3 4804 	str.w	r4, [r3, #2052]	; 0x804
                (void)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   22aa2:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
        if ((m_ep_dma_waiting | (~m_ep_ready)) & (1U << ep2bit(ep)))
   22aa6:	4f15      	ldr	r7, [pc, #84]	; (22afc <usbd_ep_abort+0xe8>)
   22aa8:	6804      	ldr	r4, [r0, #0]
   22aaa:	683b      	ldr	r3, [r7, #0]
   22aac:	ea64 0c03 	orn	ip, r4, r3
   22ab0:	ea1c 0f02 	tst.w	ip, r2
   22ab4:	d0ce      	beq.n	22a54 <usbd_ep_abort+0x40>
            m_ep_ready       |=   1U << ep2bit(ep) ;
   22ab6:	4313      	orrs	r3, r2
   22ab8:	603b      	str	r3, [r7, #0]
            p_state->handler.feeder = NULL;
   22aba:	2300      	movs	r3, #0
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22abc:	ea24 0402 	bic.w	r4, r4, r2
   22ac0:	6004      	str	r4, [r0, #0]
            p_state->handler.feeder = NULL;
   22ac2:	6033      	str	r3, [r6, #0]
            p_state->status = NRFX_USBD_EP_ABORTED;
   22ac4:	2303      	movs	r3, #3
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22ac6:	2206      	movs	r2, #6
            p_state->status = NRFX_USBD_EP_ABORTED;
   22ac8:	73b3      	strb	r3, [r6, #14]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22aca:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
   22ace:	4b0d      	ldr	r3, [pc, #52]	; (22b04 <usbd_ep_abort+0xf0>)
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22ad0:	f88d 2004 	strb.w	r2, [sp, #4]
            m_event_handler(&evt);
   22ad4:	681b      	ldr	r3, [r3, #0]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22ad6:	f88d 1006 	strb.w	r1, [sp, #6]
            m_event_handler(&evt);
   22ada:	a801      	add	r0, sp, #4
   22adc:	4798      	blx	r3
   22ade:	e7b9      	b.n	22a54 <usbd_ep_abort+0x40>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B4;
   22ae0:	f240 74b4 	movw	r4, #1972	; 0x7b4
   22ae4:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22ae8:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22aec:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22af0:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22af2:	f044 0404 	orr.w	r4, r4, #4
   22af6:	e7d1      	b.n	22a9c <usbd_ep_abort+0x88>
   22af8:	2000b5b0 	.word	0x2000b5b0
   22afc:	2000b5b4 	.word	0x2000b5b4
   22b00:	40036000 	.word	0x40036000
   22b04:	2000b5b8 	.word	0x2000b5b8

00022b08 <ev_setup_handler>:
{
   22b08:	b573      	push	{r0, r1, r4, r5, r6, lr}
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   22b0a:	4b14      	ldr	r3, [pc, #80]	; (22b5c <ev_setup_handler+0x54>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b0c:	4c14      	ldr	r4, [pc, #80]	; (22b60 <ev_setup_handler+0x58>)
   22b0e:	f8d3 5480 	ldr.w	r5, [r3, #1152]	; 0x480
   22b12:	6823      	ldr	r3, [r4, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
   22b14:	4e13      	ldr	r6, [pc, #76]	; (22b64 <ev_setup_handler+0x5c>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b16:	43da      	mvns	r2, r3
   22b18:	4b13      	ldr	r3, [pc, #76]	; (22b68 <ev_setup_handler+0x60>)
        & (1U <<ep2bit(m_last_setup_dir)))
   22b1a:	7831      	ldrb	r1, [r6, #0]
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b1c:	681b      	ldr	r3, [r3, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
   22b1e:	4608      	mov	r0, r1
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b20:	b292      	uxth	r2, r2
   22b22:	431a      	orrs	r2, r3
        & (1U <<ep2bit(m_last_setup_dir)))
   22b24:	f002 ff76 	bl	25a14 <ep2bit>
   22b28:	2301      	movs	r3, #1
   22b2a:	4083      	lsls	r3, r0
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b2c:	4213      	tst	r3, r2
   22b2e:	d002      	beq.n	22b36 <ev_setup_handler+0x2e>
        usbd_ep_abort(m_last_setup_dir);
   22b30:	4608      	mov	r0, r1
   22b32:	f7ff ff6f 	bl	22a14 <usbd_ep_abort>
    (void)(NRFX_ATOMIC_FETCH_AND(
   22b36:	f06f 1001 	mvn.w	r0, #65537	; 0x10001
        NRFX_USBD_EPOUT0 : NRFX_USBD_EPIN0;
   22b3a:	f025 057f 	bic.w	r5, r5, #127	; 0x7f
    m_last_setup_dir =
   22b3e:	7035      	strb	r5, [r6, #0]
    (void)(NRFX_ATOMIC_FETCH_AND(
   22b40:	f7ff fb4a 	bl	221d8 <atomic_and.constprop.0.isra.0>
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
   22b44:	6823      	ldr	r3, [r4, #0]
    m_event_handler(&evt);
   22b46:	a801      	add	r0, sp, #4
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
   22b48:	f043 0301 	orr.w	r3, r3, #1
   22b4c:	6023      	str	r3, [r4, #0]
    const nrfx_usbd_evt_t evt = {
   22b4e:	2305      	movs	r3, #5
   22b50:	9301      	str	r3, [sp, #4]
    m_event_handler(&evt);
   22b52:	4b06      	ldr	r3, [pc, #24]	; (22b6c <ev_setup_handler+0x64>)
   22b54:	681b      	ldr	r3, [r3, #0]
   22b56:	4798      	blx	r3
}
   22b58:	b002      	add	sp, #8
   22b5a:	bd70      	pop	{r4, r5, r6, pc}
   22b5c:	40036000 	.word	0x40036000
   22b60:	2000b5b4 	.word	0x2000b5b4
   22b64:	2000b634 	.word	0x2000b634
   22b68:	2000b5b0 	.word	0x2000b5b0
   22b6c:	2000b5b8 	.word	0x2000b5b8

00022b70 <nrfx_usbd_irq_handler>:
{
   22b70:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return p_reg->INTENSET;
   22b74:	4b1a      	ldr	r3, [pc, #104]	; (22be0 <nrfx_usbd_irq_handler+0x70>)
            active |= 1UL << event_nr;
   22b76:	2401      	movs	r4, #1
   22b78:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
    uint32_t active = 0;
   22b7c:	2300      	movs	r3, #0
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   22b7e:	461d      	mov	r5, r3
    while (to_process)
   22b80:	b970      	cbnz	r0, 22ba0 <nrfx_usbd_irq_handler+0x30>
        active &= ~(1UL << event_nr);
   22b82:	f04f 0801 	mov.w	r8, #1
        m_isr[event_nr]();
   22b86:	4f17      	ldr	r7, [pc, #92]	; (22be4 <nrfx_usbd_irq_handler+0x74>)
    bool setup_active = 0 != (active & NRF_USBD_INT_EP0SETUP_MASK);
   22b88:	f403 0600 	and.w	r6, r3, #8388608	; 0x800000
    active &= ~NRF_USBD_INT_EP0SETUP_MASK;
   22b8c:	f423 0400 	bic.w	r4, r3, #8388608	; 0x800000
    while (active)
   22b90:	b9bc      	cbnz	r4, 22bc2 <nrfx_usbd_irq_handler+0x52>
    usbd_dmareq_process();
   22b92:	f7ff fd67 	bl	22664 <usbd_dmareq_process>
    if (setup_active)
   22b96:	b306      	cbz	r6, 22bda <nrfx_usbd_irq_handler+0x6a>
}
   22b98:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        m_isr[USBD_INTEN_EP0SETUP_Pos]();
   22b9c:	f7ff bfb4 	b.w	22b08 <ev_setup_handler>
        uint8_t event_nr = NRF_CTZ(to_process);
   22ba0:	fa90 f2a0 	rbit	r2, r0
   22ba4:	fab2 f282 	clz	r2, r2
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   22ba8:	490f      	ldr	r1, [pc, #60]	; (22be8 <nrfx_usbd_irq_handler+0x78>)
}

NRF_STATIC_INLINE uint32_t nrfx_bitpos_to_event(uint32_t bit)
{
    static const uint32_t event_reg_offset = 0x100u;
    return event_reg_offset + (bit * sizeof(uint32_t));
   22baa:	0096      	lsls	r6, r2, #2
   22bac:	4431      	add	r1, r6
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   22bae:	680e      	ldr	r6, [r1, #0]
            active |= 1UL << event_nr;
   22bb0:	fa04 f202 	lsl.w	r2, r4, r2
    if (ret)
   22bb4:	b116      	cbz	r6, 22bbc <nrfx_usbd_irq_handler+0x4c>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   22bb6:	600d      	str	r5, [r1, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   22bb8:	6809      	ldr	r1, [r1, #0]
   22bba:	4313      	orrs	r3, r2
        to_process &= ~(1UL << event_nr);
   22bbc:	ea20 0002 	bic.w	r0, r0, r2
   22bc0:	e7de      	b.n	22b80 <nrfx_usbd_irq_handler+0x10>
        uint8_t event_nr = NRF_CTZ(active);
   22bc2:	fa94 f5a4 	rbit	r5, r4
   22bc6:	fab5 f585 	clz	r5, r5
        m_isr[event_nr]();
   22bca:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
        active &= ~(1UL << event_nr);
   22bce:	fa08 f505 	lsl.w	r5, r8, r5
        m_isr[event_nr]();
   22bd2:	4798      	blx	r3
        active &= ~(1UL << event_nr);
   22bd4:	ea24 0405 	bic.w	r4, r4, r5
   22bd8:	e7da      	b.n	22b90 <nrfx_usbd_irq_handler+0x20>
}
   22bda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   22bde:	bf00      	nop
   22be0:	40036000 	.word	0x40036000
   22be4:	00026918 	.word	0x00026918
   22be8:	40036100 	.word	0x40036100

00022bec <nrfx_usbd_stop>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   22bec:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
{
   22bf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22bf2:	4b1a      	ldr	r3, [pc, #104]	; (22c5c <nrfx_usbd_stop+0x70>)
    if (NRFX_IRQ_IS_ENABLED(USBD_IRQn))
   22bf4:	2036      	movs	r0, #54	; 0x36
   22bf6:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
   22bfa:	f7fb fb93 	bl	1e324 <arch_irq_is_enabled>
   22bfe:	b1b8      	cbz	r0, 22c30 <nrfx_usbd_stop+0x44>
        ep_waiting &= ~(1U << bitpos);
   22c00:	2701      	movs	r7, #1
    uint32_t ep_waiting = m_ep_dma_waiting | (m_ep_ready & NRFX_USBD_EPOUT_BIT_MASK);
   22c02:	4e17      	ldr	r6, [pc, #92]	; (22c60 <nrfx_usbd_stop+0x74>)
   22c04:	4b17      	ldr	r3, [pc, #92]	; (22c64 <nrfx_usbd_stop+0x78>)
   22c06:	6834      	ldr	r4, [r6, #0]
   22c08:	681b      	ldr	r3, [r3, #0]
   22c0a:	0c24      	lsrs	r4, r4, #16
   22c0c:	0424      	lsls	r4, r4, #16
   22c0e:	431c      	orrs	r4, r3
    while (0 != ep_waiting)
   22c10:	b97c      	cbnz	r4, 22c32 <nrfx_usbd_stop+0x46>
    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   22c12:	f240 13ff 	movw	r3, #511	; 0x1ff
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Disabled << USBD_USBPULLUP_CONNECT_Pos;
   22c16:	4d14      	ldr	r5, [pc, #80]	; (22c68 <nrfx_usbd_stop+0x7c>)
   22c18:	6033      	str	r3, [r6, #0]
        NRFX_IRQ_DISABLE(USBD_IRQn);
   22c1a:	2036      	movs	r0, #54	; 0x36
   22c1c:	f8c5 4504 	str.w	r4, [r5, #1284]	; 0x504
    (void) p_reg->USBPULLUP;
   22c20:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504
   22c24:	f7fb fb6a 	bl	1e2fc <arch_irq_disable>
    p_reg->INTENCLR = mask;
   22c28:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   22c2c:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
}
   22c30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        uint8_t bitpos = NRF_CTZ(ep_waiting);
   22c32:	fa94 f5a4 	rbit	r5, r4
   22c36:	fab5 f585 	clz	r5, r5
   22c3a:	4628      	mov	r0, r5
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   22c3c:	2d0f      	cmp	r5, #15
   22c3e:	bfc6      	itte	gt
   22c40:	f1a5 0010 	subgt.w	r0, r5, #16
   22c44:	b2c0      	uxtbgt	r0, r0
   22c46:	f040 0080 	orrle.w	r0, r0, #128	; 0x80
        if (!NRF_USBD_EPISO_CHECK(bit2ep(bitpos)))
   22c4a:	0703      	lsls	r3, r0, #28
   22c4c:	d401      	bmi.n	22c52 <nrfx_usbd_stop+0x66>
            usbd_ep_abort(bit2ep(bitpos));
   22c4e:	f7ff fee1 	bl	22a14 <usbd_ep_abort>
        ep_waiting &= ~(1U << bitpos);
   22c52:	fa07 f505 	lsl.w	r5, r7, r5
   22c56:	ea24 0405 	bic.w	r4, r4, r5
   22c5a:	e7d9      	b.n	22c10 <nrfx_usbd_stop+0x24>
   22c5c:	e000e100 	.word	0xe000e100
   22c60:	2000b5b4 	.word	0x2000b5b4
   22c64:	2000b5b0 	.word	0x2000b5b0
   22c68:	40036000 	.word	0x40036000

00022c6c <nrfx_usbd_disable>:
{
   22c6c:	b508      	push	{r3, lr}
    nrfx_usbd_stop();
   22c6e:	f7ff ffbd 	bl	22bec <nrfx_usbd_stop>
    return p_reg->INTENSET;
   22c72:	4b08      	ldr	r3, [pc, #32]	; (22c94 <nrfx_usbd_disable+0x28>)
   22c74:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
    p_reg->INTENCLR = mask;
   22c78:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Disabled << USBD_ENABLE_ENABLE_Pos;
   22c7c:	2200      	movs	r2, #0
   22c7e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   22c82:	f8d3 3500 	ldr.w	r3, [r3, #1280]	; 0x500
    m_dma_pending = false;
   22c86:	4b04      	ldr	r3, [pc, #16]	; (22c98 <nrfx_usbd_disable+0x2c>)
   22c88:	701a      	strb	r2, [r3, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   22c8a:	2201      	movs	r2, #1
   22c8c:	4b03      	ldr	r3, [pc, #12]	; (22c9c <nrfx_usbd_disable+0x30>)
   22c8e:	701a      	strb	r2, [r3, #0]
}
   22c90:	bd08      	pop	{r3, pc}
   22c92:	bf00      	nop
   22c94:	40036000 	.word	0x40036000
   22c98:	2000b633 	.word	0x2000b633
   22c9c:	2000b636 	.word	0x2000b636

00022ca0 <nrfx_usbd_ep_disable>:
{
   22ca0:	b510      	push	{r4, lr}
   22ca2:	4604      	mov	r4, r0
    usbd_ep_abort(ep);
   22ca4:	f7ff feb6 	bl	22a14 <usbd_ep_abort>
        p_reg->EPINEN &= ~(1UL << epnr);
   22ca8:	2301      	movs	r3, #1
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   22caa:	f004 000f 	and.w	r0, r4, #15
        p_reg->EPINEN &= ~(1UL << epnr);
   22cae:	4083      	lsls	r3, r0
   22cb0:	43db      	mvns	r3, r3
   22cb2:	4a0c      	ldr	r2, [pc, #48]	; (22ce4 <nrfx_usbd_ep_disable+0x44>)
    if (NRF_USBD_EPIN_CHECK(ep))
   22cb4:	f014 0f80 	tst.w	r4, #128	; 0x80
        p_reg->EPINEN &= ~(1UL << epnr);
   22cb8:	bf15      	itete	ne
   22cba:	f8d2 1510 	ldrne.w	r1, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   22cbe:	f8d2 1514 	ldreq.w	r1, [r2, #1300]	; 0x514
        p_reg->EPINEN &= ~(1UL << epnr);
   22cc2:	400b      	andne	r3, r1
        p_reg->EPOUTEN &= ~(1UL << epnr);
   22cc4:	400b      	andeq	r3, r1
        p_reg->EPINEN &= ~(1UL << epnr);
   22cc6:	bf15      	itete	ne
   22cc8:	f8c2 3510 	strne.w	r3, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   22ccc:	f8c2 3514 	streq.w	r3, [r2, #1300]	; 0x514
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22cd0:	4b05      	ldrne	r3, [pc, #20]	; (22ce8 <nrfx_usbd_ep_disable+0x48>)
   22cd2:	4b06      	ldreq	r3, [pc, #24]	; (22cec <nrfx_usbd_ep_disable+0x4c>)
   22cd4:	5c1a      	ldrb	r2, [r3, r0]
   22cd6:	2301      	movs	r3, #1
   22cd8:	4093      	lsls	r3, r2
    p_reg->INTENCLR = mask;
   22cda:	4a02      	ldr	r2, [pc, #8]	; (22ce4 <nrfx_usbd_ep_disable+0x44>)
   22cdc:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
   22ce0:	bd10      	pop	{r4, pc}
   22ce2:	bf00      	nop
   22ce4:	40036000 	.word	0x40036000
   22ce8:	00026b57 	.word	0x00026b57
   22cec:	00026b4e 	.word	0x00026b4e

00022cf0 <nrfx_usbd_ep_enable>:
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22cf0:	f010 0f80 	tst.w	r0, #128	; 0x80
{
   22cf4:	b570      	push	{r4, r5, r6, lr}
   22cf6:	4924      	ldr	r1, [pc, #144]	; (22d88 <nrfx_usbd_ep_enable+0x98>)
   22cf8:	4604      	mov	r4, r0
   22cfa:	f04f 0501 	mov.w	r5, #1
   22cfe:	f000 030f 	and.w	r3, r0, #15
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22d02:	d012      	beq.n	22d2a <nrfx_usbd_ep_enable+0x3a>
   22d04:	4a21      	ldr	r2, [pc, #132]	; (22d8c <nrfx_usbd_ep_enable+0x9c>)
   22d06:	5cd2      	ldrb	r2, [r2, r3]
   22d08:	fa05 f202 	lsl.w	r2, r5, r2
    p_reg->INTENSET = mask;
   22d0c:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
        return 0 != (p_reg->EPINEN & (1UL << epnr));
   22d10:	f8d1 2510 	ldr.w	r2, [r1, #1296]	; 0x510
   22d14:	40da      	lsrs	r2, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   22d16:	07d0      	lsls	r0, r2, #31
   22d18:	d406      	bmi.n	22d28 <nrfx_usbd_ep_enable+0x38>
        p_reg->EPINEN |= 1UL << epnr;
   22d1a:	f8d1 2510 	ldr.w	r2, [r1, #1296]	; 0x510
   22d1e:	fa05 f303 	lsl.w	r3, r5, r3
   22d22:	4313      	orrs	r3, r2
   22d24:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
}
   22d28:	bd70      	pop	{r4, r5, r6, pc}
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22d2a:	4a19      	ldr	r2, [pc, #100]	; (22d90 <nrfx_usbd_ep_enable+0xa0>)
   22d2c:	5cd2      	ldrb	r2, [r2, r3]
   22d2e:	fa05 f202 	lsl.w	r2, r5, r2
    p_reg->INTENSET = mask;
   22d32:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
        return 0 != (p_reg->EPOUTEN & (1UL << epnr));
   22d36:	f8d1 2514 	ldr.w	r2, [r1, #1300]	; 0x514
   22d3a:	40da      	lsrs	r2, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   22d3c:	07d2      	lsls	r2, r2, #31
   22d3e:	d4f3      	bmi.n	22d28 <nrfx_usbd_ep_enable+0x38>
        p_reg->EPOUTEN |= 1UL << epnr;
   22d40:	f8d1 6514 	ldr.w	r6, [r1, #1300]	; 0x514
   22d44:	fa05 f203 	lsl.w	r2, r5, r3
   22d48:	4332      	orrs	r2, r6
   22d4a:	f8c1 2514 	str.w	r2, [r1, #1300]	; 0x514
    if ((NRF_USBD_EP_NR_GET(ep) != 0) &&
   22d4e:	2b00      	cmp	r3, #0
   22d50:	d0ea      	beq.n	22d28 <nrfx_usbd_ep_enable+0x38>
        NRF_USBD_EPOUT_CHECK(ep) &&
   22d52:	0703      	lsls	r3, r0, #28
   22d54:	d4e8      	bmi.n	22d28 <nrfx_usbd_ep_enable+0x38>
	__asm__ volatile(
   22d56:	f04f 0320 	mov.w	r3, #32
   22d5a:	f3ef 8611 	mrs	r6, BASEPRI
   22d5e:	f383 8812 	msr	BASEPRI_MAX, r3
   22d62:	f3bf 8f6f 	isb	sy
        nrfx_usbd_transfer_out_drop(ep);
   22d66:	f7ff fe2b 	bl	229c0 <nrfx_usbd_transfer_out_drop>
        m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22d6a:	4620      	mov	r0, r4
   22d6c:	f002 fe52 	bl	25a14 <ep2bit>
   22d70:	4a08      	ldr	r2, [pc, #32]	; (22d94 <nrfx_usbd_ep_enable+0xa4>)
   22d72:	fa05 f000 	lsl.w	r0, r5, r0
   22d76:	6813      	ldr	r3, [r2, #0]
   22d78:	ea23 0300 	bic.w	r3, r3, r0
   22d7c:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   22d7e:	f386 8811 	msr	BASEPRI, r6
   22d82:	f3bf 8f6f 	isb	sy
}
   22d86:	e7cf      	b.n	22d28 <nrfx_usbd_ep_enable+0x38>
   22d88:	40036000 	.word	0x40036000
   22d8c:	00026b57 	.word	0x00026b57
   22d90:	00026b4e 	.word	0x00026b4e
   22d94:	2000b5b0 	.word	0x2000b5b0

00022d98 <nrfx_usbd_ep_stall_clear>:
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   22d98:	0603      	lsls	r3, r0, #24
{
   22d9a:	b510      	push	{r4, lr}
   22d9c:	4604      	mov	r4, r0
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   22d9e:	d405      	bmi.n	22dac <nrfx_usbd_ep_stall_clear+0x14>
   22da0:	f7ff fd78 	bl	22894 <nrfx_usbd_ep_stall_check>
   22da4:	b110      	cbz	r0, 22dac <nrfx_usbd_ep_stall_clear+0x14>
        nrfx_usbd_transfer_out_drop(ep);
   22da6:	4620      	mov	r0, r4
   22da8:	f7ff fe0a 	bl	229c0 <nrfx_usbd_transfer_out_drop>
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_UnStall << USBD_EPSTALL_STALL_Pos) | ep;
   22dac:	4b01      	ldr	r3, [pc, #4]	; (22db4 <nrfx_usbd_ep_stall_clear+0x1c>)
   22dae:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
}
   22db2:	bd10      	pop	{r4, pc}
   22db4:	40036000 	.word	0x40036000

00022db8 <nrfx_usbreg_enable>:
    p_reg->INTENSET = mask;
   22db8:	2207      	movs	r2, #7
   22dba:	4b02      	ldr	r3, [pc, #8]	; (22dc4 <nrfx_usbreg_enable+0xc>)
   22dbc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
void nrfx_usbreg_enable(void)
{
    nrf_usbreg_int_enable(NRF_USBREGULATOR, NRF_USBREG_INT_USBDETECTED |
                                            NRF_USBREG_INT_USBREMOVED  |
                                            NRF_USBREG_INT_USBPWRRDY);
}
   22dc0:	4770      	bx	lr
   22dc2:	bf00      	nop
   22dc4:	40037000 	.word	0x40037000

00022dc8 <nrfx_usbreg_disable>:
    p_reg->INTENCLR = mask;
   22dc8:	2207      	movs	r2, #7
   22dca:	4b02      	ldr	r3, [pc, #8]	; (22dd4 <nrfx_usbreg_disable+0xc>)
   22dcc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
void nrfx_usbreg_disable(void)
{
    nrf_usbreg_int_disable(NRF_USBREGULATOR, NRF_USBREG_INT_USBDETECTED |
                                             NRF_USBREG_INT_USBREMOVED  |
                                             NRF_USBREG_INT_USBPWRRDY);
}
   22dd0:	4770      	bx	lr
   22dd2:	bf00      	nop
   22dd4:	40037000 	.word	0x40037000

00022dd8 <nrfx_usbreg_uninit>:
   22dd8:	2207      	movs	r2, #7

void nrfx_usbreg_uninit(void)
{
   22dda:	b508      	push	{r3, lr}
   22ddc:	4b04      	ldr	r3, [pc, #16]	; (22df0 <nrfx_usbreg_uninit+0x18>)
    nrfx_usbreg_disable();
    NRFX_IRQ_DISABLE(nrfx_get_irq_number(NRF_USBREGULATOR));
   22dde:	2037      	movs	r0, #55	; 0x37
   22de0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   22de4:	f7fb fa8a 	bl	1e2fc <arch_irq_disable>
    m_usbevt_handler = NULL;
   22de8:	2200      	movs	r2, #0
   22dea:	4b02      	ldr	r3, [pc, #8]	; (22df4 <nrfx_usbreg_uninit+0x1c>)
   22dec:	601a      	str	r2, [r3, #0]
}
   22dee:	bd08      	pop	{r3, pc}
   22df0:	40037000 	.word	0x40037000
   22df4:	2000b5bc 	.word	0x2000b5bc

00022df8 <nrfx_usbreg_init>:
{
   22df8:	b510      	push	{r4, lr}
   22dfa:	4604      	mov	r4, r0
    nrfx_usbreg_uninit();
   22dfc:	f7ff ffec 	bl	22dd8 <nrfx_usbreg_uninit>
    m_usbevt_handler = p_config->handler;
   22e00:	6822      	ldr	r2, [r4, #0]
   22e02:	4b07      	ldr	r3, [pc, #28]	; (22e20 <nrfx_usbreg_init+0x28>)
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_USBREGULATOR));
   22e04:	2037      	movs	r0, #55	; 0x37
    m_usbevt_handler = p_config->handler;
   22e06:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e08:	2200      	movs	r2, #0
   22e0a:	4b06      	ldr	r3, [pc, #24]	; (22e24 <nrfx_usbreg_init+0x2c>)
   22e0c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   22e10:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   22e14:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
   22e18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_USBREGULATOR));
   22e1c:	f7fb ba60 	b.w	1e2e0 <arch_irq_enable>
   22e20:	2000b5bc 	.word	0x2000b5bc
   22e24:	40037000 	.word	0x40037000

00022e28 <nrfx_usbreg_irq_handler>:

void nrfx_usbreg_irq_handler(void)
{
   22e28:	b510      	push	{r4, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e2a:	4c11      	ldr	r4, [pc, #68]	; (22e70 <nrfx_usbreg_irq_handler+0x48>)
   22e2c:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    if (nrf_usbreg_event_check(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBDETECTED))
   22e30:	b12b      	cbz	r3, 22e3e <nrfx_usbreg_irq_handler+0x16>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e32:	2000      	movs	r0, #0
    {
        nrf_usbreg_event_clear(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBDETECTED);
        m_usbevt_handler(NRFX_USBREG_EVT_DETECTED);
   22e34:	4b0f      	ldr	r3, [pc, #60]	; (22e74 <nrfx_usbreg_irq_handler+0x4c>)
   22e36:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
   22e3a:	681b      	ldr	r3, [r3, #0]
   22e3c:	4798      	blx	r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e3e:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    }
    if (nrf_usbreg_event_check(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBREMOVED))
   22e42:	b133      	cbz	r3, 22e52 <nrfx_usbreg_irq_handler+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e44:	2300      	movs	r3, #0
   22e46:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
    {
        nrf_usbreg_event_clear(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBREMOVED);
        m_usbevt_handler(NRFX_USBREG_EVT_REMOVED);
   22e4a:	4b0a      	ldr	r3, [pc, #40]	; (22e74 <nrfx_usbreg_irq_handler+0x4c>)
   22e4c:	2001      	movs	r0, #1
   22e4e:	681b      	ldr	r3, [r3, #0]
   22e50:	4798      	blx	r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e52:	4b07      	ldr	r3, [pc, #28]	; (22e70 <nrfx_usbreg_irq_handler+0x48>)
   22e54:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    }
    if (nrf_usbreg_event_check(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBPWRRDY))
   22e58:	b142      	cbz	r2, 22e6c <nrfx_usbreg_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e5a:	2200      	movs	r2, #0
   22e5c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    {
        nrf_usbreg_event_clear(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBPWRRDY);
        m_usbevt_handler(NRFX_USBREG_EVT_READY);
   22e60:	4b04      	ldr	r3, [pc, #16]	; (22e74 <nrfx_usbreg_irq_handler+0x4c>)
   22e62:	2002      	movs	r0, #2
    }
}
   22e64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_usbevt_handler(NRFX_USBREG_EVT_READY);
   22e68:	681b      	ldr	r3, [r3, #0]
   22e6a:	4718      	bx	r3
}
   22e6c:	bd10      	pop	{r4, pc}
   22e6e:	bf00      	nop
   22e70:	40037000 	.word	0x40037000
   22e74:	2000b5bc 	.word	0x2000b5bc

00022e78 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
   22e78:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
   22e7a:	f003 021f 	and.w	r2, r3, #31
   22e7e:	6002      	str	r2, [r0, #0]
}
   22e80:	4a03      	ldr	r2, [pc, #12]	; (22e90 <nrf_gpio_pin_port_decode+0x18>)
   22e82:	4804      	ldr	r0, [pc, #16]	; (22e94 <nrf_gpio_pin_port_decode+0x1c>)
    return pin_number >> 5;
   22e84:	095b      	lsrs	r3, r3, #5
}
   22e86:	2b01      	cmp	r3, #1
   22e88:	bf18      	it	ne
   22e8a:	4610      	movne	r0, r2
   22e8c:	4770      	bx	lr
   22e8e:	bf00      	nop
   22e90:	40842500 	.word	0x40842500
   22e94:	40842800 	.word	0x40842800

00022e98 <nrfx_twi_twim_bus_recover>:
                                                  NRF_GPIO_PIN_PULLUP,        \
                                                  NRF_GPIO_PIN_S0D1,          \
                                                  NRF_GPIO_PIN_NOSENSE)

nrfx_err_t nrfx_twi_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
   22e98:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   22e9a:	4606      	mov	r6, r0
    nrf_gpio_pin_set(scl_pin);
   22e9c:	f002 fe0d 	bl	25aba <nrf_gpio_pin_set>
    nrf_gpio_pin_set(sda_pin);
   22ea0:	4608      	mov	r0, r1
   22ea2:	f002 fe0a 	bl	25aba <nrf_gpio_pin_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22ea6:	a801      	add	r0, sp, #4
   22ea8:	9601      	str	r6, [sp, #4]
   22eaa:	f7ff ffe5 	bl	22e78 <nrf_gpio_pin_port_decode>
{
   22eae:	460c      	mov	r4, r1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   22eb0:	f240 610d 	movw	r1, #1549	; 0x60d
   22eb4:	9b01      	ldr	r3, [sp, #4]
   22eb6:	9401      	str	r4, [sp, #4]
   22eb8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   22ebc:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200

    TWI_TWIM_PIN_CONFIGURE(scl_pin);
    TWI_TWIM_PIN_CONFIGURE(sda_pin);
    NRFX_DELAY_US(4);
   22ec0:	2509      	movs	r5, #9
   22ec2:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   22ec6:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
   22ec8:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22ecc:	a801      	add	r0, sp, #4
   22ece:	f7ff ffd3 	bl	22e78 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   22ed2:	9b01      	ldr	r3, [sp, #4]
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22ed4:	2701      	movs	r7, #1
   22ed6:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   22eda:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   22ede:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   22ee2:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
   22ee4:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
   22ee8:	2004      	movs	r0, #4
   22eea:	f002 fc96 	bl	2581a <nrfx_busy_wait>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22eee:	a801      	add	r0, sp, #4
   22ef0:	9401      	str	r4, [sp, #4]
   22ef2:	f7ff ffc1 	bl	22e78 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22ef6:	9a01      	ldr	r2, [sp, #4]
    return p_reg->IN;
   22ef8:	6903      	ldr	r3, [r0, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22efa:	40d3      	lsrs	r3, r2

    for (uint8_t i = 0; i < 9; i++)
    {
        if (nrf_gpio_pin_read(sda_pin))
   22efc:	07db      	lsls	r3, r3, #31
   22efe:	d414      	bmi.n	22f2a <nrfx_twi_twim_bus_recover+0x92>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22f00:	a801      	add	r0, sp, #4
   22f02:	9601      	str	r6, [sp, #4]
   22f04:	f7ff ffb8 	bl	22e78 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22f08:	9b01      	ldr	r3, [sp, #4]
    for (uint8_t i = 0; i < 9; i++)
   22f0a:	3d01      	subs	r5, #1
   22f0c:	fa07 f303 	lsl.w	r3, r7, r3
    p_reg->OUTCLR = clr_mask;
   22f10:	60c3      	str	r3, [r0, #12]
        }
        else
        {
            // Pulse CLOCK signal
            nrf_gpio_pin_clear(scl_pin);
            NRFX_DELAY_US(4);
   22f12:	2004      	movs	r0, #4
   22f14:	f002 fc81 	bl	2581a <nrfx_busy_wait>
            nrf_gpio_pin_set(scl_pin);
   22f18:	4630      	mov	r0, r6
   22f1a:	f002 fdce 	bl	25aba <nrf_gpio_pin_set>
            NRFX_DELAY_US(4);
   22f1e:	2004      	movs	r0, #4
   22f20:	f002 fc7b 	bl	2581a <nrfx_busy_wait>
    for (uint8_t i = 0; i < 9; i++)
   22f24:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   22f28:	d1e1      	bne.n	22eee <nrfx_twi_twim_bus_recover+0x56>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22f2a:	a801      	add	r0, sp, #4
   22f2c:	9401      	str	r4, [sp, #4]
   22f2e:	f7ff ffa3 	bl	22e78 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22f32:	2301      	movs	r3, #1
   22f34:	9a01      	ldr	r2, [sp, #4]
   22f36:	4093      	lsls	r3, r2
    p_reg->OUTCLR = clr_mask;
   22f38:	60c3      	str	r3, [r0, #12]
        }
    }

    // Generate a STOP condition on the bus
    nrf_gpio_pin_clear(sda_pin);
    NRFX_DELAY_US(4);
   22f3a:	2004      	movs	r0, #4
   22f3c:	f002 fc6d 	bl	2581a <nrfx_busy_wait>
    nrf_gpio_pin_set(sda_pin);
   22f40:	4620      	mov	r0, r4
   22f42:	f002 fdba 	bl	25aba <nrf_gpio_pin_set>
    NRFX_DELAY_US(4);
   22f46:	2004      	movs	r0, #4
   22f48:	f002 fc67 	bl	2581a <nrfx_busy_wait>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22f4c:	a801      	add	r0, sp, #4
   22f4e:	9401      	str	r4, [sp, #4]
   22f50:	f7ff ff92 	bl	22e78 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22f54:	9a01      	ldr	r2, [sp, #4]
    return p_reg->IN;
   22f56:	6903      	ldr	r3, [r0, #16]
    }
    else
    {
        return NRFX_ERROR_INTERNAL;
    }
}
   22f58:	4803      	ldr	r0, [pc, #12]	; (22f68 <nrfx_twi_twim_bus_recover+0xd0>)
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22f5a:	40d3      	lsrs	r3, r2
   22f5c:	f003 0301 	and.w	r3, r3, #1
   22f60:	1ac0      	subs	r0, r0, r3
   22f62:	b003      	add	sp, #12
   22f64:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22f66:	bf00      	nop
   22f68:	0bad0001 	.word	0x0bad0001

00022f6c <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   22f6c:	4b10      	ldr	r3, [pc, #64]	; (22fb0 <z_sys_init_run_level+0x44>)
{
   22f6e:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   22f70:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   22f74:	3001      	adds	r0, #1
   22f76:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   22f7a:	42a6      	cmp	r6, r4
   22f7c:	d800      	bhi.n	22f80 <z_sys_init_run_level+0x14>
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
   22f7e:	bd70      	pop	{r4, r5, r6, pc}
			int rc = entry->init_fn.dev(dev);
   22f80:	e9d4 3500 	ldrd	r3, r5, [r4]
		if (dev != NULL) {
   22f84:	b18d      	cbz	r5, 22faa <z_sys_init_run_level+0x3e>
			int rc = entry->init_fn.dev(dev);
   22f86:	4628      	mov	r0, r5
   22f88:	4798      	blx	r3
			if (rc != 0) {
   22f8a:	b138      	cbz	r0, 22f9c <z_sys_init_run_level+0x30>
				if (rc < 0) {
   22f8c:	2800      	cmp	r0, #0
   22f8e:	bfb8      	it	lt
   22f90:	4240      	neglt	r0, r0
				if (rc > UINT8_MAX) {
   22f92:	28ff      	cmp	r0, #255	; 0xff
   22f94:	bfa8      	it	ge
   22f96:	20ff      	movge	r0, #255	; 0xff
				dev->state->init_res = rc;
   22f98:	68eb      	ldr	r3, [r5, #12]
   22f9a:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   22f9c:	68ea      	ldr	r2, [r5, #12]
   22f9e:	7853      	ldrb	r3, [r2, #1]
   22fa0:	f043 0301 	orr.w	r3, r3, #1
   22fa4:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   22fa6:	3408      	adds	r4, #8
   22fa8:	e7e7      	b.n	22f7a <z_sys_init_run_level+0xe>
			(void)entry->init_fn.sys();
   22faa:	4798      	blx	r3
   22fac:	e7fb      	b.n	22fa6 <z_sys_init_run_level+0x3a>
   22fae:	bf00      	nop
   22fb0:	00026980 	.word	0x00026980

00022fb4 <bg_thread_main>:
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
   22fb4:	2201      	movs	r2, #1
{
   22fb6:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   22fb8:	4b09      	ldr	r3, [pc, #36]	; (22fe0 <bg_thread_main+0x2c>)

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
   22fba:	2003      	movs	r0, #3
	z_sys_post_kernel = true;
   22fbc:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
   22fbe:	f7ff ffd5 	bl	22f6c <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
   22fc2:	f001 fa05 	bl	243d0 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
   22fc6:	2004      	movs	r0, #4
   22fc8:	f7ff ffd0 	bl	22f6c <z_sys_init_run_level>

	z_init_static_threads();
   22fcc:	f000 f956 	bl	2327c <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
   22fd0:	f7f9 fa30 	bl	1c434 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   22fd4:	4a03      	ldr	r2, [pc, #12]	; (22fe4 <bg_thread_main+0x30>)
   22fd6:	7b13      	ldrb	r3, [r2, #12]
   22fd8:	f023 0301 	bic.w	r3, r3, #1
   22fdc:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   22fde:	bd08      	pop	{r3, pc}
   22fe0:	2000b637 	.word	0x2000b637
   22fe4:	2000a5f0 	.word	0x2000a5f0

00022fe8 <z_bss_zero>:
{
   22fe8:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
   22fea:	4803      	ldr	r0, [pc, #12]	; (22ff8 <z_bss_zero+0x10>)
   22fec:	4a03      	ldr	r2, [pc, #12]	; (22ffc <z_bss_zero+0x14>)
   22fee:	2100      	movs	r1, #0
   22ff0:	1a12      	subs	r2, r2, r0
   22ff2:	f002 fd95 	bl	25b20 <z_early_memset>
}
   22ff6:	bd08      	pop	{r3, pc}
   22ff8:	2000a410 	.word	0x2000a410
   22ffc:	2000b63c 	.word	0x2000b63c

00023000 <z_init_cpu>:

#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   23000:	2300      	movs	r3, #0
   23002:	2201      	movs	r2, #1
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
   23004:	b570      	push	{r4, r5, r6, lr}
   23006:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   23008:	e9cd 2304 	strd	r2, r3, [sp, #16]
   2300c:	220f      	movs	r2, #15
   2300e:	9301      	str	r3, [sp, #4]
   23010:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   23014:	2314      	movs	r3, #20
	z_setup_new_thread(thread, stack,
   23016:	f44f 72a0 	mov.w	r2, #320	; 0x140
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   2301a:	4d0e      	ldr	r5, [pc, #56]	; (23054 <z_init_cpu+0x54>)
	struct k_thread *thread = &z_idle_threads[i];
   2301c:	4e0e      	ldr	r6, [pc, #56]	; (23058 <z_init_cpu+0x58>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   2301e:	fb03 5500 	mla	r5, r3, r0, r5
	z_setup_new_thread(thread, stack,
   23022:	490e      	ldr	r1, [pc, #56]	; (2305c <z_init_cpu+0x5c>)
	struct k_thread *thread = &z_idle_threads[i];
   23024:	eb06 16c0 	add.w	r6, r6, r0, lsl #7
{
   23028:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
   2302a:	fb02 1100 	mla	r1, r2, r0, r1
   2302e:	4b0c      	ldr	r3, [pc, #48]	; (23060 <z_init_cpu+0x60>)
   23030:	4630      	mov	r0, r6
   23032:	9500      	str	r5, [sp, #0]
   23034:	f000 f8c6 	bl	231c4 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   23038:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
   2303a:	742c      	strb	r4, [r5, #16]
   2303c:	f023 0304 	bic.w	r3, r3, #4
   23040:	7373      	strb	r3, [r6, #13]
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
   23042:	4b08      	ldr	r3, [pc, #32]	; (23064 <z_init_cpu+0x64>)
   23044:	3401      	adds	r4, #1
   23046:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
   2304a:	60ee      	str	r6, [r5, #12]
	_kernel.cpus[id].irq_stack =
   2304c:	606b      	str	r3, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
   2304e:	b006      	add	sp, #24
   23050:	bd70      	pop	{r4, r5, r6, pc}
   23052:	bf00      	nop
   23054:	2000b5c0 	.word	0x2000b5c0
   23058:	2000a570 	.word	0x2000a570
   2305c:	2000c640 	.word	0x2000c640
   23060:	00023335 	.word	0x00023335
   23064:	2000be40 	.word	0x2000be40

00023068 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
   23068:	b580      	push	{r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
   2306a:	2000      	movs	r0, #0
{
   2306c:	b0a6      	sub	sp, #152	; 0x98
	z_sys_init_run_level(INIT_LEVEL_EARLY);
   2306e:	f7ff ff7d 	bl	22f6c <z_sys_init_run_level>
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   23072:	4b2d      	ldr	r3, [pc, #180]	; (23128 <z_cstart+0xc0>)
	uint32_t msp =
   23074:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   23078:	f382 8808 	msr	MSP, r2
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   2307c:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   23080:	2400      	movs	r4, #0
   23082:	23e0      	movs	r3, #224	; 0xe0
   23084:	4d29      	ldr	r5, [pc, #164]	; (2312c <z_cstart+0xc4>)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
   23086:	4e2a      	ldr	r6, [pc, #168]	; (23130 <z_cstart+0xc8>)
   23088:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   2308c:	77ec      	strb	r4, [r5, #31]
   2308e:	762c      	strb	r4, [r5, #24]
   23090:	766c      	strb	r4, [r5, #25]
   23092:	76ac      	strb	r4, [r5, #26]
   23094:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   23098:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   2309a:	4f26      	ldr	r7, [pc, #152]	; (23134 <z_cstart+0xcc>)
   2309c:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   230a0:	626b      	str	r3, [r5, #36]	; 0x24
   230a2:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   230a6:	f7fb fb6d 	bl	1e784 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   230aa:	f7fb f8ed 	bl	1e288 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   230ae:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   230b2:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   230b4:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   230b6:	f7fb fd6f 	bl	1eb98 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   230ba:	f7fb fc15 	bl	1e8e8 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   230be:	f240 1301 	movw	r3, #257	; 0x101
   230c2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   230c6:	ab06      	add	r3, sp, #24
   230c8:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   230ca:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	dummy_thread->resource_pool = NULL;
   230ce:	9422      	str	r4, [sp, #136]	; 0x88
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   230d0:	f002 fcff 	bl	25ad2 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
   230d4:	2001      	movs	r0, #1
   230d6:	f7ff ff49 	bl	22f6c <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
   230da:	2002      	movs	r0, #2
	_kernel.ready_q.cache = &z_main_thread;
   230dc:	4d16      	ldr	r5, [pc, #88]	; (23138 <z_cstart+0xd0>)
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
   230de:	f7ff ff45 	bl	22f6c <z_sys_init_run_level>
	z_sched_init();
   230e2:	f000 fe23 	bl	23d2c <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   230e6:	4b15      	ldr	r3, [pc, #84]	; (2313c <z_cstart+0xd4>)
	_kernel.ready_q.cache = &z_main_thread;
   230e8:	61b5      	str	r5, [r6, #24]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   230ea:	9305      	str	r3, [sp, #20]
   230ec:	2301      	movs	r3, #1
   230ee:	4914      	ldr	r1, [pc, #80]	; (23140 <z_cstart+0xd8>)
   230f0:	f44f 6280 	mov.w	r2, #1024	; 0x400
   230f4:	e9cd 4303 	strd	r4, r3, [sp, #12]
   230f8:	4628      	mov	r0, r5
   230fa:	463b      	mov	r3, r7
   230fc:	e9cd 4401 	strd	r4, r4, [sp, #4]
   23100:	9400      	str	r4, [sp, #0]
   23102:	f000 f85f 	bl	231c4 <z_setup_new_thread>
   23106:	4606      	mov	r6, r0
   23108:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
   2310a:	4628      	mov	r0, r5
   2310c:	f022 0204 	bic.w	r2, r2, #4
   23110:	736a      	strb	r2, [r5, #13]
   23112:	f002 fe93 	bl	25e3c <z_ready_thread>
	z_init_cpu(0);
   23116:	4620      	mov	r0, r4
   23118:	f7ff ff72 	bl	23000 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   2311c:	463a      	mov	r2, r7
   2311e:	4631      	mov	r1, r6
   23120:	4628      	mov	r0, r5
   23122:	f7fb f9bb 	bl	1e49c <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   23126:	bf00      	nop
   23128:	2000be40 	.word	0x2000be40
   2312c:	e000ed00 	.word	0xe000ed00
   23130:	2000b5c0 	.word	0x2000b5c0
   23134:	00022fb5 	.word	0x00022fb5
   23138:	2000a5f0 	.word	0x2000a5f0
   2313c:	00026b6a 	.word	0x00026b6a
   23140:	2000c780 	.word	0x2000c780

00023144 <init_mem_slab_module>:
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
	int rc = 0;
   23144:	2000      	movs	r0, #0
{
   23146:	b538      	push	{r3, r4, r5, lr}

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   23148:	4c05      	ldr	r4, [pc, #20]	; (23160 <init_mem_slab_module+0x1c>)
   2314a:	4d06      	ldr	r5, [pc, #24]	; (23164 <init_mem_slab_module+0x20>)
   2314c:	42ac      	cmp	r4, r5
   2314e:	d300      	bcc.n	23152 <init_mem_slab_module+0xe>
		z_object_init(slab);
	}

out:
	return rc;
}
   23150:	bd38      	pop	{r3, r4, r5, pc}
		rc = create_free_list(slab);
   23152:	4620      	mov	r0, r4
   23154:	f002 fce8 	bl	25b28 <create_free_list>
		if (rc < 0) {
   23158:	2800      	cmp	r0, #0
   2315a:	dbf9      	blt.n	23150 <init_mem_slab_module+0xc>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   2315c:	341c      	adds	r4, #28
   2315e:	e7f5      	b.n	2314c <init_mem_slab_module+0x8>
   23160:	2000a2d8 	.word	0x2000a2d8
   23164:	2000a2f4 	.word	0x2000a2f4

00023168 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   23168:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2316a:	460c      	mov	r4, r1
	__asm__ volatile(
   2316c:	f04f 0520 	mov.w	r5, #32
   23170:	f3ef 8111 	mrs	r1, BASEPRI
   23174:	f385 8812 	msr	BASEPRI_MAX, r5
   23178:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   2317c:	6945      	ldr	r5, [r0, #20]
   2317e:	b15d      	cbz	r5, 23198 <k_mem_slab_alloc+0x30>
		/* take a free block */
		*mem = slab->free_list;
   23180:	6025      	str	r5, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   23182:	682b      	ldr	r3, [r5, #0]
   23184:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   23186:	6983      	ldr	r3, [r0, #24]
   23188:	3301      	adds	r3, #1
   2318a:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   2318c:	2000      	movs	r0, #0
	__asm__ volatile(
   2318e:	f381 8811 	msr	BASEPRI, r1
   23192:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   23196:	e011      	b.n	231bc <k_mem_slab_alloc+0x54>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   23198:	ea52 0603 	orrs.w	r6, r2, r3
   2319c:	d103      	bne.n	231a6 <k_mem_slab_alloc+0x3e>
		result = -ENOMEM;
   2319e:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   231a2:	6025      	str	r5, [r4, #0]
		result = -ENOMEM;
   231a4:	e7f3      	b.n	2318e <k_mem_slab_alloc+0x26>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   231a6:	e9cd 2300 	strd	r2, r3, [sp]
   231aa:	4602      	mov	r2, r0
   231ac:	3008      	adds	r0, #8
   231ae:	f000 fcc7 	bl	23b40 <z_pend_curr>
		if (result == 0) {
   231b2:	b918      	cbnz	r0, 231bc <k_mem_slab_alloc+0x54>
			*mem = _current->base.swap_data;
   231b4:	4b02      	ldr	r3, [pc, #8]	; (231c0 <k_mem_slab_alloc+0x58>)
   231b6:	689b      	ldr	r3, [r3, #8]
   231b8:	695b      	ldr	r3, [r3, #20]
   231ba:	6023      	str	r3, [r4, #0]
}
   231bc:	b002      	add	sp, #8
   231be:	bd70      	pop	{r4, r5, r6, pc}
   231c0:	2000b5c0 	.word	0x2000b5c0

000231c4 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   231c4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   231c8:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   231ca:	f100 0558 	add.w	r5, r0, #88	; 0x58
   231ce:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   231d0:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   231d2:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
   231d6:	2500      	movs	r5, #0
{
   231d8:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
   231da:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   231dc:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   231de:	e9c0 5506 	strd	r5, r5, [r0, #24]
   231e2:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   231e4:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   231e6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   231e8:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
   231ec:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
   231f0:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   231f2:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   231f4:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   231f6:	9202      	str	r2, [sp, #8]
   231f8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   231fa:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   231fe:	9201      	str	r2, [sp, #4]
   23200:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   23202:	9200      	str	r2, [sp, #0]
   23204:	4642      	mov	r2, r8
   23206:	f7fb f92b 	bl	1e460 <arch_new_thread>
	if (!_current) {
   2320a:	4b05      	ldr	r3, [pc, #20]	; (23220 <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   2320c:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   2320e:	689b      	ldr	r3, [r3, #8]
   23210:	b103      	cbz	r3, 23214 <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   23212:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
   23214:	4640      	mov	r0, r8
   23216:	6723      	str	r3, [r4, #112]	; 0x70
   23218:	b004      	add	sp, #16
   2321a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2321e:	bf00      	nop
   23220:	2000b5c0 	.word	0x2000b5c0

00023224 <z_impl_k_thread_create>:
{
   23224:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23226:	2500      	movs	r5, #0
{
   23228:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2322a:	9505      	str	r5, [sp, #20]
   2322c:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   2322e:	e9dd 7612 	ldrd	r7, r6, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23232:	9504      	str	r5, [sp, #16]
   23234:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   23236:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23238:	9503      	str	r5, [sp, #12]
   2323a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   2323c:	9502      	str	r5, [sp, #8]
   2323e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   23240:	9501      	str	r5, [sp, #4]
   23242:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   23244:	9500      	str	r5, [sp, #0]
   23246:	f7ff ffbd 	bl	231c4 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   2324a:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
   2324e:	bf08      	it	eq
   23250:	f1b7 3fff 	cmpeq.w	r7, #4294967295	; 0xffffffff
   23254:	d005      	beq.n	23262 <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   23256:	ea56 0307 	orrs.w	r3, r6, r7
   2325a:	d105      	bne.n	23268 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
   2325c:	4620      	mov	r0, r4
   2325e:	f000 fce5 	bl	23c2c <z_sched_start>
}
   23262:	4620      	mov	r0, r4
   23264:	b007      	add	sp, #28
   23266:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   23268:	463a      	mov	r2, r7
   2326a:	4633      	mov	r3, r6
   2326c:	4902      	ldr	r1, [pc, #8]	; (23278 <z_impl_k_thread_create+0x54>)
   2326e:	f104 0018 	add.w	r0, r4, #24
   23272:	f000 fef1 	bl	24058 <z_add_timeout>
   23276:	e7f4      	b.n	23262 <z_impl_k_thread_create+0x3e>
   23278:	00025ec5 	.word	0x00025ec5

0002327c <z_init_static_threads>:
{
   2327c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   23280:	4c29      	ldr	r4, [pc, #164]	; (23328 <z_init_static_threads+0xac>)
	_FOREACH_STATIC_THREAD(thread_data) {
   23282:	4d2a      	ldr	r5, [pc, #168]	; (2332c <z_init_static_threads+0xb0>)
{
   23284:	b087      	sub	sp, #28
   23286:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
   23288:	42ae      	cmp	r6, r5
   2328a:	f104 042c 	add.w	r4, r4, #44	; 0x2c
   2328e:	d30f      	bcc.n	232b0 <z_init_static_threads+0x34>
	k_sched_lock();
   23290:	f000 fd1c 	bl	23ccc <k_sched_lock>
   23294:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   23298:	f240 37e7 	movw	r7, #999	; 0x3e7
	_FOREACH_STATIC_THREAD(thread_data) {
   2329c:	4c22      	ldr	r4, [pc, #136]	; (23328 <z_init_static_threads+0xac>)
   2329e:	f8df 9090 	ldr.w	r9, [pc, #144]	; 23330 <z_init_static_threads+0xb4>
   232a2:	42ac      	cmp	r4, r5
   232a4:	d320      	bcc.n	232e8 <z_init_static_threads+0x6c>
}
   232a6:	b007      	add	sp, #28
   232a8:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   232ac:	f000 bd22 	b.w	23cf4 <k_sched_unlock>
		z_setup_new_thread(
   232b0:	f854 3c04 	ldr.w	r3, [r4, #-4]
   232b4:	9305      	str	r3, [sp, #20]
   232b6:	f854 3c0c 	ldr.w	r3, [r4, #-12]
   232ba:	9304      	str	r3, [sp, #16]
   232bc:	f854 3c10 	ldr.w	r3, [r4, #-16]
   232c0:	9303      	str	r3, [sp, #12]
   232c2:	f854 3c14 	ldr.w	r3, [r4, #-20]
   232c6:	9302      	str	r3, [sp, #8]
   232c8:	f854 3c18 	ldr.w	r3, [r4, #-24]
   232cc:	9301      	str	r3, [sp, #4]
   232ce:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   232d2:	9300      	str	r3, [sp, #0]
   232d4:	e954 2309 	ldrd	r2, r3, [r4, #-36]	; 0x24
   232d8:	e954 010b 	ldrd	r0, r1, [r4, #-44]	; 0x2c
   232dc:	f7ff ff72 	bl	231c4 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   232e0:	f854 3c2c 	ldr.w	r3, [r4, #-44]
   232e4:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
   232e6:	e7ce      	b.n	23286 <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   232e8:	6a63      	ldr	r3, [r4, #36]	; 0x24
   232ea:	1c5a      	adds	r2, r3, #1
   232ec:	d00d      	beq.n	2330a <z_init_static_threads+0x8e>
   232ee:	2100      	movs	r1, #0
   232f0:	4638      	mov	r0, r7
					    K_MSEC(thread_data->init_delay));
   232f2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   232f6:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   232fa:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
   232fe:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   23302:	d104      	bne.n	2330e <z_init_static_threads+0x92>
	z_sched_start(thread);
   23304:	4640      	mov	r0, r8
   23306:	f000 fc91 	bl	23c2c <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   2330a:	342c      	adds	r4, #44	; 0x2c
   2330c:	e7c9      	b.n	232a2 <z_init_static_threads+0x26>
   2330e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   23312:	2300      	movs	r3, #0
   23314:	f7f8 ff1e 	bl	1c154 <__aeabi_uldivmod>
   23318:	4602      	mov	r2, r0
   2331a:	460b      	mov	r3, r1
   2331c:	f108 0018 	add.w	r0, r8, #24
   23320:	4649      	mov	r1, r9
   23322:	f000 fe99 	bl	24058 <z_add_timeout>
   23326:	e7f0      	b.n	2330a <z_init_static_threads+0x8e>
   23328:	00026528 	.word	0x00026528
   2332c:	00026528 	.word	0x00026528
   23330:	00025ec5 	.word	0x00025ec5

00023334 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   23334:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   23336:	4c0b      	ldr	r4, [pc, #44]	; (23364 <idle+0x30>)
   23338:	4d0b      	ldr	r5, [pc, #44]	; (23368 <idle+0x34>)
	__asm__ volatile(
   2333a:	f04f 0220 	mov.w	r2, #32
   2333e:	f3ef 8311 	mrs	r3, BASEPRI
   23342:	f382 8812 	msr	BASEPRI_MAX, r2
   23346:	f3bf 8f6f 	isb	sy
   2334a:	f002 fe52 	bl	25ff2 <z_get_next_timeout_expiry>
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   2334e:	782b      	ldrb	r3, [r5, #0]
		_kernel.idle = z_get_next_timeout_expiry();
   23350:	6160      	str	r0, [r4, #20]
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   23352:	b913      	cbnz	r3, 2335a <idle+0x26>
	arch_cpu_idle();
   23354:	f7fa ff9e 	bl	1e294 <arch_cpu_idle>
}
   23358:	e7ef      	b.n	2333a <idle+0x6>
   2335a:	f7f9 fe3b 	bl	1cfd4 <pm_system_suspend>
   2335e:	2800      	cmp	r0, #0
   23360:	d1eb      	bne.n	2333a <idle+0x6>
   23362:	e7f7      	b.n	23354 <idle+0x20>
   23364:	2000b5c0 	.word	0x2000b5c0
   23368:	2000b637 	.word	0x2000b637

0002336c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   2336c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   23370:	4604      	mov	r4, r0
   23372:	4617      	mov	r7, r2
   23374:	461e      	mov	r6, r3
   23376:	f04f 0320 	mov.w	r3, #32
   2337a:	f3ef 8811 	mrs	r8, BASEPRI
   2337e:	f383 8812 	msr	BASEPRI_MAX, r3
   23382:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   23386:	68c3      	ldr	r3, [r0, #12]
   23388:	4a33      	ldr	r2, [pc, #204]	; (23458 <z_impl_k_mutex_lock+0xec>)
   2338a:	b17b      	cbz	r3, 233ac <z_impl_k_mutex_lock+0x40>
   2338c:	6880      	ldr	r0, [r0, #8]
   2338e:	6891      	ldr	r1, [r2, #8]
   23390:	4288      	cmp	r0, r1
   23392:	d019      	beq.n	233c8 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   23394:	ea57 0306 	orrs.w	r3, r7, r6
   23398:	d118      	bne.n	233cc <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   2339a:	f388 8811 	msr	BASEPRI, r8
   2339e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   233a2:	f06f 000f 	mvn.w	r0, #15
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   233a6:	b002      	add	sp, #8
   233a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   233ac:	6891      	ldr	r1, [r2, #8]
   233ae:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   233b2:	3301      	adds	r3, #1
   233b4:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   233b6:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   233b8:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   233ba:	60a3      	str	r3, [r4, #8]
   233bc:	f388 8811 	msr	BASEPRI, r8
   233c0:	f3bf 8f6f 	isb	sy
		return 0;
   233c4:	2000      	movs	r0, #0
   233c6:	e7ee      	b.n	233a6 <z_impl_k_mutex_lock+0x3a>
					_current->base.prio :
   233c8:	6921      	ldr	r1, [r4, #16]
   233ca:	e7f2      	b.n	233b2 <z_impl_k_mutex_lock+0x46>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   233cc:	f991 100e 	ldrsb.w	r1, [r1, #14]
   233d0:	f990 300e 	ldrsb.w	r3, [r0, #14]
	return prio >= CONFIG_PRIORITY_CEILING;
}

static inline int z_get_new_prio_with_ceiling(int prio)
{
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
   233d4:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   233d8:	4299      	cmp	r1, r3
   233da:	bfa8      	it	ge
   233dc:	4619      	movge	r1, r3
   233de:	4291      	cmp	r1, r2
   233e0:	bfb8      	it	lt
   233e2:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   233e4:	428b      	cmp	r3, r1
   233e6:	dd2e      	ble.n	23446 <z_impl_k_mutex_lock+0xda>
		resched = adjust_owner_prio(mutex, new_prio);
   233e8:	f002 fbef 	bl	25bca <adjust_owner_prio.isra.0>
   233ec:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   233ee:	4622      	mov	r2, r4
   233f0:	4641      	mov	r1, r8
   233f2:	e9cd 7600 	strd	r7, r6, [sp]
   233f6:	4819      	ldr	r0, [pc, #100]	; (2345c <z_impl_k_mutex_lock+0xf0>)
   233f8:	f000 fba2 	bl	23b40 <z_pend_curr>
	if (got_mutex == 0) {
   233fc:	2800      	cmp	r0, #0
   233fe:	d0e1      	beq.n	233c4 <z_impl_k_mutex_lock+0x58>
	__asm__ volatile(
   23400:	f04f 0320 	mov.w	r3, #32
   23404:	f3ef 8611 	mrs	r6, BASEPRI
   23408:	f383 8812 	msr	BASEPRI_MAX, r3
   2340c:	f3bf 8f6f 	isb	sy
	if (likely(mutex->owner != NULL)) {
   23410:	68a0      	ldr	r0, [r4, #8]
   23412:	b1d0      	cbz	r0, 2344a <z_impl_k_mutex_lock+0xde>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   23414:	6823      	ldr	r3, [r4, #0]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   23416:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23418:	429c      	cmp	r4, r3
   2341a:	d00a      	beq.n	23432 <z_impl_k_mutex_lock+0xc6>
   2341c:	b14b      	cbz	r3, 23432 <z_impl_k_mutex_lock+0xc6>
   2341e:	f993 300e 	ldrsb.w	r3, [r3, #14]
   23422:	4299      	cmp	r1, r3
   23424:	bfa8      	it	ge
   23426:	4619      	movge	r1, r3
   23428:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   2342c:	4299      	cmp	r1, r3
   2342e:	bfb8      	it	lt
   23430:	4619      	movlt	r1, r3
		resched = adjust_owner_prio(mutex, new_prio) || resched;
   23432:	f002 fbca 	bl	25bca <adjust_owner_prio.isra.0>
   23436:	b140      	cbz	r0, 2344a <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
   23438:	4631      	mov	r1, r6
   2343a:	4808      	ldr	r0, [pc, #32]	; (2345c <z_impl_k_mutex_lock+0xf0>)
   2343c:	f000 fbe4 	bl	23c08 <z_reschedule>
	return -EAGAIN;
   23440:	f06f 000a 	mvn.w	r0, #10
   23444:	e7af      	b.n	233a6 <z_impl_k_mutex_lock+0x3a>
	bool resched = false;
   23446:	2500      	movs	r5, #0
   23448:	e7d1      	b.n	233ee <z_impl_k_mutex_lock+0x82>
	if (resched) {
   2344a:	2d00      	cmp	r5, #0
   2344c:	d1f4      	bne.n	23438 <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   2344e:	f386 8811 	msr	BASEPRI, r6
   23452:	f3bf 8f6f 	isb	sy
   23456:	e7f3      	b.n	23440 <z_impl_k_mutex_lock+0xd4>
   23458:	2000b5c0 	.word	0x2000b5c0
   2345c:	2000b638 	.word	0x2000b638

00023460 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   23460:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   23462:	6883      	ldr	r3, [r0, #8]
{
   23464:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   23466:	b36b      	cbz	r3, 234c4 <z_impl_k_mutex_unlock+0x64>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   23468:	4a19      	ldr	r2, [pc, #100]	; (234d0 <z_impl_k_mutex_unlock+0x70>)
   2346a:	6892      	ldr	r2, [r2, #8]
   2346c:	4293      	cmp	r3, r2
   2346e:	d12c      	bne.n	234ca <z_impl_k_mutex_unlock+0x6a>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   23470:	68c3      	ldr	r3, [r0, #12]
   23472:	2b01      	cmp	r3, #1
   23474:	d903      	bls.n	2347e <z_impl_k_mutex_unlock+0x1e>
		mutex->lock_count--;
   23476:	3b01      	subs	r3, #1
   23478:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
   2347a:	2000      	movs	r0, #0
}
   2347c:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   2347e:	f04f 0320 	mov.w	r3, #32
   23482:	f3ef 8511 	mrs	r5, BASEPRI
   23486:	f383 8812 	msr	BASEPRI_MAX, r3
   2348a:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   2348e:	6901      	ldr	r1, [r0, #16]
   23490:	6880      	ldr	r0, [r0, #8]
   23492:	f002 fb9a 	bl	25bca <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   23496:	4620      	mov	r0, r4
   23498:	f002 fd18 	bl	25ecc <z_unpend_first_thread>
	mutex->owner = new_owner;
   2349c:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   2349e:	b158      	cbz	r0, 234b8 <z_impl_k_mutex_unlock+0x58>
		mutex->owner_orig_prio = new_owner->base.prio;
   234a0:	f990 200e 	ldrsb.w	r2, [r0, #14]
   234a4:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   234a6:	2200      	movs	r2, #0
   234a8:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
   234aa:	f002 fcc7 	bl	25e3c <z_ready_thread>
		z_reschedule(&lock, key);
   234ae:	4629      	mov	r1, r5
   234b0:	4808      	ldr	r0, [pc, #32]	; (234d4 <z_impl_k_mutex_unlock+0x74>)
   234b2:	f000 fba9 	bl	23c08 <z_reschedule>
   234b6:	e7e0      	b.n	2347a <z_impl_k_mutex_unlock+0x1a>
		mutex->lock_count = 0U;
   234b8:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   234ba:	f385 8811 	msr	BASEPRI, r5
   234be:	f3bf 8f6f 	isb	sy
   234c2:	e7da      	b.n	2347a <z_impl_k_mutex_unlock+0x1a>
		return -EINVAL;
   234c4:	f06f 0015 	mvn.w	r0, #21
   234c8:	e7d8      	b.n	2347c <z_impl_k_mutex_unlock+0x1c>
		return -EPERM;
   234ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   234ce:	e7d5      	b.n	2347c <z_impl_k_mutex_unlock+0x1c>
   234d0:	2000b5c0 	.word	0x2000b5c0
   234d4:	2000b638 	.word	0x2000b638

000234d8 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   234d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   234da:	4611      	mov	r1, r2
	__asm__ volatile(
   234dc:	f04f 0220 	mov.w	r2, #32
   234e0:	f3ef 8511 	mrs	r5, BASEPRI
   234e4:	f382 8812 	msr	BASEPRI_MAX, r2
   234e8:	f3bf 8f6f 	isb	sy
   234ec:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   234ee:	b19c      	cbz	r4, 23518 <z_impl_k_queue_get+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   234f0:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   234f2:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   234f4:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   234f8:	4294      	cmp	r4, r2
	list->head = node;
   234fa:	6003      	str	r3, [r0, #0]
	list->tail = node;
   234fc:	bf08      	it	eq
   234fe:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   23500:	2101      	movs	r1, #1
   23502:	4620      	mov	r0, r4
   23504:	f002 fbd2 	bl	25cac <z_queue_node_peek>
   23508:	4604      	mov	r4, r0
	__asm__ volatile(
   2350a:	f385 8811 	msr	BASEPRI, r5
   2350e:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   23512:	4620      	mov	r0, r4
   23514:	b003      	add	sp, #12
   23516:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   23518:	ea51 0203 	orrs.w	r2, r1, r3
   2351c:	d0f5      	beq.n	2350a <z_impl_k_queue_get+0x32>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2351e:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   23522:	e9cd 1300 	strd	r1, r3, [sp]
   23526:	4610      	mov	r0, r2
   23528:	4629      	mov	r1, r5
   2352a:	f000 fb09 	bl	23b40 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   2352e:	2800      	cmp	r0, #0
   23530:	d1ef      	bne.n	23512 <z_impl_k_queue_get+0x3a>
   23532:	4b02      	ldr	r3, [pc, #8]	; (2353c <z_impl_k_queue_get+0x64>)
   23534:	689b      	ldr	r3, [r3, #8]
   23536:	695c      	ldr	r4, [r3, #20]
   23538:	e7eb      	b.n	23512 <z_impl_k_queue_get+0x3a>
   2353a:	bf00      	nop
   2353c:	2000b5c0 	.word	0x2000b5c0

00023540 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   23540:	b538      	push	{r3, r4, r5, lr}
   23542:	4604      	mov	r4, r0
	__asm__ volatile(
   23544:	f04f 0320 	mov.w	r3, #32
   23548:	f3ef 8511 	mrs	r5, BASEPRI
   2354c:	f383 8812 	msr	BASEPRI_MAX, r3
   23550:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   23554:	f002 fcba 	bl	25ecc <z_unpend_first_thread>

	if (thread != NULL) {
   23558:	b148      	cbz	r0, 2356e <z_impl_k_sem_give+0x2e>
   2355a:	2200      	movs	r2, #0
   2355c:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   2355e:	f002 fc6d 	bl	25e3c <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   23562:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   23564:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   23568:	4804      	ldr	r0, [pc, #16]	; (2357c <z_impl_k_sem_give+0x3c>)
   2356a:	f000 bb4d 	b.w	23c08 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   2356e:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   23572:	429a      	cmp	r2, r3
   23574:	bf18      	it	ne
   23576:	3301      	addne	r3, #1
   23578:	60a3      	str	r3, [r4, #8]
}
   2357a:	e7f2      	b.n	23562 <z_impl_k_sem_give+0x22>
   2357c:	2000b638 	.word	0x2000b638

00023580 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   23580:	b513      	push	{r0, r1, r4, lr}
   23582:	f04f 0420 	mov.w	r4, #32
   23586:	f3ef 8111 	mrs	r1, BASEPRI
   2358a:	f384 8812 	msr	BASEPRI_MAX, r4
   2358e:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   23592:	6884      	ldr	r4, [r0, #8]
   23594:	b144      	cbz	r4, 235a8 <z_impl_k_sem_take+0x28>
		sem->count--;
   23596:	3c01      	subs	r4, #1
   23598:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
   2359a:	f381 8811 	msr	BASEPRI, r1
   2359e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   235a2:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   235a4:	b002      	add	sp, #8
   235a6:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   235a8:	ea52 0403 	orrs.w	r4, r2, r3
   235ac:	d106      	bne.n	235bc <z_impl_k_sem_take+0x3c>
   235ae:	f381 8811 	msr	BASEPRI, r1
   235b2:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   235b6:	f06f 000f 	mvn.w	r0, #15
   235ba:	e7f3      	b.n	235a4 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   235bc:	e9cd 2300 	strd	r2, r3, [sp]
   235c0:	4602      	mov	r2, r0
   235c2:	4802      	ldr	r0, [pc, #8]	; (235cc <z_impl_k_sem_take+0x4c>)
   235c4:	f000 fabc 	bl	23b40 <z_pend_curr>
	return ret;
   235c8:	e7ec      	b.n	235a4 <z_impl_k_sem_take+0x24>
   235ca:	bf00      	nop
   235cc:	2000b638 	.word	0x2000b638

000235d0 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
   235d0:	b570      	push	{r4, r5, r6, lr}
   235d2:	4604      	mov	r4, r0
	__asm__ volatile(
   235d4:	f04f 0320 	mov.w	r3, #32
   235d8:	f3ef 8511 	mrs	r5, BASEPRI
   235dc:	f383 8812 	msr	BASEPRI_MAX, r3
   235e0:	f3bf 8f6f 	isb	sy
   235e4:	f06f 060a 	mvn.w	r6, #10
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
   235e8:	4620      	mov	r0, r4
   235ea:	f002 fc6f 	bl	25ecc <z_unpend_first_thread>
		if (thread == NULL) {
   235ee:	b118      	cbz	r0, 235f8 <z_impl_k_sem_reset+0x28>
   235f0:	6786      	str	r6, [r0, #120]	; 0x78
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
   235f2:	f002 fc23 	bl	25e3c <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
   235f6:	e7f7      	b.n	235e8 <z_impl_k_sem_reset+0x18>
	}
	sem->count = 0;
   235f8:	60a0      	str	r0, [r4, #8]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
   235fa:	4629      	mov	r1, r5
}
   235fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   23600:	4801      	ldr	r0, [pc, #4]	; (23608 <z_impl_k_sem_reset+0x38>)
   23602:	f000 bb01 	b.w	23c08 <z_reschedule>
   23606:	bf00      	nop
   23608:	2000b638 	.word	0x2000b638

0002360c <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
   2360c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23610:	4604      	mov	r4, r0
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
   23612:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   23616:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	return list->head;
   2361a:	4e48      	ldr	r6, [pc, #288]	; (2373c <work_queue_main+0x130>)
{
   2361c:	b085      	sub	sp, #20
   2361e:	f04f 0320 	mov.w	r3, #32
   23622:	f3ef 8711 	mrs	r7, BASEPRI
   23626:	f383 8812 	msr	BASEPRI_MAX, r3
   2362a:	f3bf 8f6f 	isb	sy
   2362e:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
   23632:	b98d      	cbnz	r5, 23658 <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
   23634:	2102      	movs	r1, #2
   23636:	f104 0098 	add.w	r0, r4, #152	; 0x98
   2363a:	f002 fb5a 	bl	25cf2 <flag_test_and_clear>
   2363e:	2800      	cmp	r0, #0
   23640:	d143      	bne.n	236ca <work_queue_main+0xbe>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
   23642:	2300      	movs	r3, #0
   23644:	4639      	mov	r1, r7
   23646:	e9cd 8900 	strd	r8, r9, [sp]
   2364a:	9302      	str	r3, [sp, #8]
   2364c:	f104 0288 	add.w	r2, r4, #136	; 0x88
   23650:	483b      	ldr	r0, [pc, #236]	; (23740 <work_queue_main+0x134>)
   23652:	f000 fc8f 	bl	23f74 <z_sched_wait>
			continue;
   23656:	e7e2      	b.n	2361e <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   23658:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
   2365c:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2365e:	4295      	cmp	r5, r2
	list->head = node;
   23660:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	list->tail = node;
   23664:	bf08      	it	eq
   23666:	f8c4 3084 	streq.w	r3, [r4, #132]	; 0x84
	*flagp |= BIT(bit);
   2366a:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   2366e:	f043 0302 	orr.w	r3, r3, #2
   23672:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
   23676:	68eb      	ldr	r3, [r5, #12]
   23678:	f023 0304 	bic.w	r3, r3, #4
   2367c:	f043 0301 	orr.w	r3, r3, #1
   23680:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
   23682:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
   23684:	f387 8811 	msr	BASEPRI, r7
   23688:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
		handler(work);
   2368c:	4628      	mov	r0, r5
   2368e:	4798      	blx	r3
	__asm__ volatile(
   23690:	f04f 0320 	mov.w	r3, #32
   23694:	f3ef 8b11 	mrs	fp, BASEPRI
   23698:	f383 8812 	msr	BASEPRI_MAX, r3
   2369c:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
   236a0:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   236a2:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
   236a4:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   236a8:	d419      	bmi.n	236de <work_queue_main+0xd2>
	*flagp &= ~BIT(bit);
   236aa:	60ea      	str	r2, [r5, #12]
   236ac:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   236b0:	f023 0302 	bic.w	r3, r3, #2
   236b4:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	__asm__ volatile(
   236b8:	f38b 8811 	msr	BASEPRI, fp
   236bc:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
   236c0:	05db      	lsls	r3, r3, #23
   236c2:	d4ac      	bmi.n	2361e <work_queue_main+0x12>
	z_impl_k_yield();
   236c4:	f000 fb3a 	bl	23d3c <z_impl_k_yield>
}
   236c8:	e7a9      	b.n	2361e <work_queue_main+0x12>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
   236ca:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
   236ce:	2200      	movs	r2, #0
   236d0:	2101      	movs	r1, #1
   236d2:	4628      	mov	r0, r5
   236d4:	f002 fc54 	bl	25f80 <z_sched_wake>
   236d8:	2800      	cmp	r0, #0
   236da:	d1f8      	bne.n	236ce <work_queue_main+0xc2>
   236dc:	e7b1      	b.n	23642 <work_queue_main+0x36>
	return list->head;
   236de:	6830      	ldr	r0, [r6, #0]
	*flagp &= ~BIT(bit);
   236e0:	f023 0303 	bic.w	r3, r3, #3
   236e4:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   236e6:	2800      	cmp	r0, #0
   236e8:	d0e0      	beq.n	236ac <work_queue_main+0xa0>
	return node->next;
   236ea:	2700      	movs	r7, #0
	parent->next = child;
   236ec:	463b      	mov	r3, r7
	return node->next;
   236ee:	f8d0 a000 	ldr.w	sl, [r0]
   236f2:	2800      	cmp	r0, #0
   236f4:	d0da      	beq.n	236ac <work_queue_main+0xa0>
		if (wc->work == work) {
   236f6:	6842      	ldr	r2, [r0, #4]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
   236f8:	4601      	mov	r1, r0
		if (wc->work == work) {
   236fa:	4295      	cmp	r5, r2
   236fc:	d10c      	bne.n	23718 <work_queue_main+0x10c>
   236fe:	6801      	ldr	r1, [r0, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
   23700:	b99f      	cbnz	r7, 2372a <work_queue_main+0x11e>
   23702:	6872      	ldr	r2, [r6, #4]
	list->head = node;
   23704:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
   23706:	4282      	cmp	r2, r0
   23708:	d100      	bne.n	2370c <work_queue_main+0x100>
	list->tail = node;
   2370a:	6071      	str	r1, [r6, #4]
	parent->next = child;
   2370c:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
   23710:	f7ff ff16 	bl	23540 <z_impl_k_sem_give>
}
   23714:	4639      	mov	r1, r7
   23716:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   23718:	f1ba 0f00 	cmp.w	sl, #0
   2371c:	d00b      	beq.n	23736 <work_queue_main+0x12a>
	return node->next;
   2371e:	f8da 2000 	ldr.w	r2, [sl]
   23722:	4650      	mov	r0, sl
   23724:	460f      	mov	r7, r1
   23726:	4692      	mov	sl, r2
   23728:	e7e3      	b.n	236f2 <work_queue_main+0xe6>
	parent->next = child;
   2372a:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
   2372c:	6872      	ldr	r2, [r6, #4]
   2372e:	4282      	cmp	r2, r0
	list->tail = node;
   23730:	bf08      	it	eq
   23732:	6077      	streq	r7, [r6, #4]
}
   23734:	e7ea      	b.n	2370c <work_queue_main+0x100>
   23736:	4652      	mov	r2, sl
   23738:	e7f3      	b.n	23722 <work_queue_main+0x116>
   2373a:	bf00      	nop
   2373c:	2000b5e4 	.word	0x2000b5e4
   23740:	2000b638 	.word	0x2000b638

00023744 <submit_to_queue_locked>:
{
   23744:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
   23746:	68c3      	ldr	r3, [r0, #12]
{
   23748:	4604      	mov	r4, r0
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   2374a:	079a      	lsls	r2, r3, #30
{
   2374c:	460f      	mov	r7, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   2374e:	f3c3 0640 	ubfx	r6, r3, #1, #1
   23752:	d42c      	bmi.n	237ae <submit_to_queue_locked+0x6a>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
   23754:	075b      	lsls	r3, r3, #29
   23756:	d41a      	bmi.n	2378e <submit_to_queue_locked+0x4a>
		if (*queuep == NULL) {
   23758:	680b      	ldr	r3, [r1, #0]
   2375a:	b90b      	cbnz	r3, 23760 <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
   2375c:	6883      	ldr	r3, [r0, #8]
   2375e:	600b      	str	r3, [r1, #0]
	return (*flagp & BIT(bit)) != 0U;
   23760:	68e3      	ldr	r3, [r4, #12]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
   23762:	07dd      	lsls	r5, r3, #31
			*queuep = work->queue;
   23764:	bf42      	ittt	mi
   23766:	68a3      	ldrmi	r3, [r4, #8]
			ret = 2;
   23768:	2602      	movmi	r6, #2
			*queuep = work->queue;
   2376a:	603b      	strmi	r3, [r7, #0]
		int rc = queue_submit_locked(*queuep, work);
   2376c:	683d      	ldr	r5, [r7, #0]
		ret = 1;
   2376e:	bf58      	it	pl
   23770:	2601      	movpl	r6, #1
	if (queue == NULL) {
   23772:	2d00      	cmp	r5, #0
   23774:	d03a      	beq.n	237ec <submit_to_queue_locked+0xa8>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   23776:	4b1f      	ldr	r3, [pc, #124]	; (237f4 <submit_to_queue_locked+0xb0>)
   23778:	689b      	ldr	r3, [r3, #8]
   2377a:	42ab      	cmp	r3, r5
   2377c:	d00a      	beq.n	23794 <submit_to_queue_locked+0x50>
	return (*flagp & BIT(bit)) != 0U;
   2377e:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   23782:	07d8      	lsls	r0, r3, #31
	return (*flagp & BIT(bit)) != 0U;
   23784:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   23788:	d414      	bmi.n	237b4 <submit_to_queue_locked+0x70>
		ret = -EBUSY;
   2378a:	f06f 0612 	mvn.w	r6, #18
		*queuep = NULL;
   2378e:	2300      	movs	r3, #0
   23790:	603b      	str	r3, [r7, #0]
	return ret;
   23792:	e025      	b.n	237e0 <submit_to_queue_locked+0x9c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   23794:	f002 fa07 	bl	25ba6 <k_is_in_isr>
   23798:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
   2379c:	2800      	cmp	r0, #0
   2379e:	d1f0      	bne.n	23782 <submit_to_queue_locked+0x3e>
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   237a0:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
   237a2:	f3c3 02c0 	ubfx	r2, r3, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   237a6:	d5f0      	bpl.n	2378a <submit_to_queue_locked+0x46>
	} else if (plugged && !draining) {
   237a8:	b152      	cbz	r2, 237c0 <submit_to_queue_locked+0x7c>
   237aa:	075b      	lsls	r3, r3, #29
   237ac:	d408      	bmi.n	237c0 <submit_to_queue_locked+0x7c>
		ret = -EBUSY;
   237ae:	f06f 060f 	mvn.w	r6, #15
   237b2:	e7ec      	b.n	2378e <submit_to_queue_locked+0x4a>
	} else if (draining && !chained) {
   237b4:	2a00      	cmp	r2, #0
   237b6:	d1fa      	bne.n	237ae <submit_to_queue_locked+0x6a>
	return (*flagp & BIT(bit)) != 0U;
   237b8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
	} else if (plugged && !draining) {
   237bc:	2b00      	cmp	r3, #0
   237be:	d1f6      	bne.n	237ae <submit_to_queue_locked+0x6a>
	parent->next = child;
   237c0:	2300      	movs	r3, #0
   237c2:	6023      	str	r3, [r4, #0]
	return list->tail;
   237c4:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
Z_GENLIST_APPEND(slist, snode)
   237c8:	b963      	cbnz	r3, 237e4 <submit_to_queue_locked+0xa0>
	list->head = node;
   237ca:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
		(void)notify_queue_locked(queue);
   237ce:	4628      	mov	r0, r5
   237d0:	f002 fa9a 	bl	25d08 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
   237d4:	68e3      	ldr	r3, [r4, #12]
   237d6:	f043 0304 	orr.w	r3, r3, #4
   237da:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
   237dc:	683b      	ldr	r3, [r7, #0]
   237de:	60a3      	str	r3, [r4, #8]
}
   237e0:	4630      	mov	r0, r6
   237e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
   237e4:	601c      	str	r4, [r3, #0]
	list->tail = node;
   237e6:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
}
   237ea:	e7f0      	b.n	237ce <submit_to_queue_locked+0x8a>
		return -EINVAL;
   237ec:	f06f 0615 	mvn.w	r6, #21
   237f0:	e7cd      	b.n	2378e <submit_to_queue_locked+0x4a>
   237f2:	bf00      	nop
   237f4:	2000b5c0 	.word	0x2000b5c0

000237f8 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
   237f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   237fa:	4604      	mov	r4, r0
	list->head = NULL;
   237fc:	2000      	movs	r0, #0
   237fe:	b089      	sub	sp, #36	; 0x24
	list->tail = NULL;
   23800:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
   23804:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   23806:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = (sys_dnode_t *)list;
   2380a:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
   2380e:	f104 0090 	add.w	r0, r4, #144	; 0x90
   23812:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
   23816:	b31d      	cbz	r5, 23860 <k_work_queue_start+0x68>
   23818:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
   2381a:	2800      	cmp	r0, #0
   2381c:	f240 1001 	movw	r0, #257	; 0x101
   23820:	bf08      	it	eq
   23822:	2001      	moveq	r0, #1
	*flagp = flags;
   23824:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   23828:	2000      	movs	r0, #0
   2382a:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2382e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   23832:	e9cd 3003 	strd	r3, r0, [sp, #12]
   23836:	e9cd 0001 	strd	r0, r0, [sp, #4]
   2383a:	e9cd 6706 	strd	r6, r7, [sp, #24]
   2383e:	4620      	mov	r0, r4
   23840:	4b08      	ldr	r3, [pc, #32]	; (23864 <k_work_queue_start+0x6c>)
   23842:	9400      	str	r4, [sp, #0]
   23844:	f7ff fcee 	bl	23224 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
   23848:	b125      	cbz	r5, 23854 <k_work_queue_start+0x5c>
   2384a:	6829      	ldr	r1, [r5, #0]
   2384c:	b111      	cbz	r1, 23854 <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
   2384e:	4620      	mov	r0, r4
   23850:	f002 f9af 	bl	25bb2 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
   23854:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
   23856:	b009      	add	sp, #36	; 0x24
   23858:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   2385c:	f002 b9ac 	b.w	25bb8 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
   23860:	2001      	movs	r0, #1
   23862:	e7df      	b.n	23824 <k_work_queue_start+0x2c>
   23864:	0002360d 	.word	0x0002360d

00023868 <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
   23868:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2386a:	9001      	str	r0, [sp, #4]
   2386c:	4608      	mov	r0, r1
	__asm__ volatile(
   2386e:	f04f 0120 	mov.w	r1, #32
   23872:	f3ef 8411 	mrs	r4, BASEPRI
   23876:	f381 8812 	msr	BASEPRI_MAX, r1
   2387a:	f3bf 8f6f 	isb	sy
	return *flagp;
   2387e:	68c1      	ldr	r1, [r0, #12]
	struct k_work *work = &dwork->work;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
   23880:	f011 0f0e 	tst.w	r1, #14
   23884:	d116      	bne.n	238b4 <k_work_schedule_for_queue+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   23886:	ea53 0502 	orrs.w	r5, r3, r2
   2388a:	d108      	bne.n	2389e <k_work_schedule_for_queue+0x36>
		return submit_to_queue_locked(work, queuep);
   2388c:	a901      	add	r1, sp, #4
   2388e:	f7ff ff59 	bl	23744 <submit_to_queue_locked>
	__asm__ volatile(
   23892:	f384 8811 	msr	BASEPRI, r4
   23896:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   2389a:	b003      	add	sp, #12
   2389c:	bd30      	pop	{r4, r5, pc}
	*flagp |= BIT(bit);
   2389e:	f041 0108 	orr.w	r1, r1, #8
   238a2:	60c1      	str	r1, [r0, #12]
	dwork->queue = *queuep;
   238a4:	9901      	ldr	r1, [sp, #4]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   238a6:	3010      	adds	r0, #16
	dwork->queue = *queuep;
   238a8:	6181      	str	r1, [r0, #24]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   238aa:	4903      	ldr	r1, [pc, #12]	; (238b8 <k_work_schedule_for_queue+0x50>)
   238ac:	f000 fbd4 	bl	24058 <z_add_timeout>
	return ret;
   238b0:	2001      	movs	r0, #1
   238b2:	e7ee      	b.n	23892 <k_work_schedule_for_queue+0x2a>
	int ret = 0;
   238b4:	2000      	movs	r0, #0
   238b6:	e7ec      	b.n	23892 <k_work_schedule_for_queue+0x2a>
   238b8:	00025d17 	.word	0x00025d17

000238bc <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
   238bc:	89c3      	ldrh	r3, [r0, #14]
   238be:	2b7f      	cmp	r3, #127	; 0x7f
   238c0:	d812      	bhi.n	238e8 <sliceable+0x2c>
	int ret = slice_ticks;
   238c2:	4b0a      	ldr	r3, [pc, #40]	; (238ec <sliceable+0x30>)
   238c4:	681b      	ldr	r3, [r3, #0]
		&& slice_time(thread) != 0
   238c6:	b163      	cbz	r3, 238e2 <sliceable+0x26>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   238c8:	4b09      	ldr	r3, [pc, #36]	; (238f0 <sliceable+0x34>)
   238ca:	f990 200e 	ldrsb.w	r2, [r0, #14]
   238ce:	681b      	ldr	r3, [r3, #0]
   238d0:	429a      	cmp	r2, r3
   238d2:	db09      	blt.n	238e8 <sliceable+0x2c>
		&& !z_is_thread_prevented_from_running(thread)
   238d4:	7b43      	ldrb	r3, [r0, #13]
   238d6:	06db      	lsls	r3, r3, #27
   238d8:	d106      	bne.n	238e8 <sliceable+0x2c>
		&& !z_is_idle_thread_object(thread);
   238da:	4b06      	ldr	r3, [pc, #24]	; (238f4 <sliceable+0x38>)
   238dc:	1ac3      	subs	r3, r0, r3
   238de:	bf18      	it	ne
   238e0:	2301      	movne	r3, #1
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
   238e2:	f003 0001 	and.w	r0, r3, #1
   238e6:	4770      	bx	lr
		&& !z_is_idle_thread_object(thread);
   238e8:	2300      	movs	r3, #0
   238ea:	e7fa      	b.n	238e2 <sliceable+0x26>
   238ec:	2000b5f4 	.word	0x2000b5f4
   238f0:	2000b5f0 	.word	0x2000b5f0
   238f4:	2000a570 	.word	0x2000a570

000238f8 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);

	slice_expired[cpu] = true;
   238f8:	2201      	movs	r2, #1
	int cpu = ARRAY_INDEX(slice_timeouts, t);
   238fa:	4b04      	ldr	r3, [pc, #16]	; (2390c <slice_timeout+0x14>)
   238fc:	1ac0      	subs	r0, r0, r3
   238fe:	4b04      	ldr	r3, [pc, #16]	; (23910 <slice_timeout+0x18>)
   23900:	10c0      	asrs	r0, r0, #3
   23902:	4358      	muls	r0, r3
	slice_expired[cpu] = true;
   23904:	4b03      	ldr	r3, [pc, #12]	; (23914 <slice_timeout+0x1c>)
   23906:	541a      	strb	r2, [r3, r0]
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
   23908:	4770      	bx	lr
   2390a:	bf00      	nop
   2390c:	2000a670 	.word	0x2000a670
   23910:	aaaaaaab 	.word	0xaaaaaaab
   23914:	2000b638 	.word	0x2000b638

00023918 <z_reset_time_slice>:

void z_reset_time_slice(struct k_thread *curr)
{
   23918:	b570      	push	{r4, r5, r6, lr}
	int cpu = _current_cpu->id;
   2391a:	4b0e      	ldr	r3, [pc, #56]	; (23954 <z_reset_time_slice+0x3c>)

	z_abort_timeout(&slice_timeouts[cpu]);
   2391c:	4c0e      	ldr	r4, [pc, #56]	; (23958 <z_reset_time_slice+0x40>)
	int cpu = _current_cpu->id;
   2391e:	7c1e      	ldrb	r6, [r3, #16]
{
   23920:	4605      	mov	r5, r0
	z_abort_timeout(&slice_timeouts[cpu]);
   23922:	eb06 0346 	add.w	r3, r6, r6, lsl #1
   23926:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
   2392a:	4620      	mov	r0, r4
   2392c:	f002 fb4b 	bl	25fc6 <z_abort_timeout>
	slice_expired[cpu] = false;
   23930:	2200      	movs	r2, #0
   23932:	4b0a      	ldr	r3, [pc, #40]	; (2395c <z_reset_time_slice+0x44>)
	if (sliceable(curr)) {
   23934:	4628      	mov	r0, r5
	slice_expired[cpu] = false;
   23936:	559a      	strb	r2, [r3, r6]
	if (sliceable(curr)) {
   23938:	f7ff ffc0 	bl	238bc <sliceable>
   2393c:	b148      	cbz	r0, 23952 <z_reset_time_slice+0x3a>
	int ret = slice_ticks;
   2393e:	4b08      	ldr	r3, [pc, #32]	; (23960 <z_reset_time_slice+0x48>)
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
   23940:	4620      	mov	r0, r4
			      K_TICKS(slice_time(curr) - 1));
	}
}
   23942:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			      K_TICKS(slice_time(curr) - 1));
   23946:	681a      	ldr	r2, [r3, #0]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
   23948:	4906      	ldr	r1, [pc, #24]	; (23964 <z_reset_time_slice+0x4c>)
			      K_TICKS(slice_time(curr) - 1));
   2394a:	3a01      	subs	r2, #1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
   2394c:	17d3      	asrs	r3, r2, #31
   2394e:	f000 bb83 	b.w	24058 <z_add_timeout>
}
   23952:	bd70      	pop	{r4, r5, r6, pc}
   23954:	2000b5c0 	.word	0x2000b5c0
   23958:	2000a670 	.word	0x2000a670
   2395c:	2000b638 	.word	0x2000b638
   23960:	2000b5f4 	.word	0x2000b5f4
   23964:	000238f9 	.word	0x000238f9

00023968 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
   23968:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   2396a:	4d0d      	ldr	r5, [pc, #52]	; (239a0 <update_cache+0x38>)
   2396c:	462b      	mov	r3, r5
   2396e:	f853 4f1c 	ldr.w	r4, [r3, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23972:	429c      	cmp	r4, r3
   23974:	d000      	beq.n	23978 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   23976:	b904      	cbnz	r4, 2397a <update_cache+0x12>
   23978:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
   2397a:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
   2397c:	b938      	cbnz	r0, 2398e <update_cache+0x26>
	if (z_is_thread_prevented_from_running(_current)) {
   2397e:	7b5a      	ldrb	r2, [r3, #13]
   23980:	06d2      	lsls	r2, r2, #27
   23982:	d104      	bne.n	2398e <update_cache+0x26>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   23984:	69a2      	ldr	r2, [r4, #24]
   23986:	b912      	cbnz	r2, 2398e <update_cache+0x26>
	if (is_preempt(_current) || is_metairq(thread)) {
   23988:	89da      	ldrh	r2, [r3, #14]
   2398a:	2a7f      	cmp	r2, #127	; 0x7f
   2398c:	d805      	bhi.n	2399a <update_cache+0x32>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
   2398e:	429c      	cmp	r4, r3
   23990:	d002      	beq.n	23998 <update_cache+0x30>
			z_reset_time_slice(thread);
   23992:	4620      	mov	r0, r4
   23994:	f7ff ffc0 	bl	23918 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
   23998:	4623      	mov	r3, r4
   2399a:	61ab      	str	r3, [r5, #24]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
   2399c:	bd38      	pop	{r3, r4, r5, pc}
   2399e:	bf00      	nop
   239a0:	2000b5c0 	.word	0x2000b5c0

000239a4 <move_thread_to_end_of_prio_q>:
{
   239a4:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   239a6:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   239aa:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   239ac:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
   239ae:	7b43      	ldrb	r3, [r0, #13]
   239b0:	da04      	bge.n	239bc <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   239b2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   239b6:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   239b8:	f002 fa06 	bl	25dc8 <sys_dlist_remove>
	return list->head == list;
   239bc:	4a15      	ldr	r2, [pc, #84]	; (23a14 <move_thread_to_end_of_prio_q+0x70>)
	thread->base.thread_state |= _THREAD_QUEUED;
   239be:	7b4b      	ldrb	r3, [r1, #13]
   239c0:	4610      	mov	r0, r2
   239c2:	f063 037f 	orn	r3, r3, #127	; 0x7f
   239c6:	734b      	strb	r3, [r1, #13]
   239c8:	f850 3f1c 	ldr.w	r3, [r0, #28]!
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
   239cc:	6a14      	ldr	r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   239ce:	4283      	cmp	r3, r0
   239d0:	bf08      	it	eq
   239d2:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   239d4:	b923      	cbnz	r3, 239e0 <move_thread_to_end_of_prio_q+0x3c>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
   239d6:	e9c1 0400 	strd	r0, r4, [r1]

	tail->next = node;
   239da:	6021      	str	r1, [r4, #0]
	list->tail = node;
   239dc:	6211      	str	r1, [r2, #32]
}
   239de:	e00c      	b.n	239fa <move_thread_to_end_of_prio_q+0x56>
	int32_t b1 = thread_1->base.prio;
   239e0:	f991 500e 	ldrsb.w	r5, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   239e4:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
   239e8:	42b5      	cmp	r5, r6
   239ea:	d00e      	beq.n	23a0a <move_thread_to_end_of_prio_q+0x66>
		if (z_sched_prio_cmp(thread, t) > 0) {
   239ec:	42ae      	cmp	r6, r5
   239ee:	dd0c      	ble.n	23a0a <move_thread_to_end_of_prio_q+0x66>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   239f0:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   239f2:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   239f6:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   239f8:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   239fa:	6890      	ldr	r0, [r2, #8]
}
   239fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   23a00:	1a43      	subs	r3, r0, r1
   23a02:	4258      	negs	r0, r3
   23a04:	4158      	adcs	r0, r3
   23a06:	f7ff bfaf 	b.w	23968 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   23a0a:	429c      	cmp	r4, r3
   23a0c:	d0e3      	beq.n	239d6 <move_thread_to_end_of_prio_q+0x32>
   23a0e:	681b      	ldr	r3, [r3, #0]
   23a10:	e7e0      	b.n	239d4 <move_thread_to_end_of_prio_q+0x30>
   23a12:	bf00      	nop
   23a14:	2000b5c0 	.word	0x2000b5c0

00023a18 <ready_thread>:
{
   23a18:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   23a1a:	f990 300d 	ldrsb.w	r3, [r0, #13]
   23a1e:	7b42      	ldrb	r2, [r0, #13]
   23a20:	2b00      	cmp	r3, #0
   23a22:	db29      	blt.n	23a78 <ready_thread+0x60>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   23a24:	06d3      	lsls	r3, r2, #27
   23a26:	d127      	bne.n	23a78 <ready_thread+0x60>
	return node->next != NULL;
   23a28:	6983      	ldr	r3, [r0, #24]
   23a2a:	bb2b      	cbnz	r3, 23a78 <ready_thread+0x60>
	return list->head == list;
   23a2c:	4913      	ldr	r1, [pc, #76]	; (23a7c <ready_thread+0x64>)
	thread->base.thread_state |= _THREAD_QUEUED;
   23a2e:	f062 027f 	orn	r2, r2, #127	; 0x7f
   23a32:	7342      	strb	r2, [r0, #13]
   23a34:	460a      	mov	r2, r1
   23a36:	f852 4f1c 	ldr.w	r4, [r2, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23a3a:	4294      	cmp	r4, r2
   23a3c:	bf18      	it	ne
   23a3e:	4623      	movne	r3, r4
	return (node == list->tail) ? NULL : node->next;
   23a40:	6a0c      	ldr	r4, [r1, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   23a42:	b923      	cbnz	r3, 23a4e <ready_thread+0x36>
	node->prev = tail;
   23a44:	e9c0 2400 	strd	r2, r4, [r0]
	tail->next = node;
   23a48:	6020      	str	r0, [r4, #0]
	list->tail = node;
   23a4a:	6208      	str	r0, [r1, #32]
}
   23a4c:	e00c      	b.n	23a68 <ready_thread+0x50>
	int32_t b1 = thread_1->base.prio;
   23a4e:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   23a52:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
   23a56:	42b5      	cmp	r5, r6
   23a58:	d00a      	beq.n	23a70 <ready_thread+0x58>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23a5a:	42ae      	cmp	r6, r5
   23a5c:	dd08      	ble.n	23a70 <ready_thread+0x58>
	sys_dnode_t *const prev = successor->prev;
   23a5e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   23a60:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   23a64:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   23a66:	6058      	str	r0, [r3, #4]
		update_cache(0);
   23a68:	2000      	movs	r0, #0
}
   23a6a:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   23a6c:	f7ff bf7c 	b.w	23968 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   23a70:	42a3      	cmp	r3, r4
   23a72:	d0e7      	beq.n	23a44 <ready_thread+0x2c>
   23a74:	681b      	ldr	r3, [r3, #0]
   23a76:	e7e4      	b.n	23a42 <ready_thread+0x2a>
}
   23a78:	bc70      	pop	{r4, r5, r6}
   23a7a:	4770      	bx	lr
   23a7c:	2000b5c0 	.word	0x2000b5c0

00023a80 <unready_thread>:
{
   23a80:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   23a82:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   23a86:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   23a88:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
   23a8a:	7b43      	ldrb	r3, [r0, #13]
   23a8c:	da04      	bge.n	23a98 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23a8e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   23a92:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23a94:	f002 f998 	bl	25dc8 <sys_dlist_remove>
	update_cache(thread == _current);
   23a98:	4b04      	ldr	r3, [pc, #16]	; (23aac <unready_thread+0x2c>)
   23a9a:	6898      	ldr	r0, [r3, #8]
   23a9c:	1a43      	subs	r3, r0, r1
   23a9e:	4258      	negs	r0, r3
   23aa0:	4158      	adcs	r0, r3
}
   23aa2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   23aa6:	f7ff bf5f 	b.w	23968 <update_cache>
   23aaa:	bf00      	nop
   23aac:	2000b5c0 	.word	0x2000b5c0

00023ab0 <pend_locked>:
{
   23ab0:	b570      	push	{r4, r5, r6, lr}
   23ab2:	4615      	mov	r5, r2
   23ab4:	461c      	mov	r4, r3
   23ab6:	4606      	mov	r6, r0
	add_to_waitq_locked(thread, wait_q);
   23ab8:	f002 f998 	bl	25dec <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   23abc:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   23ac0:	bf08      	it	eq
   23ac2:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
   23ac6:	d008      	beq.n	23ada <pend_locked+0x2a>
   23ac8:	462a      	mov	r2, r5
   23aca:	4623      	mov	r3, r4
   23acc:	f106 0018 	add.w	r0, r6, #24
   23ad0:	4902      	ldr	r1, [pc, #8]	; (23adc <pend_locked+0x2c>)
}
   23ad2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   23ad6:	f000 babf 	b.w	24058 <z_add_timeout>
   23ada:	bd70      	pop	{r4, r5, r6, pc}
   23adc:	00025ec5 	.word	0x00025ec5

00023ae0 <z_time_slice>:
{
   23ae0:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   23ae2:	f04f 0320 	mov.w	r3, #32
   23ae6:	f3ef 8511 	mrs	r5, BASEPRI
   23aea:	f383 8812 	msr	BASEPRI_MAX, r3
   23aee:	f3bf 8f6f 	isb	sy
	struct k_thread *curr = _current;
   23af2:	4b10      	ldr	r3, [pc, #64]	; (23b34 <z_time_slice+0x54>)
	if (pending_current == curr) {
   23af4:	4a10      	ldr	r2, [pc, #64]	; (23b38 <z_time_slice+0x58>)
	struct k_thread *curr = _current;
   23af6:	689c      	ldr	r4, [r3, #8]
	if (pending_current == curr) {
   23af8:	6810      	ldr	r0, [r2, #0]
   23afa:	42a0      	cmp	r0, r4
   23afc:	d106      	bne.n	23b0c <z_time_slice+0x2c>
		z_reset_time_slice(curr);
   23afe:	f7ff ff0b 	bl	23918 <z_reset_time_slice>
	__asm__ volatile(
   23b02:	f385 8811 	msr	BASEPRI, r5
   23b06:	f3bf 8f6f 	isb	sy
}
   23b0a:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
   23b0c:	2100      	movs	r1, #0
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
   23b0e:	7c1b      	ldrb	r3, [r3, #16]
	pending_current = NULL;
   23b10:	6011      	str	r1, [r2, #0]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
   23b12:	4a0a      	ldr	r2, [pc, #40]	; (23b3c <z_time_slice+0x5c>)
   23b14:	5cd3      	ldrb	r3, [r2, r3]
   23b16:	2b00      	cmp	r3, #0
   23b18:	d0f3      	beq.n	23b02 <z_time_slice+0x22>
   23b1a:	4620      	mov	r0, r4
   23b1c:	f7ff fece 	bl	238bc <sliceable>
   23b20:	2800      	cmp	r0, #0
   23b22:	d0ee      	beq.n	23b02 <z_time_slice+0x22>
		if (!z_is_thread_prevented_from_running(curr)) {
   23b24:	7b63      	ldrb	r3, [r4, #13]
   23b26:	06db      	lsls	r3, r3, #27
   23b28:	d102      	bne.n	23b30 <z_time_slice+0x50>
			move_thread_to_end_of_prio_q(curr);
   23b2a:	4620      	mov	r0, r4
   23b2c:	f7ff ff3a 	bl	239a4 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
   23b30:	4620      	mov	r0, r4
   23b32:	e7e4      	b.n	23afe <z_time_slice+0x1e>
   23b34:	2000b5c0 	.word	0x2000b5c0
   23b38:	2000b5ec 	.word	0x2000b5ec
   23b3c:	2000b638 	.word	0x2000b638

00023b40 <z_pend_curr>:
{
   23b40:	b570      	push	{r4, r5, r6, lr}
	pending_current = _current;
   23b42:	480c      	ldr	r0, [pc, #48]	; (23b74 <z_pend_curr+0x34>)
   23b44:	4d0c      	ldr	r5, [pc, #48]	; (23b78 <z_pend_curr+0x38>)
   23b46:	6886      	ldr	r6, [r0, #8]
{
   23b48:	460c      	mov	r4, r1
	pending_current = _current;
   23b4a:	602e      	str	r6, [r5, #0]
{
   23b4c:	4611      	mov	r1, r2
   23b4e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
	__asm__ volatile(
   23b52:	f04f 0620 	mov.w	r6, #32
   23b56:	f3ef 8511 	mrs	r5, BASEPRI
   23b5a:	f386 8812 	msr	BASEPRI_MAX, r6
   23b5e:	f3bf 8f6f 	isb	sy
	pend_locked(_current, wait_q, timeout);
   23b62:	6880      	ldr	r0, [r0, #8]
   23b64:	f7ff ffa4 	bl	23ab0 <pend_locked>
	ret = arch_swap(key);
   23b68:	4620      	mov	r0, r4
}
   23b6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   23b6e:	f7fa bc1d 	b.w	1e3ac <arch_swap>
   23b72:	bf00      	nop
   23b74:	2000b5c0 	.word	0x2000b5c0
   23b78:	2000b5ec 	.word	0x2000b5ec

00023b7c <z_set_prio>:
{
   23b7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   23b7e:	4604      	mov	r4, r0
   23b80:	f04f 0320 	mov.w	r3, #32
   23b84:	f3ef 8611 	mrs	r6, BASEPRI
   23b88:	f383 8812 	msr	BASEPRI_MAX, r3
   23b8c:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
   23b90:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
   23b92:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   23b94:	06da      	lsls	r2, r3, #27
   23b96:	d119      	bne.n	23bcc <z_set_prio+0x50>
	return node->next != NULL;
   23b98:	6985      	ldr	r5, [r0, #24]
   23b9a:	b9bd      	cbnz	r5, 23bcc <z_set_prio+0x50>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23b9c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   23ba0:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23ba2:	f002 f911 	bl	25dc8 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   23ba6:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
   23ba8:	4a16      	ldr	r2, [pc, #88]	; (23c04 <z_set_prio+0x88>)
   23baa:	f063 037f 	orn	r3, r3, #127	; 0x7f
   23bae:	7343      	strb	r3, [r0, #13]
   23bb0:	4613      	mov	r3, r2
				thread->base.prio = prio;
   23bb2:	7381      	strb	r1, [r0, #14]
   23bb4:	f853 0f1c 	ldr.w	r0, [r3, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23bb8:	4298      	cmp	r0, r3
   23bba:	bf18      	it	ne
   23bbc:	4605      	movne	r5, r0
	return (node == list->tail) ? NULL : node->next;
   23bbe:	6a10      	ldr	r0, [r2, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   23bc0:	b95d      	cbnz	r5, 23bda <z_set_prio+0x5e>
	node->prev = tail;
   23bc2:	e9c4 3000 	strd	r3, r0, [r4]
	tail->next = node;
   23bc6:	6004      	str	r4, [r0, #0]
	list->tail = node;
   23bc8:	6214      	str	r4, [r2, #32]
}
   23bca:	e011      	b.n	23bf0 <z_set_prio+0x74>
   23bcc:	2000      	movs	r0, #0
			thread->base.prio = prio;
   23bce:	73a1      	strb	r1, [r4, #14]
	__asm__ volatile(
   23bd0:	f386 8811 	msr	BASEPRI, r6
   23bd4:	f3bf 8f6f 	isb	sy
}
   23bd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int32_t b2 = thread_2->base.prio;
   23bda:	f995 700e 	ldrsb.w	r7, [r5, #14]
	if (b1 != b2) {
   23bde:	42b9      	cmp	r1, r7
   23be0:	d00b      	beq.n	23bfa <z_set_prio+0x7e>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23be2:	428f      	cmp	r7, r1
   23be4:	dd09      	ble.n	23bfa <z_set_prio+0x7e>
	sys_dnode_t *const prev = successor->prev;
   23be6:	686b      	ldr	r3, [r5, #4]
	node->next = successor;
   23be8:	e9c4 5300 	strd	r5, r3, [r4]
	prev->next = node;
   23bec:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   23bee:	606c      	str	r4, [r5, #4]
			update_cache(1);
   23bf0:	2001      	movs	r0, #1
   23bf2:	f7ff feb9 	bl	23968 <update_cache>
   23bf6:	2001      	movs	r0, #1
   23bf8:	e7ea      	b.n	23bd0 <z_set_prio+0x54>
	return (node == list->tail) ? NULL : node->next;
   23bfa:	42a8      	cmp	r0, r5
   23bfc:	d0e1      	beq.n	23bc2 <z_set_prio+0x46>
   23bfe:	682d      	ldr	r5, [r5, #0]
   23c00:	e7de      	b.n	23bc0 <z_set_prio+0x44>
   23c02:	bf00      	nop
   23c04:	2000b5c0 	.word	0x2000b5c0

00023c08 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   23c08:	b949      	cbnz	r1, 23c1e <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   23c0a:	f3ef 8005 	mrs	r0, IPSR
   23c0e:	b930      	cbnz	r0, 23c1e <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   23c10:	4b05      	ldr	r3, [pc, #20]	; (23c28 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   23c12:	699a      	ldr	r2, [r3, #24]
   23c14:	689b      	ldr	r3, [r3, #8]
   23c16:	429a      	cmp	r2, r3
   23c18:	d001      	beq.n	23c1e <z_reschedule+0x16>
   23c1a:	f7fa bbc7 	b.w	1e3ac <arch_swap>
   23c1e:	f381 8811 	msr	BASEPRI, r1
   23c22:	f3bf 8f6f 	isb	sy
}
   23c26:	4770      	bx	lr
   23c28:	2000b5c0 	.word	0x2000b5c0

00023c2c <z_sched_start>:
{
   23c2c:	b510      	push	{r4, lr}
	__asm__ volatile(
   23c2e:	f04f 0220 	mov.w	r2, #32
   23c32:	f3ef 8411 	mrs	r4, BASEPRI
   23c36:	f382 8812 	msr	BASEPRI_MAX, r2
   23c3a:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
   23c3e:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
   23c40:	0751      	lsls	r1, r2, #29
   23c42:	d404      	bmi.n	23c4e <z_sched_start+0x22>
	__asm__ volatile(
   23c44:	f384 8811 	msr	BASEPRI, r4
   23c48:	f3bf 8f6f 	isb	sy
}
   23c4c:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   23c4e:	f022 0204 	bic.w	r2, r2, #4
   23c52:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   23c54:	f7ff fee0 	bl	23a18 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   23c58:	4621      	mov	r1, r4
}
   23c5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   23c5e:	4801      	ldr	r0, [pc, #4]	; (23c64 <z_sched_start+0x38>)
   23c60:	f7ff bfd2 	b.w	23c08 <z_reschedule>
   23c64:	2000b639 	.word	0x2000b639

00023c68 <z_impl_k_thread_suspend>:
{
   23c68:	b570      	push	{r4, r5, r6, lr}
   23c6a:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   23c6c:	3018      	adds	r0, #24
   23c6e:	f002 f9aa 	bl	25fc6 <z_abort_timeout>
	__asm__ volatile(
   23c72:	f04f 0320 	mov.w	r3, #32
   23c76:	f3ef 8611 	mrs	r6, BASEPRI
   23c7a:	f383 8812 	msr	BASEPRI_MAX, r3
   23c7e:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   23c82:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
   23c86:	7b63      	ldrb	r3, [r4, #13]
   23c88:	2a00      	cmp	r2, #0
   23c8a:	da05      	bge.n	23c98 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23c8c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
   23c90:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23c92:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23c94:	f002 f898 	bl	25dc8 <sys_dlist_remove>
		update_cache(thread == _current);
   23c98:	4d0b      	ldr	r5, [pc, #44]	; (23cc8 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   23c9a:	7b63      	ldrb	r3, [r4, #13]
   23c9c:	68a8      	ldr	r0, [r5, #8]
   23c9e:	f043 0310 	orr.w	r3, r3, #16
   23ca2:	7363      	strb	r3, [r4, #13]
   23ca4:	1b03      	subs	r3, r0, r4
   23ca6:	4258      	negs	r0, r3
   23ca8:	4158      	adcs	r0, r3
   23caa:	f7ff fe5d 	bl	23968 <update_cache>
	__asm__ volatile(
   23cae:	f386 8811 	msr	BASEPRI, r6
   23cb2:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   23cb6:	68ab      	ldr	r3, [r5, #8]
   23cb8:	42a3      	cmp	r3, r4
   23cba:	d103      	bne.n	23cc4 <z_impl_k_thread_suspend+0x5c>
}
   23cbc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   23cc0:	f002 b944 	b.w	25f4c <z_reschedule_unlocked>
}
   23cc4:	bd70      	pop	{r4, r5, r6, pc}
   23cc6:	bf00      	nop
   23cc8:	2000b5c0 	.word	0x2000b5c0

00023ccc <k_sched_lock>:
	__asm__ volatile(
   23ccc:	f04f 0320 	mov.w	r3, #32
   23cd0:	f3ef 8111 	mrs	r1, BASEPRI
   23cd4:	f383 8812 	msr	BASEPRI_MAX, r3
   23cd8:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
   23cdc:	4b04      	ldr	r3, [pc, #16]	; (23cf0 <k_sched_lock+0x24>)
   23cde:	689a      	ldr	r2, [r3, #8]
   23ce0:	7bd3      	ldrb	r3, [r2, #15]
   23ce2:	3b01      	subs	r3, #1
   23ce4:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   23ce6:	f381 8811 	msr	BASEPRI, r1
   23cea:	f3bf 8f6f 	isb	sy
}
   23cee:	4770      	bx	lr
   23cf0:	2000b5c0 	.word	0x2000b5c0

00023cf4 <k_sched_unlock>:
{
   23cf4:	b510      	push	{r4, lr}
	__asm__ volatile(
   23cf6:	f04f 0320 	mov.w	r3, #32
   23cfa:	f3ef 8411 	mrs	r4, BASEPRI
   23cfe:	f383 8812 	msr	BASEPRI_MAX, r3
   23d02:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   23d06:	4b08      	ldr	r3, [pc, #32]	; (23d28 <k_sched_unlock+0x34>)
		update_cache(0);
   23d08:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   23d0a:	689a      	ldr	r2, [r3, #8]
   23d0c:	7bd3      	ldrb	r3, [r2, #15]
   23d0e:	3301      	adds	r3, #1
   23d10:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   23d12:	f7ff fe29 	bl	23968 <update_cache>
	__asm__ volatile(
   23d16:	f384 8811 	msr	BASEPRI, r4
   23d1a:	f3bf 8f6f 	isb	sy
}
   23d1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   23d22:	f002 b913 	b.w	25f4c <z_reschedule_unlocked>
   23d26:	bf00      	nop
   23d28:	2000b5c0 	.word	0x2000b5c0

00023d2c <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   23d2c:	4b02      	ldr	r3, [pc, #8]	; (23d38 <z_sched_init+0xc>)
   23d2e:	f103 021c 	add.w	r2, r3, #28
	list->tail = (sys_dnode_t *)list;
   23d32:	e9c3 2207 	strd	r2, r2, [r3, #28]
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
   23d36:	4770      	bx	lr
   23d38:	2000b5c0 	.word	0x2000b5c0

00023d3c <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
   23d3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   23d3e:	f04f 0320 	mov.w	r3, #32
   23d42:	f3ef 8511 	mrs	r5, BASEPRI
   23d46:	f383 8812 	msr	BASEPRI_MAX, r3
   23d4a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   23d4e:	4919      	ldr	r1, [pc, #100]	; (23db4 <z_impl_k_yield+0x78>)
   23d50:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23d52:	7b43      	ldrb	r3, [r0, #13]
   23d54:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   23d58:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23d5a:	f002 f835 	bl	25dc8 <sys_dlist_remove>
	return list->head == list;
   23d5e:	4608      	mov	r0, r1
	}
	queue_thread(_current);
   23d60:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   23d62:	7b5a      	ldrb	r2, [r3, #13]
   23d64:	f062 027f 	orn	r2, r2, #127	; 0x7f
   23d68:	735a      	strb	r2, [r3, #13]
   23d6a:	f850 2f1c 	ldr.w	r2, [r0, #28]!
	return (node == list->tail) ? NULL : node->next;
   23d6e:	6a0c      	ldr	r4, [r1, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23d70:	4282      	cmp	r2, r0
   23d72:	bf08      	it	eq
   23d74:	2200      	moveq	r2, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   23d76:	b922      	cbnz	r2, 23d82 <z_impl_k_yield+0x46>
	node->prev = tail;
   23d78:	e9c3 0400 	strd	r0, r4, [r3]
	tail->next = node;
   23d7c:	6023      	str	r3, [r4, #0]
	list->tail = node;
   23d7e:	620b      	str	r3, [r1, #32]
}
   23d80:	e00c      	b.n	23d9c <z_impl_k_yield+0x60>
	int32_t b1 = thread_1->base.prio;
   23d82:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
   23d86:	f992 700e 	ldrsb.w	r7, [r2, #14]
	if (b1 != b2) {
   23d8a:	42be      	cmp	r6, r7
   23d8c:	d00e      	beq.n	23dac <z_impl_k_yield+0x70>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23d8e:	42b7      	cmp	r7, r6
   23d90:	dd0c      	ble.n	23dac <z_impl_k_yield+0x70>
	sys_dnode_t *const prev = successor->prev;
   23d92:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   23d94:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
   23d98:	600b      	str	r3, [r1, #0]
	successor->prev = node;
   23d9a:	6053      	str	r3, [r2, #4]
	update_cache(1);
   23d9c:	2001      	movs	r0, #1
   23d9e:	f7ff fde3 	bl	23968 <update_cache>
   23da2:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
   23da4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   23da8:	f7fa bb00 	b.w	1e3ac <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   23dac:	42a2      	cmp	r2, r4
   23dae:	d0e3      	beq.n	23d78 <z_impl_k_yield+0x3c>
   23db0:	6812      	ldr	r2, [r2, #0]
   23db2:	e7e0      	b.n	23d76 <z_impl_k_yield+0x3a>
   23db4:	2000b5c0 	.word	0x2000b5c0

00023db8 <z_tick_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   23db8:	ea50 0301 	orrs.w	r3, r0, r1
{
   23dbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23dc0:	4605      	mov	r5, r0
   23dc2:	460e      	mov	r6, r1
	if (ticks == 0) {
   23dc4:	d103      	bne.n	23dce <z_tick_sleep+0x16>
	z_impl_k_yield();
   23dc6:	f7ff ffb9 	bl	23d3c <z_impl_k_yield>
		k_yield();
		return 0;
   23dca:	2000      	movs	r0, #0
   23dcc:	e02c      	b.n	23e28 <z_tick_sleep+0x70>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
   23dce:	1c83      	adds	r3, r0, #2
   23dd0:	f171 33ff 	sbcs.w	r3, r1, #4294967295	; 0xffffffff
   23dd4:	db2a      	blt.n	23e2c <z_tick_sleep+0x74>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   23dd6:	f002 f91c 	bl	26012 <sys_clock_tick_get_32>
   23dda:	182c      	adds	r4, r5, r0
   23ddc:	f04f 0320 	mov.w	r3, #32
   23de0:	f3ef 8811 	mrs	r8, BASEPRI
   23de4:	f383 8812 	msr	BASEPRI_MAX, r3
   23de8:	f3bf 8f6f 	isb	sy
	}

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   23dec:	4f11      	ldr	r7, [pc, #68]	; (23e34 <z_tick_sleep+0x7c>)
   23dee:	4b12      	ldr	r3, [pc, #72]	; (23e38 <z_tick_sleep+0x80>)
   23df0:	68b8      	ldr	r0, [r7, #8]
   23df2:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
   23df4:	f7ff fe44 	bl	23a80 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   23df8:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   23dfa:	4910      	ldr	r1, [pc, #64]	; (23e3c <z_tick_sleep+0x84>)
   23dfc:	462a      	mov	r2, r5
   23dfe:	4633      	mov	r3, r6
   23e00:	3018      	adds	r0, #24
   23e02:	f000 f929 	bl	24058 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   23e06:	68ba      	ldr	r2, [r7, #8]
   23e08:	4640      	mov	r0, r8
	thread->base.thread_state |= _THREAD_SUSPENDED;
   23e0a:	7b53      	ldrb	r3, [r2, #13]
   23e0c:	f043 0310 	orr.w	r3, r3, #16
   23e10:	7353      	strb	r3, [r2, #13]
   23e12:	f7fa facb 	bl	1e3ac <arch_swap>

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   23e16:	f002 f8fc 	bl	26012 <sys_clock_tick_get_32>
   23e1a:	1a20      	subs	r0, r4, r0
   23e1c:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
   23e20:	2801      	cmp	r0, #1
   23e22:	f173 0300 	sbcs.w	r3, r3, #0
   23e26:	dbd0      	blt.n	23dca <z_tick_sleep+0x12>
		return ticks;
	}
#endif

	return 0;
}
   23e28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   23e2c:	f06f 0401 	mvn.w	r4, #1
   23e30:	1a24      	subs	r4, r4, r0
   23e32:	e7d3      	b.n	23ddc <z_tick_sleep+0x24>
   23e34:	2000b5c0 	.word	0x2000b5c0
   23e38:	2000b5ec 	.word	0x2000b5ec
   23e3c:	00025ec5 	.word	0x00025ec5

00023e40 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   23e40:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   23e44:	bf08      	it	eq
   23e46:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   23e4a:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   23e4c:	d106      	bne.n	23e5c <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
   23e4e:	4b08      	ldr	r3, [pc, #32]	; (23e70 <z_impl_k_sleep+0x30>)
   23e50:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   23e52:	f7ff ff09 	bl	23c68 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
   23e56:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   23e5a:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
   23e5c:	f7ff ffac 	bl	23db8 <z_tick_sleep>
   23e60:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   23e64:	fb80 0303 	smull	r0, r3, r0, r3
   23e68:	0bc0      	lsrs	r0, r0, #15
   23e6a:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
   23e6e:	e7f4      	b.n	23e5a <z_impl_k_sleep+0x1a>
   23e70:	2000b5c0 	.word	0x2000b5c0

00023e74 <z_impl_k_usleep>:
}
#include <syscalls/k_sleep_mrsh.c>
#endif

int32_t z_impl_k_usleep(int us)
{
   23e74:	b538      	push	{r3, r4, r5, lr}
   23e76:	2100      	movs	r1, #0
   23e78:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   23e7c:	4c08      	ldr	r4, [pc, #32]	; (23ea0 <z_impl_k_usleep+0x2c>)
   23e7e:	2300      	movs	r3, #0
   23e80:	fbc0 4105 	smlal	r4, r1, r0, r5
   23e84:	4a07      	ldr	r2, [pc, #28]	; (23ea4 <z_impl_k_usleep+0x30>)
   23e86:	4620      	mov	r0, r4
   23e88:	f7f8 f964 	bl	1c154 <__aeabi_uldivmod>
	int32_t ticks;

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, usleep, us);

	ticks = k_us_to_ticks_ceil64(us);
	ticks = z_tick_sleep(ticks);
   23e8c:	17c1      	asrs	r1, r0, #31
   23e8e:	f7ff ff93 	bl	23db8 <z_tick_sleep>
   23e92:	4b04      	ldr	r3, [pc, #16]	; (23ea4 <z_impl_k_usleep+0x30>)
   23e94:	fb80 0303 	smull	r0, r3, r0, r3
   23e98:	0bc0      	lsrs	r0, r0, #15

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, usleep, us, k_ticks_to_us_floor64(ticks));

	return k_ticks_to_us_floor64(ticks);
}
   23e9a:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   23e9e:	bd38      	pop	{r3, r4, r5, pc}
   23ea0:	000f423f 	.word	0x000f423f
   23ea4:	000f4240 	.word	0x000f4240

00023ea8 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   23ea8:	4b01      	ldr	r3, [pc, #4]	; (23eb0 <z_impl_z_current_get+0x8>)
   23eaa:	6898      	ldr	r0, [r3, #8]
   23eac:	4770      	bx	lr
   23eae:	bf00      	nop
   23eb0:	2000b5c0 	.word	0x2000b5c0

00023eb4 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   23eb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23eb8:	4604      	mov	r4, r0
   23eba:	f04f 0320 	mov.w	r3, #32
   23ebe:	f3ef 8611 	mrs	r6, BASEPRI
   23ec2:	f383 8812 	msr	BASEPRI_MAX, r3
   23ec6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
   23eca:	7b03      	ldrb	r3, [r0, #12]
   23ecc:	07d9      	lsls	r1, r3, #31
   23ece:	d50b      	bpl.n	23ee8 <z_thread_abort+0x34>
	__asm__ volatile(
   23ed0:	f386 8811 	msr	BASEPRI, r6
   23ed4:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
   23ed8:	4040      	eors	r0, r0
   23eda:	f380 8811 	msr	BASEPRI, r0
   23ede:	f04f 0004 	mov.w	r0, #4
   23ee2:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   23ee4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   23ee8:	7b43      	ldrb	r3, [r0, #13]
   23eea:	071a      	lsls	r2, r3, #28
   23eec:	d504      	bpl.n	23ef8 <z_thread_abort+0x44>
   23eee:	f386 8811 	msr	BASEPRI, r6
   23ef2:	f3bf 8f6f 	isb	sy
   23ef6:	e7f5      	b.n	23ee4 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   23ef8:	f023 0220 	bic.w	r2, r3, #32
   23efc:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   23f00:	09d2      	lsrs	r2, r2, #7
   23f02:	d120      	bne.n	23f46 <z_thread_abort+0x92>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   23f04:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   23f06:	68a3      	ldr	r3, [r4, #8]
   23f08:	b113      	cbz	r3, 23f10 <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
   23f0a:	4620      	mov	r0, r4
   23f0c:	f001 ff64 	bl	25dd8 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   23f10:	f104 0018 	add.w	r0, r4, #24
   23f14:	f002 f857 	bl	25fc6 <z_abort_timeout>
   23f18:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   23f1c:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
   23f20:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23f22:	42bd      	cmp	r5, r7
   23f24:	d000      	beq.n	23f28 <z_thread_abort+0x74>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   23f26:	b9b5      	cbnz	r5, 23f56 <z_thread_abort+0xa2>
		update_cache(1);
   23f28:	2001      	movs	r0, #1
   23f2a:	f7ff fd1d 	bl	23968 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   23f2e:	4b10      	ldr	r3, [pc, #64]	; (23f70 <z_thread_abort+0xbc>)
   23f30:	689b      	ldr	r3, [r3, #8]
   23f32:	42a3      	cmp	r3, r4
   23f34:	d1db      	bne.n	23eee <z_thread_abort+0x3a>
   23f36:	f3ef 8305 	mrs	r3, IPSR
   23f3a:	2b00      	cmp	r3, #0
   23f3c:	d1d7      	bne.n	23eee <z_thread_abort+0x3a>
   23f3e:	4630      	mov	r0, r6
   23f40:	f7fa fa34 	bl	1e3ac <arch_swap>
	return ret;
   23f44:	e7d3      	b.n	23eee <z_thread_abort+0x3a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23f46:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   23f4a:	f043 0308 	orr.w	r3, r3, #8
   23f4e:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23f50:	f001 ff3a 	bl	25dc8 <sys_dlist_remove>
}
   23f54:	e7d7      	b.n	23f06 <z_thread_abort+0x52>
		unpend_thread_no_timeout(thread);
   23f56:	4628      	mov	r0, r5
   23f58:	f001 ff3e 	bl	25dd8 <unpend_thread_no_timeout>
   23f5c:	f105 0018 	add.w	r0, r5, #24
   23f60:	f002 f831 	bl	25fc6 <z_abort_timeout>
		ready_thread(thread);
   23f64:	4628      	mov	r0, r5
   23f66:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
   23f6a:	f7ff fd55 	bl	23a18 <ready_thread>
   23f6e:	e7d7      	b.n	23f20 <z_thread_abort+0x6c>
   23f70:	2000b5c0 	.word	0x2000b5c0

00023f74 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
   23f74:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   23f76:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
   23f7a:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   23f7c:	e9cd 6700 	strd	r6, r7, [sp]
   23f80:	f7ff fdde 	bl	23b40 <z_pend_curr>

	if (data != NULL) {
   23f84:	b11c      	cbz	r4, 23f8e <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
   23f86:	4b03      	ldr	r3, [pc, #12]	; (23f94 <z_sched_wait+0x20>)
   23f88:	689b      	ldr	r3, [r3, #8]
   23f8a:	695b      	ldr	r3, [r3, #20]
   23f8c:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
   23f8e:	b002      	add	sp, #8
   23f90:	bdd0      	pop	{r4, r6, r7, pc}
   23f92:	bf00      	nop
   23f94:	2000b5c0 	.word	0x2000b5c0

00023f98 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
   23f98:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
   23f9a:	4806      	ldr	r0, [pc, #24]	; (23fb4 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
   23f9c:	4a06      	ldr	r2, [pc, #24]	; (23fb8 <z_data_copy+0x20>)
   23f9e:	4907      	ldr	r1, [pc, #28]	; (23fbc <z_data_copy+0x24>)
   23fa0:	1a12      	subs	r2, r2, r0
   23fa2:	f001 fdbf 	bl	25b24 <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   23fa6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
   23faa:	4a05      	ldr	r2, [pc, #20]	; (23fc0 <z_data_copy+0x28>)
   23fac:	4905      	ldr	r1, [pc, #20]	; (23fc4 <z_data_copy+0x2c>)
   23fae:	4806      	ldr	r0, [pc, #24]	; (23fc8 <z_data_copy+0x30>)
   23fb0:	f001 bdb8 	b.w	25b24 <z_early_memcpy>
   23fb4:	2000a000 	.word	0x2000a000
   23fb8:	2000a410 	.word	0x2000a410
   23fbc:	00026bac 	.word	0x00026bac
   23fc0:	00000000 	.word	0x00000000
   23fc4:	00026bac 	.word	0x00026bac
   23fc8:	2000a000 	.word	0x2000a000

00023fcc <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   23fcc:	4b03      	ldr	r3, [pc, #12]	; (23fdc <elapsed+0x10>)
   23fce:	681b      	ldr	r3, [r3, #0]
   23fd0:	b90b      	cbnz	r3, 23fd6 <elapsed+0xa>
   23fd2:	f7fc bc8d 	b.w	208f0 <sys_clock_elapsed>
}
   23fd6:	2000      	movs	r0, #0
   23fd8:	4770      	bx	lr
   23fda:	bf00      	nop
   23fdc:	2000b5f8 	.word	0x2000b5f8

00023fe0 <next_timeout>:

static int32_t next_timeout(void)
{
   23fe0:	b510      	push	{r4, lr}
	return list->head == list;
   23fe2:	4b0e      	ldr	r3, [pc, #56]	; (2401c <next_timeout+0x3c>)
   23fe4:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23fe6:	429c      	cmp	r4, r3
   23fe8:	d104      	bne.n	23ff4 <next_timeout+0x14>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   23fea:	f7ff ffef 	bl	23fcc <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
   23fee:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
   23ff2:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
   23ff4:	f7ff ffea 	bl	23fcc <elapsed>
	if ((to == NULL) ||
   23ff8:	2c00      	cmp	r4, #0
   23ffa:	d0f8      	beq.n	23fee <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
   23ffc:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
   24000:	1a1b      	subs	r3, r3, r0
   24002:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
   24006:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   2400a:	f172 0100 	sbcs.w	r1, r2, #0
   2400e:	daee      	bge.n	23fee <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
   24010:	2a00      	cmp	r2, #0
   24012:	bfac      	ite	ge
   24014:	4618      	movge	r0, r3
   24016:	2000      	movlt	r0, #0
	return ret;
   24018:	e7eb      	b.n	23ff2 <next_timeout+0x12>
   2401a:	bf00      	nop
   2401c:	2000a284 	.word	0x2000a284

00024020 <remove_timeout>:
{
   24020:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   24022:	b170      	cbz	r0, 24042 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
   24024:	4b0b      	ldr	r3, [pc, #44]	; (24054 <remove_timeout+0x34>)
   24026:	685b      	ldr	r3, [r3, #4]
   24028:	4298      	cmp	r0, r3
   2402a:	d00a      	beq.n	24042 <remove_timeout+0x22>
   2402c:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
   2402e:	b143      	cbz	r3, 24042 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   24030:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   24034:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   24038:	1912      	adds	r2, r2, r4
   2403a:	eb41 0105 	adc.w	r1, r1, r5
   2403e:	e9c3 2104 	strd	r2, r1, [r3, #16]
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
   24042:	e9d0 3200 	ldrd	r3, r2, [r0]

	prev->next = next;
   24046:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   24048:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   2404a:	2300      	movs	r3, #0
	node->prev = NULL;
   2404c:	e9c0 3300 	strd	r3, r3, [r0]
}
   24050:	bd30      	pop	{r4, r5, pc}
   24052:	bf00      	nop
   24054:	2000a284 	.word	0x2000a284

00024058 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   24058:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2405c:	bf08      	it	eq
   2405e:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   24062:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24064:	4604      	mov	r4, r0
   24066:	461d      	mov	r5, r3
   24068:	4616      	mov	r6, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2406a:	d05c      	beq.n	24126 <z_add_timeout+0xce>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   2406c:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   2406e:	f04f 0320 	mov.w	r3, #32
   24072:	f3ef 8711 	mrs	r7, BASEPRI
   24076:	f383 8812 	msr	BASEPRI_MAX, r3
   2407a:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   2407e:	3201      	adds	r2, #1
   24080:	f175 33ff 	sbcs.w	r3, r5, #4294967295	; 0xffffffff
   24084:	da24      	bge.n	240d0 <z_add_timeout+0x78>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   24086:	f06f 0301 	mvn.w	r3, #1
   2408a:	492c      	ldr	r1, [pc, #176]	; (2413c <z_add_timeout+0xe4>)
   2408c:	e9d1 2000 	ldrd	r2, r0, [r1]
   24090:	1a9b      	subs	r3, r3, r2
   24092:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   24096:	eb62 0000 	sbc.w	r0, r2, r0
   2409a:	1b9e      	subs	r6, r3, r6
   2409c:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
   240a0:	2e01      	cmp	r6, #1
   240a2:	f170 0300 	sbcs.w	r3, r0, #0
   240a6:	da01      	bge.n	240ac <z_add_timeout+0x54>
   240a8:	2601      	movs	r6, #1
   240aa:	2000      	movs	r0, #0
   240ac:	e9c4 6004 	strd	r6, r0, [r4, #16]
	return list->head == list;
   240b0:	4e23      	ldr	r6, [pc, #140]	; (24140 <z_add_timeout+0xe8>)
   240b2:	f8d6 c000 	ldr.w	ip, [r6]
	return (node == list->tail) ? NULL : node->next;
   240b6:	6875      	ldr	r5, [r6, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   240b8:	45b4      	cmp	ip, r6
   240ba:	bf08      	it	eq
   240bc:	f04f 0c00 	moveq.w	ip, #0
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
   240c0:	f1bc 0f00 	cmp.w	ip, #0
   240c4:	d10d      	bne.n	240e2 <z_add_timeout+0x8a>
	node->prev = tail;
   240c6:	e9c4 6500 	strd	r6, r5, [r4]
	tail->next = node;
   240ca:	602c      	str	r4, [r5, #0]
	list->tail = node;
   240cc:	6074      	str	r4, [r6, #4]
}
   240ce:	e01c      	b.n	2410a <z_add_timeout+0xb2>
			to->dticks = timeout.ticks + 1 + elapsed();
   240d0:	f7ff ff7c 	bl	23fcc <elapsed>
   240d4:	3601      	adds	r6, #1
   240d6:	f145 0500 	adc.w	r5, r5, #0
   240da:	1836      	adds	r6, r6, r0
   240dc:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
   240e0:	e7e4      	b.n	240ac <z_add_timeout+0x54>
			if (t->dticks > to->dticks) {
   240e2:	e9dc 2004 	ldrd	r2, r0, [ip, #16]
   240e6:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
   240ea:	4293      	cmp	r3, r2
   240ec:	eb71 0e00 	sbcs.w	lr, r1, r0
   240f0:	da1a      	bge.n	24128 <z_add_timeout+0xd0>
				t->dticks -= to->dticks;
   240f2:	1ad2      	subs	r2, r2, r3
	sys_dnode_t *const prev = successor->prev;
   240f4:	f8dc 3004 	ldr.w	r3, [ip, #4]
   240f8:	eb60 0001 	sbc.w	r0, r0, r1
   240fc:	e9cc 2004 	strd	r2, r0, [ip, #16]
	node->next = successor;
   24100:	e9c4 c300 	strd	ip, r3, [r4]
	prev->next = node;
   24104:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   24106:	f8cc 4004 	str.w	r4, [ip, #4]
	return list->head == list;
   2410a:	6833      	ldr	r3, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2410c:	42b3      	cmp	r3, r6
   2410e:	d006      	beq.n	2411e <z_add_timeout+0xc6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   24110:	429c      	cmp	r4, r3
   24112:	d104      	bne.n	2411e <z_add_timeout+0xc6>
			sys_clock_set_timeout(next_timeout(), false);
   24114:	f7ff ff64 	bl	23fe0 <next_timeout>
   24118:	2100      	movs	r1, #0
   2411a:	f7fc fbb7 	bl	2088c <sys_clock_set_timeout>
	__asm__ volatile(
   2411e:	f387 8811 	msr	BASEPRI, r7
   24122:	f3bf 8f6f 	isb	sy
		}
	}
}
   24126:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			to->dticks -= t->dticks;
   24128:	1a9b      	subs	r3, r3, r2
   2412a:	eb61 0100 	sbc.w	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   2412e:	45ac      	cmp	ip, r5
   24130:	e9c4 3104 	strd	r3, r1, [r4, #16]
   24134:	d0c7      	beq.n	240c6 <z_add_timeout+0x6e>
   24136:	f8dc c000 	ldr.w	ip, [ip]
   2413a:	e7c1      	b.n	240c0 <z_add_timeout+0x68>
   2413c:	2000a688 	.word	0x2000a688
   24140:	2000a284 	.word	0x2000a284

00024144 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
   24144:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__asm__ volatile(
   24148:	f04f 0320 	mov.w	r3, #32
   2414c:	f3ef 8c11 	mrs	ip, BASEPRI
   24150:	f383 8812 	msr	BASEPRI_MAX, r3
   24154:	f3bf 8f6f 	isb	sy
	return list->head == list;
   24158:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 2420c <sys_clock_announce+0xc8>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
   2415c:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 24210 <sys_clock_announce+0xcc>
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
		t->dticks = 0;
   24160:	2400      	movs	r4, #0
	announce_remaining = ticks;
   24162:	f8c9 0000 	str.w	r0, [r9]
   24166:	f8da 0000 	ldr.w	r0, [sl]
		t->dticks = 0;
   2416a:	2500      	movs	r5, #0
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2416c:	4550      	cmp	r0, sl
   2416e:	bf08      	it	eq
   24170:	2000      	moveq	r0, #0
		curr_tick += dt;
   24172:	4f28      	ldr	r7, [pc, #160]	; (24214 <sys_clock_announce+0xd0>)
   24174:	46e0      	mov	r8, ip
   24176:	e9d7 2100 	ldrd	r2, r1, [r7]
	     (t != NULL) && (t->dticks <= announce_remaining);
   2417a:	f8d9 3000 	ldr.w	r3, [r9]
   2417e:	b380      	cbz	r0, 241e2 <sys_clock_announce+0x9e>
   24180:	e9d0 6c04 	ldrd	r6, ip, [r0, #16]
   24184:	ea4f 7ee3 	mov.w	lr, r3, asr #31
   24188:	42b3      	cmp	r3, r6
   2418a:	eb7e 0b0c 	sbcs.w	fp, lr, ip
   2418e:	da05      	bge.n	2419c <sys_clock_announce+0x58>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
   24190:	1af6      	subs	r6, r6, r3
   24192:	eb6c 040e 	sbc.w	r4, ip, lr
   24196:	e9c0 6404 	strd	r6, r4, [r0, #16]
   2419a:	e022      	b.n	241e2 <sys_clock_announce+0x9e>
		curr_tick += dt;
   2419c:	18b2      	adds	r2, r6, r2
   2419e:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
		t->dticks = 0;
   241a2:	e9c0 4504 	strd	r4, r5, [r0, #16]
		curr_tick += dt;
   241a6:	e9c7 2100 	strd	r2, r1, [r7]
		remove_timeout(t);
   241aa:	f7ff ff39 	bl	24020 <remove_timeout>
	__asm__ volatile(
   241ae:	f388 8811 	msr	BASEPRI, r8
   241b2:	f3bf 8f6f 	isb	sy
		t->fn(t);
   241b6:	6883      	ldr	r3, [r0, #8]
   241b8:	4798      	blx	r3
	__asm__ volatile(
   241ba:	f04f 0320 	mov.w	r3, #32
   241be:	f3ef 8811 	mrs	r8, BASEPRI
   241c2:	f383 8812 	msr	BASEPRI_MAX, r3
   241c6:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
   241ca:	f8d9 3000 	ldr.w	r3, [r9]
	return list->head == list;
   241ce:	f8da 0000 	ldr.w	r0, [sl]
   241d2:	1b9b      	subs	r3, r3, r6
	return sys_dlist_is_empty(list) ? NULL : list->head;
   241d4:	4550      	cmp	r0, sl
	k.key = arch_irq_lock();
   241d6:	46c4      	mov	ip, r8
   241d8:	f8c9 3000 	str.w	r3, [r9]
   241dc:	d1ca      	bne.n	24174 <sys_clock_announce+0x30>
		curr_tick += dt;
   241de:	e9d7 2100 	ldrd	r2, r1, [r7]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   241e2:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   241e4:	189a      	adds	r2, r3, r2
   241e6:	eb41 73e3 	adc.w	r3, r1, r3, asr #31
   241ea:	e9c7 2300 	strd	r2, r3, [r7]
	announce_remaining = 0;
   241ee:	f8c9 4000 	str.w	r4, [r9]

	sys_clock_set_timeout(next_timeout(), false);
   241f2:	f7ff fef5 	bl	23fe0 <next_timeout>
   241f6:	4621      	mov	r1, r4
   241f8:	f7fc fb48 	bl	2088c <sys_clock_set_timeout>
	__asm__ volatile(
   241fc:	f388 8811 	msr	BASEPRI, r8
   24200:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
   24204:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_time_slice();
   24208:	f7ff bc6a 	b.w	23ae0 <z_time_slice>
   2420c:	2000a284 	.word	0x2000a284
   24210:	2000b5f8 	.word	0x2000b5f8
   24214:	2000a688 	.word	0x2000a688

00024218 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   24218:	b510      	push	{r4, lr}
	__asm__ volatile(
   2421a:	f04f 0320 	mov.w	r3, #32
   2421e:	f3ef 8411 	mrs	r4, BASEPRI
   24222:	f383 8812 	msr	BASEPRI_MAX, r3
   24226:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
   2422a:	f7ff fecf 	bl	23fcc <elapsed>
   2422e:	4603      	mov	r3, r0
   24230:	4a05      	ldr	r2, [pc, #20]	; (24248 <sys_clock_tick_get+0x30>)
   24232:	e9d2 0100 	ldrd	r0, r1, [r2]
   24236:	1818      	adds	r0, r3, r0
   24238:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
	__asm__ volatile(
   2423c:	f384 8811 	msr	BASEPRI, r4
   24240:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   24244:	bd10      	pop	{r4, pc}
   24246:	bf00      	nop
   24248:	2000a688 	.word	0x2000a688

0002424c <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   2424c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2424e:	4604      	mov	r4, r0
	__asm__ volatile(
   24250:	f04f 0320 	mov.w	r3, #32
   24254:	f3ef 8711 	mrs	r7, BASEPRI
   24258:	f383 8812 	msr	BASEPRI_MAX, r3
   2425c:	f3bf 8f6f 	isb	sy
	 * interrupt. Then, the timeout structure for this timer will turn out
	 * to be linked to the timeout list. And in such case, since the timer
	 * was restarted, its expiration handler should not be executed then,
	 * so the function exits immediately.
	 */
	if (sys_dnode_is_linked(&t->node)) {
   24260:	6802      	ldr	r2, [r0, #0]
   24262:	b122      	cbz	r2, 2426e <z_timer_expiration_handler+0x22>
	__asm__ volatile(
   24264:	f387 8811 	msr	BASEPRI, r7
   24268:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   2426c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   2426e:	e9d0 360a 	ldrd	r3, r6, [r0, #40]	; 0x28
   24272:	1c58      	adds	r0, r3, #1
   24274:	f146 0100 	adc.w	r1, r6, #0
   24278:	2802      	cmp	r0, #2
   2427a:	f171 0100 	sbcs.w	r1, r1, #0
   2427e:	d327      	bcc.n	242d0 <z_timer_expiration_handler+0x84>
		next.ticks = MAX(next.ticks - 1, 0);
   24280:	2b01      	cmp	r3, #1
   24282:	f176 0100 	sbcs.w	r1, r6, #0
   24286:	bfbc      	itt	lt
   24288:	2301      	movlt	r3, #1
   2428a:	4616      	movlt	r6, r2
   2428c:	1e5d      	subs	r5, r3, #1
   2428e:	f146 36ff 	adc.w	r6, r6, #4294967295	; 0xffffffff
	return z_impl_k_uptime_ticks();
   24292:	f001 fec2 	bl	2601a <z_impl_k_uptime_ticks>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
   24296:	3001      	adds	r0, #1
   24298:	f141 0100 	adc.w	r1, r1, #0
   2429c:	1940      	adds	r0, r0, r5
   2429e:	eb46 0101 	adc.w	r1, r6, r1
   242a2:	2801      	cmp	r0, #1
   242a4:	f171 0100 	sbcs.w	r1, r1, #0
   242a8:	db3a      	blt.n	24320 <z_timer_expiration_handler+0xd4>
   242aa:	f001 feb6 	bl	2601a <z_impl_k_uptime_ticks>
   242ae:	3001      	adds	r0, #1
   242b0:	f141 0100 	adc.w	r1, r1, #0
   242b4:	f06f 0201 	mvn.w	r2, #1
   242b8:	1940      	adds	r0, r0, r5
   242ba:	eb46 0301 	adc.w	r3, r6, r1
   242be:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   242c2:	1a12      	subs	r2, r2, r0
   242c4:	eb61 0303 	sbc.w	r3, r1, r3
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   242c8:	4620      	mov	r0, r4
   242ca:	4918      	ldr	r1, [pc, #96]	; (2432c <z_timer_expiration_handler+0xe0>)
   242cc:	f7ff fec4 	bl	24058 <z_add_timeout>
	timer->status += 1U;
   242d0:	6b23      	ldr	r3, [r4, #48]	; 0x30
   242d2:	3301      	adds	r3, #1
   242d4:	6323      	str	r3, [r4, #48]	; 0x30
	if (timer->expiry_fn != NULL) {
   242d6:	6a23      	ldr	r3, [r4, #32]
   242d8:	b173      	cbz	r3, 242f8 <z_timer_expiration_handler+0xac>
   242da:	f387 8811 	msr	BASEPRI, r7
   242de:	f3bf 8f6f 	isb	sy
		timer->expiry_fn(timer);
   242e2:	4620      	mov	r0, r4
   242e4:	6a23      	ldr	r3, [r4, #32]
   242e6:	4798      	blx	r3
	__asm__ volatile(
   242e8:	f04f 0320 	mov.w	r3, #32
   242ec:	f3ef 8711 	mrs	r7, BASEPRI
   242f0:	f383 8812 	msr	BASEPRI_MAX, r3
   242f4:	f3bf 8f6f 	isb	sy
	return list->head == list;
   242f8:	f854 5f18 	ldr.w	r5, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   242fc:	42a5      	cmp	r5, r4
   242fe:	d0b1      	beq.n	24264 <z_timer_expiration_handler+0x18>
	if (thread == NULL) {
   24300:	2d00      	cmp	r5, #0
   24302:	d0af      	beq.n	24264 <z_timer_expiration_handler+0x18>
	z_unpend_thread_no_timeout(thread);
   24304:	4628      	mov	r0, r5
   24306:	f001 fda9 	bl	25e5c <z_unpend_thread_no_timeout>
   2430a:	2300      	movs	r3, #0
   2430c:	67ab      	str	r3, [r5, #120]	; 0x78
	__asm__ volatile(
   2430e:	f387 8811 	msr	BASEPRI, r7
   24312:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   24316:	4628      	mov	r0, r5
}
   24318:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_ready_thread(thread);
   2431c:	f001 bd8e 	b.w	25e3c <z_ready_thread>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
   24320:	f06f 0201 	mvn.w	r2, #1
   24324:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24328:	e7ce      	b.n	242c8 <z_timer_expiration_handler+0x7c>
   2432a:	bf00      	nop
   2432c:	0002424d 	.word	0x0002424d

00024330 <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   24330:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   24334:	bf08      	it	eq
   24336:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   2433a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2433e:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
   24342:	4605      	mov	r5, r0
   24344:	461c      	mov	r4, r3
   24346:	4691      	mov	r9, r2
   24348:	4698      	mov	r8, r3
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   2434a:	d01c      	beq.n	24386 <z_impl_k_timer_start+0x56>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (Z_TICK_ABS(duration.ticks) < 0) {
   2434c:	1c53      	adds	r3, r2, #1
   2434e:	f174 33ff 	sbcs.w	r3, r4, #4294967295	; 0xffffffff
   24352:	db09      	blt.n	24368 <z_impl_k_timer_start+0x38>
		duration.ticks = MAX(duration.ticks - 1, 0);
   24354:	2a01      	cmp	r2, #1
   24356:	f174 0300 	sbcs.w	r3, r4, #0
   2435a:	bfbc      	itt	lt
   2435c:	2201      	movlt	r2, #1
   2435e:	2400      	movlt	r4, #0
   24360:	f112 39ff 	adds.w	r9, r2, #4294967295	; 0xffffffff
   24364:	f144 38ff 	adc.w	r8, r4, #4294967295	; 0xffffffff
	}

	(void)z_abort_timeout(&timer->timeout);
   24368:	4628      	mov	r0, r5
   2436a:	f001 fe2c 	bl	25fc6 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   2436e:	2300      	movs	r3, #0
	timer->period = period;
   24370:	e9c5 670a 	strd	r6, r7, [r5, #40]	; 0x28
	timer->status = 0U;
   24374:	632b      	str	r3, [r5, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   24376:	464a      	mov	r2, r9
   24378:	4643      	mov	r3, r8
   2437a:	4628      	mov	r0, r5
		     duration);
}
   2437c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   24380:	4902      	ldr	r1, [pc, #8]	; (2438c <z_impl_k_timer_start+0x5c>)
   24382:	f7ff be69 	b.w	24058 <z_add_timeout>
}
   24386:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2438a:	bf00      	nop
   2438c:	0002424d 	.word	0x0002424d

00024390 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   24390:	b573      	push	{r0, r1, r4, r5, r6, lr}
   24392:	4606      	mov	r6, r0
   24394:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
   24396:	f001 fc06 	bl	25ba6 <k_is_in_isr>
   2439a:	b978      	cbnz	r0, 243bc <z_thread_aligned_alloc+0x2c>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
   2439c:	4b0b      	ldr	r3, [pc, #44]	; (243cc <z_thread_aligned_alloc+0x3c>)
   2439e:	689b      	ldr	r3, [r3, #8]
   243a0:	6f1c      	ldr	r4, [r3, #112]	; 0x70
	}

	if (heap != NULL) {
   243a2:	b17c      	cbz	r4, 243c4 <z_thread_aligned_alloc+0x34>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   243a4:	1d2a      	adds	r2, r5, #4
   243a6:	d209      	bcs.n	243bc <z_thread_aligned_alloc+0x2c>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   243a8:	2000      	movs	r0, #0
   243aa:	2100      	movs	r1, #0
   243ac:	e9cd 0100 	strd	r0, r1, [sp]
   243b0:	4620      	mov	r0, r4
   243b2:	f046 0104 	orr.w	r1, r6, #4
   243b6:	f001 fe67 	bl	26088 <k_heap_aligned_alloc>
	if (mem == NULL) {
   243ba:	b908      	cbnz	r0, 243c0 <z_thread_aligned_alloc+0x30>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
   243bc:	2400      	movs	r4, #0
	}

	return ret;
   243be:	e001      	b.n	243c4 <z_thread_aligned_alloc+0x34>
	*heap_ref = heap;
   243c0:	6004      	str	r4, [r0, #0]
	mem = ++heap_ref;
   243c2:	1d04      	adds	r4, r0, #4
}
   243c4:	4620      	mov	r0, r4
   243c6:	b002      	add	sp, #8
   243c8:	bd70      	pop	{r4, r5, r6, pc}
   243ca:	bf00      	nop
   243cc:	2000b5c0 	.word	0x2000b5c0

000243d0 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
   243d0:	4801      	ldr	r0, [pc, #4]	; (243d8 <boot_banner+0x8>)
   243d2:	f000 b850 	b.w	24476 <printk>
   243d6:	bf00      	nop
   243d8:	00026b72 	.word	0x00026b72

000243dc <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
   243dc:	b538      	push	{r3, r4, r5, lr}
	STRUCT_SECTION_FOREACH(k_heap, h) {
   243de:	4c06      	ldr	r4, [pc, #24]	; (243f8 <statics_init+0x1c>)
   243e0:	4d06      	ldr	r5, [pc, #24]	; (243fc <statics_init+0x20>)
   243e2:	42ac      	cmp	r4, r5
   243e4:	d301      	bcc.n	243ea <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   243e6:	2000      	movs	r0, #0
   243e8:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   243ea:	4620      	mov	r0, r4
   243ec:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   243f0:	f001 fe42 	bl	26078 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   243f4:	3414      	adds	r4, #20
   243f6:	e7f4      	b.n	243e2 <statics_init+0x6>
   243f8:	2000a2f4 	.word	0x2000a2f4
   243fc:	2000a2f4 	.word	0x2000a2f4

00024400 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
   24400:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_work_queue_config cfg = {
   24402:	2400      	movs	r4, #0
   24404:	4b08      	ldr	r3, [pc, #32]	; (24428 <k_sys_work_q_init+0x28>)
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
   24406:	f44f 6280 	mov.w	r2, #1024	; 0x400
	struct k_work_queue_config cfg = {
   2440a:	9302      	str	r3, [sp, #8]
	k_work_queue_start(&k_sys_work_q,
   2440c:	ab02      	add	r3, sp, #8
   2440e:	9300      	str	r3, [sp, #0]
   24410:	4906      	ldr	r1, [pc, #24]	; (2442c <k_sys_work_q_init+0x2c>)
   24412:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24416:	4806      	ldr	r0, [pc, #24]	; (24430 <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
   24418:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
   2441c:	f7ff f9ec 	bl	237f8 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
   24420:	4620      	mov	r0, r4
   24422:	b004      	add	sp, #16
   24424:	bd10      	pop	{r4, pc}
   24426:	bf00      	nop
   24428:	00026ba2 	.word	0x00026ba2
   2442c:	2000cb80 	.word	0x2000cb80
   24430:	2000a690 	.word	0x2000a690

00024434 <gpio_pin_configure_dt>:
{
   24434:	4603      	mov	r3, r0
   24436:	460a      	mov	r2, r1
   24438:	b4f0      	push	{r4, r5, r6, r7}
				  spec->pin,
   2443a:	7919      	ldrb	r1, [r3, #4]
				  spec->dt_flags | extra_flags);
   2443c:	88db      	ldrh	r3, [r3, #6]
	return gpio_pin_configure(spec->port,
   2443e:	6800      	ldr	r0, [r0, #0]
   24440:	4313      	orrs	r3, r2
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   24442:	02dc      	lsls	r4, r3, #11
	const struct gpio_driver_api *api =
   24444:	6887      	ldr	r7, [r0, #8]
	struct gpio_driver_data *data =
   24446:	6906      	ldr	r6, [r0, #16]
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   24448:	d506      	bpl.n	24458 <gpio_pin_configure_dt+0x24>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   2444a:	f413 2f40 	tst.w	r3, #786432	; 0xc0000
   2444e:	d003      	beq.n	24458 <gpio_pin_configure_dt+0x24>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   24450:	07da      	lsls	r2, r3, #31
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   24452:	bf48      	it	mi
   24454:	f483 2340 	eormi.w	r3, r3, #786432	; 0xc0000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   24458:	2501      	movs	r5, #1
   2445a:	6834      	ldr	r4, [r6, #0]
   2445c:	408d      	lsls	r5, r1
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   2445e:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   24462:	07db      	lsls	r3, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   24464:	bf4c      	ite	mi
   24466:	432c      	orrmi	r4, r5
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   24468:	43ac      	bicpl	r4, r5
   2446a:	6034      	str	r4, [r6, #0]
	return api->pin_configure(port, pin, flags);
   2446c:	683b      	ldr	r3, [r7, #0]
}
   2446e:	bcf0      	pop	{r4, r5, r6, r7}
	return api->pin_configure(port, pin, flags);
   24470:	4718      	bx	r3

00024472 <arch_printk_char_out>:
}
   24472:	2000      	movs	r0, #0
   24474:	4770      	bx	lr

00024476 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
   24476:	b40f      	push	{r0, r1, r2, r3}
   24478:	b507      	push	{r0, r1, r2, lr}
   2447a:	a904      	add	r1, sp, #16
   2447c:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
   24480:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
   24482:	f7f8 f82b 	bl	1c4dc <vprintk>

	va_end(ap);
}
   24486:	b003      	add	sp, #12
   24488:	f85d eb04 	ldr.w	lr, [sp], #4
   2448c:	b004      	add	sp, #16
   2448e:	4770      	bx	lr

00024490 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   24490:	4604      	mov	r4, r0
   24492:	b508      	push	{r3, lr}
   24494:	4608      	mov	r0, r1
   24496:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   24498:	461a      	mov	r2, r3
   2449a:	47a0      	blx	r4
	return z_impl_z_current_get();
   2449c:	f7ff fd04 	bl	23ea8 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   244a0:	f7fa fa0c 	bl	1e8bc <z_impl_k_thread_abort>

000244a4 <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   244a4:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   244a8:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   244aa:	0840      	lsrs	r0, r0, #1
   244ac:	4770      	bx	lr

000244ae <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   244ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   244b0:	4603      	mov	r3, r0
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   244b2:	f7ff fff7 	bl	244a4 <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   244b6:	fab0 f080 	clz	r0, r0
   244ba:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   244be:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   244c2:	f8dc 6010 	ldr.w	r6, [ip, #16]
	void *cmem = &buf[c];
   244c6:	00ca      	lsls	r2, r1, #3
		((uint16_t *)cmem)[f] = val;
   244c8:	1d17      	adds	r7, r2, #4
{
   244ca:	460c      	mov	r4, r1
   244cc:	3206      	adds	r2, #6
   244ce:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
   244d0:	b956      	cbnz	r6, 244e8 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   244d2:	2101      	movs	r1, #1
   244d4:	fa01 f000 	lsl.w	r0, r1, r0
   244d8:	68d9      	ldr	r1, [r3, #12]
   244da:	4301      	orrs	r1, r0
   244dc:	60d9      	str	r1, [r3, #12]
		b->next = c;
   244de:	f8cc 4010 	str.w	r4, [ip, #16]
   244e2:	53dd      	strh	r5, [r3, r7]
   244e4:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   244e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   244e8:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   244ea:	3104      	adds	r1, #4
   244ec:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   244ee:	53d8      	strh	r0, [r3, r7]
   244f0:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   244f4:	529e      	strh	r6, [r3, r2]
   244f6:	80c5      	strh	r5, [r0, #6]
   244f8:	525d      	strh	r5, [r3, r1]
   244fa:	e7f4      	b.n	244e6 <free_list_add+0x38>

000244fc <free_list_remove_bidx>:
{
   244fc:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   244fe:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   24502:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   24504:	4299      	cmp	r1, r3
   24506:	f102 0104 	add.w	r1, r2, #4
   2450a:	d10a      	bne.n	24522 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   2450c:	2301      	movs	r3, #1
   2450e:	fa03 f202 	lsl.w	r2, r3, r2
   24512:	68c3      	ldr	r3, [r0, #12]
   24514:	ea23 0302 	bic.w	r3, r3, r2
   24518:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   2451a:	2300      	movs	r3, #0
   2451c:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   24520:	bd10      	pop	{r4, pc}
   24522:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   24524:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   24528:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   2452c:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   24530:	80cb      	strh	r3, [r1, #6]
   24532:	8082      	strh	r2, [r0, #4]
}
   24534:	e7f4      	b.n	24520 <free_list_remove_bidx+0x24>

00024536 <free_list_remove>:
{
   24536:	b508      	push	{r3, lr}
   24538:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   2453a:	f7ff ffb3 	bl	244a4 <chunk_size>
	return 31 - __builtin_clz(usable_sz);
   2453e:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   24542:	4618      	mov	r0, r3
}
   24544:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
   24548:	f1c2 021f 	rsb	r2, r2, #31
   2454c:	f7ff bfd6 	b.w	244fc <free_list_remove_bidx>

00024550 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   24550:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   24554:	fab1 f581 	clz	r5, r1
   24558:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   2455c:	eb00 0889 	add.w	r8, r0, r9, lsl #2
   24560:	f8d8 2010 	ldr.w	r2, [r8, #16]
{
   24564:	4603      	mov	r3, r0
   24566:	460e      	mov	r6, r1
	if (b->next) {
   24568:	b1c2      	cbz	r2, 2459c <alloc_chunk+0x4c>
   2456a:	2703      	movs	r7, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   2456c:	f8d8 4010 	ldr.w	r4, [r8, #16]
			if (chunk_size(h, c) >= sz) {
   24570:	4618      	mov	r0, r3
   24572:	4621      	mov	r1, r4
   24574:	f7ff ff96 	bl	244a4 <chunk_size>
   24578:	42b0      	cmp	r0, r6
   2457a:	d306      	bcc.n	2458a <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   2457c:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   2457e:	4618      	mov	r0, r3
   24580:	f7ff ffbc 	bl	244fc <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   24584:	4620      	mov	r0, r4
   24586:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   2458a:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   2458e:	88e0      	ldrh	r0, [r4, #6]
		} while (--i && b->next != first);
   24590:	3f01      	subs	r7, #1
			b->next = next_free_chunk(h, c);
   24592:	f8c8 0010 	str.w	r0, [r8, #16]
		} while (--i && b->next != first);
   24596:	d001      	beq.n	2459c <alloc_chunk+0x4c>
   24598:	4282      	cmp	r2, r0
   2459a:	d1e7      	bne.n	2456c <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   2459c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   245a0:	f1c5 0220 	rsb	r2, r5, #32
   245a4:	4094      	lsls	r4, r2
   245a6:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
   245a8:	4014      	ands	r4, r2
   245aa:	d0eb      	beq.n	24584 <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   245ac:	fa94 f2a4 	rbit	r2, r4
   245b0:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   245b4:	1d11      	adds	r1, r2, #4
   245b6:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
   245ba:	4621      	mov	r1, r4
   245bc:	e7df      	b.n	2457e <alloc_chunk+0x2e>

000245be <merge_chunks>:
{
   245be:	b538      	push	{r3, r4, r5, lr}
   245c0:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   245c2:	f7ff ff6f 	bl	244a4 <chunk_size>
{
   245c6:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   245c8:	4604      	mov	r4, r0
   245ca:	4611      	mov	r1, r2
   245cc:	4618      	mov	r0, r3
   245ce:	f7ff ff69 	bl	244a4 <chunk_size>
   245d2:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   245d4:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
   245d6:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
   245da:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
   245dc:	4618      	mov	r0, r3
   245de:	f7ff ff61 	bl	244a4 <chunk_size>
	void *cmem = &buf[c];
   245e2:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   245e4:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
   245e8:	bd38      	pop	{r3, r4, r5, pc}

000245ea <split_chunks>:
{
   245ea:	b538      	push	{r3, r4, r5, lr}
   245ec:	460c      	mov	r4, r1
   245ee:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
   245f0:	f7ff ff58 	bl	244a4 <chunk_size>
	chunksz_t rsz = sz0 - lsz;
   245f4:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
   245f6:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
   245f8:	4405      	add	r5, r0
   245fa:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   245fe:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   24600:	8060      	strh	r0, [r4, #2]
   24602:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   24606:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   24608:	8044      	strh	r4, [r0, #2]
   2460a:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   2460e:	4618      	mov	r0, r3
   24610:	4611      	mov	r1, r2
   24612:	f7ff ff47 	bl	244a4 <chunk_size>
	void *cmem = &buf[c];
   24616:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   24618:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
   2461c:	bd38      	pop	{r3, r4, r5, pc}

0002461e <free_chunk>:
{
   2461e:	b538      	push	{r3, r4, r5, lr}
   24620:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
   24622:	f7ff ff3f 	bl	244a4 <chunk_size>
   24626:	460c      	mov	r4, r1
   24628:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   2462a:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   2462e:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   24630:	07da      	lsls	r2, r3, #31
   24632:	d40a      	bmi.n	2464a <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   24634:	4628      	mov	r0, r5
   24636:	f7ff ff7e 	bl	24536 <free_list_remove>
	return c + chunk_size(h, c);
   2463a:	4621      	mov	r1, r4
   2463c:	4628      	mov	r0, r5
   2463e:	f7ff ff31 	bl	244a4 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   24642:	1822      	adds	r2, r4, r0
   24644:	4628      	mov	r0, r5
   24646:	f7ff ffba 	bl	245be <merge_chunks>
		return ((uint16_t *)cmem)[f];
   2464a:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   2464e:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   24650:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   24654:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   24656:	07db      	lsls	r3, r3, #31
   24658:	d40c      	bmi.n	24674 <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   2465a:	4628      	mov	r0, r5
   2465c:	f7ff ff6b 	bl	24536 <free_list_remove>
		return ((uint16_t *)cmem)[f];
   24660:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   24664:	4622      	mov	r2, r4
   24666:	1a61      	subs	r1, r4, r1
   24668:	4628      	mov	r0, r5
   2466a:	f7ff ffa8 	bl	245be <merge_chunks>
   2466e:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   24672:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   24674:	4621      	mov	r1, r4
   24676:	4628      	mov	r0, r5
}
   24678:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   2467c:	f7ff bf17 	b.w	244ae <free_list_add>

00024680 <sys_heap_free>:
	if (mem == NULL) {
   24680:	b161      	cbz	r1, 2469c <sys_heap_free+0x1c>
   24682:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   24684:	3904      	subs	r1, #4
   24686:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   24688:	f021 0307 	bic.w	r3, r1, #7
   2468c:	4403      	add	r3, r0
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   2468e:	885a      	ldrh	r2, [r3, #2]
	free_chunk(h, c);
   24690:	08c9      	lsrs	r1, r1, #3
   24692:	f022 0201 	bic.w	r2, r2, #1
   24696:	805a      	strh	r2, [r3, #2]
   24698:	f7ff bfc1 	b.w	2461e <free_chunk>
}
   2469c:	4770      	bx	lr

0002469e <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   2469e:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   246a0:	6805      	ldr	r5, [r0, #0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
   246a2:	b909      	cbnz	r1, 246a8 <sys_heap_alloc+0xa>
		return NULL;
   246a4:	2000      	movs	r0, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
   246a6:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   246a8:	68ab      	ldr	r3, [r5, #8]
   246aa:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   246ae:	d9f9      	bls.n	246a4 <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   246b0:	310b      	adds	r1, #11
   246b2:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   246b4:	4621      	mov	r1, r4
   246b6:	4628      	mov	r0, r5
   246b8:	f7ff ff4a 	bl	24550 <alloc_chunk>
	if (c == 0U) {
   246bc:	4606      	mov	r6, r0
   246be:	2800      	cmp	r0, #0
   246c0:	d0f0      	beq.n	246a4 <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   246c2:	4601      	mov	r1, r0
   246c4:	4628      	mov	r0, r5
   246c6:	f7ff feed 	bl	244a4 <chunk_size>
   246ca:	42a0      	cmp	r0, r4
   246cc:	d907      	bls.n	246de <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
   246ce:	4628      	mov	r0, r5
   246d0:	1932      	adds	r2, r6, r4
   246d2:	f7ff ff8a 	bl	245ea <split_chunks>
		free_list_add(h, c + chunk_sz);
   246d6:	4611      	mov	r1, r2
   246d8:	4628      	mov	r0, r5
   246da:	f7ff fee8 	bl	244ae <free_list_add>
	void *cmem = &buf[c];
   246de:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   246e2:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   246e4:	8853      	ldrh	r3, [r2, #2]
   246e6:	3004      	adds	r0, #4
   246e8:	f043 0301 	orr.w	r3, r3, #1
   246ec:	8053      	strh	r3, [r2, #2]
	return mem;
   246ee:	e7da      	b.n	246a6 <sys_heap_alloc+0x8>

000246f0 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   246f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   246f4:	f101 39ff 	add.w	r9, r1, #4294967295	; 0xffffffff
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
	if (align != rew) {
   246f8:	ea19 0901 	ands.w	r9, r9, r1
{
   246fc:	460f      	mov	r7, r1
   246fe:	4614      	mov	r4, r2
	struct z_heap *h = heap->heap;
   24700:	6806      	ldr	r6, [r0, #0]
	if (align != rew) {
   24702:	d00c      	beq.n	2471e <sys_heap_aligned_alloc+0x2e>
	rew = align & -align;
   24704:	424b      	negs	r3, r1
   24706:	400b      	ands	r3, r1
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
   24708:	2b04      	cmp	r3, #4
   2470a:	461a      	mov	r2, r3
   2470c:	464f      	mov	r7, r9
   2470e:	bf28      	it	cs
   24710:	2204      	movcs	r2, #4
	rew = align & -align;
   24712:	4699      	mov	r9, r3
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   24714:	b964      	cbnz	r4, 24730 <sys_heap_aligned_alloc+0x40>
		return NULL;
   24716:	2500      	movs	r5, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
   24718:	4628      	mov	r0, r5
   2471a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   2471e:	2904      	cmp	r1, #4
   24720:	d804      	bhi.n	2472c <sys_heap_aligned_alloc+0x3c>
}
   24722:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   24726:	4611      	mov	r1, r2
   24728:	f7ff bfb9 	b.w	2469e <sys_heap_alloc>
		gap = chunk_header_bytes(h);
   2472c:	2204      	movs	r2, #4
   2472e:	e7f1      	b.n	24714 <sys_heap_aligned_alloc+0x24>
	if (bytes == 0 || size_too_big(h, bytes)) {
   24730:	68b3      	ldr	r3, [r6, #8]
   24732:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   24736:	d9ee      	bls.n	24716 <sys_heap_aligned_alloc+0x26>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   24738:	f104 010b 	add.w	r1, r4, #11
   2473c:	4439      	add	r1, r7
   2473e:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   24740:	4630      	mov	r0, r6
   24742:	08c9      	lsrs	r1, r1, #3
   24744:	f7ff ff04 	bl	24550 <alloc_chunk>
	if (c0 == 0) {
   24748:	4680      	mov	r8, r0
   2474a:	2800      	cmp	r0, #0
   2474c:	d0e3      	beq.n	24716 <sys_heap_aligned_alloc+0x26>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   2474e:	f109 0504 	add.w	r5, r9, #4
   24752:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   24756:	1e7b      	subs	r3, r7, #1
   24758:	4435      	add	r5, r6
   2475a:	441d      	add	r5, r3
   2475c:	427f      	negs	r7, r7
   2475e:	403d      	ands	r5, r7
   24760:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   24764:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   24766:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   24768:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   2476a:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   2476c:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   24770:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   24772:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   24776:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   2477a:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   2477e:	d208      	bcs.n	24792 <sys_heap_aligned_alloc+0xa2>
		split_chunks(h, c0, c);
   24780:	4601      	mov	r1, r0
   24782:	463a      	mov	r2, r7
   24784:	4630      	mov	r0, r6
   24786:	f7ff ff30 	bl	245ea <split_chunks>
		free_list_add(h, c0);
   2478a:	4641      	mov	r1, r8
   2478c:	4630      	mov	r0, r6
   2478e:	f7ff fe8e 	bl	244ae <free_list_add>
	return c + chunk_size(h, c);
   24792:	4639      	mov	r1, r7
   24794:	4630      	mov	r0, r6
   24796:	f7ff fe85 	bl	244a4 <chunk_size>
   2479a:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   2479c:	4284      	cmp	r4, r0
   2479e:	d207      	bcs.n	247b0 <sys_heap_aligned_alloc+0xc0>
		split_chunks(h, c, c_end);
   247a0:	4630      	mov	r0, r6
   247a2:	4622      	mov	r2, r4
   247a4:	f7ff ff21 	bl	245ea <split_chunks>
		free_list_add(h, c_end);
   247a8:	4621      	mov	r1, r4
   247aa:	4630      	mov	r0, r6
   247ac:	f7ff fe7f 	bl	244ae <free_list_add>
	void *cmem = &buf[c];
   247b0:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   247b4:	8873      	ldrh	r3, [r6, #2]
   247b6:	f043 0301 	orr.w	r3, r3, #1
   247ba:	8073      	strh	r3, [r6, #2]
   247bc:	e7ac      	b.n	24718 <sys_heap_aligned_alloc+0x28>

000247be <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   247be:	b4f0      	push	{r4, r5, r6, r7}
   247c0:	4604      	mov	r4, r0
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   247c2:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   247c4:	1dc8      	adds	r0, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   247c6:	4411      	add	r1, r2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   247c8:	f020 0007 	bic.w	r0, r0, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   247cc:	f021 0107 	bic.w	r1, r1, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   247d0:	1a0e      	subs	r6, r1, r0
   247d2:	08f3      	lsrs	r3, r6, #3
	return 31 - __builtin_clz(usable_sz);
   247d4:	fab3 f283 	clz	r2, r3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   247d8:	6020      	str	r0, [r4, #0]
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   247da:	2700      	movs	r7, #0
   247dc:	4604      	mov	r4, r0
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   247de:	f1c2 0524 	rsb	r5, r2, #36	; 0x24
   247e2:	00ad      	lsls	r5, r5, #2
	h->end_chunk = heap_sz;
   247e4:	6083      	str	r3, [r0, #8]
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   247e6:	3507      	adds	r5, #7
	h->avail_buckets = 0;
   247e8:	f844 7f0c 	str.w	r7, [r4, #12]!
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
   247ec:	f1c2 0220 	rsb	r2, r2, #32
   247f0:	08e9      	lsrs	r1, r5, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   247f2:	eb04 0282 	add.w	r2, r4, r2, lsl #2
		h->buckets[i].next = 0;
   247f6:	f844 7f04 	str.w	r7, [r4, #4]!
	for (int i = 0; i < nb_buckets; i++) {
   247fa:	4294      	cmp	r4, r2
   247fc:	d1fb      	bne.n	247f6 <sys_heap_init+0x38>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   247fe:	004a      	lsls	r2, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   24800:	f042 0201 	orr.w	r2, r2, #1
   24804:	8042      	strh	r2, [r0, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   24806:	1a5a      	subs	r2, r3, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   24808:	0055      	lsls	r5, r2, #1
		((uint16_t *)cmem)[f] = val;
   2480a:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   2480e:	8007      	strh	r7, [r0, #0]
   24810:	8065      	strh	r5, [r4, #2]
   24812:	1984      	adds	r4, r0, r6
   24814:	f820 1031 	strh.w	r1, [r0, r1, lsl #3]
	void *cmem = &buf[c];
   24818:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
		((uint16_t *)cmem)[f] = val;
   2481c:	8067      	strh	r7, [r4, #2]
   2481e:	5382      	strh	r2, [r0, r6]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   24820:	885a      	ldrh	r2, [r3, #2]
   24822:	f042 0201 	orr.w	r2, r2, #1
   24826:	805a      	strh	r2, [r3, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
   24828:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   2482a:	f7ff be40 	b.w	244ae <free_list_add>

0002482e <sys_slist_find_and_remove>:
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2482e:	2200      	movs	r2, #0
	return list->head;
   24830:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24832:	b90b      	cbnz	r3, 24838 <sys_slist_find_and_remove+0xa>
   24834:	4618      	mov	r0, r3
   24836:	4770      	bx	lr
   24838:	428b      	cmp	r3, r1
   2483a:	d110      	bne.n	2485e <sys_slist_find_and_remove+0x30>
	return node->next;
   2483c:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   2483e:	b942      	cbnz	r2, 24852 <sys_slist_find_and_remove+0x24>
   24840:	6842      	ldr	r2, [r0, #4]
	list->head = node;
   24842:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   24844:	4291      	cmp	r1, r2
   24846:	d100      	bne.n	2484a <sys_slist_find_and_remove+0x1c>
	list->tail = node;
   24848:	6043      	str	r3, [r0, #4]
	parent->next = child;
   2484a:	2300      	movs	r3, #0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2484c:	2001      	movs	r0, #1
	parent->next = child;
   2484e:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   24850:	4770      	bx	lr
	parent->next = child;
   24852:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   24854:	6843      	ldr	r3, [r0, #4]
   24856:	4299      	cmp	r1, r3
	list->tail = node;
   24858:	bf08      	it	eq
   2485a:	6042      	streq	r2, [r0, #4]
}
   2485c:	e7f5      	b.n	2484a <sys_slist_find_and_remove+0x1c>
	return node->next;
   2485e:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24860:	681b      	ldr	r3, [r3, #0]
   24862:	e7e6      	b.n	24832 <sys_slist_find_and_remove+0x4>

00024864 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   24864:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   24866:	f013 0307 	ands.w	r3, r3, #7
   2486a:	d105      	bne.n	24878 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   2486c:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
   2486e:	2b00      	cmp	r3, #0
   24870:	bf0c      	ite	eq
   24872:	2000      	moveq	r0, #0
   24874:	2003      	movne	r0, #3
   24876:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   24878:	2b02      	cmp	r3, #2
   2487a:	d105      	bne.n	24888 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   2487c:	8b40      	ldrh	r0, [r0, #26]
   2487e:	fab0 f080 	clz	r0, r0
   24882:	0940      	lsrs	r0, r0, #5
   24884:	0080      	lsls	r0, r0, #2
   24886:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   24888:	2b01      	cmp	r3, #1
   2488a:	d105      	bne.n	24898 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   2488c:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
   2488e:	2b00      	cmp	r3, #0
   24890:	bf0c      	ite	eq
   24892:	2000      	moveq	r0, #0
   24894:	2005      	movne	r0, #5
   24896:	4770      	bx	lr
	int evt = EVT_NOP;
   24898:	2000      	movs	r0, #0
}
   2489a:	4770      	bx	lr

0002489c <validate_args>:
{
   2489c:	b510      	push	{r4, lr}
   2489e:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   248a0:	b100      	cbz	r0, 248a4 <validate_args+0x8>
   248a2:	b911      	cbnz	r1, 248aa <validate_args+0xe>
		return -EINVAL;
   248a4:	f06f 0015 	mvn.w	r0, #21
}
   248a8:	bd10      	pop	{r4, pc}
	int rv = sys_notify_validate(&cli->notify);
   248aa:	1d08      	adds	r0, r1, #4
   248ac:	f000 f8d6 	bl	24a5c <sys_notify_validate>
	if ((rv == 0)
   248b0:	2800      	cmp	r0, #0
   248b2:	d1f9      	bne.n	248a8 <validate_args+0xc>
	    && ((cli->notify.flags
   248b4:	68a3      	ldr	r3, [r4, #8]
   248b6:	2b03      	cmp	r3, #3
   248b8:	d9f6      	bls.n	248a8 <validate_args+0xc>
   248ba:	e7f3      	b.n	248a4 <validate_args+0x8>

000248bc <notify_one>:
{
   248bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   248c0:	460d      	mov	r5, r1
   248c2:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   248c4:	4619      	mov	r1, r3
   248c6:	1d28      	adds	r0, r5, #4
{
   248c8:	4690      	mov	r8, r2
   248ca:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   248cc:	f000 f8d7 	bl	24a7e <sys_notify_finalize>
	if (cb) {
   248d0:	4604      	mov	r4, r0
   248d2:	b138      	cbz	r0, 248e4 <notify_one+0x28>
		cb(mgr, cli, state, res);
   248d4:	4633      	mov	r3, r6
   248d6:	4642      	mov	r2, r8
   248d8:	4629      	mov	r1, r5
   248da:	4638      	mov	r0, r7
   248dc:	46a4      	mov	ip, r4
}
   248de:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   248e2:	4760      	bx	ip
}
   248e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000248e8 <transition_complete>:
{
   248e8:	b410      	push	{r4}
	__asm__ volatile(
   248ea:	f04f 0420 	mov.w	r4, #32
   248ee:	f3ef 8211 	mrs	r2, BASEPRI
   248f2:	f384 8812 	msr	BASEPRI_MAX, r4
   248f6:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   248fa:	6141      	str	r1, [r0, #20]
}
   248fc:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   248fe:	2101      	movs	r1, #1
   24900:	f7f7 bdfa 	b.w	1c4f8 <process_event>

00024904 <onoff_manager_init>:
{
   24904:	b538      	push	{r3, r4, r5, lr}
   24906:	460c      	mov	r4, r1
	if ((mgr == NULL)
   24908:	4605      	mov	r5, r0
   2490a:	b158      	cbz	r0, 24924 <onoff_manager_init+0x20>
	    || (transitions == NULL)
   2490c:	b151      	cbz	r1, 24924 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   2490e:	680b      	ldr	r3, [r1, #0]
   24910:	b143      	cbz	r3, 24924 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   24912:	684b      	ldr	r3, [r1, #4]
   24914:	b133      	cbz	r3, 24924 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   24916:	221c      	movs	r2, #28
   24918:	2100      	movs	r1, #0
   2491a:	f000 fb6d 	bl	24ff8 <memset>
	return 0;
   2491e:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   24920:	612c      	str	r4, [r5, #16]
}
   24922:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   24924:	f06f 0015 	mvn.w	r0, #21
   24928:	e7fb      	b.n	24922 <onoff_manager_init+0x1e>

0002492a <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   2492a:	b570      	push	{r4, r5, r6, lr}
   2492c:	4605      	mov	r5, r0
   2492e:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   24930:	f7ff ffb4 	bl	2489c <validate_args>

	if (rv < 0) {
   24934:	1e04      	subs	r4, r0, #0
   24936:	db15      	blt.n	24964 <onoff_request+0x3a>
   24938:	f04f 0320 	mov.w	r3, #32
   2493c:	f3ef 8211 	mrs	r2, BASEPRI
   24940:	f383 8812 	msr	BASEPRI_MAX, r3
   24944:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   24948:	f64f 71ff 	movw	r1, #65535	; 0xffff
   2494c:	8b6b      	ldrh	r3, [r5, #26]
   2494e:	8b2c      	ldrh	r4, [r5, #24]
   24950:	428b      	cmp	r3, r1
   24952:	f004 0407 	and.w	r4, r4, #7
   24956:	d107      	bne.n	24968 <onoff_request+0x3e>
	__asm__ volatile(
   24958:	f382 8811 	msr	BASEPRI, r2
   2495c:	f3bf 8f6f 	isb	sy
		rv = -EAGAIN;
   24960:	f06f 040a 	mvn.w	r4, #10
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
   24964:	4620      	mov	r0, r4
   24966:	bd70      	pop	{r4, r5, r6, pc}
	if (state == ONOFF_STATE_ON) {
   24968:	2c02      	cmp	r4, #2
   2496a:	d10c      	bne.n	24986 <onoff_request+0x5c>
		mgr->refs += 1U;
   2496c:	3301      	adds	r3, #1
   2496e:	836b      	strh	r3, [r5, #26]
   24970:	f382 8811 	msr	BASEPRI, r2
   24974:	f3bf 8f6f 	isb	sy
			notify_one(mgr, cli, state, 0);
   24978:	2300      	movs	r3, #0
   2497a:	4622      	mov	r2, r4
   2497c:	4631      	mov	r1, r6
   2497e:	4628      	mov	r0, r5
   24980:	f7ff ff9c 	bl	248bc <notify_one>
   24984:	e7ee      	b.n	24964 <onoff_request+0x3a>
	} else if ((state == ONOFF_STATE_OFF)
   24986:	2c06      	cmp	r4, #6
   24988:	d814      	bhi.n	249b4 <onoff_request+0x8a>
   2498a:	e8df f004 	tbb	[pc, r4]
   2498e:	1304      	.short	0x1304
   24990:	1a041313 	.word	0x1a041313
   24994:	04          	.byte	0x04
   24995:	00          	.byte	0x00
	parent->next = child;
   24996:	2300      	movs	r3, #0
   24998:	6033      	str	r3, [r6, #0]
	return list->tail;
   2499a:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_APPEND(slist, snode)
   2499c:	b93b      	cbnz	r3, 249ae <onoff_request+0x84>
	list->head = node;
   2499e:	e9c5 6600 	strd	r6, r6, [r5]
	if (start) {
   249a2:	b9ac      	cbnz	r4, 249d0 <onoff_request+0xa6>
		process_event(mgr, EVT_RECHECK, key);
   249a4:	2102      	movs	r1, #2
   249a6:	4628      	mov	r0, r5
   249a8:	f7f7 fda6 	bl	1c4f8 <process_event>
   249ac:	e7da      	b.n	24964 <onoff_request+0x3a>
	parent->next = child;
   249ae:	601e      	str	r6, [r3, #0]
	list->tail = node;
   249b0:	606e      	str	r6, [r5, #4]
}
   249b2:	e7f6      	b.n	249a2 <onoff_request+0x78>
   249b4:	f382 8811 	msr	BASEPRI, r2
   249b8:	f3bf 8f6f 	isb	sy
		rv = -EIO;
   249bc:	f06f 0404 	mvn.w	r4, #4
   249c0:	e7d0      	b.n	24964 <onoff_request+0x3a>
   249c2:	f382 8811 	msr	BASEPRI, r2
   249c6:	f3bf 8f6f 	isb	sy
   249ca:	f06f 0485 	mvn.w	r4, #133	; 0x85
   249ce:	e7c9      	b.n	24964 <onoff_request+0x3a>
   249d0:	f382 8811 	msr	BASEPRI, r2
   249d4:	f3bf 8f6f 	isb	sy
		if (notify) {
   249d8:	e7c4      	b.n	24964 <onoff_request+0x3a>

000249da <onoff_release>:

int onoff_release(struct onoff_manager *mgr)
{
   249da:	b510      	push	{r4, lr}
	__asm__ volatile(
   249dc:	f04f 0320 	mov.w	r3, #32
   249e0:	f3ef 8211 	mrs	r2, BASEPRI
   249e4:	f383 8812 	msr	BASEPRI_MAX, r3
   249e8:	f3bf 8f6f 	isb	sy
	bool stop = false;      /* trigger a stop transition */

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   249ec:	8b04      	ldrh	r4, [r0, #24]
   249ee:	f004 0407 	and.w	r4, r4, #7
	int rv = state;

	if (state != ONOFF_STATE_ON) {
   249f2:	2c02      	cmp	r4, #2
   249f4:	d00a      	beq.n	24a0c <onoff_release+0x32>
		if (state == ONOFF_STATE_ERROR) {
			rv = -EIO;
		} else {
			rv = -ENOTSUP;
   249f6:	2c01      	cmp	r4, #1
   249f8:	bf0c      	ite	eq
   249fa:	f06f 0004 	mvneq.w	r0, #4
   249fe:	f06f 0085 	mvnne.w	r0, #133	; 0x85
	__asm__ volatile(
   24a02:	f382 8811 	msr	BASEPRI, r2
   24a06:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);
	}

	return rv;
   24a0a:	e008      	b.n	24a1e <onoff_release+0x44>
	mgr->refs -= 1U;
   24a0c:	8b43      	ldrh	r3, [r0, #26]
   24a0e:	3b01      	subs	r3, #1
   24a10:	b29b      	uxth	r3, r3
   24a12:	8343      	strh	r3, [r0, #26]
	if (stop) {
   24a14:	b923      	cbnz	r3, 24a20 <onoff_release+0x46>
		process_event(mgr, EVT_RECHECK, key);
   24a16:	4621      	mov	r1, r4
   24a18:	f7f7 fd6e 	bl	1c4f8 <process_event>
	int rv = state;
   24a1c:	4620      	mov	r0, r4
}
   24a1e:	bd10      	pop	{r4, pc}
	int rv = state;
   24a20:	4620      	mov	r0, r4
   24a22:	e7ee      	b.n	24a02 <onoff_release+0x28>

00024a24 <onoff_cancel>:
	return rv;
}

int onoff_cancel(struct onoff_manager *mgr,
		 struct onoff_client *cli)
{
   24a24:	b538      	push	{r3, r4, r5, lr}
	if ((mgr == NULL) || (cli == NULL)) {
   24a26:	b1b0      	cbz	r0, 24a56 <onoff_cancel+0x32>
   24a28:	b1a9      	cbz	r1, 24a56 <onoff_cancel+0x32>
	__asm__ volatile(
   24a2a:	f04f 0220 	mov.w	r2, #32
   24a2e:	f3ef 8511 	mrs	r5, BASEPRI
   24a32:	f382 8812 	msr	BASEPRI_MAX, r2
   24a36:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	int rv = -EALREADY;
	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   24a3a:	8b04      	ldrh	r4, [r0, #24]

	if (sys_slist_find_and_remove(&mgr->clients, &cli->node)) {
   24a3c:	f7ff fef7 	bl	2482e <sys_slist_find_and_remove>
   24a40:	b130      	cbz	r0, 24a50 <onoff_cancel+0x2c>
		__ASSERT_NO_MSG((state == ONOFF_STATE_TO_ON)
				|| (state == ONOFF_STATE_TO_OFF)
				|| (state == ONOFF_STATE_RESETTING));
		rv = state;
   24a42:	f004 0007 	and.w	r0, r4, #7
	__asm__ volatile(
   24a46:	f385 8811 	msr	BASEPRI, r5
   24a4a:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&mgr->lock, key);

	return rv;
}
   24a4e:	bd38      	pop	{r3, r4, r5, pc}
	int rv = -EALREADY;
   24a50:	f06f 0077 	mvn.w	r0, #119	; 0x77
   24a54:	e7f7      	b.n	24a46 <onoff_cancel+0x22>
		return -EINVAL;
   24a56:	f06f 0015 	mvn.w	r0, #21
   24a5a:	e7f8      	b.n	24a4e <onoff_cancel+0x2a>

00024a5c <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   24a5c:	4603      	mov	r3, r0
   24a5e:	b158      	cbz	r0, 24a78 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   24a60:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   24a62:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   24a66:	2a01      	cmp	r2, #1
   24a68:	d003      	beq.n	24a72 <sys_notify_validate+0x16>
   24a6a:	2a03      	cmp	r2, #3
   24a6c:	d104      	bne.n	24a78 <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   24a6e:	6802      	ldr	r2, [r0, #0]
   24a70:	b112      	cbz	r2, 24a78 <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   24a72:	2000      	movs	r0, #0
   24a74:	6098      	str	r0, [r3, #8]
   24a76:	4770      	bx	lr
   24a78:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   24a7c:	4770      	bx	lr

00024a7e <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   24a7e:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   24a80:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
   24a82:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   24a86:	2a03      	cmp	r2, #3
   24a88:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
   24a8c:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
   24a8e:	bf14      	ite	ne
   24a90:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   24a92:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   24a94:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   24a96:	4770      	bx	lr

00024a98 <encode_uint>:
{
   24a98:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24a9c:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier) != 0;
   24a9e:	78d3      	ldrb	r3, [r2, #3]
{
   24aa0:	4680      	mov	r8, r0
	switch (specifier) {
   24aa2:	2b6f      	cmp	r3, #111	; 0x6f
{
   24aa4:	460f      	mov	r7, r1
   24aa6:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   24aa8:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
   24aac:	d029      	beq.n	24b02 <encode_uint+0x6a>
   24aae:	d824      	bhi.n	24afa <encode_uint+0x62>
		return 10;
   24ab0:	2b58      	cmp	r3, #88	; 0x58
   24ab2:	bf0c      	ite	eq
   24ab4:	2610      	moveq	r6, #16
   24ab6:	260a      	movne	r6, #10
	char *bp = bps + (bpe - bps);
   24ab8:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
   24abc:	4632      	mov	r2, r6
   24abe:	2300      	movs	r3, #0
   24ac0:	4640      	mov	r0, r8
   24ac2:	4639      	mov	r1, r7
   24ac4:	f7f7 fb46 	bl	1c154 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24ac8:	2a09      	cmp	r2, #9
   24aca:	b2d4      	uxtb	r4, r2
   24acc:	d81e      	bhi.n	24b0c <encode_uint+0x74>
   24ace:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   24ad0:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24ad2:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
   24ad4:	f177 0700 	sbcs.w	r7, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24ad8:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
   24adc:	d301      	bcc.n	24ae2 <encode_uint+0x4a>
   24ade:	45d1      	cmp	r9, sl
   24ae0:	d811      	bhi.n	24b06 <encode_uint+0x6e>
	if (conv->flag_hash) {
   24ae2:	782b      	ldrb	r3, [r5, #0]
   24ae4:	069b      	lsls	r3, r3, #26
   24ae6:	d505      	bpl.n	24af4 <encode_uint+0x5c>
		if (radix == 8) {
   24ae8:	2e08      	cmp	r6, #8
   24aea:	d115      	bne.n	24b18 <encode_uint+0x80>
			conv->altform_0 = true;
   24aec:	78ab      	ldrb	r3, [r5, #2]
   24aee:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   24af2:	70ab      	strb	r3, [r5, #2]
}
   24af4:	4648      	mov	r0, r9
   24af6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   24afa:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 10;
   24afe:	2b70      	cmp	r3, #112	; 0x70
   24b00:	e7d7      	b.n	24ab2 <encode_uint+0x1a>
	switch (specifier) {
   24b02:	2608      	movs	r6, #8
   24b04:	e7d8      	b.n	24ab8 <encode_uint+0x20>
		value /= radix;
   24b06:	4680      	mov	r8, r0
   24b08:	460f      	mov	r7, r1
   24b0a:	e7d7      	b.n	24abc <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24b0c:	f1bb 0f19 	cmp.w	fp, #25
   24b10:	bf94      	ite	ls
   24b12:	3437      	addls	r4, #55	; 0x37
   24b14:	3457      	addhi	r4, #87	; 0x57
   24b16:	e7db      	b.n	24ad0 <encode_uint+0x38>
		} else if (radix == 16) {
   24b18:	2e10      	cmp	r6, #16
   24b1a:	d1eb      	bne.n	24af4 <encode_uint+0x5c>
			conv->altform_0c = true;
   24b1c:	78ab      	ldrb	r3, [r5, #2]
   24b1e:	f043 0310 	orr.w	r3, r3, #16
   24b22:	e7e6      	b.n	24af2 <encode_uint+0x5a>

00024b24 <outs>:
{
   24b24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24b28:	4607      	mov	r7, r0
   24b2a:	4688      	mov	r8, r1
   24b2c:	4615      	mov	r5, r2
   24b2e:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   24b30:	4614      	mov	r4, r2
   24b32:	42b4      	cmp	r4, r6
   24b34:	d305      	bcc.n	24b42 <outs+0x1e>
   24b36:	b10e      	cbz	r6, 24b3c <outs+0x18>
	return (int)count;
   24b38:	1b60      	subs	r0, r4, r5
   24b3a:	e008      	b.n	24b4e <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   24b3c:	7823      	ldrb	r3, [r4, #0]
   24b3e:	2b00      	cmp	r3, #0
   24b40:	d0fa      	beq.n	24b38 <outs+0x14>
		int rc = out((int)*sp++, ctx);
   24b42:	4641      	mov	r1, r8
   24b44:	f814 0b01 	ldrb.w	r0, [r4], #1
   24b48:	47b8      	blx	r7
		if (rc < 0) {
   24b4a:	2800      	cmp	r0, #0
   24b4c:	daf1      	bge.n	24b32 <outs+0xe>
}
   24b4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024b52 <ring_buf_put_claim>:

#include <zephyr/sys/ring_buffer.h>
#include <string.h>

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
   24b52:	4694      	mov	ip, r2
   24b54:	b5f0      	push	{r4, r5, r6, r7, lr}
   24b56:	4604      	mov	r4, r0
	uint32_t free_space, wrap_size;
	int32_t base;

	base = buf->put_base;
	wrap_size = buf->put_head - base;
	if (unlikely(wrap_size >= buf->size)) {
   24b58:	69c3      	ldr	r3, [r0, #28]
	base = buf->put_base;
   24b5a:	68c6      	ldr	r6, [r0, #12]
	wrap_size = buf->put_head - base;
   24b5c:	6845      	ldr	r5, [r0, #4]
   24b5e:	6940      	ldr	r0, [r0, #20]
   24b60:	1baf      	subs	r7, r5, r6
   24b62:	1a28      	subs	r0, r5, r0
   24b64:	1a1a      	subs	r2, r3, r0
	if (unlikely(wrap_size >= buf->size)) {
   24b66:	42bb      	cmp	r3, r7
		/* put_base is not yet adjusted */
		wrap_size -= buf->size;
   24b68:	bf9c      	itt	ls
   24b6a:	1aff      	subls	r7, r7, r3
		base += buf->size;
   24b6c:	18f6      	addls	r6, r6, r3
	}
	wrap_size = buf->size - wrap_size;

	free_space = ring_buf_space_get(buf);
	size = MIN(size, free_space);
   24b6e:	4562      	cmp	r2, ip
   24b70:	bf28      	it	cs
   24b72:	4662      	movcs	r2, ip
	wrap_size = buf->size - wrap_size;
   24b74:	1bd8      	subs	r0, r3, r7
	size = MIN(size, wrap_size);
   24b76:	4290      	cmp	r0, r2
   24b78:	bf28      	it	cs
   24b7a:	4610      	movcs	r0, r2

	*data = &buf->buffer[buf->put_head - base];
   24b7c:	6823      	ldr	r3, [r4, #0]
   24b7e:	1bad      	subs	r5, r5, r6
   24b80:	442b      	add	r3, r5
   24b82:	600b      	str	r3, [r1, #0]
	buf->put_head += size;
   24b84:	6863      	ldr	r3, [r4, #4]
   24b86:	4403      	add	r3, r0
   24b88:	6063      	str	r3, [r4, #4]

	return size;
}
   24b8a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00024b8c <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->put_head - buf->put_tail;
   24b8c:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
   24b90:	1ad2      	subs	r2, r2, r3
	if (unlikely(size > finish_space)) {
   24b92:	428a      	cmp	r2, r1
   24b94:	d30c      	bcc.n	24bb0 <ring_buf_put_finish+0x24>
		return -EINVAL;
	}

	buf->put_tail += size;
   24b96:	4419      	add	r1, r3
	buf->put_head = buf->put_tail;

	wrap_size = buf->put_tail - buf->put_base;
   24b98:	68c3      	ldr	r3, [r0, #12]
	if (unlikely(wrap_size >= buf->size)) {
   24b9a:	69c2      	ldr	r2, [r0, #28]
	buf->put_head = buf->put_tail;
   24b9c:	e9c0 1101 	strd	r1, r1, [r0, #4]
	wrap_size = buf->put_tail - buf->put_base;
   24ba0:	1ac9      	subs	r1, r1, r3
	if (unlikely(wrap_size >= buf->size)) {
   24ba2:	428a      	cmp	r2, r1
   24ba4:	d901      	bls.n	24baa <ring_buf_put_finish+0x1e>
		/* we wrapped: adjust put_base */
		buf->put_base += buf->size;
	}

	return 0;
   24ba6:	2000      	movs	r0, #0
   24ba8:	4770      	bx	lr
		buf->put_base += buf->size;
   24baa:	4413      	add	r3, r2
   24bac:	60c3      	str	r3, [r0, #12]
   24bae:	e7fa      	b.n	24ba6 <ring_buf_put_finish+0x1a>
		return -EINVAL;
   24bb0:	f06f 0015 	mvn.w	r0, #21
}
   24bb4:	4770      	bx	lr

00024bb6 <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
   24bb6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   24bba:	4680      	mov	r8, r0
   24bbc:	460e      	mov	r6, r1
   24bbe:	4615      	mov	r5, r2
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
   24bc0:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
   24bc2:	462a      	mov	r2, r5
   24bc4:	a901      	add	r1, sp, #4
   24bc6:	4640      	mov	r0, r8
   24bc8:	f7ff ffc3 	bl	24b52 <ring_buf_put_claim>
   24bcc:	4604      	mov	r4, r0
		memcpy(dst, data, partial_size);
   24bce:	4602      	mov	r2, r0
   24bd0:	4631      	mov	r1, r6
   24bd2:	9801      	ldr	r0, [sp, #4]
   24bd4:	f000 fa05 	bl	24fe2 <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
   24bd8:	1b2d      	subs	r5, r5, r4
		total_size += partial_size;
   24bda:	4427      	add	r7, r4
		data += partial_size;
   24bdc:	4426      	add	r6, r4
	} while (size && partial_size);
   24bde:	d001      	beq.n	24be4 <ring_buf_put+0x2e>
   24be0:	2c00      	cmp	r4, #0
   24be2:	d1ee      	bne.n	24bc2 <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
   24be4:	4639      	mov	r1, r7
   24be6:	4640      	mov	r0, r8
   24be8:	f7ff ffd0 	bl	24b8c <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
   24bec:	4638      	mov	r0, r7
   24bee:	b002      	add	sp, #8
   24bf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024bf4 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
   24bf4:	b5f0      	push	{r4, r5, r6, r7, lr}
   24bf6:	4604      	mov	r4, r0
   24bf8:	4694      	mov	ip, r2
	uint32_t available_size, wrap_size;
	int32_t base;

	base = buf->get_base;
   24bfa:	6986      	ldr	r6, [r0, #24]
	wrap_size = buf->get_head - base;
   24bfc:	6905      	ldr	r5, [r0, #16]
 *
 * @return Ring buffer space used (in bytes).
 */
static inline uint32_t ring_buf_size_get(struct ring_buf *buf)
{
	return buf->put_tail - buf->get_head;
   24bfe:	68a3      	ldr	r3, [r4, #8]
	if (unlikely(wrap_size >= buf->size)) {
   24c00:	69c0      	ldr	r0, [r0, #28]
	wrap_size = buf->get_head - base;
   24c02:	1baf      	subs	r7, r5, r6
   24c04:	1b5a      	subs	r2, r3, r5
	if (unlikely(wrap_size >= buf->size)) {
   24c06:	42b8      	cmp	r0, r7
		/* get_base is not yet adjusted */
		wrap_size -= buf->size;
		base += buf->size;
   24c08:	bf9c      	itt	ls
   24c0a:	1836      	addls	r6, r6, r0
		wrap_size -= buf->size;
   24c0c:	1a3f      	subls	r7, r7, r0
	}
	wrap_size = buf->size - wrap_size;

	available_size = ring_buf_size_get(buf);
	size = MIN(size, available_size);
   24c0e:	4562      	cmp	r2, ip
   24c10:	bf28      	it	cs
   24c12:	4662      	movcs	r2, ip
	wrap_size = buf->size - wrap_size;
   24c14:	1bc0      	subs	r0, r0, r7
	size = MIN(size, wrap_size);
   24c16:	4290      	cmp	r0, r2
   24c18:	bf28      	it	cs
   24c1a:	4610      	movcs	r0, r2

	*data = &buf->buffer[buf->get_head - base];
   24c1c:	6823      	ldr	r3, [r4, #0]
   24c1e:	1bad      	subs	r5, r5, r6
   24c20:	442b      	add	r3, r5
   24c22:	600b      	str	r3, [r1, #0]
	buf->get_head += size;
   24c24:	6923      	ldr	r3, [r4, #16]
   24c26:	4403      	add	r3, r0
   24c28:	6123      	str	r3, [r4, #16]

	return size;
}
   24c2a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00024c2c <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->get_head - buf->get_tail;
   24c2c:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
   24c30:	1ad2      	subs	r2, r2, r3
	if (unlikely(size > finish_space)) {
   24c32:	428a      	cmp	r2, r1
   24c34:	d30c      	bcc.n	24c50 <ring_buf_get_finish+0x24>
		return -EINVAL;
	}

	buf->get_tail += size;
   24c36:	4419      	add	r1, r3
	buf->get_head = buf->get_tail;
   24c38:	e9c0 1104 	strd	r1, r1, [r0, #16]

	wrap_size = buf->get_tail - buf->get_base;
	if (unlikely(wrap_size >= buf->size)) {
   24c3c:	e9d0 3206 	ldrd	r3, r2, [r0, #24]
	wrap_size = buf->get_tail - buf->get_base;
   24c40:	1ac9      	subs	r1, r1, r3
	if (unlikely(wrap_size >= buf->size)) {
   24c42:	428a      	cmp	r2, r1
   24c44:	d901      	bls.n	24c4a <ring_buf_get_finish+0x1e>
		/* we wrapped: adjust get_base */
		buf->get_base += buf->size;
	}

	return 0;
   24c46:	2000      	movs	r0, #0
   24c48:	4770      	bx	lr
		buf->get_base += buf->size;
   24c4a:	4413      	add	r3, r2
   24c4c:	6183      	str	r3, [r0, #24]
   24c4e:	e7fa      	b.n	24c46 <ring_buf_get_finish+0x1a>
		return -EINVAL;
   24c50:	f06f 0015 	mvn.w	r0, #21
}
   24c54:	4770      	bx	lr

00024c56 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
   24c56:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   24c5a:	4680      	mov	r8, r0
   24c5c:	460d      	mov	r5, r1
   24c5e:	4616      	mov	r6, r2
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
   24c60:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
   24c62:	4632      	mov	r2, r6
   24c64:	4640      	mov	r0, r8
   24c66:	a901      	add	r1, sp, #4
   24c68:	f7ff ffc4 	bl	24bf4 <ring_buf_get_claim>
   24c6c:	4604      	mov	r4, r0
		if (data) {
   24c6e:	b12d      	cbz	r5, 24c7c <ring_buf_get+0x26>
			memcpy(data, src, partial_size);
   24c70:	4602      	mov	r2, r0
   24c72:	9901      	ldr	r1, [sp, #4]
   24c74:	4628      	mov	r0, r5
   24c76:	f000 f9b4 	bl	24fe2 <memcpy>
			data += partial_size;
   24c7a:	4425      	add	r5, r4
		}
		total_size += partial_size;
		size -= partial_size;
	} while (size && partial_size);
   24c7c:	1b36      	subs	r6, r6, r4
		total_size += partial_size;
   24c7e:	4427      	add	r7, r4
	} while (size && partial_size);
   24c80:	d001      	beq.n	24c86 <ring_buf_get+0x30>
   24c82:	2c00      	cmp	r4, #0
   24c84:	d1ed      	bne.n	24c62 <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
   24c86:	4639      	mov	r1, r7
   24c88:	4640      	mov	r0, r8
   24c8a:	f7ff ffcf 	bl	24c2c <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
   24c8e:	4638      	mov	r0, r7
   24c90:	b002      	add	sp, #8
   24c92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024c96 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_MCUBOOT_SIGNATURE_KEY_FILE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_MCUBOOT_EXTRA_IMGTOOL_ARGS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_MCUBOOT_BOOTLOADER_MODE_SWAP_WITHOUT_SCRATCH, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   24c96:	4770      	bx	lr

00024c98 <nordicsemi_nrf53_init>:
{
   24c98:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   24c9a:	f04f 0320 	mov.w	r3, #32
   24c9e:	f3ef 8511 	mrs	r5, BASEPRI
   24ca2:	f383 8812 	msr	BASEPRI_MAX, r3
   24ca6:	f3bf 8f6f 	isb	sy
}

NRF_STATIC_INLINE void nrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS_Type *     p_reg,
                                                    nrf_oscillators_lfxo_cap_t cap)
{
    p_reg->XOSC32KI.INTCAP = (uint32_t)cap;
   24caa:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   24cae:	2401      	movs	r4, #1
   24cb0:	2202      	movs	r2, #2
		soc_secure_gpio_pin_mcu_select(forwarded_psels[i], NRF_GPIO_PIN_SEL_NETWORK);
   24cb2:	4621      	mov	r1, r4
   24cb4:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
   24cb8:	202b      	movs	r0, #43	; 0x2b
   24cba:	f8c3 4704 	str.w	r4, [r3, #1796]	; 0x704
#endif

#if NRF_REGULATORS_HAS_DCDCEN_RADIO
NRF_STATIC_INLINE void nrf_regulators_dcdcen_radio_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
    p_reg->VREGRADIO.DCDCEN = (enable) ? REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Enabled :
   24cbe:	f8c3 4904 	str.w	r4, [r3, #2308]	; 0x904
    p_reg->VREGH.DCDCEN = (enable) ? REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled :
   24cc2:	f8c3 4b00 	str.w	r4, [r3, #2816]	; 0xb00
   24cc6:	f000 f824 	bl	24d12 <soc_secure_gpio_pin_mcu_select>
   24cca:	4621      	mov	r1, r4
   24ccc:	202c      	movs	r0, #44	; 0x2c
   24cce:	f000 f820 	bl	24d12 <soc_secure_gpio_pin_mcu_select>
   24cd2:	4621      	mov	r1, r4
   24cd4:	202a      	movs	r0, #42	; 0x2a
   24cd6:	f000 f81c 	bl	24d12 <soc_secure_gpio_pin_mcu_select>
   24cda:	4621      	mov	r1, r4
   24cdc:	201e      	movs	r0, #30
   24cde:	f000 f818 	bl	24d12 <soc_secure_gpio_pin_mcu_select>
	__asm__ volatile(
   24ce2:	f385 8811 	msr	BASEPRI, r5
   24ce6:	f3bf 8f6f 	isb	sy
}
   24cea:	2000      	movs	r0, #0
   24cec:	bd38      	pop	{r3, r4, r5, pc}

00024cee <pm_state_set>:
/* Invoke Low Power/System Off specific Tasks */
__weak void pm_state_set(enum pm_state state, uint8_t substate_id)
{
	ARG_UNUSED(substate_id);

	switch (state) {
   24cee:	2806      	cmp	r0, #6
   24cf0:	d108      	bne.n	24d04 <pm_state_set+0x16>
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
   24cf2:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   24cf6:	2201      	movs	r2, #1
   24cf8:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   24cfc:	f3bf 8f4f 	dsb	sy
        __WFE();
   24d00:	bf20      	wfe
    while (true)
   24d02:	e7fd      	b.n	24d00 <pm_state_set+0x12>
		break;
	default:
		LOG_DBG("Unsupported power state %u", state);
		break;
	}
}
   24d04:	4770      	bx	lr

00024d06 <pm_state_exit_post_ops>:
   24d06:	2300      	movs	r3, #0
   24d08:	f383 8811 	msr	BASEPRI, r3
   24d0c:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   24d10:	4770      	bx	lr

00024d12 <soc_secure_gpio_pin_mcu_select>:
#include "tfm_platform_api.h"
#include "tfm_ioctl_api.h"

#if NRF_GPIO_HAS_SEL
void soc_secure_gpio_pin_mcu_select(uint32_t pin_number, nrf_gpio_pin_sel_t mcu)
{
   24d12:	b507      	push	{r0, r1, r2, lr}
	uint32_t result;
	enum tfm_platform_err_t err;

	err = tfm_platform_gpio_pin_mcu_select(pin_number, mcu, &result);
   24d14:	aa01      	add	r2, sp, #4
   24d16:	f000 fd65 	bl	257e4 <tfm_platform_gpio_pin_mcu_select>
	__ASSERT(err == TFM_PLATFORM_ERR_SUCCESS, "TFM platform error (%d)", err);
	__ASSERT(result == 0, "GPIO service error (%d)", result);
}
   24d1a:	b003      	add	sp, #12
   24d1c:	f85d fb04 	ldr.w	pc, [sp], #4

00024d20 <soc_secure_mem_read>:
#endif /* NRF_GPIO_HAS_SEL */

int soc_secure_mem_read(void *dst, void *src, size_t len)
{
   24d20:	b507      	push	{r0, r1, r2, lr}
	enum tfm_platform_err_t status;
	uint32_t result;

	status = tfm_platform_mem_read(dst, (uintptr_t)src, len, &result);
   24d22:	ab01      	add	r3, sp, #4
   24d24:	f000 fd46 	bl	257b4 <tfm_platform_mem_read>

	switch (status) {
   24d28:	2802      	cmp	r0, #2
   24d2a:	d00a      	beq.n	24d42 <soc_secure_mem_read+0x22>
   24d2c:	2803      	cmp	r0, #3
   24d2e:	d00b      	beq.n	24d48 <soc_secure_mem_read+0x28>
   24d30:	b968      	cbnz	r0, 24d4e <soc_secure_mem_read+0x2e>
	case TFM_PLATFORM_ERR_INVALID_PARAM:
		return -EINVAL;
	case TFM_PLATFORM_ERR_NOT_SUPPORTED:
		return -ENOTSUP;
	case TFM_PLATFORM_ERR_SUCCESS:
		if (result == 0) {
   24d32:	9801      	ldr	r0, [sp, #4]
   24d34:	3800      	subs	r0, #0
   24d36:	bf18      	it	ne
   24d38:	2001      	movne	r0, #1
   24d3a:	4240      	negs	r0, r0
		}
		/* Fallthrough */
	default:
		return -EPERM;
	}
}
   24d3c:	b003      	add	sp, #12
   24d3e:	f85d fb04 	ldr.w	pc, [sp], #4
		return -EINVAL;
   24d42:	f06f 0015 	mvn.w	r0, #21
   24d46:	e7f9      	b.n	24d3c <soc_secure_mem_read+0x1c>
	switch (status) {
   24d48:	f06f 0085 	mvn.w	r0, #133	; 0x85
   24d4c:	e7f6      	b.n	24d3c <soc_secure_mem_read+0x1c>
		return -EPERM;
   24d4e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24d52:	e7f3      	b.n	24d3c <soc_secure_mem_read+0x1c>

00024d54 <get_ep_bm_from_addr>:
	if (ep_idx > 15) {
   24d54:	f010 0f70 	tst.w	r0, #112	; 0x70
   24d58:	d109      	bne.n	24d6e <get_ep_bm_from_addr+0x1a>
	ep_idx = ep & (~USB_EP_DIR_IN);
   24d5a:	f000 037f 	and.w	r3, r0, #127	; 0x7f
	if (ep & USB_EP_DIR_IN) {
   24d5e:	f010 0f80 	tst.w	r0, #128	; 0x80
   24d62:	f04f 0001 	mov.w	r0, #1
		ep_bm = BIT(ep_idx + 16);
   24d66:	bf18      	it	ne
   24d68:	3310      	addne	r3, #16
		ep_bm = BIT(ep_idx);
   24d6a:	4098      	lsls	r0, r3
   24d6c:	4770      	bx	lr
	uint32_t ep_bm = 0;
   24d6e:	2000      	movs	r0, #0
}
   24d70:	4770      	bx	lr

00024d72 <usb_write>:
{
   24d72:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   24d76:	4606      	mov	r6, r0
   24d78:	460f      	mov	r7, r1
   24d7a:	4690      	mov	r8, r2
   24d7c:	4699      	mov	r9, r3
   24d7e:	2504      	movs	r5, #4
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   24d80:	464b      	mov	r3, r9
   24d82:	4642      	mov	r2, r8
   24d84:	4639      	mov	r1, r7
   24d86:	4630      	mov	r0, r6
   24d88:	f7fa fbb8 	bl	1f4fc <usb_dc_ep_write>
		if (ret == -EAGAIN) {
   24d8c:	f110 0f0b 	cmn.w	r0, #11
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   24d90:	4604      	mov	r4, r0
		if (ret == -EAGAIN) {
   24d92:	d103      	bne.n	24d9c <usb_write+0x2a>
	z_impl_k_yield();
   24d94:	f7fe ffd2 	bl	23d3c <z_impl_k_yield>
	} while (ret == -EAGAIN && tries--);
   24d98:	3d01      	subs	r5, #1
   24d9a:	d1f1      	bne.n	24d80 <usb_write+0xe>
}
   24d9c:	4620      	mov	r0, r4
   24d9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00024da2 <usb_get_dev_data_by_cfg>:
	return list->head;
   24da2:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_cfg(sys_slist_t *list,
					     struct usb_cfg_data *cfg)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24da4:	b138      	cbz	r0, 24db6 <usb_get_dev_data_by_cfg+0x14>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg_cur = dev->config;
   24da6:	f850 3c04 	ldr.w	r3, [r0, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24daa:	3804      	subs	r0, #4

		if (cfg_cur == cfg) {
   24dac:	685b      	ldr	r3, [r3, #4]
   24dae:	428b      	cmp	r3, r1
   24db0:	d001      	beq.n	24db6 <usb_get_dev_data_by_cfg+0x14>
	return node->next;
   24db2:	6840      	ldr	r0, [r0, #4]
   24db4:	e7f6      	b.n	24da4 <usb_get_dev_data_by_cfg+0x2>
	}

	LOG_DBG("Device data not found for cfg %p", cfg);

	return NULL;
}
   24db6:	4770      	bx	lr

00024db8 <usb_get_dev_data_by_iface>:
	return list->head;
   24db8:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_iface(sys_slist_t *list,
					       uint8_t iface_num)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dba:	b148      	cbz	r0, 24dd0 <usb_get_dev_data_by_iface+0x18>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
   24dbc:	f850 3c04 	ldr.w	r3, [r0, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dc0:	3804      	subs	r0, #4
		const struct usb_if_descriptor *if_desc =
   24dc2:	685b      	ldr	r3, [r3, #4]
						cfg->interface_descriptor;

		if (if_desc->bInterfaceNumber == iface_num) {
   24dc4:	685b      	ldr	r3, [r3, #4]
   24dc6:	789b      	ldrb	r3, [r3, #2]
   24dc8:	428b      	cmp	r3, r1
   24dca:	d001      	beq.n	24dd0 <usb_get_dev_data_by_iface+0x18>
	return node->next;
   24dcc:	6840      	ldr	r0, [r0, #4]
   24dce:	e7f4      	b.n	24dba <usb_get_dev_data_by_iface+0x2>
	}

	LOG_DBG("Device data not found for iface number %u", iface_num);

	return NULL;
}
   24dd0:	4770      	bx	lr

00024dd2 <usb_get_dev_data_by_ep>:

struct usb_dev_data *usb_get_dev_data_by_ep(sys_slist_t *list, uint8_t ep)
{
   24dd2:	b530      	push	{r4, r5, lr}
	return list->head;
   24dd4:	6800      	ldr	r0, [r0, #0]
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dd6:	b188      	cbz	r0, 24dfc <usb_get_dev_data_by_ep+0x2a>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
   24dd8:	f850 3c04 	ldr.w	r3, [r0, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24ddc:	3804      	subs	r0, #4
		const struct usb_cfg_data *cfg = dev->config;
   24dde:	685b      	ldr	r3, [r3, #4]
		const struct usb_ep_cfg_data *ep_data = cfg->endpoint;
   24de0:	6a1a      	ldr	r2, [r3, #32]

		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
   24de2:	7f1d      	ldrb	r5, [r3, #28]
   24de4:	2300      	movs	r3, #0
			if (ep_data[i].ep_addr == ep) {
   24de6:	3a04      	subs	r2, #4
		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
   24de8:	b2dc      	uxtb	r4, r3
   24dea:	42a5      	cmp	r5, r4
   24dec:	d801      	bhi.n	24df2 <usb_get_dev_data_by_ep+0x20>
	return node->next;
   24dee:	6840      	ldr	r0, [r0, #4]
   24df0:	e7f1      	b.n	24dd6 <usb_get_dev_data_by_ep+0x4>
			if (ep_data[i].ep_addr == ep) {
   24df2:	3301      	adds	r3, #1
   24df4:	f812 4033 	ldrb.w	r4, [r2, r3, lsl #3]
   24df8:	428c      	cmp	r4, r1
   24dfa:	d1f5      	bne.n	24de8 <usb_get_dev_data_by_ep+0x16>
	}

	LOG_DBG("Device data not found for ep %u", ep);

	return NULL;
}
   24dfc:	bd30      	pop	{r4, r5, pc}

00024dfe <usb_transfer_is_busy>:
{
   24dfe:	b508      	push	{r3, lr}
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);
   24e00:	f7f8 fee0 	bl	1dbc4 <usb_ep_get_transfer>
	if (trans && trans->status == -EBUSY) {
   24e04:	b128      	cbz	r0, 24e12 <usb_transfer_is_busy+0x14>
   24e06:	6840      	ldr	r0, [r0, #4]
   24e08:	f110 0f10 	cmn.w	r0, #16
   24e0c:	bf14      	ite	ne
   24e0e:	2000      	movne	r0, #0
   24e10:	2001      	moveq	r0, #1
}
   24e12:	bd08      	pop	{r3, pc}

00024e14 <cdc_interface_config>:
	desc->if1.bInterfaceNumber = bInterfaceNumber + 1;
   24e14:	1c4b      	adds	r3, r1, #1
   24e16:	b2db      	uxtb	r3, r3
	desc->if0.bInterfaceNumber = bInterfaceNumber;
   24e18:	7081      	strb	r1, [r0, #2]
	desc->if0_union.bControlInterface = bInterfaceNumber;
   24e1a:	7681      	strb	r1, [r0, #26]
	desc->if1.bInterfaceNumber = bInterfaceNumber + 1;
   24e1c:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
	desc->if0_union.bSubordinateInterface0 = bInterfaceNumber + 1;
   24e20:	76c3      	strb	r3, [r0, #27]
	desc->iad_cdc.bFirstInterface = bInterfaceNumber;
   24e22:	f800 1c06 	strb.w	r1, [r0, #-6]
}
   24e26:	4770      	bx	lr

00024e28 <cdc_acm_irq_callback_work_handler>:
	dev_data->cb(dev_data->common.dev, dev_data->cb_data);
   24e28:	e950 3102 	ldrd	r3, r1, [r0, #-8]
   24e2c:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
   24e30:	4718      	bx	r3

00024e32 <cdc_acm_irq_tx_disable>:
	dev_data->tx_irq_ena = false;
   24e32:	2200      	movs	r2, #0
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e34:	6903      	ldr	r3, [r0, #16]
	dev_data->tx_irq_ena = false;
   24e36:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
}
   24e3a:	4770      	bx	lr

00024e3c <cdc_acm_irq_tx_ready>:
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e3c:	6903      	ldr	r3, [r0, #16]
	if (dev_data->tx_irq_ena && dev_data->tx_ready) {
   24e3e:	f893 004a 	ldrb.w	r0, [r3, #74]	; 0x4a
   24e42:	b108      	cbz	r0, 24e48 <cdc_acm_irq_tx_ready+0xc>
   24e44:	f893 0048 	ldrb.w	r0, [r3, #72]	; 0x48
}
   24e48:	4770      	bx	lr

00024e4a <cdc_acm_irq_rx_disable>:
	dev_data->rx_irq_ena = false;
   24e4a:	2200      	movs	r2, #0
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e4c:	6903      	ldr	r3, [r0, #16]
	dev_data->rx_irq_ena = false;
   24e4e:	f883 204b 	strb.w	r2, [r3, #75]	; 0x4b
}
   24e52:	4770      	bx	lr

00024e54 <cdc_acm_irq_rx_ready>:
	if (dev_data->rx_ready) {
   24e54:	6903      	ldr	r3, [r0, #16]
}
   24e56:	f893 0049 	ldrb.w	r0, [r3, #73]	; 0x49
   24e5a:	4770      	bx	lr

00024e5c <cdc_acm_irq_is_pending>:
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e5c:	6903      	ldr	r3, [r0, #16]
	if (dev_data->tx_ready && dev_data->tx_irq_ena) {
   24e5e:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
   24e62:	b112      	cbz	r2, 24e6a <cdc_acm_irq_is_pending+0xe>
   24e64:	f893 204a 	ldrb.w	r2, [r3, #74]	; 0x4a
   24e68:	b92a      	cbnz	r2, 24e76 <cdc_acm_irq_is_pending+0x1a>
	} else if (dev_data->rx_ready && dev_data->rx_irq_ena) {
   24e6a:	f893 0049 	ldrb.w	r0, [r3, #73]	; 0x49
   24e6e:	b118      	cbz	r0, 24e78 <cdc_acm_irq_is_pending+0x1c>
   24e70:	f893 004b 	ldrb.w	r0, [r3, #75]	; 0x4b
   24e74:	4770      	bx	lr
		return 1;
   24e76:	2001      	movs	r0, #1
}
   24e78:	4770      	bx	lr

00024e7a <cdc_acm_irq_update>:
}
   24e7a:	2001      	movs	r0, #1
   24e7c:	4770      	bx	lr

00024e7e <cdc_acm_irq_callback_set>:
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e7e:	6903      	ldr	r3, [r0, #16]
	dev_data->cb_data = cb_data;
   24e80:	e9c3 1200 	strd	r1, r2, [r3]
}
   24e84:	4770      	bx	lr

00024e86 <cdc_acm_configure>:
}
   24e86:	2000      	movs	r0, #0
   24e88:	4770      	bx	lr

00024e8a <cdc_acm_config_get>:
{
   24e8a:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e8c:	6903      	ldr	r3, [r0, #16]
	cfg->baudrate = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
   24e8e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
   24e92:	600a      	str	r2, [r1, #0]
	switch (dev_data->line_coding.bCharFormat) {
   24e94:	f893 2098 	ldrb.w	r2, [r3, #152]	; 0x98
   24e98:	b16a      	cbz	r2, 24eb6 <cdc_acm_config_get+0x2c>
   24e9a:	2a01      	cmp	r2, #1
   24e9c:	bf0c      	ite	eq
   24e9e:	2202      	moveq	r2, #2
   24ea0:	2203      	movne	r2, #3
		cfg->stop_bits = UART_CFG_STOP_BITS_1;
   24ea2:	714a      	strb	r2, [r1, #5]
	switch (dev_data->line_coding.bParityType) {
   24ea4:	f893 2099 	ldrb.w	r2, [r3, #153]	; 0x99
   24ea8:	1e50      	subs	r0, r2, #1
   24eaa:	2803      	cmp	r0, #3
   24eac:	d805      	bhi.n	24eba <cdc_acm_config_get+0x30>
   24eae:	e8df f000 	tbb	[pc, r0]
   24eb2:	0505      	.short	0x0505
   24eb4:	0505      	.short	0x0505
	switch (dev_data->line_coding.bCharFormat) {
   24eb6:	2201      	movs	r2, #1
   24eb8:	e7f3      	b.n	24ea2 <cdc_acm_config_get+0x18>
	switch (dev_data->line_coding.bParityType) {
   24eba:	2200      	movs	r2, #0
		cfg->parity = UART_CFG_PARITY_NONE;
   24ebc:	710a      	strb	r2, [r1, #4]
	switch (dev_data->line_coding.bDataBits) {
   24ebe:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
   24ec2:	2b06      	cmp	r3, #6
   24ec4:	d009      	beq.n	24eda <cdc_acm_config_get+0x50>
   24ec6:	2b07      	cmp	r3, #7
   24ec8:	d009      	beq.n	24ede <cdc_acm_config_get+0x54>
   24eca:	2b05      	cmp	r3, #5
   24ecc:	bf0c      	ite	eq
   24ece:	2300      	moveq	r3, #0
   24ed0:	2303      	movne	r3, #3
	cfg->flow_ctrl = UART_CFG_FLOW_CTRL_NONE;
   24ed2:	2000      	movs	r0, #0
		cfg->data_bits = UART_CFG_DATA_BITS_5;
   24ed4:	718b      	strb	r3, [r1, #6]
	cfg->flow_ctrl = UART_CFG_FLOW_CTRL_NONE;
   24ed6:	71c8      	strb	r0, [r1, #7]
}
   24ed8:	bd10      	pop	{r4, pc}
	switch (dev_data->line_coding.bDataBits) {
   24eda:	2301      	movs	r3, #1
   24edc:	e7f9      	b.n	24ed2 <cdc_acm_config_get+0x48>
   24ede:	2302      	movs	r3, #2
   24ee0:	e7f7      	b.n	24ed2 <cdc_acm_config_get+0x48>

00024ee2 <cdc_acm_fifo_read>:
{
   24ee2:	b570      	push	{r4, r5, r6, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24ee4:	6904      	ldr	r4, [r0, #16]
{
   24ee6:	4605      	mov	r5, r0
	len = ring_buf_get(dev_data->rx_ringbuf, rx_data, size);
   24ee8:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   24eec:	f7ff feb3 	bl	24c56 <ring_buf_get>
	if (ring_buf_is_empty(dev_data->rx_ringbuf)) {
   24ef0:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
	len = ring_buf_get(dev_data->rx_ringbuf, rx_data, size);
   24ef4:	4606      	mov	r6, r0
	if (ring_buf_is_empty(dev_data->rx_ringbuf)) {
   24ef6:	691a      	ldr	r2, [r3, #16]
   24ef8:	6899      	ldr	r1, [r3, #8]
   24efa:	4291      	cmp	r1, r2
		dev_data->rx_ready = false;
   24efc:	bf04      	itt	eq
   24efe:	2200      	moveq	r2, #0
   24f00:	f884 2049 	strbeq.w	r2, [r4, #73]	; 0x49
	if (dev_data->rx_paused == true) {
   24f04:	f894 20a0 	ldrb.w	r2, [r4, #160]	; 0xa0
   24f08:	b19a      	cbz	r2, 24f32 <cdc_acm_fifo_read+0x50>
	return buf->size - (buf->put_head - buf->get_tail);
   24f0a:	685a      	ldr	r2, [r3, #4]
   24f0c:	6959      	ldr	r1, [r3, #20]
   24f0e:	69db      	ldr	r3, [r3, #28]
   24f10:	1a52      	subs	r2, r2, r1
   24f12:	1a9b      	subs	r3, r3, r2
		if (ring_buf_space_get(dev_data->rx_ringbuf) >= CDC_ACM_BUFFER_SIZE) {
   24f14:	2b3f      	cmp	r3, #63	; 0x3f
   24f16:	d90c      	bls.n	24f32 <cdc_acm_fifo_read+0x50>
			if (dev_data->configured) {
   24f18:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
   24f1c:	b133      	cbz	r3, 24f2c <cdc_acm_fifo_read+0x4a>
				cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr, 0, dev_data);
   24f1e:	686b      	ldr	r3, [r5, #4]
   24f20:	4622      	mov	r2, r4
   24f22:	6a1b      	ldr	r3, [r3, #32]
   24f24:	2100      	movs	r1, #0
   24f26:	7b18      	ldrb	r0, [r3, #12]
   24f28:	f7f9 f91a 	bl	1e160 <cdc_acm_read_cb>
			dev_data->rx_paused = false;
   24f2c:	2300      	movs	r3, #0
   24f2e:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
}
   24f32:	4630      	mov	r0, r6
   24f34:	bd70      	pop	{r4, r5, r6, pc}

00024f36 <cdc_acm_poll_in>:
	int ret = cdc_acm_fifo_read(dev, c, 1);
   24f36:	2201      	movs	r2, #1
{
   24f38:	b508      	push	{r3, lr}
	int ret = cdc_acm_fifo_read(dev, c, 1);
   24f3a:	f7ff ffd2 	bl	24ee2 <cdc_acm_fifo_read>
}
   24f3e:	3801      	subs	r0, #1
   24f40:	bf18      	it	ne
   24f42:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   24f46:	bd08      	pop	{r3, pc}

00024f48 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   24f48:	f000 bdcf 	b.w	25aea <z_fatal_error>

00024f4c <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
   24f4c:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
   24f4e:	6800      	ldr	r0, [r0, #0]
   24f50:	f000 bdcb 	b.w	25aea <z_fatal_error>

00024f54 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   24f54:	2100      	movs	r1, #0
   24f56:	2001      	movs	r0, #1
   24f58:	f7ff bff6 	b.w	24f48 <z_arm_fatal_error>

00024f5c <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
   24f5c:	b508      	push	{r3, lr}
	handler();
   24f5e:	f7f9 fa05 	bl	1e36c <z_SysNmiOnReset>
	z_arm_int_exit();
}
   24f62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   24f66:	f7f9 bacd 	b.w	1e504 <z_arm_exc_exit>

00024f6a <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   24f6a:	6e43      	ldr	r3, [r0, #100]	; 0x64
   24f6c:	f383 880b 	msr	PSPLIM, r3
}
   24f70:	4770      	bx	lr

00024f72 <z_arm_save_fp_context>:
		 * here though, since FPCA should have no impact on instruction
		 * fetching.
		 */
	}
#endif
}
   24f72:	4770      	bx	lr

00024f74 <z_arm_restore_fp_context>:

void z_arm_restore_fp_context(const struct fpu_ctx_full *buffer)
   24f74:	4770      	bx	lr

00024f76 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   24f76:	e840 f300 	tt	r3, r0
int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
		return addr_info.flags.mpu_region;
   24f7a:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   24f7e:	b2d8      	uxtb	r0, r3
	}

	return -EINVAL;
}
   24f80:	bf08      	it	eq
   24f82:	f06f 0015 	mvneq.w	r0, #21
   24f86:	4770      	bx	lr

00024f88 <mpu_configure_region>:
{
   24f88:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	p_attr->rbar = attr->rbar &
   24f8a:	890a      	ldrh	r2, [r1, #8]
   24f8c:	894e      	ldrh	r6, [r1, #10]
	region_conf.base = new_region->start;
   24f8e:	680b      	ldr	r3, [r1, #0]
		&new_region->attr, new_region->start, new_region->size);
   24f90:	684d      	ldr	r5, [r1, #4]
   24f92:	f002 021f 	and.w	r2, r2, #31
   24f96:	ea42 1246 	orr.w	r2, r2, r6, lsl #5
	region_conf.base = new_region->start;
   24f9a:	9300      	str	r3, [sp, #0]
   24f9c:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   24fa0:	f023 031f 	bic.w	r3, r3, #31
   24fa4:	1e6a      	subs	r2, r5, #1
   24fa6:	4413      	add	r3, r2
   24fa8:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1U)) {
   24fac:	2807      	cmp	r0, #7
   24fae:	9303      	str	r3, [sp, #12]
   24fb0:	d804      	bhi.n	24fbc <mpu_configure_region+0x34>
	region_init(index, region_conf);
   24fb2:	4669      	mov	r1, sp
   24fb4:	f7f9 fcb4 	bl	1e920 <region_init>
}
   24fb8:	b004      	add	sp, #16
   24fba:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   24fbc:	f06f 0015 	mvn.w	r0, #21
	return region_allocate_and_init(index,
   24fc0:	e7fa      	b.n	24fb8 <mpu_configure_region+0x30>

00024fc2 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   24fc2:	4603      	mov	r3, r0
	size_t n = 0;
   24fc4:	2000      	movs	r0, #0

	while (*s != '\0') {
   24fc6:	5c1a      	ldrb	r2, [r3, r0]
   24fc8:	b902      	cbnz	r2, 24fcc <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   24fca:	4770      	bx	lr
		n++;
   24fcc:	3001      	adds	r0, #1
   24fce:	e7fa      	b.n	24fc6 <strlen+0x4>

00024fd0 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   24fd0:	4603      	mov	r3, r0
	size_t n = 0;
   24fd2:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   24fd4:	5c1a      	ldrb	r2, [r3, r0]
   24fd6:	b10a      	cbz	r2, 24fdc <strnlen+0xc>
   24fd8:	4288      	cmp	r0, r1
   24fda:	d100      	bne.n	24fde <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   24fdc:	4770      	bx	lr
		n++;
   24fde:	3001      	adds	r0, #1
   24fe0:	e7f8      	b.n	24fd4 <strnlen+0x4>

00024fe2 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   24fe2:	b510      	push	{r4, lr}
   24fe4:	1e43      	subs	r3, r0, #1
   24fe6:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   24fe8:	4291      	cmp	r1, r2
   24fea:	d100      	bne.n	24fee <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   24fec:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   24fee:	f811 4b01 	ldrb.w	r4, [r1], #1
   24ff2:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   24ff6:	e7f7      	b.n	24fe8 <memcpy+0x6>

00024ff8 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   24ff8:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
   24ffa:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   24ffc:	4402      	add	r2, r0
   24ffe:	4293      	cmp	r3, r2
   25000:	d100      	bne.n	25004 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   25002:	4770      	bx	lr
		*(d_byte++) = c_byte;
   25004:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   25008:	e7f9      	b.n	24ffe <memset+0x6>

0002500a <_stdout_hook_default>:
}
   2500a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2500e:	4770      	bx	lr

00025010 <ep_ctx_reset>:
{
   25010:	b510      	push	{r4, lr}
	ep_ctx->buf.data = ep_ctx->buf.block.data;
   25012:	6903      	ldr	r3, [r0, #16]
{
   25014:	4604      	mov	r4, r0
	ep_ctx->buf.curr = ep_ctx->buf.data;
   25016:	e9c0 3305 	strd	r3, r3, [r0, #20]
	ep_ctx->buf.len  = 0U;
   2501a:	2300      	movs	r3, #0
   2501c:	60c3      	str	r3, [r0, #12]
	if (ep_ctx->write_in_progress) {
   2501e:	7f83      	ldrb	r3, [r0, #30]
   25020:	b113      	cbz	r3, 25028 <ep_ctx_reset+0x18>
		nrfx_usbd_ep_abort(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   25022:	7a40      	ldrb	r0, [r0, #9]
   25024:	f000 fd47 	bl	25ab6 <nrfx_usbd_ep_abort>
	ep_ctx->read_complete = true;
   25028:	2301      	movs	r3, #1
   2502a:	7723      	strb	r3, [r4, #28]
	ep_ctx->read_pending = false;
   2502c:	2300      	movs	r3, #0
   2502e:	7763      	strb	r3, [r4, #29]
	ep_ctx->trans_zlp = false;
   25030:	77e3      	strb	r3, [r4, #31]
	ep_ctx->write_in_progress = false;
   25032:	77a3      	strb	r3, [r4, #30]
}
   25034:	bd10      	pop	{r4, pc}

00025036 <attached_evt_delay_handler>:
	submit_dc_power_event(USBD_ATTACHED);
   25036:	2001      	movs	r0, #1
   25038:	f7f9 be58 	b.w	1ecec <submit_dc_power_event>

0002503c <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
   2503c:	f7fe b996 	b.w	2336c <z_impl_k_mutex_lock>

00025040 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
   25040:	f7fe ba0e 	b.w	23460 <z_impl_k_mutex_unlock>

00025044 <usb_dc_ep_check_cap>:
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
   25044:	7803      	ldrb	r3, [r0, #0]
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
   25046:	7901      	ldrb	r1, [r0, #4]
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
   25048:	f003 020f 	and.w	r2, r3, #15
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
   2504c:	b921      	cbnz	r1, 25058 <usb_dc_ep_check_cap+0x14>
   2504e:	3a00      	subs	r2, #0
   25050:	bf18      	it	ne
   25052:	2201      	movne	r2, #1
   25054:	4250      	negs	r0, r2
   25056:	4770      	bx	lr
	if (!NRF_USBD_EP_VALIDATE(ep_cfg->ep_addr)) {
   25058:	2a08      	cmp	r2, #8
   2505a:	d806      	bhi.n	2506a <usb_dc_ep_check_cap+0x26>
	if ((ep_cfg->ep_type == USB_DC_EP_ISOCHRONOUS) &&
   2505c:	2901      	cmp	r1, #1
   2505e:	d107      	bne.n	25070 <usb_dc_ep_check_cap+0x2c>
   25060:	f083 0008 	eor.w	r0, r3, #8
   25064:	f340 00c0 	sbfx	r0, r0, #3, #1
   25068:	4770      	bx	lr
		return -1;
   2506a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2506e:	4770      	bx	lr
	return 0;
   25070:	2000      	movs	r0, #0
}
   25072:	4770      	bx	lr

00025074 <usb_dc_ep_disable>:
{
   25074:	b538      	push	{r3, r4, r5, lr}
   25076:	4604      	mov	r4, r0
	ep_ctx = endpoint_ctx(ep);
   25078:	f7f9 fdd0 	bl	1ec1c <endpoint_ctx>
	if (!ep_ctx) {
   2507c:	4605      	mov	r5, r0
   2507e:	b160      	cbz	r0, 2509a <usb_dc_ep_disable+0x26>
	if (!ep_ctx->cfg.en) {
   25080:	7a03      	ldrb	r3, [r0, #8]
   25082:	b16b      	cbz	r3, 250a0 <usb_dc_ep_disable+0x2c>
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
   25084:	4620      	mov	r0, r4
	ep_ctx->write_in_progress = false;
   25086:	2400      	movs	r4, #0
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
   25088:	f7fd fe0a 	bl	22ca0 <nrfx_usbd_ep_disable>
	ep_ctx_reset(ep_ctx);
   2508c:	4628      	mov	r0, r5
	ep_ctx->write_in_progress = false;
   2508e:	77ac      	strb	r4, [r5, #30]
	ep_ctx_reset(ep_ctx);
   25090:	f7ff ffbe 	bl	25010 <ep_ctx_reset>
	return 0;
   25094:	4620      	mov	r0, r4
	ep_ctx->cfg.en = false;
   25096:	722c      	strb	r4, [r5, #8]
}
   25098:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   2509a:	f06f 0015 	mvn.w	r0, #21
   2509e:	e7fb      	b.n	25098 <usb_dc_ep_disable+0x24>
		return -EALREADY;
   250a0:	f06f 0077 	mvn.w	r0, #119	; 0x77
   250a4:	e7f8      	b.n	25098 <usb_dc_ep_disable+0x24>

000250a6 <usb_dc_ep_read>:
{
   250a6:	b570      	push	{r4, r5, r6, lr}
   250a8:	4604      	mov	r4, r0
   250aa:	460e      	mov	r6, r1
   250ac:	4615      	mov	r5, r2
	ret = usb_dc_ep_read_wait(ep, data, max_data_len, read_bytes);
   250ae:	f7fa faa1 	bl	1f5f4 <usb_dc_ep_read_wait>
	if (ret) {
   250b2:	b930      	cbnz	r0, 250c2 <usb_dc_ep_read+0x1c>
	if (!data && !max_data_len) {
   250b4:	b906      	cbnz	r6, 250b8 <usb_dc_ep_read+0x12>
   250b6:	b125      	cbz	r5, 250c2 <usb_dc_ep_read+0x1c>
	ret = usb_dc_ep_read_continue(ep);
   250b8:	4620      	mov	r0, r4
}
   250ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = usb_dc_ep_read_continue(ep);
   250be:	f7fa bae1 	b.w	1f684 <usb_dc_ep_read_continue>
}
   250c2:	bd70      	pop	{r4, r5, r6, pc}

000250c4 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   250c4:	220c      	movs	r2, #12
   250c6:	6903      	ldr	r3, [r0, #16]
   250c8:	b2c9      	uxtb	r1, r1
   250ca:	fb01 3302 	mla	r3, r1, r2, r3
   250ce:	6f98      	ldr	r0, [r3, #120]	; 0x78
}
   250d0:	f000 0007 	and.w	r0, r0, #7
   250d4:	4770      	bx	lr

000250d6 <set_on_state>:
	__asm__ volatile(
   250d6:	f04f 0320 	mov.w	r3, #32
   250da:	f3ef 8211 	mrs	r2, BASEPRI
   250de:	f383 8812 	msr	BASEPRI_MAX, r3
   250e2:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   250e6:	6803      	ldr	r3, [r0, #0]
   250e8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   250ec:	f043 0302 	orr.w	r3, r3, #2
   250f0:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   250f2:	f382 8811 	msr	BASEPRI, r2
   250f6:	f3bf 8f6f 	isb	sy
}
   250fa:	4770      	bx	lr

000250fc <stop>:
{
   250fc:	b570      	push	{r4, r5, r6, lr}
   250fe:	b2c9      	uxtb	r1, r1
	struct nrf_clock_control_data *data = dev->data;
   25100:	6903      	ldr	r3, [r0, #16]
	__asm__ volatile(
   25102:	f04f 0420 	mov.w	r4, #32
   25106:	f3ef 8511 	mrs	r5, BASEPRI
   2510a:	f384 8812 	msr	BASEPRI_MAX, r4
   2510e:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   25112:	260c      	movs	r6, #12
   25114:	fb06 3401 	mla	r4, r6, r1, r3
   25118:	6fa4      	ldr	r4, [r4, #120]	; 0x78
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   2511a:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
   2511e:	d008      	beq.n	25132 <stop+0x36>
   25120:	42a2      	cmp	r2, r4
   25122:	d006      	beq.n	25132 <stop+0x36>
	__asm__ volatile(
   25124:	f385 8811 	msr	BASEPRI, r5
   25128:	f3bf 8f6f 	isb	sy
		err = -EPERM;
   2512c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   25130:	bd70      	pop	{r4, r5, r6, pc}
		*flags = CLOCK_CONTROL_STATUS_OFF;
   25132:	2201      	movs	r2, #1
   25134:	fb06 3301 	mla	r3, r6, r1, r3
   25138:	679a      	str	r2, [r3, #120]	; 0x78
   2513a:	f385 8811 	msr	BASEPRI, r5
   2513e:	f3bf 8f6f 	isb	sy
	get_sub_config(dev, type)->stop();
   25142:	6843      	ldr	r3, [r0, #4]
   25144:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
   25148:	685b      	ldr	r3, [r3, #4]
   2514a:	4798      	blx	r3
	return 0;
   2514c:	2000      	movs	r0, #0
   2514e:	e7ef      	b.n	25130 <stop+0x34>

00025150 <api_stop>:
	return stop(dev, subsys, CTX_API);
   25150:	2280      	movs	r2, #128	; 0x80
   25152:	f7ff bfd3 	b.w	250fc <stop>

00025156 <async_start>:
{
   25156:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25158:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
   2515a:	6904      	ldr	r4, [r0, #16]
	return &data->subsys[type];
   2515c:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
   2515e:	f04f 0520 	mov.w	r5, #32
   25162:	f3ef 8611 	mrs	r6, BASEPRI
   25166:	f385 8812 	msr	BASEPRI_MAX, r5
   2516a:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   2516e:	250c      	movs	r5, #12
   25170:	fb05 4401 	mla	r4, r5, r1, r4
   25174:	6fa5      	ldr	r5, [r4, #120]	; 0x78
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   25176:	f005 0c07 	and.w	ip, r5, #7
   2517a:	f1bc 0f01 	cmp.w	ip, #1
   2517e:	d10c      	bne.n	2519a <async_start+0x44>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   25180:	67a7      	str	r7, [r4, #120]	; 0x78
	__asm__ volatile(
   25182:	f386 8811 	msr	BASEPRI, r6
   25186:	f3bf 8f6f 	isb	sy
	subdata->user_data = user_data;
   2518a:	e9c4 231c 	strd	r2, r3, [r4, #112]	; 0x70
	 get_sub_config(dev, type)->start();
   2518e:	6843      	ldr	r3, [r0, #4]
   25190:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
   25194:	4798      	blx	r3
	return 0;
   25196:	2000      	movs	r0, #0
}
   25198:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   2519a:	f005 05c0 	and.w	r5, r5, #192	; 0xc0
	} else if (current_ctx != ctx) {
   2519e:	42af      	cmp	r7, r5
   251a0:	f386 8811 	msr	BASEPRI, r6
   251a4:	f3bf 8f6f 	isb	sy
		err = -EALREADY;
   251a8:	bf0c      	ite	eq
   251aa:	f06f 0077 	mvneq.w	r0, #119	; 0x77
		err = -EPERM;
   251ae:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   251b2:	e7f1      	b.n	25198 <async_start+0x42>

000251b4 <api_start>:
{
   251b4:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
   251b6:	2480      	movs	r4, #128	; 0x80
   251b8:	9400      	str	r4, [sp, #0]
   251ba:	f7ff ffcc 	bl	25156 <async_start>
}
   251be:	b002      	add	sp, #8
   251c0:	bd10      	pop	{r4, pc}

000251c2 <onoff_started_callback>:
{
   251c2:	b410      	push	{r4}
	notify(mgr, 0);
   251c4:	241c      	movs	r4, #28
	return &data->mgr[type];
   251c6:	6900      	ldr	r0, [r0, #16]
   251c8:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   251ca:	fb03 0004 	mla	r0, r3, r4, r0
   251ce:	2100      	movs	r1, #0
}
   251d0:	bc10      	pop	{r4}
	notify(mgr, 0);
   251d2:	4710      	bx	r2

000251d4 <hfclkaudio_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   251d4:	2003      	movs	r0, #3
   251d6:	f7fb bd47 	b.w	20c68 <nrfx_clock_start>

000251da <hfclk192m_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK192M);
   251da:	2002      	movs	r0, #2
   251dc:	f7fb bd44 	b.w	20c68 <nrfx_clock_start>

000251e0 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   251e0:	2000      	movs	r0, #0
   251e2:	f7fb bd41 	b.w	20c68 <nrfx_clock_start>

000251e6 <hfclkaudio_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   251e6:	2003      	movs	r0, #3
   251e8:	f000 bb19 	b.w	2581e <nrfx_clock_stop>

000251ec <hfclk192m_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK192M);
   251ec:	2002      	movs	r0, #2
   251ee:	f000 bb16 	b.w	2581e <nrfx_clock_stop>

000251f2 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   251f2:	2000      	movs	r0, #0
   251f4:	f000 bb13 	b.w	2581e <nrfx_clock_stop>

000251f8 <blocking_start_callback>:
{
   251f8:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   251fa:	f7fe b9a1 	b.w	23540 <z_impl_k_sem_give>

000251fe <entropy_psa_crypto_rng_get_entropy>:
}

/* API implementation: get_entropy */
static int entropy_psa_crypto_rng_get_entropy(const struct device *dev,
					      uint8_t *buffer, uint16_t length)
{
   251fe:	4608      	mov	r0, r1
   25200:	b508      	push	{r3, lr}
	psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

	ARG_UNUSED(dev);

	status = psa_generate_random(buffer, length);
   25202:	4611      	mov	r1, r2
   25204:	f7fb fbd6 	bl	209b4 <psa_generate_random>
	if (status != PSA_SUCCESS) {
		return -EIO;
   25208:	2800      	cmp	r0, #0
	}

	return 0;
}
   2520a:	bf18      	it	ne
   2520c:	f06f 0004 	mvnne.w	r0, #4
   25210:	bd08      	pop	{r3, pc}

00025212 <entropy_psa_crypto_rng_init>:
{
   25212:	b508      	push	{r3, lr}
	status = psa_crypto_init();
   25214:	f000 facc 	bl	257b0 <psa_crypto_init>
		return -EIO;
   25218:	2800      	cmp	r0, #0
}
   2521a:	bf18      	it	ne
   2521c:	f06f 0004 	mvnne.w	r0, #4
   25220:	bd08      	pop	{r3, pc}

00025222 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25222:	6843      	ldr	r3, [r0, #4]
}
   25224:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25226:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   25228:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   2522a:	600b      	str	r3, [r1, #0]
}
   2522c:	4770      	bx	lr

0002522e <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2522e:	6843      	ldr	r3, [r0, #4]
	const uint32_t set_mask = value & mask;
   25230:	ea02 0001 	and.w	r0, r2, r1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25234:	685b      	ldr	r3, [r3, #4]
	const uint32_t clear_mask = (~set_mask) & mask;
   25236:	ea21 0102 	bic.w	r1, r1, r2
    p_reg->OUTSET = set_mask;
   2523a:	6098      	str	r0, [r3, #8]
}
   2523c:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   2523e:	60d9      	str	r1, [r3, #12]
   25240:	4770      	bx	lr

00025242 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25242:	6843      	ldr	r3, [r0, #4]
}
   25244:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25246:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   25248:	6099      	str	r1, [r3, #8]
}
   2524a:	4770      	bx	lr

0002524c <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2524c:	6843      	ldr	r3, [r0, #4]
}
   2524e:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25250:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   25252:	60d9      	str	r1, [r3, #12]
}
   25254:	4770      	bx	lr

00025256 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25256:	6843      	ldr	r3, [r0, #4]
   25258:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   2525a:	6853      	ldr	r3, [r2, #4]
	const uint32_t set_mask = value & mask;
   2525c:	ea21 0003 	bic.w	r0, r1, r3
	const uint32_t clear_mask = (~value) & mask;
   25260:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
   25262:	6090      	str	r0, [r2, #8]
}
   25264:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   25266:	60d3      	str	r3, [r2, #12]
   25268:	4770      	bx	lr

0002526a <gpio_nrfx_manage_callback>:
{
   2526a:	b510      	push	{r4, lr}
	return port->data;
   2526c:	6903      	ldr	r3, [r0, #16]
	return list->head;
   2526e:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   25270:	b1f8      	cbz	r0, 252b2 <gpio_nrfx_manage_callback+0x48>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   25272:	4288      	cmp	r0, r1
   25274:	d119      	bne.n	252aa <gpio_nrfx_manage_callback+0x40>
Z_GENLIST_REMOVE(slist, snode)
   25276:	689c      	ldr	r4, [r3, #8]
	return node->next;
   25278:	6808      	ldr	r0, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   2527a:	42a1      	cmp	r1, r4
	list->head = node;
   2527c:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   2527e:	d100      	bne.n	25282 <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
   25280:	6098      	str	r0, [r3, #8]
	parent->next = child;
   25282:	2000      	movs	r0, #0
   25284:	6008      	str	r0, [r1, #0]
	if (set) {
   25286:	b12a      	cbz	r2, 25294 <gpio_nrfx_manage_callback+0x2a>
	return list->head;
   25288:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   2528a:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   2528c:	689a      	ldr	r2, [r3, #8]
	list->head = node;
   2528e:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   25290:	b902      	cbnz	r2, 25294 <gpio_nrfx_manage_callback+0x2a>
	list->tail = node;
   25292:	6099      	str	r1, [r3, #8]
	return 0;
   25294:	2000      	movs	r0, #0
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   25296:	e010      	b.n	252ba <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   25298:	4281      	cmp	r1, r0
   2529a:	d106      	bne.n	252aa <gpio_nrfx_manage_callback+0x40>
	return node->next;
   2529c:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
   2529e:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   252a0:	6898      	ldr	r0, [r3, #8]
   252a2:	4281      	cmp	r1, r0
   252a4:	d1ed      	bne.n	25282 <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
   252a6:	609c      	str	r4, [r3, #8]
}
   252a8:	e7eb      	b.n	25282 <gpio_nrfx_manage_callback+0x18>
	return node->next;
   252aa:	4604      	mov	r4, r0
   252ac:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   252ae:	2800      	cmp	r0, #0
   252b0:	d1f2      	bne.n	25298 <gpio_nrfx_manage_callback+0x2e>
			if (!set) {
   252b2:	2a00      	cmp	r2, #0
   252b4:	d1e8      	bne.n	25288 <gpio_nrfx_manage_callback+0x1e>
				return -EINVAL;
   252b6:	f06f 0015 	mvn.w	r0, #21
}
   252ba:	bd10      	pop	{r4, pc}

000252bc <i2c_nrfx_twim_configure>:
	if (I2C_ADDR_10_BITS & i2c_config) {
   252bc:	07ca      	lsls	r2, r1, #31
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   252be:	6843      	ldr	r3, [r0, #4]
	if (I2C_ADDR_10_BITS & i2c_config) {
   252c0:	d416      	bmi.n	252f0 <i2c_nrfx_twim_configure+0x34>
	switch (I2C_SPEED_GET(i2c_config)) {
   252c2:	f3c1 0142 	ubfx	r1, r1, #1, #3
   252c6:	2902      	cmp	r1, #2
   252c8:	d00a      	beq.n	252e0 <i2c_nrfx_twim_configure+0x24>
   252ca:	2903      	cmp	r1, #3
   252cc:	d00c      	beq.n	252e8 <i2c_nrfx_twim_configure+0x2c>
   252ce:	2901      	cmp	r1, #1
   252d0:	d10e      	bne.n	252f0 <i2c_nrfx_twim_configure+0x34>
    p_reg->FREQUENCY = frequency;
   252d2:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   252d6:	681b      	ldr	r3, [r3, #0]
	return 0;
   252d8:	2000      	movs	r0, #0
   252da:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
   252de:	4770      	bx	lr
   252e0:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   252e4:	681b      	ldr	r3, [r3, #0]
   252e6:	e7f7      	b.n	252d8 <i2c_nrfx_twim_configure+0x1c>
   252e8:	f04f 627f 	mov.w	r2, #267386880	; 0xff00000
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   252ec:	681b      	ldr	r3, [r3, #0]
   252ee:	e7f3      	b.n	252d8 <i2c_nrfx_twim_configure+0x1c>
	switch (I2C_SPEED_GET(i2c_config)) {
   252f0:	f06f 0015 	mvn.w	r0, #21
}
   252f4:	4770      	bx	lr

000252f6 <irq_connect1>:
#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
   252f6:	2200      	movs	r2, #0
   252f8:	2101      	movs	r1, #1
   252fa:	2009      	movs	r0, #9
   252fc:	f7f9 b820 	b.w	1e340 <z_arm_irq_priority_set>

00025300 <pinctrl_apply_state.constprop.0>:
 *
 * @retval 0 If succeeded.
 * @retval -ENOENT If given state id does not exist.
 * @retval -errno Negative errno for other failures.
 */
static inline int pinctrl_apply_state(const struct pinctrl_dev_config *config,
   25300:	b513      	push	{r0, r1, r4, lr}
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
   25302:	2100      	movs	r1, #0
   25304:	aa01      	add	r2, sp, #4
static inline int pinctrl_apply_state(const struct pinctrl_dev_config *config,
   25306:	4604      	mov	r4, r0
	ret = pinctrl_lookup_state(config, id, &state);
   25308:	f000 f80a 	bl	25320 <pinctrl_lookup_state>
	if (ret < 0) {
   2530c:	2800      	cmp	r0, #0
   2530e:	db05      	blt.n	2531c <pinctrl_apply_state.constprop.0+0x1c>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
   25310:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   25312:	6822      	ldr	r2, [r4, #0]
   25314:	7919      	ldrb	r1, [r3, #4]
   25316:	6818      	ldr	r0, [r3, #0]
   25318:	f7fa fe4e 	bl	1ffb8 <pinctrl_configure_pins>
}
   2531c:	b002      	add	sp, #8
   2531e:	bd10      	pop	{r4, pc}

00025320 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
   25320:	b530      	push	{r4, r5, lr}
	*state = &config->states[0];
   25322:	6843      	ldr	r3, [r0, #4]
   25324:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
   25326:	7a05      	ldrb	r5, [r0, #8]
   25328:	6844      	ldr	r4, [r0, #4]
   2532a:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   2532e:	42a3      	cmp	r3, r4
   25330:	d302      	bcc.n	25338 <pinctrl_lookup_state+0x18>
		}

		(*state)++;
	}

	return -ENOENT;
   25332:	f06f 0001 	mvn.w	r0, #1
}
   25336:	bd30      	pop	{r4, r5, pc}
		if (id == (*state)->id) {
   25338:	795c      	ldrb	r4, [r3, #5]
   2533a:	428c      	cmp	r4, r1
   2533c:	d001      	beq.n	25342 <pinctrl_lookup_state+0x22>
		(*state)++;
   2533e:	3308      	adds	r3, #8
   25340:	e7f0      	b.n	25324 <pinctrl_lookup_state+0x4>
			return 0;
   25342:	2000      	movs	r0, #0
   25344:	e7f7      	b.n	25336 <pinctrl_lookup_state+0x16>

00025346 <regulator_common_data_init>:
 */

#include <zephyr/drivers/regulator.h>

void regulator_common_data_init(const struct device *dev)
{
   25346:	b510      	push	{r4, lr}
	struct regulator_common_data *data = dev->data;
   25348:	6904      	ldr	r4, [r0, #16]
	return z_impl_k_mutex_init(mutex);
   2534a:	4620      	mov	r0, r4
   2534c:	f000 fc45 	bl	25bda <z_impl_k_mutex_init>

	(void)k_mutex_init(&data->lock);
	data->refcnt = 0;
   25350:	2300      	movs	r3, #0
   25352:	6163      	str	r3, [r4, #20]
}
   25354:	bd10      	pop	{r4, pc}

00025356 <regulator_is_enabled>:

	return ret;
}

bool regulator_is_enabled(const struct device *dev)
{
   25356:	b538      	push	{r3, r4, r5, lr}
	const struct regulator_common_config *config = dev->config;
	struct regulator_common_data *data = dev->data;
	bool enabled;

	if ((config->flags & REGULATOR_ALWAYS_ON) != 0U) {
   25358:	6843      	ldr	r3, [r0, #4]
   2535a:	7e9b      	ldrb	r3, [r3, #26]
   2535c:	07db      	lsls	r3, r3, #31
   2535e:	d410      	bmi.n	25382 <regulator_is_enabled+0x2c>
	struct regulator_common_data *data = dev->data;
   25360:	6905      	ldr	r5, [r0, #16]
	return z_impl_k_mutex_lock(mutex, timeout);
   25362:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   25366:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2536a:	4628      	mov	r0, r5
   2536c:	f7fd fffe 	bl	2336c <z_impl_k_mutex_lock>
		enabled = true;
	} else {
		(void)k_mutex_lock(&data->lock, K_FOREVER);
		enabled = data->refcnt != 0;
   25370:	696c      	ldr	r4, [r5, #20]
   25372:	3c00      	subs	r4, #0
   25374:	bf18      	it	ne
   25376:	2401      	movne	r4, #1
	return z_impl_k_mutex_unlock(mutex);
   25378:	4628      	mov	r0, r5
   2537a:	f7fe f871 	bl	23460 <z_impl_k_mutex_unlock>
		k_mutex_unlock(&data->lock);
	}

	return enabled;
}
   2537e:	4620      	mov	r0, r4
   25380:	bd38      	pop	{r3, r4, r5, pc}
		enabled = true;
   25382:	2401      	movs	r4, #1
   25384:	e7fb      	b.n	2537e <regulator_is_enabled+0x28>

00025386 <regulator_set_voltage>:
	return false;
}

int regulator_set_voltage(const struct device *dev, int32_t min_uv,
			  int32_t max_uv)
{
   25386:	b4f0      	push	{r4, r5, r6, r7}
	const struct regulator_common_config *config = dev->config;
	const struct regulator_driver_api *api = dev->api;

	if (api->set_voltage == NULL) {
   25388:	e9d0 6301 	ldrd	r6, r3, [r0, #4]
   2538c:	691b      	ldr	r3, [r3, #16]
   2538e:	b13b      	cbz	r3, 253a0 <regulator_set_voltage+0x1a>
		return -ENOSYS;
	}

	/* voltage may not be allowed, even if supported */
	if ((min_uv > config->max_uv) || (max_uv < config->min_uv)) {
   25390:	6877      	ldr	r7, [r6, #4]
   25392:	428f      	cmp	r7, r1
   25394:	db08      	blt.n	253a8 <regulator_set_voltage+0x22>
   25396:	6835      	ldr	r5, [r6, #0]
   25398:	4295      	cmp	r5, r2
   2539a:	dc05      	bgt.n	253a8 <regulator_set_voltage+0x22>
		return -EINVAL;
	}

	return api->set_voltage(dev, min_uv, max_uv);
}
   2539c:	bcf0      	pop	{r4, r5, r6, r7}
	return api->set_voltage(dev, min_uv, max_uv);
   2539e:	4718      	bx	r3
		return -ENOSYS;
   253a0:	f06f 0057 	mvn.w	r0, #87	; 0x57
}
   253a4:	bcf0      	pop	{r4, r5, r6, r7}
   253a6:	4770      	bx	lr
		return -EINVAL;
   253a8:	f06f 0015 	mvn.w	r0, #21
   253ac:	e7fa      	b.n	253a4 <regulator_set_voltage+0x1e>

000253ae <regulator_set_mode>:

	return api->set_current_limit(dev, min_ua, max_ua);
}

int regulator_set_mode(const struct device *dev, regulator_mode_t mode)
{
   253ae:	b470      	push	{r4, r5, r6}
	const struct regulator_common_config *config = dev->config;
	const struct regulator_driver_api *api = dev->api;

	if (api->set_mode == NULL) {
   253b0:	e9d0 6201 	ldrd	r6, r2, [r0, #4]
   253b4:	6a15      	ldr	r5, [r2, #32]
{
   253b6:	4603      	mov	r3, r0
   253b8:	460c      	mov	r4, r1
	if (api->set_mode == NULL) {
   253ba:	b19d      	cbz	r5, 253e4 <regulator_set_mode+0x36>
		return -ENOSYS;
	}

	/* no mode restrictions */
	if (config->allowed_modes_cnt == 0U) {
   253bc:	7e32      	ldrb	r2, [r6, #24]
   253be:	b912      	cbnz	r2, 253c6 <regulator_set_mode+0x18>
	}

	/* check if mode is allowed, apply if it is */
	for (uint8_t i = 0U; i < config->allowed_modes_cnt; i++) {
		if (mode == config->allowed_modes[i]) {
			return api->set_mode(dev, mode);
   253c0:	462b      	mov	r3, r5
		}
	}

	return -ENOTSUP;
}
   253c2:	bc70      	pop	{r4, r5, r6}
			return api->set_mode(dev, mode);
   253c4:	4718      	bx	r3
   253c6:	6970      	ldr	r0, [r6, #20]
   253c8:	4402      	add	r2, r0
		if (mode == config->allowed_modes[i]) {
   253ca:	f810 1b01 	ldrb.w	r1, [r0], #1
   253ce:	42a1      	cmp	r1, r4
   253d0:	d102      	bne.n	253d8 <regulator_set_mode+0x2a>
			return api->set_mode(dev, mode);
   253d2:	4621      	mov	r1, r4
   253d4:	4618      	mov	r0, r3
   253d6:	e7f3      	b.n	253c0 <regulator_set_mode+0x12>
	for (uint8_t i = 0U; i < config->allowed_modes_cnt; i++) {
   253d8:	4290      	cmp	r0, r2
   253da:	d1f6      	bne.n	253ca <regulator_set_mode+0x1c>
	return -ENOTSUP;
   253dc:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   253e0:	bc70      	pop	{r4, r5, r6}
   253e2:	4770      	bx	lr
		return -ENOSYS;
   253e4:	f06f 0057 	mvn.w	r0, #87	; 0x57
   253e8:	e7fa      	b.n	253e0 <regulator_set_mode+0x32>

000253ea <regulator_common_init>:
{
   253ea:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   253ee:	460e      	mov	r6, r1
	const struct regulator_common_config *config = dev->config;
   253f0:	e9d0 8701 	ldrd	r8, r7, [r0, #4]
	if (config->initial_mode != REGULATOR_INITIAL_MODE_UNKNOWN) {
   253f4:	f898 1019 	ldrb.w	r1, [r8, #25]
{
   253f8:	4604      	mov	r4, r0
	if (config->initial_mode != REGULATOR_INITIAL_MODE_UNKNOWN) {
   253fa:	29ff      	cmp	r1, #255	; 0xff
	struct regulator_common_data *data = dev->data;
   253fc:	6905      	ldr	r5, [r0, #16]
	if (config->initial_mode != REGULATOR_INITIAL_MODE_UNKNOWN) {
   253fe:	d123      	bne.n	25448 <regulator_common_init+0x5e>
	if (config->init_uv > INT32_MIN) {
   25400:	f8d8 2008 	ldr.w	r2, [r8, #8]
   25404:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   25408:	d005      	beq.n	25416 <regulator_common_init+0x2c>
		ret = regulator_set_voltage(dev, config->init_uv, config->init_uv);
   2540a:	4611      	mov	r1, r2
   2540c:	4620      	mov	r0, r4
   2540e:	f7ff ffba 	bl	25386 <regulator_set_voltage>
		if (ret < 0) {
   25412:	2800      	cmp	r0, #0
   25414:	db1c      	blt.n	25450 <regulator_common_init+0x66>
	if ((config->min_uv > INT32_MIN) || (config->max_uv < INT32_MAX)) {
   25416:	f8d8 3000 	ldr.w	r3, [r8]
   2541a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   2541e:	d01a      	beq.n	25456 <regulator_common_init+0x6c>
					int32_t *volt_uv)
{
	const struct regulator_driver_api *api =
		(const struct regulator_driver_api *)dev->api;

	if (api->get_voltage == NULL) {
   25420:	68a3      	ldr	r3, [r4, #8]
   25422:	695b      	ldr	r3, [r3, #20]
   25424:	b38b      	cbz	r3, 2548a <regulator_common_init+0xa0>
		return -ENOSYS;
	}

	return api->get_voltage(dev, volt_uv);
   25426:	4620      	mov	r0, r4
   25428:	a901      	add	r1, sp, #4
   2542a:	4798      	blx	r3
		if (ret < 0) {
   2542c:	2800      	cmp	r0, #0
   2542e:	db0f      	blt.n	25450 <regulator_common_init+0x66>
		if (current_uv < config->min_uv) {
   25430:	f8d8 2000 	ldr.w	r2, [r8]
   25434:	9b01      	ldr	r3, [sp, #4]
   25436:	429a      	cmp	r2, r3
   25438:	dd22      	ble.n	25480 <regulator_common_init+0x96>
			ret = regulator_set_voltage(dev, config->max_uv, config->max_uv);
   2543a:	4611      	mov	r1, r2
   2543c:	4620      	mov	r0, r4
   2543e:	f7ff ffa2 	bl	25386 <regulator_set_voltage>
			if (ret < 0) {
   25442:	2800      	cmp	r0, #0
   25444:	da0d      	bge.n	25462 <regulator_common_init+0x78>
   25446:	e003      	b.n	25450 <regulator_common_init+0x66>
		ret = regulator_set_mode(dev, config->initial_mode);
   25448:	f7ff ffb1 	bl	253ae <regulator_set_mode>
		if (ret < 0) {
   2544c:	2800      	cmp	r0, #0
   2544e:	dad7      	bge.n	25400 <regulator_common_init+0x16>
}
   25450:	b002      	add	sp, #8
   25452:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((config->min_uv > INT32_MIN) || (config->max_uv < INT32_MAX)) {
   25456:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   2545a:	f8d8 2004 	ldr.w	r2, [r8, #4]
   2545e:	429a      	cmp	r2, r3
   25460:	d1de      	bne.n	25420 <regulator_common_init+0x36>
	if (is_enabled) {
   25462:	b946      	cbnz	r6, 25476 <regulator_common_init+0x8c>
	} else if ((config->flags & REGULATOR_INIT_ENABLED) != 0U) {
   25464:	f898 301a 	ldrb.w	r3, [r8, #26]
   25468:	079b      	lsls	r3, r3, #30
   2546a:	d007      	beq.n	2547c <regulator_common_init+0x92>
		ret = api->enable(dev);
   2546c:	4620      	mov	r0, r4
   2546e:	683b      	ldr	r3, [r7, #0]
   25470:	4798      	blx	r3
		if (ret < 0) {
   25472:	2800      	cmp	r0, #0
   25474:	dbec      	blt.n	25450 <regulator_common_init+0x66>
		data->refcnt++;
   25476:	696b      	ldr	r3, [r5, #20]
   25478:	3301      	adds	r3, #1
   2547a:	616b      	str	r3, [r5, #20]
	return 0;
   2547c:	2000      	movs	r0, #0
   2547e:	e7e7      	b.n	25450 <regulator_common_init+0x66>
		} else if (current_uv > config->max_uv) {
   25480:	f8d8 2004 	ldr.w	r2, [r8, #4]
   25484:	4293      	cmp	r3, r2
   25486:	ddec      	ble.n	25462 <regulator_common_init+0x78>
   25488:	e7d7      	b.n	2543a <regulator_common_init+0x50>
		return -ENOSYS;
   2548a:	f06f 0057 	mvn.w	r0, #87	; 0x57
   2548e:	e7df      	b.n	25450 <regulator_common_init+0x66>

00025490 <gpio_pin_set>:
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   25490:	2301      	movs	r3, #1
   25492:	fa03 f101 	lsl.w	r1, r3, r1
   25496:	6903      	ldr	r3, [r0, #16]
   25498:	681b      	ldr	r3, [r3, #0]
   2549a:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   2549c:	bf18      	it	ne
   2549e:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   254a2:	b112      	cbz	r2, 254aa <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   254a4:	6883      	ldr	r3, [r0, #8]
   254a6:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   254a8:	4718      	bx	r3
   254aa:	6883      	ldr	r3, [r0, #8]
   254ac:	691b      	ldr	r3, [r3, #16]
   254ae:	e7fb      	b.n	254a8 <gpio_pin_set+0x18>

000254b0 <regulator_fixed_init>:
	.enable = regulator_fixed_enable,
	.disable = regulator_fixed_disable,
};

static int regulator_fixed_init(const struct device *dev)
{
   254b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct regulator_fixed_config *cfg = dev->config;
   254b2:	6844      	ldr	r4, [r0, #4]
{
   254b4:	4605      	mov	r5, r0
	int ret;

	regulator_common_data_init(dev);
   254b6:	f7ff ff46 	bl	25346 <regulator_common_data_init>

	if (!device_is_ready(cfg->enable.port)) {
   254ba:	6a60      	ldr	r0, [r4, #36]	; 0x24
   254bc:	f000 fb0a 	bl	25ad4 <z_device_is_ready>
   254c0:	b370      	cbz	r0, 25520 <regulator_fixed_init+0x70>
	return gpio_pin_configure(spec->port,
   254c2:	6a60      	ldr	r0, [r4, #36]	; 0x24
				  spec->pin,
   254c4:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
				  spec->dt_flags | extra_flags);
   254c8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254ca:	2701      	movs	r7, #1
	struct gpio_driver_data *data =
   254cc:	f8d0 c010 	ldr.w	ip, [r0, #16]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   254d0:	07da      	lsls	r2, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254d2:	f8dc 6000 	ldr.w	r6, [ip]
	return gpio_pin_configure(spec->port,
   254d6:	bf54      	ite	pl
   254d8:	f443 13b0 	orrpl.w	r3, r3, #1441792	; 0x160000
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   254dc:	f483 13d0 	eormi.w	r3, r3, #1703936	; 0x1a0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   254e0:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254e4:	408f      	lsls	r7, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   254e6:	07db      	lsls	r3, r3, #31
	const struct gpio_driver_api *api =
   254e8:	f8d0 e008 	ldr.w	lr, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254ec:	bf4c      	ite	mi
   254ee:	433e      	orrmi	r6, r7
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   254f0:	43be      	bicpl	r6, r7
   254f2:	f8cc 6000 	str.w	r6, [ip]
	return api->pin_configure(port, pin, flags);
   254f6:	f8de 3000 	ldr.w	r3, [lr]
   254fa:	4798      	blx	r3
		LOG_ERR("GPIO port: %s not ready", cfg->enable.port->name);
		return -ENODEV;
	}

	ret = gpio_pin_configure_dt(&cfg->enable, GPIO_OUTPUT_INACTIVE);
	if (ret < 0) {
   254fc:	2800      	cmp	r0, #0
   254fe:	db0a      	blt.n	25516 <regulator_fixed_init+0x66>
		return ret;
	}

	ret = regulator_common_init(dev, false);
   25500:	2100      	movs	r1, #0
   25502:	4628      	mov	r0, r5
   25504:	f7ff ff71 	bl	253ea <regulator_common_init>
	if (ret < 0) {
   25508:	2800      	cmp	r0, #0
   2550a:	db04      	blt.n	25516 <regulator_fixed_init+0x66>
		return ret;
	}

	if (regulator_is_enabled(dev)) {
   2550c:	4628      	mov	r0, r5
   2550e:	f7ff ff22 	bl	25356 <regulator_is_enabled>
   25512:	b908      	cbnz	r0, 25518 <regulator_fixed_init+0x68>
		k_busy_wait(cfg->startup_delay_us);
	}

	return 0;
   25514:	2000      	movs	r0, #0
}
   25516:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		k_busy_wait(cfg->startup_delay_us);
   25518:	69e0      	ldr	r0, [r4, #28]
	z_impl_k_busy_wait(usec_to_wait);
   2551a:	f000 fd80 	bl	2601e <z_impl_k_busy_wait>
}
   2551e:	e7f9      	b.n	25514 <regulator_fixed_init+0x64>
		return -ENODEV;
   25520:	f06f 0012 	mvn.w	r0, #18
   25524:	e7f7      	b.n	25516 <regulator_fixed_init+0x66>

00025526 <regulator_fixed_disable>:
	const struct regulator_fixed_config *cfg = dev->config;
   25526:	6843      	ldr	r3, [r0, #4]
	return gpio_pin_set(spec->port, spec->pin, value);
   25528:	2200      	movs	r2, #0
   2552a:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
   2552e:	6a58      	ldr	r0, [r3, #36]	; 0x24
   25530:	f7ff bfae 	b.w	25490 <gpio_pin_set>

00025534 <irq_connect3>:
#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(2);
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(3);
   25534:	2200      	movs	r2, #0
   25536:	2101      	movs	r1, #1
   25538:	200c      	movs	r0, #12
   2553a:	f7f8 bf01 	b.w	1e340 <z_arm_irq_priority_set>

0002553e <irq_connect4>:
#endif

#ifdef CONFIG_SPI_4_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(4);
   2553e:	2200      	movs	r2, #0
   25540:	2101      	movs	r1, #1
   25542:	200a      	movs	r0, #10
   25544:	f7f8 befc 	b.w	1e340 <z_arm_irq_priority_set>

00025548 <spi_context_get_next_buf.constprop.0>:
static inline void *spi_context_get_next_buf(const struct spi_buf **current,
   25548:	b510      	push	{r4, lr}
	while (*count) {
   2554a:	680b      	ldr	r3, [r1, #0]
   2554c:	b913      	cbnz	r3, 25554 <spi_context_get_next_buf.constprop.0+0xc>
	return NULL;
   2554e:	4618      	mov	r0, r3
	*buf_len = 0;
   25550:	6013      	str	r3, [r2, #0]
	return NULL;
   25552:	e005      	b.n	25560 <spi_context_get_next_buf.constprop.0+0x18>
		if (((*current)->len / dfs) != 0) {
   25554:	6803      	ldr	r3, [r0, #0]
   25556:	685c      	ldr	r4, [r3, #4]
   25558:	b11c      	cbz	r4, 25562 <spi_context_get_next_buf.constprop.0+0x1a>
			*buf_len = (*current)->len / dfs;
   2555a:	6014      	str	r4, [r2, #0]
			return (*current)->buf;
   2555c:	6803      	ldr	r3, [r0, #0]
   2555e:	6818      	ldr	r0, [r3, #0]
}
   25560:	bd10      	pop	{r4, pc}
		++(*current);
   25562:	3308      	adds	r3, #8
   25564:	6003      	str	r3, [r0, #0]
		--(*count);
   25566:	680b      	ldr	r3, [r1, #0]
   25568:	3b01      	subs	r3, #1
   2556a:	600b      	str	r3, [r1, #0]
   2556c:	e7ed      	b.n	2554a <spi_context_get_next_buf.constprop.0+0x2>

0002556e <gpio_pin_set_dt.isra.0>:
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
   2556e:	4603      	mov	r3, r0
   25570:	460a      	mov	r2, r1
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   25572:	7919      	ldrb	r1, [r3, #4]
   25574:	2301      	movs	r3, #1
	return gpio_pin_set(spec->port, spec->pin, value);
   25576:	6800      	ldr	r0, [r0, #0]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   25578:	fa03 f101 	lsl.w	r1, r3, r1
   2557c:	6903      	ldr	r3, [r0, #16]
   2557e:	681b      	ldr	r3, [r3, #0]
   25580:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   25582:	bf18      	it	ne
   25584:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   25588:	b112      	cbz	r2, 25590 <gpio_pin_set_dt.isra.0+0x22>
	return api->port_set_bits_raw(port, pins);
   2558a:	6883      	ldr	r3, [r0, #8]
   2558c:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   2558e:	4718      	bx	r3
   25590:	6883      	ldr	r3, [r0, #8]
   25592:	691b      	ldr	r3, [r3, #16]
   25594:	e7fb      	b.n	2558e <gpio_pin_set_dt.isra.0+0x20>

00025596 <_spi_context_cs_control>:
{
   25596:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   25598:	6803      	ldr	r3, [r0, #0]
{
   2559a:	4604      	mov	r4, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   2559c:	b1e3      	cbz	r3, 255d8 <_spi_context_cs_control+0x42>
   2559e:	6898      	ldr	r0, [r3, #8]
   255a0:	b1d0      	cbz	r0, 255d8 <_spi_context_cs_control+0x42>
   255a2:	6805      	ldr	r5, [r0, #0]
   255a4:	b1c5      	cbz	r5, 255d8 <_spi_context_cs_control+0x42>
		if (on) {
   255a6:	b149      	cbz	r1, 255bc <_spi_context_cs_control+0x26>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 1);
   255a8:	2101      	movs	r1, #1
   255aa:	f7ff ffe0 	bl	2556e <gpio_pin_set_dt.isra.0>
			k_busy_wait(ctx->config->cs->delay);
   255ae:	6823      	ldr	r3, [r4, #0]
   255b0:	689b      	ldr	r3, [r3, #8]
   255b2:	6898      	ldr	r0, [r3, #8]
}
   255b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   255b8:	f000 bd31 	b.w	2601e <z_impl_k_busy_wait>
			if (!force_off &&
   255bc:	b912      	cbnz	r2, 255c4 <_spi_context_cs_control+0x2e>
   255be:	889b      	ldrh	r3, [r3, #4]
   255c0:	04db      	lsls	r3, r3, #19
   255c2:	d409      	bmi.n	255d8 <_spi_context_cs_control+0x42>
			k_busy_wait(ctx->config->cs->delay);
   255c4:	6880      	ldr	r0, [r0, #8]
   255c6:	f000 fd2a 	bl	2601e <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   255ca:	6823      	ldr	r3, [r4, #0]
   255cc:	2100      	movs	r1, #0
   255ce:	6898      	ldr	r0, [r3, #8]
}
   255d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   255d4:	f7ff bfcb 	b.w	2556e <gpio_pin_set_dt.isra.0>
}
   255d8:	bd38      	pop	{r3, r4, r5, pc}

000255da <spi_context_unlock_unconditionally>:
{
   255da:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   255dc:	2201      	movs	r2, #1
   255de:	2100      	movs	r1, #0
{
   255e0:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   255e2:	f7ff ffd8 	bl	25596 <_spi_context_cs_control>
	if (!k_sem_count_get(&ctx->lock)) {
   255e6:	69a3      	ldr	r3, [r4, #24]
   255e8:	b933      	cbnz	r3, 255f8 <spi_context_unlock_unconditionally+0x1e>
		ctx->owner = NULL;
   255ea:	6063      	str	r3, [r4, #4]
	z_impl_k_sem_give(sem);
   255ec:	f104 0010 	add.w	r0, r4, #16
}
   255f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   255f4:	f7fd bfa4 	b.w	23540 <z_impl_k_sem_give>
   255f8:	bd10      	pop	{r4, pc}

000255fa <spi_nrfx_release>:
{
   255fa:	b510      	push	{r4, lr}
	struct spi_nrfx_data *dev_data = dev->data;
   255fc:	6900      	ldr	r0, [r0, #16]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   255fe:	6803      	ldr	r3, [r0, #0]
   25600:	428b      	cmp	r3, r1
   25602:	d106      	bne.n	25612 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   25604:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   25608:	b934      	cbnz	r4, 25618 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   2560a:	f7ff ffe6 	bl	255da <spi_context_unlock_unconditionally>
	return 0;
   2560e:	4620      	mov	r0, r4
}
   25610:	bd10      	pop	{r4, pc}
		return -EINVAL;
   25612:	f06f 0015 	mvn.w	r0, #21
   25616:	e7fb      	b.n	25610 <spi_nrfx_release+0x16>
		return -EBUSY;
   25618:	f06f 000f 	mvn.w	r0, #15
   2561c:	e7f8      	b.n	25610 <spi_nrfx_release+0x16>

0002561e <spi_nrfx_init>:
{
   2561e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	const struct spi_nrfx_config *dev_config = dev->config;
   25622:	6844      	ldr	r4, [r0, #4]
	struct spi_nrfx_data *dev_data = dev->data;
   25624:	6905      	ldr	r5, [r0, #16]
	err = pinctrl_apply_state(dev_config->pcfg, PINCTRL_STATE_DEFAULT);
   25626:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
	ret = pinctrl_lookup_state(config, id, &state);
   25628:	2100      	movs	r1, #0
   2562a:	4630      	mov	r0, r6
   2562c:	aa01      	add	r2, sp, #4
   2562e:	f7ff fe77 	bl	25320 <pinctrl_lookup_state>
	if (ret < 0) {
   25632:	2800      	cmp	r0, #0
   25634:	db43      	blt.n	256be <spi_nrfx_init+0xa0>
	return pinctrl_apply_state_direct(config, state);
   25636:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   25638:	6832      	ldr	r2, [r6, #0]
   2563a:	7919      	ldrb	r1, [r3, #4]
   2563c:	6818      	ldr	r0, [r3, #0]
   2563e:	f7fa fcbb 	bl	1ffb8 <pinctrl_configure_pins>
	if (err < 0) {
   25642:	2800      	cmp	r0, #0
   25644:	db3b      	blt.n	256be <spi_nrfx_init+0xa0>
		data->invert |= (gpio_port_pins_t)BIT(pin);
   25646:	2601      	movs	r6, #1
	dev_config->irq_connect();
   25648:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2564a:	4798      	blx	r3
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
   2564c:	68ac      	ldr	r4, [r5, #8]
   2564e:	3408      	adds	r4, #8
   25650:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
   25654:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   25658:	f1a4 0208 	sub.w	r2, r4, #8
   2565c:	4293      	cmp	r3, r2
   2565e:	d804      	bhi.n	2566a <spi_nrfx_init+0x4c>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   25660:	4628      	mov	r0, r5
   25662:	f7ff ffba 	bl	255da <spi_context_unlock_unconditionally>
	return 0;
   25666:	2000      	movs	r0, #0
	return 0;
   25668:	e029      	b.n	256be <spi_nrfx_init+0xa0>
		if (!device_is_ready(cs_gpio->port)) {
   2566a:	f854 0c08 	ldr.w	r0, [r4, #-8]
   2566e:	f000 fa31 	bl	25ad4 <z_device_is_ready>
   25672:	b338      	cbz	r0, 256c4 <spi_nrfx_init+0xa6>
	return gpio_pin_configure(spec->port,
   25674:	f854 0c08 	ldr.w	r0, [r4, #-8]
				  spec->pin,
   25678:	f814 1c04 	ldrb.w	r1, [r4, #-4]
				  spec->dt_flags | extra_flags);
   2567c:	f834 3c02 	ldrh.w	r3, [r4, #-2]
	struct gpio_driver_data *data =
   25680:	f8d0 c010 	ldr.w	ip, [r0, #16]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   25684:	07da      	lsls	r2, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   25686:	f8dc 7000 	ldr.w	r7, [ip]
	return gpio_pin_configure(spec->port,
   2568a:	bf54      	ite	pl
   2568c:	f443 13b0 	orrpl.w	r3, r3, #1441792	; 0x160000
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   25690:	f483 13d0 	eormi.w	r3, r3, #1703936	; 0x1a0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   25694:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   25698:	fa06 fe01 	lsl.w	lr, r6, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   2569c:	07db      	lsls	r3, r3, #31
	const struct gpio_driver_api *api =
   2569e:	f8d0 8008 	ldr.w	r8, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
   256a2:	bf4c      	ite	mi
   256a4:	ea4e 0707 	orrmi.w	r7, lr, r7
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   256a8:	ea27 070e 	bicpl.w	r7, r7, lr
   256ac:	f8cc 7000 	str.w	r7, [ip]
	return api->pin_configure(port, pin, flags);
   256b0:	f8d8 3000 	ldr.w	r3, [r8]
   256b4:	4798      	blx	r3
		if (ret < 0) {
   256b6:	2800      	cmp	r0, #0
   256b8:	f104 0408 	add.w	r4, r4, #8
   256bc:	dac8      	bge.n	25650 <spi_nrfx_init+0x32>
}
   256be:	b002      	add	sp, #8
   256c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return -ENODEV;
   256c4:	f06f 0012 	mvn.w	r0, #18
	if (err < 0) {
   256c8:	e7f9      	b.n	256be <spi_nrfx_init+0xa0>

000256ca <finish_transaction.isra.0>:
	_spi_context_cs_control(ctx, on, false);
   256ca:	2200      	movs	r2, #0
static void finish_transaction(const struct device *dev, int error)
   256cc:	b538      	push	{r3, r4, r5, lr}
   256ce:	4604      	mov	r4, r0
   256d0:	460d      	mov	r5, r1
   256d2:	4611      	mov	r1, r2
   256d4:	f7ff ff5f 	bl	25596 <_spi_context_cs_control>
	ctx->sync_status = status;
   256d8:	6325      	str	r5, [r4, #48]	; 0x30
   256da:	f104 0020 	add.w	r0, r4, #32
   256de:	f7fd ff2f 	bl	23540 <z_impl_k_sem_give>
	dev_data->busy = false;
   256e2:	2300      	movs	r3, #0
   256e4:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
   256e8:	bd38      	pop	{r3, r4, r5, pc}

000256ea <event_handler>:
{
   256ea:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   256ec:	7803      	ldrb	r3, [r0, #0]
{
   256ee:	460c      	mov	r4, r1
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   256f0:	2b00      	cmp	r3, #0
   256f2:	d145      	bne.n	25780 <event_handler+0x96>
		if (dev_data->chunk_len == 0) {
   256f4:	6d8d      	ldr	r5, [r1, #88]	; 0x58
   256f6:	b93d      	cbnz	r5, 25708 <event_handler+0x1e>
			finish_transaction(dev_data->dev, -ETIMEDOUT);
   256f8:	6d4b      	ldr	r3, [r1, #84]	; 0x54
   256fa:	f06f 0173 	mvn.w	r1, #115	; 0x73
   256fe:	6918      	ldr	r0, [r3, #16]
}
   25700:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			finish_transaction(dev_data->dev, -ETIMEDOUT);
   25704:	f7ff bfe1 	b.w	256ca <finish_transaction.isra.0>
	if (!ctx->tx_len) {
   25708:	6c8b      	ldr	r3, [r1, #72]	; 0x48
   2570a:	b193      	cbz	r3, 25732 <event_handler+0x48>
	if (len > ctx->tx_len) {
   2570c:	429d      	cmp	r5, r3
   2570e:	d810      	bhi.n	25732 <event_handler+0x48>
	ctx->tx_len -= len;
   25710:	1b5b      	subs	r3, r3, r5
   25712:	648b      	str	r3, [r1, #72]	; 0x48
	if (!ctx->tx_len) {
   25714:	bb43      	cbnz	r3, 25768 <event_handler+0x7e>
		++ctx->current_tx;
   25716:	6b4b      	ldr	r3, [r1, #52]	; 0x34
			spi_context_get_next_buf(&ctx->current_tx,
   25718:	f101 0248 	add.w	r2, r1, #72	; 0x48
		++ctx->current_tx;
   2571c:	3308      	adds	r3, #8
   2571e:	634b      	str	r3, [r1, #52]	; 0x34
		--ctx->tx_count;
   25720:	6b8b      	ldr	r3, [r1, #56]	; 0x38
			spi_context_get_next_buf(&ctx->current_tx,
   25722:	f104 0034 	add.w	r0, r4, #52	; 0x34
		--ctx->tx_count;
   25726:	3b01      	subs	r3, #1
   25728:	638b      	str	r3, [r1, #56]	; 0x38
			spi_context_get_next_buf(&ctx->current_tx,
   2572a:	3138      	adds	r1, #56	; 0x38
   2572c:	f7ff ff0c 	bl	25548 <spi_context_get_next_buf.constprop.0>
		ctx->tx_buf = (const uint8_t *)
   25730:	6460      	str	r0, [r4, #68]	; 0x44
	if (!ctx->rx_len) {
   25732:	6d23      	ldr	r3, [r4, #80]	; 0x50
   25734:	b19b      	cbz	r3, 2575e <event_handler+0x74>
	if (len > ctx->rx_len) {
   25736:	429d      	cmp	r5, r3
   25738:	d811      	bhi.n	2575e <event_handler+0x74>
	ctx->rx_len -= len;
   2573a:	1b5b      	subs	r3, r3, r5
   2573c:	6523      	str	r3, [r4, #80]	; 0x50
	if (!ctx->rx_len) {
   2573e:	b9cb      	cbnz	r3, 25774 <event_handler+0x8a>
		++ctx->current_rx;
   25740:	6be3      	ldr	r3, [r4, #60]	; 0x3c
			spi_context_get_next_buf(&ctx->current_rx,
   25742:	f104 0250 	add.w	r2, r4, #80	; 0x50
		++ctx->current_rx;
   25746:	3308      	adds	r3, #8
   25748:	63e3      	str	r3, [r4, #60]	; 0x3c
		--ctx->rx_count;
   2574a:	6c23      	ldr	r3, [r4, #64]	; 0x40
			spi_context_get_next_buf(&ctx->current_rx,
   2574c:	f104 0140 	add.w	r1, r4, #64	; 0x40
		--ctx->rx_count;
   25750:	3b01      	subs	r3, #1
   25752:	6423      	str	r3, [r4, #64]	; 0x40
			spi_context_get_next_buf(&ctx->current_rx,
   25754:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   25758:	f7ff fef6 	bl	25548 <spi_context_get_next_buf.constprop.0>
		ctx->rx_buf = (uint8_t *)
   2575c:	64e0      	str	r0, [r4, #76]	; 0x4c
		transfer_next_chunk(dev_data->dev);
   2575e:	6d60      	ldr	r0, [r4, #84]	; 0x54
}
   25760:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev_data->dev);
   25764:	f7fa bcfe 	b.w	20164 <transfer_next_chunk>
	} else if (ctx->tx_buf) {
   25768:	6c4b      	ldr	r3, [r1, #68]	; 0x44
   2576a:	2b00      	cmp	r3, #0
   2576c:	d0e1      	beq.n	25732 <event_handler+0x48>
		ctx->tx_buf += dfs * len;
   2576e:	442b      	add	r3, r5
   25770:	644b      	str	r3, [r1, #68]	; 0x44
   25772:	e7de      	b.n	25732 <event_handler+0x48>
	} else if (ctx->rx_buf) {
   25774:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   25776:	2b00      	cmp	r3, #0
   25778:	d0f1      	beq.n	2575e <event_handler+0x74>
		ctx->rx_buf += dfs * len;
   2577a:	442b      	add	r3, r5
   2577c:	64e3      	str	r3, [r4, #76]	; 0x4c
   2577e:	e7ee      	b.n	2575e <event_handler+0x74>
}
   25780:	bd38      	pop	{r3, r4, r5, pc}

00025782 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   25782:	4770      	bx	lr

00025784 <event_clear>:
   25784:	2200      	movs	r2, #0
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   25786:	f100 0350 	add.w	r3, r0, #80	; 0x50
   2578a:	009b      	lsls	r3, r3, #2
   2578c:	b29b      	uxth	r3, r3
   2578e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   25792:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
   25796:	601a      	str	r2, [r3, #0]
   25798:	681b      	ldr	r3, [r3, #0]
}
   2579a:	4770      	bx	lr

0002579c <sys_clock_cycle_get_32>:
{
   2579c:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   2579e:	f7fa ff1b 	bl	205d8 <z_nrf_rtc_timer_read>
}
   257a2:	bd08      	pop	{r3, pc}

000257a4 <k_sys_fatal_error_handler>:

	LOG_PANIC();

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
		sys_arch_reboot(0);
   257a4:	2000      	movs	r0, #0
{
   257a6:	b508      	push	{r3, lr}
		sys_arch_reboot(0);
   257a8:	f7f9 f83e 	bl	1e828 <sys_arch_reboot>

000257ac <ns_interface_init>:

	__ASSERT(tfm_ns_interface_init() == TFM_SUCCESS,
		"TF-M NS interface init failed");

	return 0;
}
   257ac:	2000      	movs	r0, #0
   257ae:	4770      	bx	lr

000257b0 <psa_crypto_init>:
}
   257b0:	2000      	movs	r0, #0
   257b2:	4770      	bx	lr

000257b4 <tfm_platform_mem_read>:
#include <tfm_platform_api.h>
#include <tfm_ioctl_core_api.h>

enum tfm_platform_err_t tfm_platform_mem_read(void *destination, uint32_t addr,
					      size_t len, uint32_t *result)
{
   257b4:	b510      	push	{r4, lr}
   257b6:	b088      	sub	sp, #32
   257b8:	461c      	mov	r4, r3
	psa_invec in_vec;
	psa_outvec out_vec;
	struct tfm_read_service_args_t args;
	struct tfm_read_service_out_t out;

	in_vec.base = (const void *)&args;
   257ba:	ab05      	add	r3, sp, #20
   257bc:	9301      	str	r3, [sp, #4]
	in_vec.len = sizeof(args);
   257be:	230c      	movs	r3, #12
   257c0:	9302      	str	r3, [sp, #8]

	out_vec.base = (void *)&out;
	out_vec.len = sizeof(out);
   257c2:	2304      	movs	r3, #4

	args.destination = destination;
	args.addr = addr;
	args.len = len;
   257c4:	e9cd 1206 	strd	r1, r2, [sp, #24]
	args.destination = destination;
   257c8:	e9cd 3004 	strd	r3, r0, [sp, #16]

	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_READ_SERVICE, &in_vec,
   257cc:	eb0d 0103 	add.w	r1, sp, r3
   257d0:	aa03      	add	r2, sp, #12
   257d2:	2000      	movs	r0, #0
	out_vec.base = (void *)&out;
   257d4:	f8cd d00c 	str.w	sp, [sp, #12]
	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_READ_SERVICE, &in_vec,
   257d8:	f7fb f8c6 	bl	20968 <tfm_platform_ioctl>
				 &out_vec);

	*result = out.result;
   257dc:	9b00      	ldr	r3, [sp, #0]
   257de:	6023      	str	r3, [r4, #0]

	return ret;
}
   257e0:	b008      	add	sp, #32
   257e2:	bd10      	pop	{r4, pc}

000257e4 <tfm_platform_gpio_pin_mcu_select>:
	psa_invec in_vec;
	psa_outvec out_vec;
	struct tfm_gpio_service_args args;
	struct tfm_gpio_service_out out;

	args.type = TFM_GPIO_SERVICE_TYPE_PIN_MCU_SELECT;
   257e4:	2300      	movs	r3, #0
{
   257e6:	b510      	push	{r4, lr}
   257e8:	b088      	sub	sp, #32
	args.mcu_select.pin_number = pin_number;
   257ea:	e9cd 3005 	strd	r3, r0, [sp, #20]
	args.mcu_select.mcu = mcu;

	in_vec.base = (const void *)&args;
   257ee:	ab05      	add	r3, sp, #20
   257f0:	9301      	str	r3, [sp, #4]
	in_vec.len = sizeof(args);
   257f2:	230c      	movs	r3, #12
   257f4:	9302      	str	r3, [sp, #8]

	out_vec.base = (void *)&out;
	out_vec.len = sizeof(out);
   257f6:	2304      	movs	r3, #4
{
   257f8:	4614      	mov	r4, r2
	args.mcu_select.mcu = mcu;
   257fa:	9107      	str	r1, [sp, #28]

	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_GPIO_SERVICE, &in_vec,
   257fc:	aa03      	add	r2, sp, #12
   257fe:	eb0d 0103 	add.w	r1, sp, r3
   25802:	2001      	movs	r0, #1
	out_vec.len = sizeof(out);
   25804:	9304      	str	r3, [sp, #16]
	out_vec.base = (void *)&out;
   25806:	f8cd d00c 	str.w	sp, [sp, #12]
	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_GPIO_SERVICE, &in_vec,
   2580a:	f7fb f8ad 	bl	20968 <tfm_platform_ioctl>
				 &out_vec);

	*result = out.result;
   2580e:	9b00      	ldr	r3, [sp, #0]
   25810:	6023      	str	r3, [r4, #0]

	return ret;
#else
	return TFM_PLATFORM_ERR_NOT_SUPPORTED;
#endif
}
   25812:	b008      	add	sp, #32
   25814:	bd10      	pop	{r4, pc}

00025816 <SystemInit>:
    #if (__FPU_USED == 1)
        SCB->CPACR |= (3UL << 20) | (3UL << 22);
        __DSB();
        __ISB();
    #endif
}
   25816:	4770      	bx	lr

00025818 <nrfx_isr>:
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   25818:	4700      	bx	r0

0002581a <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   2581a:	f000 bc00 	b.w	2601e <z_impl_k_busy_wait>

0002581e <nrfx_clock_stop>:
    clock_stop(domain);
   2581e:	f7fb b93d 	b.w	20a9c <clock_stop>

00025822 <nrf_gpio_reconfigure>:
{
   25822:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   25824:	4616      	mov	r6, r2
   25826:	e9dd 4708 	ldrd	r4, r7, [sp, #32]
   2582a:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2582c:	a801      	add	r0, sp, #4
{
   2582e:	461d      	mov	r5, r3
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25830:	f7fb facc 	bl	20dcc <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   25834:	9b01      	ldr	r3, [sp, #4]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   25836:	f1b6 0c00 	subs.w	ip, r6, #0
   2583a:	bf18      	it	ne
   2583c:	f04f 0c01 	movne.w	ip, #1
   25840:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   25844:	1e0b      	subs	r3, r1, #0
   25846:	bf18      	it	ne
   25848:	2301      	movne	r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   2584a:	2d00      	cmp	r5, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   2584c:	ea43 034c 	orr.w	r3, r3, ip, lsl #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   25850:	bf14      	ite	ne
   25852:	f04f 0c0c 	movne.w	ip, #12
   25856:	f04f 0c00 	moveq.w	ip, #0
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   2585a:	2c00      	cmp	r4, #0
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   2585c:	ea43 030c 	orr.w	r3, r3, ip
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   25860:	bf14      	ite	ne
   25862:	f44f 6c70 	movne.w	ip, #3840	; 0xf00
   25866:	f04f 0c00 	moveq.w	ip, #0
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   2586a:	2f00      	cmp	r7, #0
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   2586c:	ea43 030c 	orr.w	r3, r3, ip
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   25870:	bf14      	ite	ne
   25872:	f44f 3c40 	movne.w	ip, #196608	; 0x30000
   25876:	f04f 0c00 	moveq.w	ip, #0
    uint32_t cnf = reg->PIN_CNF[pin_number];
   2587a:	f8d0 2200 	ldr.w	r2, [r0, #512]	; 0x200
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   2587e:	ea43 030c 	orr.w	r3, r3, ip
    cnf &= ~to_update;
   25882:	ea22 0303 	bic.w	r3, r2, r3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   25886:	b101      	cbz	r1, 2588a <nrf_gpio_reconfigure+0x68>
   25888:	7809      	ldrb	r1, [r1, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   2588a:	b10e      	cbz	r6, 25890 <nrf_gpio_reconfigure+0x6e>
   2588c:	7836      	ldrb	r6, [r6, #0]
   2588e:	0076      	lsls	r6, r6, #1
   25890:	4319      	orrs	r1, r3
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   25892:	b10d      	cbz	r5, 25898 <nrf_gpio_reconfigure+0x76>
   25894:	782d      	ldrb	r5, [r5, #0]
   25896:	00ad      	lsls	r5, r5, #2
   25898:	4331      	orrs	r1, r6
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   2589a:	b10c      	cbz	r4, 258a0 <nrf_gpio_reconfigure+0x7e>
   2589c:	7824      	ldrb	r4, [r4, #0]
   2589e:	0224      	lsls	r4, r4, #8
   258a0:	4329      	orrs	r1, r5
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
   258a2:	b10f      	cbz	r7, 258a8 <nrf_gpio_reconfigure+0x86>
   258a4:	783f      	ldrb	r7, [r7, #0]
   258a6:	043f      	lsls	r7, r7, #16
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   258a8:	430c      	orrs	r4, r1
   258aa:	433c      	orrs	r4, r7
    reg->PIN_CNF[pin_number] = cnf;
   258ac:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
}
   258b0:	b003      	add	sp, #12
   258b2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000258b4 <nrf_gpio_cfg_sense_set>:
{
   258b4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   258b6:	f10d 030f 	add.w	r3, sp, #15
   258ba:	9301      	str	r3, [sp, #4]
   258bc:	2300      	movs	r3, #0
{
   258be:	f88d 100f 	strb.w	r1, [sp, #15]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   258c2:	461a      	mov	r2, r3
   258c4:	4619      	mov	r1, r3
   258c6:	9300      	str	r3, [sp, #0]
   258c8:	f7ff ffab 	bl	25822 <nrf_gpio_reconfigure>
}
   258cc:	b005      	add	sp, #20
   258ce:	f85d fb04 	ldr.w	pc, [sp], #4

000258d2 <nrfx_power_clock_irq_handler>:
 * a library with nrfx is created. In such case, forcing a linker to use this
 * function instead of another one defined as weak will require additional
 * actions, and might be even impossible.
 */
void nrfx_power_clock_irq_handler(void)
{
   258d2:	b508      	push	{r3, lr}
    nrfx_power_irq_handler();
   258d4:	f7fb fe08 	bl	214e8 <nrfx_power_irq_handler>
    nrfx_clock_irq_handler();
}
   258d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_irq_handler();
   258dc:	f7fb ba20 	b.w	20d20 <nrfx_clock_irq_handler>

000258e0 <spim_pin_uninit>:
    if (pin == NRF_SPIM_PIN_NOT_CONNECTED)
   258e0:	1c43      	adds	r3, r0, #1
{
   258e2:	b507      	push	{r0, r1, r2, lr}
    if (pin == NRF_SPIM_PIN_NOT_CONNECTED)
   258e4:	d005      	beq.n	258f2 <spim_pin_uninit+0x12>
    nrf_gpio_cfg(
   258e6:	2300      	movs	r3, #0
   258e8:	2201      	movs	r2, #1
   258ea:	4619      	mov	r1, r3
   258ec:	9300      	str	r3, [sp, #0]
   258ee:	f7fb fe43 	bl	21578 <nrf_gpio_cfg.constprop.0>
}
   258f2:	b003      	add	sp, #12
   258f4:	f85d fb04 	ldr.w	pc, [sp], #4

000258f8 <set_ss_pin_state>:
    if (p_cb->use_hw_ss)
   258f8:	7f83      	ldrb	r3, [r0, #30]
   258fa:	075a      	lsls	r2, r3, #29
   258fc:	d40b      	bmi.n	25916 <set_ss_pin_state+0x1e>
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   258fe:	7fc0      	ldrb	r0, [r0, #31]
   25900:	28ff      	cmp	r0, #255	; 0xff
   25902:	d008      	beq.n	25916 <set_ss_pin_state+0x1e>
        nrf_gpio_pin_write(p_cb->ss_pin,
   25904:	079b      	lsls	r3, r3, #30
   25906:	bf58      	it	pl
   25908:	f081 0101 	eorpl.w	r1, r1, #1
    if (value == 0)
   2590c:	b909      	cbnz	r1, 25912 <set_ss_pin_state+0x1a>
        nrf_gpio_pin_clear(pin_number);
   2590e:	f7fb be23 	b.w	21558 <nrf_gpio_pin_clear>
        nrf_gpio_pin_set(pin_number);
   25912:	f7fb be51 	b.w	215b8 <nrf_gpio_pin_set>
}
   25916:	4770      	bx	lr

00025918 <finish_transfer>:
{
   25918:	b510      	push	{r4, lr}
   2591a:	4604      	mov	r4, r0
    set_ss_pin_state(p_cb, false);
   2591c:	2100      	movs	r1, #0
   2591e:	f7ff ffeb 	bl	258f8 <set_ss_pin_state>
    p_cb->transfer_in_progress = false;
   25922:	2300      	movs	r3, #0
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   25924:	4620      	mov	r0, r4
    p_cb->transfer_in_progress = false;
   25926:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   25928:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2592a:	6861      	ldr	r1, [r4, #4]
   2592c:	f850 3b08 	ldr.w	r3, [r0], #8
}
   25930:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   25934:	4718      	bx	r3

00025936 <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   25936:	7b0a      	ldrb	r2, [r1, #12]
{
   25938:	4603      	mov	r3, r0
    switch (p_cb->xfer_desc.type)
   2593a:	2a03      	cmp	r2, #3
   2593c:	d829      	bhi.n	25992 <xfer_completeness_check+0x5c>
   2593e:	e8df f002 	tbb	[pc, r2]
   25942:	2521      	.short	0x2521
   25944:	0219      	.short	0x0219
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   25946:	688a      	ldr	r2, [r1, #8]
   25948:	0350      	lsls	r0, r2, #13
   2594a:	d504      	bpl.n	25956 <xfer_completeness_check+0x20>
    return p_reg->TXD.AMOUNT;
   2594c:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
   25950:	6908      	ldr	r0, [r1, #16]
   25952:	4290      	cmp	r0, r2
   25954:	d107      	bne.n	25966 <xfer_completeness_check+0x30>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   25956:	688a      	ldr	r2, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   25958:	0352      	lsls	r2, r2, #13
   2595a:	d41a      	bmi.n	25992 <xfer_completeness_check+0x5c>
   2595c:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   25960:	6949      	ldr	r1, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   25962:	4291      	cmp	r1, r2
   25964:	d015      	beq.n	25992 <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   25966:	2000      	movs	r0, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   25968:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   2596a:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   2596e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   25972:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   25974:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   25978:	6908      	ldr	r0, [r1, #16]
   2597a:	4290      	cmp	r0, r2
   2597c:	d1f3      	bne.n	25966 <xfer_completeness_check+0x30>
    return p_reg->RXD.AMOUNT;
   2597e:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   25982:	e7ed      	b.n	25960 <xfer_completeness_check+0x2a>
    return p_reg->TXD.AMOUNT;
   25984:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   25988:	6909      	ldr	r1, [r1, #16]
   2598a:	e7ea      	b.n	25962 <xfer_completeness_check+0x2c>
    return p_reg->RXD.AMOUNT;
   2598c:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   25990:	e7fa      	b.n	25988 <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   25992:	2001      	movs	r0, #1
}
   25994:	4770      	bx	lr

00025996 <nrfx_usbd_consumer>:
{
   25996:	b530      	push	{r4, r5, lr}
    size_t size = p_transfer->size;
   25998:	684c      	ldr	r4, [r1, #4]
    if (size < data_size)
   2599a:	429c      	cmp	r4, r3
   2599c:	d209      	bcs.n	259b2 <nrfx_usbd_consumer+0x1c>
        p_next->size = 0;
   2599e:	2500      	movs	r5, #0
   259a0:	6045      	str	r5, [r0, #4]
        p_next->p_data = p_transfer->p_data;
   259a2:	6809      	ldr	r1, [r1, #0]
   259a4:	6001      	str	r1, [r0, #0]
    return (ep_size == data_size) && (size != 0);
   259a6:	429a      	cmp	r2, r3
   259a8:	d10c      	bne.n	259c4 <nrfx_usbd_consumer+0x2e>
   259aa:	1e20      	subs	r0, r4, #0
   259ac:	bf18      	it	ne
   259ae:	2001      	movne	r0, #1
}
   259b0:	bd30      	pop	{r4, r5, pc}
        p_next->size = data_size;
   259b2:	6043      	str	r3, [r0, #4]
        p_next->p_data = p_transfer->p_data;
   259b4:	680d      	ldr	r5, [r1, #0]
        size -= data_size;
   259b6:	1ae4      	subs	r4, r4, r3
        p_next->p_data = p_transfer->p_data;
   259b8:	6005      	str	r5, [r0, #0]
        p_transfer->p_data.addr += data_size;
   259ba:	6808      	ldr	r0, [r1, #0]
        p_transfer->size = size;
   259bc:	604c      	str	r4, [r1, #4]
        p_transfer->p_data.addr += data_size;
   259be:	4418      	add	r0, r3
   259c0:	6008      	str	r0, [r1, #0]
   259c2:	e7f0      	b.n	259a6 <nrfx_usbd_consumer+0x10>
    return (ep_size == data_size) && (size != 0);
   259c4:	2000      	movs	r0, #0
   259c6:	e7f3      	b.n	259b0 <nrfx_usbd_consumer+0x1a>

000259c8 <nrfx_usbd_feeder_ram>:
    if (tx_size > ep_size)
   259c8:	684b      	ldr	r3, [r1, #4]
   259ca:	429a      	cmp	r2, r3
   259cc:	bf28      	it	cs
   259ce:	461a      	movcs	r2, r3
    p_next->p_data = p_transfer->p_data;
   259d0:	680b      	ldr	r3, [r1, #0]
    p_next->size = tx_size;
   259d2:	e9c0 3200 	strd	r3, r2, [r0]
    p_transfer->size -= tx_size;
   259d6:	6848      	ldr	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   259d8:	680b      	ldr	r3, [r1, #0]
    p_transfer->size -= tx_size;
   259da:	1a80      	subs	r0, r0, r2
   259dc:	6048      	str	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   259de:	4413      	add	r3, r2
}
   259e0:	3800      	subs	r0, #0
   259e2:	bf18      	it	ne
   259e4:	2001      	movne	r0, #1
    p_transfer->p_data.addr += tx_size;
   259e6:	600b      	str	r3, [r1, #0]
}
   259e8:	4770      	bx	lr

000259ea <nrfx_usbd_feeder_ram_zlp>:
    if (tx_size > ep_size)
   259ea:	684b      	ldr	r3, [r1, #4]
   259ec:	429a      	cmp	r2, r3
   259ee:	bf28      	it	cs
   259f0:	461a      	movcs	r2, r3
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
   259f2:	b16a      	cbz	r2, 25a10 <nrfx_usbd_feeder_ram_zlp+0x26>
   259f4:	680b      	ldr	r3, [r1, #0]
    p_next->size = tx_size;
   259f6:	e9c0 3200 	strd	r3, r2, [r0]
    p_transfer->size -= tx_size;
   259fa:	684b      	ldr	r3, [r1, #4]
}
   259fc:	1e10      	subs	r0, r2, #0
    p_transfer->size -= tx_size;
   259fe:	eba3 0302 	sub.w	r3, r3, r2
   25a02:	604b      	str	r3, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   25a04:	680b      	ldr	r3, [r1, #0]
}
   25a06:	bf18      	it	ne
   25a08:	2001      	movne	r0, #1
    p_transfer->p_data.addr += tx_size;
   25a0a:	4413      	add	r3, r2
   25a0c:	600b      	str	r3, [r1, #0]
}
   25a0e:	4770      	bx	lr
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
   25a10:	4613      	mov	r3, r2
   25a12:	e7f0      	b.n	259f6 <nrfx_usbd_feeder_ram_zlp+0xc>

00025a14 <ep2bit>:
    return NRFX_USBD_EP_BITPOS(ep);
   25a14:	43c3      	mvns	r3, r0
   25a16:	f000 000f 	and.w	r0, r0, #15
   25a1a:	f3c3 13c0 	ubfx	r3, r3, #7, #1
}
   25a1e:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   25a22:	4770      	bx	lr

00025a24 <ev_started_handler>:
}
   25a24:	4770      	bx	lr

00025a26 <ev_dma_epin7_handler>:
static void ev_dma_epin7_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN7 ); }
   25a26:	2087      	movs	r0, #135	; 0x87
   25a28:	f7fc bbe2 	b.w	221f0 <nrf_usbd_epin_dma_handler>

00025a2c <ev_dma_epin6_handler>:
static void ev_dma_epin6_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN6 ); }
   25a2c:	2086      	movs	r0, #134	; 0x86
   25a2e:	f7fc bbdf 	b.w	221f0 <nrf_usbd_epin_dma_handler>

00025a32 <ev_dma_epin5_handler>:
static void ev_dma_epin5_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN5 ); }
   25a32:	2085      	movs	r0, #133	; 0x85
   25a34:	f7fc bbdc 	b.w	221f0 <nrf_usbd_epin_dma_handler>

00025a38 <ev_dma_epin4_handler>:
static void ev_dma_epin4_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN4 ); }
   25a38:	2084      	movs	r0, #132	; 0x84
   25a3a:	f7fc bbd9 	b.w	221f0 <nrf_usbd_epin_dma_handler>

00025a3e <ev_dma_epin3_handler>:
static void ev_dma_epin3_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN3 ); }
   25a3e:	2083      	movs	r0, #131	; 0x83
   25a40:	f7fc bbd6 	b.w	221f0 <nrf_usbd_epin_dma_handler>

00025a44 <ev_dma_epin2_handler>:
static void ev_dma_epin2_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN2 ); }
   25a44:	2082      	movs	r0, #130	; 0x82
   25a46:	f7fc bbd3 	b.w	221f0 <nrf_usbd_epin_dma_handler>

00025a4a <ev_dma_epin1_handler>:
static void ev_dma_epin1_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN1 ); }
   25a4a:	2081      	movs	r0, #129	; 0x81
   25a4c:	f7fc bbd0 	b.w	221f0 <nrf_usbd_epin_dma_handler>

00025a50 <ev_dma_epin0_handler>:
static void ev_dma_epin0_handler(void)  { nrf_usbd_ep0in_dma_handler(); }
   25a50:	f7fc bbea 	b.w	22228 <nrf_usbd_ep0in_dma_handler>

00025a54 <nrfx_usbd_ep_max_packet_size_set>:
{
   25a54:	b508      	push	{r3, lr}
    usbd_ep_state_t * p_state = ep_state_access(ep);
   25a56:	f7fc fb03 	bl	22060 <ep_state_access>
    p_state->max_packet_size = size;
   25a5a:	8181      	strh	r1, [r0, #12]
}
   25a5c:	bd08      	pop	{r3, pc}

00025a5e <nrfx_usbd_ep_status_get>:
{
   25a5e:	b508      	push	{r3, lr}
    usbd_ep_state_t const * p_state = ep_state_access(ep);
   25a60:	f7fc fafe 	bl	22060 <ep_state_access>
	__asm__ volatile(
   25a64:	f04f 0220 	mov.w	r2, #32
   25a68:	f3ef 8311 	mrs	r3, BASEPRI
   25a6c:	f382 8812 	msr	BASEPRI_MAX, r2
   25a70:	f3bf 8f6f 	isb	sy
    *p_size = p_state->transfer_cnt;
   25a74:	6882      	ldr	r2, [r0, #8]
   25a76:	600a      	str	r2, [r1, #0]
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   25a78:	6802      	ldr	r2, [r0, #0]
   25a7a:	b92a      	cbnz	r2, 25a88 <nrfx_usbd_ep_status_get+0x2a>
   25a7c:	7b80      	ldrb	r0, [r0, #14]
	__asm__ volatile(
   25a7e:	f383 8811 	msr	BASEPRI, r3
   25a82:	f3bf 8f6f 	isb	sy
}
   25a86:	bd08      	pop	{r3, pc}
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   25a88:	2004      	movs	r0, #4
   25a8a:	e7f8      	b.n	25a7e <nrfx_usbd_ep_status_get+0x20>

00025a8c <ev_dma_epout7_handler>:
static void ev_dma_epout7_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT7); }
   25a8c:	2007      	movs	r0, #7
   25a8e:	f7fc bec5 	b.w	2281c <nrf_usbd_epout_dma_handler>

00025a92 <ev_dma_epout6_handler>:
static void ev_dma_epout6_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT6); }
   25a92:	2006      	movs	r0, #6
   25a94:	f7fc bec2 	b.w	2281c <nrf_usbd_epout_dma_handler>

00025a98 <ev_dma_epout5_handler>:
static void ev_dma_epout5_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT5); }
   25a98:	2005      	movs	r0, #5
   25a9a:	f7fc bebf 	b.w	2281c <nrf_usbd_epout_dma_handler>

00025a9e <ev_dma_epout4_handler>:
static void ev_dma_epout4_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT4); }
   25a9e:	2004      	movs	r0, #4
   25aa0:	f7fc bebc 	b.w	2281c <nrf_usbd_epout_dma_handler>

00025aa4 <ev_dma_epout3_handler>:
static void ev_dma_epout3_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT3); }
   25aa4:	2003      	movs	r0, #3
   25aa6:	f7fc beb9 	b.w	2281c <nrf_usbd_epout_dma_handler>

00025aaa <ev_dma_epout2_handler>:
static void ev_dma_epout2_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT2); }
   25aaa:	2002      	movs	r0, #2
   25aac:	f7fc beb6 	b.w	2281c <nrf_usbd_epout_dma_handler>

00025ab0 <ev_dma_epout1_handler>:
static void ev_dma_epout1_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT1); }
   25ab0:	2001      	movs	r0, #1
   25ab2:	f7fc beb3 	b.w	2281c <nrf_usbd_epout_dma_handler>

00025ab6 <nrfx_usbd_ep_abort>:
    usbd_ep_abort(ep);
   25ab6:	f7fc bfad 	b.w	22a14 <usbd_ep_abort>

00025aba <nrf_gpio_pin_set>:
{
   25aba:	b507      	push	{r0, r1, r2, lr}
   25abc:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25abe:	a801      	add	r0, sp, #4
   25ac0:	f7fd f9da 	bl	22e78 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25ac4:	2301      	movs	r3, #1
   25ac6:	9a01      	ldr	r2, [sp, #4]
   25ac8:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
   25aca:	6083      	str	r3, [r0, #8]
}
   25acc:	b003      	add	sp, #12
   25ace:	f85d fb04 	ldr.w	pc, [sp], #4

00025ad2 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
   25ad2:	4770      	bx	lr

00025ad4 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   25ad4:	b140      	cbz	r0, 25ae8 <z_device_is_ready+0x14>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   25ad6:	68c3      	ldr	r3, [r0, #12]
   25ad8:	7858      	ldrb	r0, [r3, #1]
   25ada:	f010 0001 	ands.w	r0, r0, #1
   25ade:	bf1e      	ittt	ne
   25ae0:	7818      	ldrbne	r0, [r3, #0]
   25ae2:	fab0 f080 	clzne	r0, r0
   25ae6:	0940      	lsrne	r0, r0, #5
}
   25ae8:	4770      	bx	lr

00025aea <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   25aea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25aec:	4605      	mov	r5, r0
   25aee:	460e      	mov	r6, r1
	__asm__ volatile(
   25af0:	f04f 0320 	mov.w	r3, #32
   25af4:	f3ef 8711 	mrs	r7, BASEPRI
   25af8:	f383 8812 	msr	BASEPRI_MAX, r3
   25afc:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   25b00:	f7fe f9d2 	bl	23ea8 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
   25b04:	4631      	mov	r1, r6
   25b06:	4604      	mov	r4, r0
   25b08:	4628      	mov	r0, r5
   25b0a:	f7ff fe4b 	bl	257a4 <k_sys_fatal_error_handler>
	__asm__ volatile(
   25b0e:	f387 8811 	msr	BASEPRI, r7
   25b12:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   25b16:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   25b18:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   25b1c:	f7f8 bece 	b.w	1e8bc <z_impl_k_thread_abort>

00025b20 <z_early_memset>:
	(void) memset(dst, c, n);
   25b20:	f7ff ba6a 	b.w	24ff8 <memset>

00025b24 <z_early_memcpy>:
	(void) memcpy(dst, src, n);
   25b24:	f7ff ba5d 	b.w	24fe2 <memcpy>

00025b28 <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   25b28:	e9d0 3203 	ldrd	r3, r2, [r0, #12]
   25b2c:	4313      	orrs	r3, r2
   25b2e:	f013 0303 	ands.w	r3, r3, #3
   25b32:	d10c      	bne.n	25b4e <create_free_list+0x26>
	slab->free_list = NULL;
   25b34:	6143      	str	r3, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   25b36:	6881      	ldr	r1, [r0, #8]
   25b38:	4299      	cmp	r1, r3
   25b3a:	d801      	bhi.n	25b40 <create_free_list+0x18>
	return 0;
   25b3c:	2000      	movs	r0, #0
   25b3e:	4770      	bx	lr
		*(char **)p = slab->free_list;
   25b40:	6941      	ldr	r1, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   25b42:	3301      	adds	r3, #1
		*(char **)p = slab->free_list;
   25b44:	6011      	str	r1, [r2, #0]
		p += slab->block_size;
   25b46:	68c1      	ldr	r1, [r0, #12]
		slab->free_list = p;
   25b48:	6142      	str	r2, [r0, #20]
		p += slab->block_size;
   25b4a:	440a      	add	r2, r1
	for (j = 0U; j < slab->num_blocks; j++) {
   25b4c:	e7f3      	b.n	25b36 <create_free_list+0xe>
		return -EINVAL;
   25b4e:	f06f 0015 	mvn.w	r0, #21
}
   25b52:	4770      	bx	lr

00025b54 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   25b54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25b56:	4604      	mov	r4, r0
   25b58:	460d      	mov	r5, r1
	__asm__ volatile(
   25b5a:	f04f 0320 	mov.w	r3, #32
   25b5e:	f3ef 8611 	mrs	r6, BASEPRI
   25b62:	f383 8812 	msr	BASEPRI_MAX, r3
   25b66:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   25b6a:	6947      	ldr	r7, [r0, #20]
   25b6c:	b977      	cbnz	r7, 25b8c <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   25b6e:	f000 f9ad 	bl	25ecc <z_unpend_first_thread>

		if (pending_thread != NULL) {
   25b72:	b158      	cbz	r0, 25b8c <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   25b74:	682a      	ldr	r2, [r5, #0]
   25b76:	6787      	str	r7, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   25b78:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   25b7a:	f000 f95f 	bl	25e3c <z_ready_thread>
			z_reschedule(&slab->lock, key);
   25b7e:	4631      	mov	r1, r6
   25b80:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   25b84:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   25b88:	f7fe b83e 	b.w	23c08 <z_reschedule>
	**(char ***) mem = slab->free_list;
   25b8c:	682b      	ldr	r3, [r5, #0]
   25b8e:	6962      	ldr	r2, [r4, #20]
   25b90:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   25b92:	682b      	ldr	r3, [r5, #0]
   25b94:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   25b96:	69a3      	ldr	r3, [r4, #24]
   25b98:	3b01      	subs	r3, #1
   25b9a:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   25b9c:	f386 8811 	msr	BASEPRI, r6
   25ba0:	f3bf 8f6f 	isb	sy
}
   25ba4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00025ba6 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   25ba6:	f3ef 8005 	mrs	r0, IPSR
}
   25baa:	3800      	subs	r0, #0
   25bac:	bf18      	it	ne
   25bae:	2001      	movne	r0, #1
   25bb0:	4770      	bx	lr

00025bb2 <z_impl_k_thread_name_set>:
}
   25bb2:	f06f 0057 	mvn.w	r0, #87	; 0x57
   25bb6:	4770      	bx	lr

00025bb8 <z_impl_k_thread_start>:
	z_sched_start(thread);
   25bb8:	f7fe b838 	b.w	23c2c <z_sched_start>

00025bbc <z_pm_save_idle_exit>:
{
   25bbc:	b508      	push	{r3, lr}
	pm_system_resume();
   25bbe:	f7f7 f9d1 	bl	1cf64 <pm_system_resume>
}
   25bc2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   25bc6:	f7ff bddc 	b.w	25782 <sys_clock_idle_exit>

00025bca <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
   25bca:	f990 300e 	ldrsb.w	r3, [r0, #14]
   25bce:	428b      	cmp	r3, r1
   25bd0:	d001      	beq.n	25bd6 <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
   25bd2:	f7fd bfd3 	b.w	23b7c <z_set_prio>
}
   25bd6:	2000      	movs	r0, #0
   25bd8:	4770      	bx	lr

00025bda <z_impl_k_mutex_init>:
{
   25bda:	4603      	mov	r3, r0
	mutex->owner = NULL;
   25bdc:	2000      	movs	r0, #0
	list->tail = (sys_dnode_t *)list;
   25bde:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   25be2:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   25be6:	4770      	bx	lr

00025be8 <queue_insert>:
{
   25be8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   25bec:	4699      	mov	r9, r3
   25bee:	4604      	mov	r4, r0
   25bf0:	460d      	mov	r5, r1
   25bf2:	4690      	mov	r8, r2
   25bf4:	f89d 3020 	ldrb.w	r3, [sp, #32]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   25bf8:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   25bfc:	f04f 0220 	mov.w	r2, #32
   25c00:	f3ef 8711 	mrs	r7, BASEPRI
   25c04:	f382 8812 	msr	BASEPRI_MAX, r2
   25c08:	f3bf 8f6f 	isb	sy
	if (is_append) {
   25c0c:	b103      	cbz	r3, 25c10 <queue_insert+0x28>
	return list->tail;
   25c0e:	6845      	ldr	r5, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   25c10:	4630      	mov	r0, r6
   25c12:	f000 f95b 	bl	25ecc <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   25c16:	b158      	cbz	r0, 25c30 <queue_insert+0x48>
   25c18:	2300      	movs	r3, #0
   25c1a:	f8c0 8014 	str.w	r8, [r0, #20]
   25c1e:	6783      	str	r3, [r0, #120]	; 0x78
	z_ready_thread(thread);
   25c20:	f000 f90c 	bl	25e3c <z_ready_thread>
	z_reschedule(&queue->lock, key);
   25c24:	4630      	mov	r0, r6
   25c26:	4639      	mov	r1, r7
   25c28:	f7fd ffee 	bl	23c08 <z_reschedule>
		return 0;
   25c2c:	2000      	movs	r0, #0
   25c2e:	e00c      	b.n	25c4a <queue_insert+0x62>
	if (alloc) {
   25c30:	f1b9 0f00 	cmp.w	r9, #0
   25c34:	d01c      	beq.n	25c70 <queue_insert+0x88>
	return z_thread_aligned_alloc(0, size);
   25c36:	2108      	movs	r1, #8
   25c38:	f7fe fbaa 	bl	24390 <z_thread_aligned_alloc>
		if (anode == NULL) {
   25c3c:	b938      	cbnz	r0, 25c4e <queue_insert+0x66>
	__asm__ volatile(
   25c3e:	f387 8811 	msr	BASEPRI, r7
   25c42:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   25c46:	f06f 000b 	mvn.w	r0, #11
}
   25c4a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   25c4e:	2201      	movs	r2, #1
		anode->data = data;
   25c50:	f8c0 8004 	str.w	r8, [r0, #4]
   25c54:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25c56:	6801      	ldr	r1, [r0, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c58:	f001 0103 	and.w	r1, r1, #3
Z_GENLIST_INSERT(sflist, sfnode)
   25c5c:	b965      	cbnz	r5, 25c78 <queue_insert+0x90>
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c5e:	6822      	ldr	r2, [r4, #0]
   25c60:	430a      	orrs	r2, r1
   25c62:	6002      	str	r2, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   25c64:	6862      	ldr	r2, [r4, #4]
	list->head = node;
   25c66:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   25c68:	2a00      	cmp	r2, #0
   25c6a:	d1db      	bne.n	25c24 <queue_insert+0x3c>
	list->tail = node;
   25c6c:	6060      	str	r0, [r4, #4]
}
   25c6e:	e7d9      	b.n	25c24 <queue_insert+0x3c>
}
   25c70:	4640      	mov	r0, r8
	node->next_and_flags = flags;
   25c72:	f8c8 9000 	str.w	r9, [r8]
}
   25c76:	e7ee      	b.n	25c56 <queue_insert+0x6e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   25c78:	682a      	ldr	r2, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   25c7a:	2a03      	cmp	r2, #3
   25c7c:	d80b      	bhi.n	25c96 <queue_insert+0xae>
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c7e:	6001      	str	r1, [r0, #0]
	return list->tail;
   25c80:	6861      	ldr	r1, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   25c82:	b911      	cbnz	r1, 25c8a <queue_insert+0xa2>
	list->head = node;
   25c84:	e9c4 0000 	strd	r0, r0, [r4]
}
   25c88:	e7cc      	b.n	25c24 <queue_insert+0x3c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25c8a:	680a      	ldr	r2, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c8c:	f002 0203 	and.w	r2, r2, #3
   25c90:	4302      	orrs	r2, r0
   25c92:	600a      	str	r2, [r1, #0]
   25c94:	e7ea      	b.n	25c6c <queue_insert+0x84>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   25c96:	f022 0203 	bic.w	r2, r2, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c9a:	430a      	orrs	r2, r1
   25c9c:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25c9e:	682a      	ldr	r2, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   25ca0:	f002 0203 	and.w	r2, r2, #3
   25ca4:	ea40 0302 	orr.w	r3, r0, r2
   25ca8:	602b      	str	r3, [r5, #0]
}
   25caa:	e7bb      	b.n	25c24 <queue_insert+0x3c>

00025cac <z_queue_node_peek>:
{
   25cac:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   25cae:	4604      	mov	r4, r0
   25cb0:	b130      	cbz	r0, 25cc0 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25cb2:	6802      	ldr	r2, [r0, #0]
   25cb4:	0793      	lsls	r3, r2, #30
   25cb6:	d003      	beq.n	25cc0 <z_queue_node_peek+0x14>
		ret = anode->data;
   25cb8:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   25cba:	b109      	cbz	r1, 25cc0 <z_queue_node_peek+0x14>
			k_free(anode);
   25cbc:	f000 f9d5 	bl	2606a <k_free>
}
   25cc0:	4620      	mov	r0, r4
   25cc2:	bd10      	pop	{r4, pc}

00025cc4 <k_queue_append>:
	(void)queue_insert(queue, NULL, data, false, true);
   25cc4:	2301      	movs	r3, #1
{
   25cc6:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
   25cc8:	9300      	str	r3, [sp, #0]
   25cca:	2300      	movs	r3, #0
{
   25ccc:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
   25cce:	4619      	mov	r1, r3
   25cd0:	f7ff ff8a 	bl	25be8 <queue_insert>
}
   25cd4:	b003      	add	sp, #12
   25cd6:	f85d fb04 	ldr.w	pc, [sp], #4

00025cda <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   25cda:	b13a      	cbz	r2, 25cec <z_impl_k_sem_init+0x12>
   25cdc:	428a      	cmp	r2, r1
   25cde:	d305      	bcc.n	25cec <z_impl_k_sem_init+0x12>
	sem->limit = limit;
   25ce0:	e9c0 1202 	strd	r1, r2, [r0, #8]
   25ce4:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
   25ce8:	2000      	movs	r0, #0
   25cea:	4770      	bx	lr
		return -EINVAL;
   25cec:	f06f 0015 	mvn.w	r0, #21
}
   25cf0:	4770      	bx	lr

00025cf2 <flag_test_and_clear>:
	*flagp &= ~BIT(bit);
   25cf2:	2301      	movs	r3, #1
	return (*flagp & BIT(bit)) != 0U;
   25cf4:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
   25cf6:	408b      	lsls	r3, r1
   25cf8:	ea22 0303 	bic.w	r3, r2, r3
   25cfc:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
   25cfe:	fa22 f001 	lsr.w	r0, r2, r1
}
   25d02:	f000 0001 	and.w	r0, r0, #1
   25d06:	4770      	bx	lr

00025d08 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
   25d08:	b120      	cbz	r0, 25d14 <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
   25d0a:	2200      	movs	r2, #0
   25d0c:	3088      	adds	r0, #136	; 0x88
   25d0e:	4611      	mov	r1, r2
   25d10:	f000 b936 	b.w	25f80 <z_sched_wake>
}
   25d14:	4770      	bx	lr

00025d16 <work_timeout>:
{
   25d16:	b573      	push	{r0, r1, r4, r5, r6, lr}
   25d18:	4604      	mov	r4, r0
	__asm__ volatile(
   25d1a:	f04f 0320 	mov.w	r3, #32
   25d1e:	f3ef 8511 	mrs	r5, BASEPRI
   25d22:	f383 8812 	msr	BASEPRI_MAX, r3
   25d26:	f3bf 8f6f 	isb	sy
	struct k_work_q *queue = NULL;
   25d2a:	2300      	movs	r3, #0
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   25d2c:	f1a0 0610 	sub.w	r6, r0, #16
   25d30:	2103      	movs	r1, #3
   25d32:	3804      	subs	r0, #4
	struct k_work_q *queue = NULL;
   25d34:	9301      	str	r3, [sp, #4]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   25d36:	f7ff ffdc 	bl	25cf2 <flag_test_and_clear>
   25d3a:	b128      	cbz	r0, 25d48 <work_timeout+0x32>
		queue = dw->queue;
   25d3c:	69a3      	ldr	r3, [r4, #24]
		(void)submit_to_queue_locked(wp, &queue);
   25d3e:	4630      	mov	r0, r6
   25d40:	a901      	add	r1, sp, #4
		queue = dw->queue;
   25d42:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
   25d44:	f7fd fcfe 	bl	23744 <submit_to_queue_locked>
	__asm__ volatile(
   25d48:	f385 8811 	msr	BASEPRI, r5
   25d4c:	f3bf 8f6f 	isb	sy
}
   25d50:	b002      	add	sp, #8
   25d52:	bd70      	pop	{r4, r5, r6, pc}

00025d54 <k_work_init>:
{
   25d54:	b538      	push	{r3, r4, r5, lr}
   25d56:	4604      	mov	r4, r0
   25d58:	460d      	mov	r5, r1
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   25d5a:	2210      	movs	r2, #16
   25d5c:	2100      	movs	r1, #0
   25d5e:	f7ff f94b 	bl	24ff8 <memset>
   25d62:	6065      	str	r5, [r4, #4]
}
   25d64:	bd38      	pop	{r3, r4, r5, pc}

00025d66 <z_work_submit_to_queue>:
{
   25d66:	b513      	push	{r0, r1, r4, lr}
   25d68:	9001      	str	r0, [sp, #4]
   25d6a:	4608      	mov	r0, r1
	__asm__ volatile(
   25d6c:	f04f 0320 	mov.w	r3, #32
   25d70:	f3ef 8411 	mrs	r4, BASEPRI
   25d74:	f383 8812 	msr	BASEPRI_MAX, r3
   25d78:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
   25d7c:	a901      	add	r1, sp, #4
   25d7e:	f7fd fce1 	bl	23744 <submit_to_queue_locked>
	__asm__ volatile(
   25d82:	f384 8811 	msr	BASEPRI, r4
   25d86:	f3bf 8f6f 	isb	sy
}
   25d8a:	b002      	add	sp, #8
   25d8c:	bd10      	pop	{r4, pc}

00025d8e <k_work_submit_to_queue>:
{
   25d8e:	b510      	push	{r4, lr}
	int ret = z_work_submit_to_queue(queue, work);
   25d90:	f7ff ffe9 	bl	25d66 <z_work_submit_to_queue>
	if (ret > 0) {
   25d94:	1e04      	subs	r4, r0, #0
   25d96:	dd09      	ble.n	25dac <k_work_submit_to_queue+0x1e>
	__asm__ volatile(
   25d98:	f04f 0320 	mov.w	r3, #32
   25d9c:	f3ef 8011 	mrs	r0, BASEPRI
   25da0:	f383 8812 	msr	BASEPRI_MAX, r3
   25da4:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   25da8:	f000 f8c4 	bl	25f34 <z_reschedule_irqlock>
}
   25dac:	4620      	mov	r0, r4
   25dae:	bd10      	pop	{r4, pc}

00025db0 <k_work_init_delayable>:
{
   25db0:	b538      	push	{r3, r4, r5, lr}
	*dwork = (struct k_work_delayable){
   25db2:	2230      	movs	r2, #48	; 0x30
{
   25db4:	460d      	mov	r5, r1
	*dwork = (struct k_work_delayable){
   25db6:	2100      	movs	r1, #0
{
   25db8:	4604      	mov	r4, r0
	*dwork = (struct k_work_delayable){
   25dba:	f7ff f91d 	bl	24ff8 <memset>
   25dbe:	f44f 7380 	mov.w	r3, #256	; 0x100
   25dc2:	6065      	str	r5, [r4, #4]
   25dc4:	60e3      	str	r3, [r4, #12]
}
   25dc6:	bd38      	pop	{r3, r4, r5, pc}

00025dc8 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   25dc8:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   25dcc:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   25dce:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   25dd0:	2300      	movs	r3, #0
	node->prev = NULL;
   25dd2:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
   25dd6:	4770      	bx	lr

00025dd8 <unpend_thread_no_timeout>:
{
   25dd8:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   25dda:	f7ff fff5 	bl	25dc8 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   25dde:	7b43      	ldrb	r3, [r0, #13]
   25de0:	f023 0302 	bic.w	r3, r3, #2
   25de4:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   25de6:	2300      	movs	r3, #0
   25de8:	6083      	str	r3, [r0, #8]
}
   25dea:	bd08      	pop	{r3, pc}

00025dec <add_to_waitq_locked>:
{
   25dec:	b538      	push	{r3, r4, r5, lr}
   25dee:	4604      	mov	r4, r0
   25df0:	460d      	mov	r5, r1
	unready_thread(thread);
   25df2:	f7fd fe45 	bl	23a80 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   25df6:	7b63      	ldrb	r3, [r4, #13]
   25df8:	f043 0302 	orr.w	r3, r3, #2
   25dfc:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   25dfe:	b1e5      	cbz	r5, 25e3a <add_to_waitq_locked+0x4e>
		thread->base.pended_on = wait_q;
   25e00:	60a5      	str	r5, [r4, #8]
	return list->head == list;
   25e02:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25e04:	429d      	cmp	r5, r3
   25e06:	d109      	bne.n	25e1c <add_to_waitq_locked+0x30>
	sys_dnode_t *const tail = list->tail;
   25e08:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   25e0a:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   25e0e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   25e10:	606c      	str	r4, [r5, #4]
}
   25e12:	e012      	b.n	25e3a <add_to_waitq_locked+0x4e>
	return (node == list->tail) ? NULL : node->next;
   25e14:	686a      	ldr	r2, [r5, #4]
   25e16:	4293      	cmp	r3, r2
   25e18:	d0f6      	beq.n	25e08 <add_to_waitq_locked+0x1c>
   25e1a:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   25e1c:	2b00      	cmp	r3, #0
   25e1e:	d0f3      	beq.n	25e08 <add_to_waitq_locked+0x1c>
	int32_t b1 = thread_1->base.prio;
   25e20:	f994 200e 	ldrsb.w	r2, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   25e24:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
   25e28:	428a      	cmp	r2, r1
   25e2a:	d0f3      	beq.n	25e14 <add_to_waitq_locked+0x28>
		if (z_sched_prio_cmp(thread, t) > 0) {
   25e2c:	4291      	cmp	r1, r2
   25e2e:	ddf1      	ble.n	25e14 <add_to_waitq_locked+0x28>
	sys_dnode_t *const prev = successor->prev;
   25e30:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   25e32:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   25e36:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   25e38:	605c      	str	r4, [r3, #4]
}
   25e3a:	bd38      	pop	{r3, r4, r5, pc}

00025e3c <z_ready_thread>:
{
   25e3c:	b510      	push	{r4, lr}
   25e3e:	f04f 0320 	mov.w	r3, #32
   25e42:	f3ef 8411 	mrs	r4, BASEPRI
   25e46:	f383 8812 	msr	BASEPRI_MAX, r3
   25e4a:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   25e4e:	f7fd fde3 	bl	23a18 <ready_thread>
	__asm__ volatile(
   25e52:	f384 8811 	msr	BASEPRI, r4
   25e56:	f3bf 8f6f 	isb	sy
}
   25e5a:	bd10      	pop	{r4, pc}

00025e5c <z_unpend_thread_no_timeout>:
{
   25e5c:	b508      	push	{r3, lr}
	__asm__ volatile(
   25e5e:	f04f 0220 	mov.w	r2, #32
   25e62:	f3ef 8111 	mrs	r1, BASEPRI
   25e66:	f382 8812 	msr	BASEPRI_MAX, r2
   25e6a:	f3bf 8f6f 	isb	sy
		if (thread->base.pended_on != NULL) {
   25e6e:	6883      	ldr	r3, [r0, #8]
   25e70:	b10b      	cbz	r3, 25e76 <z_unpend_thread_no_timeout+0x1a>
			unpend_thread_no_timeout(thread);
   25e72:	f7ff ffb1 	bl	25dd8 <unpend_thread_no_timeout>
	__asm__ volatile(
   25e76:	f381 8811 	msr	BASEPRI, r1
   25e7a:	f3bf 8f6f 	isb	sy
}
   25e7e:	bd08      	pop	{r3, pc}

00025e80 <z_sched_wake_thread>:
{
   25e80:	b538      	push	{r3, r4, r5, lr}
   25e82:	4604      	mov	r4, r0
	__asm__ volatile(
   25e84:	f04f 0320 	mov.w	r3, #32
   25e88:	f3ef 8511 	mrs	r5, BASEPRI
   25e8c:	f383 8812 	msr	BASEPRI_MAX, r3
   25e90:	f3bf 8f6f 	isb	sy
		if (!killed) {
   25e94:	7b43      	ldrb	r3, [r0, #13]
   25e96:	f013 0f28 	tst.w	r3, #40	; 0x28
   25e9a:	d10b      	bne.n	25eb4 <z_sched_wake_thread+0x34>
			if (thread->base.pended_on != NULL) {
   25e9c:	6883      	ldr	r3, [r0, #8]
   25e9e:	b10b      	cbz	r3, 25ea4 <z_sched_wake_thread+0x24>
				unpend_thread_no_timeout(thread);
   25ea0:	f7ff ff9a 	bl	25dd8 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   25ea4:	7b63      	ldrb	r3, [r4, #13]
			if (is_timeout) {
   25ea6:	b951      	cbnz	r1, 25ebe <z_sched_wake_thread+0x3e>
   25ea8:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
			ready_thread(thread);
   25eac:	4620      	mov	r0, r4
   25eae:	7363      	strb	r3, [r4, #13]
   25eb0:	f7fd fdb2 	bl	23a18 <ready_thread>
	__asm__ volatile(
   25eb4:	f385 8811 	msr	BASEPRI, r5
   25eb8:	f3bf 8f6f 	isb	sy
}
   25ebc:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   25ebe:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
}
   25ec2:	e7f3      	b.n	25eac <z_sched_wake_thread+0x2c>

00025ec4 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
   25ec4:	2101      	movs	r1, #1
   25ec6:	3818      	subs	r0, #24
   25ec8:	f7ff bfda 	b.w	25e80 <z_sched_wake_thread>

00025ecc <z_unpend_first_thread>:
{
   25ecc:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   25ece:	f04f 0320 	mov.w	r3, #32
   25ed2:	f3ef 8511 	mrs	r5, BASEPRI
   25ed6:	f383 8812 	msr	BASEPRI_MAX, r3
   25eda:	f3bf 8f6f 	isb	sy
	return list->head == list;
   25ede:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25ee0:	42a0      	cmp	r0, r4
   25ee2:	d00d      	beq.n	25f00 <z_unpend_first_thread+0x34>
		if (thread != NULL) {
   25ee4:	b134      	cbz	r4, 25ef4 <z_unpend_first_thread+0x28>
			unpend_thread_no_timeout(thread);
   25ee6:	4620      	mov	r0, r4
   25ee8:	f7ff ff76 	bl	25dd8 <unpend_thread_no_timeout>
   25eec:	f104 0018 	add.w	r0, r4, #24
   25ef0:	f000 f869 	bl	25fc6 <z_abort_timeout>
	__asm__ volatile(
   25ef4:	f385 8811 	msr	BASEPRI, r5
   25ef8:	f3bf 8f6f 	isb	sy
}
   25efc:	4620      	mov	r0, r4
   25efe:	bd38      	pop	{r3, r4, r5, pc}
   25f00:	2400      	movs	r4, #0
   25f02:	e7f7      	b.n	25ef4 <z_unpend_first_thread+0x28>

00025f04 <z_unpend_thread>:
{
   25f04:	4601      	mov	r1, r0
   25f06:	b510      	push	{r4, lr}
	__asm__ volatile(
   25f08:	f04f 0320 	mov.w	r3, #32
   25f0c:	f3ef 8411 	mrs	r4, BASEPRI
   25f10:	f383 8812 	msr	BASEPRI_MAX, r3
   25f14:	f3bf 8f6f 	isb	sy
		if (thread->base.pended_on != NULL) {
   25f18:	6883      	ldr	r3, [r0, #8]
   25f1a:	b10b      	cbz	r3, 25f20 <z_unpend_thread+0x1c>
			unpend_thread_no_timeout(thread);
   25f1c:	f7ff ff5c 	bl	25dd8 <unpend_thread_no_timeout>
	__asm__ volatile(
   25f20:	f384 8811 	msr	BASEPRI, r4
   25f24:	f3bf 8f6f 	isb	sy
}
   25f28:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   25f2c:	f101 0018 	add.w	r0, r1, #24
   25f30:	f000 b849 	b.w	25fc6 <z_abort_timeout>

00025f34 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   25f34:	4603      	mov	r3, r0
   25f36:	b920      	cbnz	r0, 25f42 <z_reschedule_irqlock+0xe>
   25f38:	f3ef 8205 	mrs	r2, IPSR
   25f3c:	b90a      	cbnz	r2, 25f42 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   25f3e:	f7f8 ba35 	b.w	1e3ac <arch_swap>
   25f42:	f383 8811 	msr	BASEPRI, r3
   25f46:	f3bf 8f6f 	isb	sy
}
   25f4a:	4770      	bx	lr

00025f4c <z_reschedule_unlocked>:
	__asm__ volatile(
   25f4c:	f04f 0320 	mov.w	r3, #32
   25f50:	f3ef 8011 	mrs	r0, BASEPRI
   25f54:	f383 8812 	msr	BASEPRI_MAX, r3
   25f58:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   25f5c:	f7ff bfea 	b.w	25f34 <z_reschedule_irqlock>

00025f60 <z_unpend_all>:
{
   25f60:	b538      	push	{r3, r4, r5, lr}
   25f62:	4605      	mov	r5, r0
	int need_sched = 0;
   25f64:	2000      	movs	r0, #0
	return list->head == list;
   25f66:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25f68:	42a5      	cmp	r5, r4
   25f6a:	d000      	beq.n	25f6e <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   25f6c:	b904      	cbnz	r4, 25f70 <z_unpend_all+0x10>
}
   25f6e:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   25f70:	4620      	mov	r0, r4
   25f72:	f7ff ffc7 	bl	25f04 <z_unpend_thread>
		z_ready_thread(thread);
   25f76:	4620      	mov	r0, r4
   25f78:	f7ff ff60 	bl	25e3c <z_ready_thread>
		need_sched = 1;
   25f7c:	2001      	movs	r0, #1
   25f7e:	e7f2      	b.n	25f66 <z_unpend_all+0x6>

00025f80 <z_sched_wake>:
{
   25f80:	b538      	push	{r3, r4, r5, lr}
   25f82:	f04f 0320 	mov.w	r3, #32
   25f86:	f3ef 8511 	mrs	r5, BASEPRI
   25f8a:	f383 8812 	msr	BASEPRI_MAX, r3
   25f8e:	f3bf 8f6f 	isb	sy
	return list->head == list;
   25f92:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25f94:	42a0      	cmp	r0, r4
   25f96:	d012      	beq.n	25fbe <z_sched_wake+0x3e>
		if (thread != NULL) {
   25f98:	b19c      	cbz	r4, 25fc2 <z_sched_wake+0x42>
   25f9a:	67a1      	str	r1, [r4, #120]	; 0x78
	thread->base.swap_data = data;
   25f9c:	6162      	str	r2, [r4, #20]
			unpend_thread_no_timeout(thread);
   25f9e:	4620      	mov	r0, r4
   25fa0:	f7ff ff1a 	bl	25dd8 <unpend_thread_no_timeout>
   25fa4:	f104 0018 	add.w	r0, r4, #24
   25fa8:	f000 f80d 	bl	25fc6 <z_abort_timeout>
			ready_thread(thread);
   25fac:	4620      	mov	r0, r4
   25fae:	f7fd fd33 	bl	23a18 <ready_thread>
			ret = true;
   25fb2:	2001      	movs	r0, #1
	__asm__ volatile(
   25fb4:	f385 8811 	msr	BASEPRI, r5
   25fb8:	f3bf 8f6f 	isb	sy
}
   25fbc:	bd38      	pop	{r3, r4, r5, pc}
	bool ret = false;
   25fbe:	2000      	movs	r0, #0
   25fc0:	e7f8      	b.n	25fb4 <z_sched_wake+0x34>
   25fc2:	4620      	mov	r0, r4
   25fc4:	e7f6      	b.n	25fb4 <z_sched_wake+0x34>

00025fc6 <z_abort_timeout>:
{
   25fc6:	b510      	push	{r4, lr}
	__asm__ volatile(
   25fc8:	f04f 0220 	mov.w	r2, #32
   25fcc:	f3ef 8411 	mrs	r4, BASEPRI
   25fd0:	f382 8812 	msr	BASEPRI_MAX, r2
   25fd4:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   25fd8:	6803      	ldr	r3, [r0, #0]
   25fda:	b13b      	cbz	r3, 25fec <z_abort_timeout+0x26>
			remove_timeout(to);
   25fdc:	f7fe f820 	bl	24020 <remove_timeout>
			ret = 0;
   25fe0:	2000      	movs	r0, #0
	__asm__ volatile(
   25fe2:	f384 8811 	msr	BASEPRI, r4
   25fe6:	f3bf 8f6f 	isb	sy
}
   25fea:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   25fec:	f06f 0015 	mvn.w	r0, #21
   25ff0:	e7f7      	b.n	25fe2 <z_abort_timeout+0x1c>

00025ff2 <z_get_next_timeout_expiry>:
{
   25ff2:	b510      	push	{r4, lr}
	__asm__ volatile(
   25ff4:	f04f 0320 	mov.w	r3, #32
   25ff8:	f3ef 8411 	mrs	r4, BASEPRI
   25ffc:	f383 8812 	msr	BASEPRI_MAX, r3
   26000:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   26004:	f7fd ffec 	bl	23fe0 <next_timeout>
	__asm__ volatile(
   26008:	f384 8811 	msr	BASEPRI, r4
   2600c:	f3bf 8f6f 	isb	sy
}
   26010:	bd10      	pop	{r4, pc}

00026012 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   26012:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   26014:	f7fe f900 	bl	24218 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   26018:	bd08      	pop	{r3, pc}

0002601a <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   2601a:	f7fe b8fd 	b.w	24218 <sys_clock_tick_get>

0002601e <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   2601e:	b108      	cbz	r0, 26024 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   26020:	f7f6 bf5e 	b.w	1cee0 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   26024:	4770      	bx	lr

00026026 <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   26026:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   2602a:	bf08      	it	eq
   2602c:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   26030:	b538      	push	{r3, r4, r5, lr}
   26032:	460c      	mov	r4, r1
   26034:	4605      	mov	r5, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   26036:	d014      	beq.n	26062 <sys_clock_timeout_end_calc+0x3c>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   26038:	4308      	orrs	r0, r1
   2603a:	d103      	bne.n	26044 <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   2603c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   26040:	f7fe b8ea 	b.w	24218 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   26044:	f06f 0001 	mvn.w	r0, #1
   26048:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2604c:	1b40      	subs	r0, r0, r5
   2604e:	eb63 0101 	sbc.w	r1, r3, r1
   26052:	2900      	cmp	r1, #0
   26054:	da04      	bge.n	26060 <sys_clock_timeout_end_calc+0x3a>
		return sys_clock_tick_get() + MAX(1, dt);
   26056:	f7fe f8df 	bl	24218 <sys_clock_tick_get>
   2605a:	1940      	adds	r0, r0, r5
   2605c:	eb41 0104 	adc.w	r1, r1, r4
}
   26060:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
   26062:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26066:	4601      	mov	r1, r0
   26068:	e7fa      	b.n	26060 <sys_clock_timeout_end_calc+0x3a>

0002606a <k_free>:
	if (ptr != NULL) {
   2606a:	b120      	cbz	r0, 26076 <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
   2606c:	1f01      	subs	r1, r0, #4
   2606e:	f850 0c04 	ldr.w	r0, [r0, #-4]
   26072:	f000 b856 	b.w	26122 <k_heap_free>
}
   26076:	4770      	bx	lr

00026078 <k_heap_init>:
{
   26078:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   2607a:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   2607e:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   26082:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   26084:	f7fe bb9b 	b.w	247be <sys_heap_init>

00026088 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   26088:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2608c:	b085      	sub	sp, #20
   2608e:	e9dd a40e 	ldrd	sl, r4, [sp, #56]	; 0x38
   26092:	4607      	mov	r7, r0
   26094:	4688      	mov	r8, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   26096:	4650      	mov	r0, sl
   26098:	4621      	mov	r1, r4
{
   2609a:	4691      	mov	r9, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   2609c:	f7ff ffc3 	bl	26026 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
   260a0:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   260a4:	bf08      	it	eq
   260a6:	f1ba 3fff 	cmpeq.w	sl, #4294967295	; 0xffffffff
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   260aa:	4605      	mov	r5, r0
   260ac:	460e      	mov	r6, r1
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
   260ae:	bf04      	itt	eq
   260b0:	f04f 35ff 	moveq.w	r5, #4294967295	; 0xffffffff
   260b4:	f06f 4600 	mvneq.w	r6, #2147483648	; 0x80000000

	k_spinlock_key_t key = k_spin_lock(&h->lock);
   260b8:	f107 0a14 	add.w	sl, r7, #20
	__asm__ volatile(
   260bc:	f04f 0320 	mov.w	r3, #32
   260c0:	f3ef 8411 	mrs	r4, BASEPRI
   260c4:	f383 8812 	msr	BASEPRI_MAX, r3
   260c8:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   260cc:	f107 0b0c 	add.w	fp, r7, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   260d0:	464a      	mov	r2, r9
   260d2:	4641      	mov	r1, r8
   260d4:	4638      	mov	r0, r7
   260d6:	f7fe fb0b 	bl	246f0 <sys_heap_aligned_alloc>
   260da:	9003      	str	r0, [sp, #12]
		now = sys_clock_tick_get();
   260dc:	f7fe f89c 	bl	24218 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   260e0:	9b03      	ldr	r3, [sp, #12]
   260e2:	b13b      	cbz	r3, 260f4 <k_heap_aligned_alloc+0x6c>
	__asm__ volatile(
   260e4:	f384 8811 	msr	BASEPRI, r4
   260e8:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   260ec:	4618      	mov	r0, r3
   260ee:	b005      	add	sp, #20
   260f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   260f4:	1a28      	subs	r0, r5, r0
   260f6:	eb66 0101 	sbc.w	r1, r6, r1
   260fa:	2801      	cmp	r0, #1
   260fc:	f171 0200 	sbcs.w	r2, r1, #0
   26100:	dbf0      	blt.n	260e4 <k_heap_aligned_alloc+0x5c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   26102:	e9cd 0100 	strd	r0, r1, [sp]
   26106:	465a      	mov	r2, fp
   26108:	4621      	mov	r1, r4
   2610a:	4650      	mov	r0, sl
   2610c:	f7fd fd18 	bl	23b40 <z_pend_curr>
	__asm__ volatile(
   26110:	f04f 0320 	mov.w	r3, #32
   26114:	f3ef 8411 	mrs	r4, BASEPRI
   26118:	f383 8812 	msr	BASEPRI_MAX, r3
   2611c:	f3bf 8f6f 	isb	sy
	return k;
   26120:	e7d6      	b.n	260d0 <k_heap_aligned_alloc+0x48>

00026122 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
   26122:	b538      	push	{r3, r4, r5, lr}
   26124:	4604      	mov	r4, r0
   26126:	f04f 0320 	mov.w	r3, #32
   2612a:	f3ef 8511 	mrs	r5, BASEPRI
   2612e:	f383 8812 	msr	BASEPRI_MAX, r3
   26132:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   26136:	f7fe faa3 	bl	24680 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   2613a:	f104 000c 	add.w	r0, r4, #12
   2613e:	f7ff ff0f 	bl	25f60 <z_unpend_all>
   26142:	b130      	cbz	r0, 26152 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   26144:	4629      	mov	r1, r5
   26146:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   2614a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   2614e:	f7fd bd5b 	b.w	23c08 <z_reschedule>
	__asm__ volatile(
   26152:	f385 8811 	msr	BASEPRI, r5
   26156:	f3bf 8f6f 	isb	sy
}
   2615a:	bd38      	pop	{r3, r4, r5, pc}

0002615c <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   2615c:	4770      	bx	lr
	...
