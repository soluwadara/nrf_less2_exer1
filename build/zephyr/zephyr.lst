
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0001c000 <_vector_table>:
   1c000:	70 cb 00 20 e1 e7 01 00 75 4f 02 00 b5 e7 01 00     p.. ....uO......
   1c010:	b5 e7 01 00 b5 e7 01 00 b5 e7 01 00 b5 e7 01 00     ................
	...
   1c02c:	59 e4 01 00 b5 e7 01 00 00 00 00 00 f9 e3 01 00     Y...............
   1c03c:	b5 e7 01 00                                         ....

0001c040 <_irq_vector_table>:
   1c040:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c050:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c060:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c070:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c080:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c090:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c0a0:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c0b0:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c0c0:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c0d0:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c0e0:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c0f0:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c100:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c110:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c120:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c130:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c140:	dd e4 01 00 dd e4 01 00 dd e4 01 00 dd e4 01 00     ................
   1c150:	dd e4 01 00                                         ....

Disassembly of section text:

0001c154 <__aeabi_uldivmod>:
   1c154:	b953      	cbnz	r3, 1c16c <__aeabi_uldivmod+0x18>
   1c156:	b94a      	cbnz	r2, 1c16c <__aeabi_uldivmod+0x18>
   1c158:	2900      	cmp	r1, #0
   1c15a:	bf08      	it	eq
   1c15c:	2800      	cmpeq	r0, #0
   1c15e:	bf1c      	itt	ne
   1c160:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   1c164:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   1c168:	f000 b80c 	b.w	1c184 <__aeabi_idiv0>
   1c16c:	f1ad 0c08 	sub.w	ip, sp, #8
   1c170:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1c174:	f000 f808 	bl	1c188 <__udivmoddi4>
   1c178:	f8dd e004 	ldr.w	lr, [sp, #4]
   1c17c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1c180:	b004      	add	sp, #16
   1c182:	4770      	bx	lr

0001c184 <__aeabi_idiv0>:
   1c184:	4770      	bx	lr
   1c186:	bf00      	nop

0001c188 <__udivmoddi4>:
   1c188:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c18c:	4686      	mov	lr, r0
   1c18e:	468c      	mov	ip, r1
   1c190:	4608      	mov	r0, r1
   1c192:	9e08      	ldr	r6, [sp, #32]
   1c194:	4615      	mov	r5, r2
   1c196:	4674      	mov	r4, lr
   1c198:	4619      	mov	r1, r3
   1c19a:	2b00      	cmp	r3, #0
   1c19c:	f040 80c1 	bne.w	1c322 <__udivmoddi4+0x19a>
   1c1a0:	4285      	cmp	r5, r0
   1c1a2:	fab2 f282 	clz	r2, r2
   1c1a6:	d945      	bls.n	1c234 <__udivmoddi4+0xac>
   1c1a8:	b14a      	cbz	r2, 1c1be <__udivmoddi4+0x36>
   1c1aa:	f1c2 0320 	rsb	r3, r2, #32
   1c1ae:	fa00 fc02 	lsl.w	ip, r0, r2
   1c1b2:	4095      	lsls	r5, r2
   1c1b4:	4094      	lsls	r4, r2
   1c1b6:	fa2e f303 	lsr.w	r3, lr, r3
   1c1ba:	ea43 0c0c 	orr.w	ip, r3, ip
   1c1be:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c1c2:	b2a8      	uxth	r0, r5
   1c1c4:	0c23      	lsrs	r3, r4, #16
   1c1c6:	fbbc f8fe 	udiv	r8, ip, lr
   1c1ca:	fb0e cc18 	mls	ip, lr, r8, ip
   1c1ce:	fb08 f900 	mul.w	r9, r8, r0
   1c1d2:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
   1c1d6:	4599      	cmp	r9, r3
   1c1d8:	d928      	bls.n	1c22c <__udivmoddi4+0xa4>
   1c1da:	18eb      	adds	r3, r5, r3
   1c1dc:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
   1c1e0:	d204      	bcs.n	1c1ec <__udivmoddi4+0x64>
   1c1e2:	4599      	cmp	r9, r3
   1c1e4:	d902      	bls.n	1c1ec <__udivmoddi4+0x64>
   1c1e6:	f1a8 0702 	sub.w	r7, r8, #2
   1c1ea:	442b      	add	r3, r5
   1c1ec:	eba3 0309 	sub.w	r3, r3, r9
   1c1f0:	b2a4      	uxth	r4, r4
   1c1f2:	fbb3 fcfe 	udiv	ip, r3, lr
   1c1f6:	fb0e 331c 	mls	r3, lr, ip, r3
   1c1fa:	fb0c f000 	mul.w	r0, ip, r0
   1c1fe:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1c202:	42a0      	cmp	r0, r4
   1c204:	d914      	bls.n	1c230 <__udivmoddi4+0xa8>
   1c206:	192c      	adds	r4, r5, r4
   1c208:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   1c20c:	d204      	bcs.n	1c218 <__udivmoddi4+0x90>
   1c20e:	42a0      	cmp	r0, r4
   1c210:	d902      	bls.n	1c218 <__udivmoddi4+0x90>
   1c212:	f1ac 0302 	sub.w	r3, ip, #2
   1c216:	442c      	add	r4, r5
   1c218:	1a24      	subs	r4, r4, r0
   1c21a:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
   1c21e:	b11e      	cbz	r6, 1c228 <__udivmoddi4+0xa0>
   1c220:	40d4      	lsrs	r4, r2
   1c222:	2300      	movs	r3, #0
   1c224:	6034      	str	r4, [r6, #0]
   1c226:	6073      	str	r3, [r6, #4]
   1c228:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c22c:	4647      	mov	r7, r8
   1c22e:	e7dd      	b.n	1c1ec <__udivmoddi4+0x64>
   1c230:	4663      	mov	r3, ip
   1c232:	e7f1      	b.n	1c218 <__udivmoddi4+0x90>
   1c234:	bb92      	cbnz	r2, 1c29c <__udivmoddi4+0x114>
   1c236:	1b43      	subs	r3, r0, r5
   1c238:	2101      	movs	r1, #1
   1c23a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c23e:	b2af      	uxth	r7, r5
   1c240:	0c20      	lsrs	r0, r4, #16
   1c242:	fbb3 fcfe 	udiv	ip, r3, lr
   1c246:	fb0e 331c 	mls	r3, lr, ip, r3
   1c24a:	fb0c f807 	mul.w	r8, ip, r7
   1c24e:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
   1c252:	4598      	cmp	r8, r3
   1c254:	d961      	bls.n	1c31a <__udivmoddi4+0x192>
   1c256:	18eb      	adds	r3, r5, r3
   1c258:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   1c25c:	d204      	bcs.n	1c268 <__udivmoddi4+0xe0>
   1c25e:	4598      	cmp	r8, r3
   1c260:	d902      	bls.n	1c268 <__udivmoddi4+0xe0>
   1c262:	f1ac 0002 	sub.w	r0, ip, #2
   1c266:	442b      	add	r3, r5
   1c268:	eba3 0308 	sub.w	r3, r3, r8
   1c26c:	b2a4      	uxth	r4, r4
   1c26e:	fbb3 fcfe 	udiv	ip, r3, lr
   1c272:	fb0e 331c 	mls	r3, lr, ip, r3
   1c276:	fb0c f707 	mul.w	r7, ip, r7
   1c27a:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1c27e:	42a7      	cmp	r7, r4
   1c280:	d94d      	bls.n	1c31e <__udivmoddi4+0x196>
   1c282:	192c      	adds	r4, r5, r4
   1c284:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   1c288:	d204      	bcs.n	1c294 <__udivmoddi4+0x10c>
   1c28a:	42a7      	cmp	r7, r4
   1c28c:	d902      	bls.n	1c294 <__udivmoddi4+0x10c>
   1c28e:	f1ac 0302 	sub.w	r3, ip, #2
   1c292:	442c      	add	r4, r5
   1c294:	1be4      	subs	r4, r4, r7
   1c296:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   1c29a:	e7c0      	b.n	1c21e <__udivmoddi4+0x96>
   1c29c:	f1c2 0320 	rsb	r3, r2, #32
   1c2a0:	4095      	lsls	r5, r2
   1c2a2:	4094      	lsls	r4, r2
   1c2a4:	fa20 f103 	lsr.w	r1, r0, r3
   1c2a8:	fa2e f303 	lsr.w	r3, lr, r3
   1c2ac:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c2b0:	4090      	lsls	r0, r2
   1c2b2:	b2af      	uxth	r7, r5
   1c2b4:	4303      	orrs	r3, r0
   1c2b6:	fbb1 fcfe 	udiv	ip, r1, lr
   1c2ba:	fb0e 101c 	mls	r0, lr, ip, r1
   1c2be:	0c19      	lsrs	r1, r3, #16
   1c2c0:	fb0c f807 	mul.w	r8, ip, r7
   1c2c4:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   1c2c8:	4588      	cmp	r8, r1
   1c2ca:	d922      	bls.n	1c312 <__udivmoddi4+0x18a>
   1c2cc:	1869      	adds	r1, r5, r1
   1c2ce:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   1c2d2:	d204      	bcs.n	1c2de <__udivmoddi4+0x156>
   1c2d4:	4588      	cmp	r8, r1
   1c2d6:	d902      	bls.n	1c2de <__udivmoddi4+0x156>
   1c2d8:	f1ac 0002 	sub.w	r0, ip, #2
   1c2dc:	4429      	add	r1, r5
   1c2de:	eba1 0108 	sub.w	r1, r1, r8
   1c2e2:	b29b      	uxth	r3, r3
   1c2e4:	fbb1 fcfe 	udiv	ip, r1, lr
   1c2e8:	fb0e 111c 	mls	r1, lr, ip, r1
   1c2ec:	fb0c f707 	mul.w	r7, ip, r7
   1c2f0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1c2f4:	429f      	cmp	r7, r3
   1c2f6:	d90e      	bls.n	1c316 <__udivmoddi4+0x18e>
   1c2f8:	18eb      	adds	r3, r5, r3
   1c2fa:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
   1c2fe:	d204      	bcs.n	1c30a <__udivmoddi4+0x182>
   1c300:	429f      	cmp	r7, r3
   1c302:	d902      	bls.n	1c30a <__udivmoddi4+0x182>
   1c304:	f1ac 0102 	sub.w	r1, ip, #2
   1c308:	442b      	add	r3, r5
   1c30a:	1bdb      	subs	r3, r3, r7
   1c30c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   1c310:	e793      	b.n	1c23a <__udivmoddi4+0xb2>
   1c312:	4660      	mov	r0, ip
   1c314:	e7e3      	b.n	1c2de <__udivmoddi4+0x156>
   1c316:	4661      	mov	r1, ip
   1c318:	e7f7      	b.n	1c30a <__udivmoddi4+0x182>
   1c31a:	4660      	mov	r0, ip
   1c31c:	e7a4      	b.n	1c268 <__udivmoddi4+0xe0>
   1c31e:	4663      	mov	r3, ip
   1c320:	e7b8      	b.n	1c294 <__udivmoddi4+0x10c>
   1c322:	4283      	cmp	r3, r0
   1c324:	d906      	bls.n	1c334 <__udivmoddi4+0x1ac>
   1c326:	b916      	cbnz	r6, 1c32e <__udivmoddi4+0x1a6>
   1c328:	2100      	movs	r1, #0
   1c32a:	4608      	mov	r0, r1
   1c32c:	e77c      	b.n	1c228 <__udivmoddi4+0xa0>
   1c32e:	e9c6 e000 	strd	lr, r0, [r6]
   1c332:	e7f9      	b.n	1c328 <__udivmoddi4+0x1a0>
   1c334:	fab3 f783 	clz	r7, r3
   1c338:	b98f      	cbnz	r7, 1c35e <__udivmoddi4+0x1d6>
   1c33a:	4283      	cmp	r3, r0
   1c33c:	d301      	bcc.n	1c342 <__udivmoddi4+0x1ba>
   1c33e:	4572      	cmp	r2, lr
   1c340:	d808      	bhi.n	1c354 <__udivmoddi4+0x1cc>
   1c342:	ebbe 0402 	subs.w	r4, lr, r2
   1c346:	eb60 0303 	sbc.w	r3, r0, r3
   1c34a:	2001      	movs	r0, #1
   1c34c:	469c      	mov	ip, r3
   1c34e:	b91e      	cbnz	r6, 1c358 <__udivmoddi4+0x1d0>
   1c350:	2100      	movs	r1, #0
   1c352:	e769      	b.n	1c228 <__udivmoddi4+0xa0>
   1c354:	4638      	mov	r0, r7
   1c356:	e7fa      	b.n	1c34e <__udivmoddi4+0x1c6>
   1c358:	e9c6 4c00 	strd	r4, ip, [r6]
   1c35c:	e7f8      	b.n	1c350 <__udivmoddi4+0x1c8>
   1c35e:	f1c7 0c20 	rsb	ip, r7, #32
   1c362:	40bb      	lsls	r3, r7
   1c364:	fa0e f507 	lsl.w	r5, lr, r7
   1c368:	fa22 f40c 	lsr.w	r4, r2, ip
   1c36c:	fa2e f10c 	lsr.w	r1, lr, ip
   1c370:	40ba      	lsls	r2, r7
   1c372:	431c      	orrs	r4, r3
   1c374:	fa20 f30c 	lsr.w	r3, r0, ip
   1c378:	40b8      	lsls	r0, r7
   1c37a:	ea4f 4914 	mov.w	r9, r4, lsr #16
   1c37e:	4301      	orrs	r1, r0
   1c380:	fa1f fe84 	uxth.w	lr, r4
   1c384:	fbb3 f8f9 	udiv	r8, r3, r9
   1c388:	fb09 3018 	mls	r0, r9, r8, r3
   1c38c:	0c0b      	lsrs	r3, r1, #16
   1c38e:	fb08 fa0e 	mul.w	sl, r8, lr
   1c392:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   1c396:	459a      	cmp	sl, r3
   1c398:	d940      	bls.n	1c41c <__udivmoddi4+0x294>
   1c39a:	18e3      	adds	r3, r4, r3
   1c39c:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
   1c3a0:	d204      	bcs.n	1c3ac <__udivmoddi4+0x224>
   1c3a2:	459a      	cmp	sl, r3
   1c3a4:	d902      	bls.n	1c3ac <__udivmoddi4+0x224>
   1c3a6:	f1a8 0002 	sub.w	r0, r8, #2
   1c3aa:	4423      	add	r3, r4
   1c3ac:	eba3 030a 	sub.w	r3, r3, sl
   1c3b0:	b289      	uxth	r1, r1
   1c3b2:	fbb3 f8f9 	udiv	r8, r3, r9
   1c3b6:	fb09 3318 	mls	r3, r9, r8, r3
   1c3ba:	fb08 fe0e 	mul.w	lr, r8, lr
   1c3be:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   1c3c2:	458e      	cmp	lr, r1
   1c3c4:	d92c      	bls.n	1c420 <__udivmoddi4+0x298>
   1c3c6:	1861      	adds	r1, r4, r1
   1c3c8:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   1c3cc:	d204      	bcs.n	1c3d8 <__udivmoddi4+0x250>
   1c3ce:	458e      	cmp	lr, r1
   1c3d0:	d902      	bls.n	1c3d8 <__udivmoddi4+0x250>
   1c3d2:	f1a8 0302 	sub.w	r3, r8, #2
   1c3d6:	4421      	add	r1, r4
   1c3d8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   1c3dc:	eba1 010e 	sub.w	r1, r1, lr
   1c3e0:	fba0 9802 	umull	r9, r8, r0, r2
   1c3e4:	4541      	cmp	r1, r8
   1c3e6:	46ce      	mov	lr, r9
   1c3e8:	4643      	mov	r3, r8
   1c3ea:	d302      	bcc.n	1c3f2 <__udivmoddi4+0x26a>
   1c3ec:	d106      	bne.n	1c3fc <__udivmoddi4+0x274>
   1c3ee:	454d      	cmp	r5, r9
   1c3f0:	d204      	bcs.n	1c3fc <__udivmoddi4+0x274>
   1c3f2:	3801      	subs	r0, #1
   1c3f4:	ebb9 0e02 	subs.w	lr, r9, r2
   1c3f8:	eb68 0304 	sbc.w	r3, r8, r4
   1c3fc:	2e00      	cmp	r6, #0
   1c3fe:	d0a7      	beq.n	1c350 <__udivmoddi4+0x1c8>
   1c400:	ebb5 020e 	subs.w	r2, r5, lr
   1c404:	eb61 0103 	sbc.w	r1, r1, r3
   1c408:	fa01 fc0c 	lsl.w	ip, r1, ip
   1c40c:	fa22 f307 	lsr.w	r3, r2, r7
   1c410:	40f9      	lsrs	r1, r7
   1c412:	ea4c 0303 	orr.w	r3, ip, r3
   1c416:	e9c6 3100 	strd	r3, r1, [r6]
   1c41a:	e799      	b.n	1c350 <__udivmoddi4+0x1c8>
   1c41c:	4640      	mov	r0, r8
   1c41e:	e7c5      	b.n	1c3ac <__udivmoddi4+0x224>
   1c420:	4643      	mov	r3, r8
   1c422:	e7d9      	b.n	1c3d8 <__udivmoddi4+0x250>

0001c424 <main>:
static const struct gpio_dt_spec red_led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);
static const struct gpio_dt_spec green_led = GPIO_DT_SPEC_GET(LED1_NODE, gpios);


void main(void)
{
   1c424:	b537      	push	{r0, r1, r2, r4, r5, lr}
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
   1c426:	4829      	ldr	r0, [pc, #164]	; (1c4cc <main+0xa8>)
   1c428:	f009 fb60 	bl	25aec <z_device_is_ready>
   1c42c:	4c27      	ldr	r4, [pc, #156]	; (1c4cc <main+0xa8>)
	int ret;
	/* Verify that the device is ready for use */
	if (!device_is_ready(green_led.port)) {
   1c42e:	2800      	cmp	r0, #0
   1c430:	d04a      	beq.n	1c4c8 <main+0xa4>
   1c432:	4620      	mov	r0, r4
   1c434:	f009 fb5a 	bl	25aec <z_device_is_ready>
		return;
	}
	if (!device_is_ready(red_led.port)) {
   1c438:	2800      	cmp	r0, #0
   1c43a:	d045      	beq.n	1c4c8 <main+0xa4>
   1c43c:	4620      	mov	r0, r4
   1c43e:	f009 fb55 	bl	25aec <z_device_is_ready>
		return;
	}
	if (!device_is_ready(button.port)) {
   1c442:	2800      	cmp	r0, #0
   1c444:	d040      	beq.n	1c4c8 <main+0xa4>
		return;
	}

	/* Configure the pin connected to the button to be an input pin and set its hardware specifications */
	ret = gpio_pin_configure_dt(&green_led, GPIO_OUTPUT_ACTIVE);
   1c446:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   1c44a:	4821      	ldr	r0, [pc, #132]	; (1c4d0 <main+0xac>)
   1c44c:	f007 fffe 	bl	2444c <gpio_pin_configure_dt>
	if (ret < 0) {
   1c450:	2800      	cmp	r0, #0
   1c452:	db39      	blt.n	1c4c8 <main+0xa4>
		return;
	}
	ret = gpio_pin_configure_dt(&red_led, GPIO_OUTPUT_ACTIVE);
   1c454:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   1c458:	481e      	ldr	r0, [pc, #120]	; (1c4d4 <main+0xb0>)
   1c45a:	f007 fff7 	bl	2444c <gpio_pin_configure_dt>
	if (ret < 0) {
   1c45e:	2800      	cmp	r0, #0
   1c460:	db32      	blt.n	1c4c8 <main+0xa4>
		return;
	}
	ret = gpio_pin_configure_dt(&button, GPIO_INPUT);
   1c462:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   1c466:	481c      	ldr	r0, [pc, #112]	; (1c4d8 <main+0xb4>)
   1c468:	f007 fff0 	bl	2444c <gpio_pin_configure_dt>
	if (ret < 0) {
   1c46c:	2800      	cmp	r0, #0
   1c46e:	db2b      	blt.n	1c4c8 <main+0xa4>
 * @retval -EWOULDBLOCK if operation would block.
 */
static inline int gpio_port_get(const struct device *port,
				gpio_port_value_t *value)
{
	const struct gpio_driver_data *const data =
   1c470:	6925      	ldr	r5, [r4, #16]
	return api->port_get_raw(port, value);
   1c472:	68a3      	ldr	r3, [r4, #8]
   1c474:	4620      	mov	r0, r4
   1c476:	685b      	ldr	r3, [r3, #4]
   1c478:	a901      	add	r1, sp, #4
   1c47a:	4798      	blx	r3
			(const struct gpio_driver_data *)port->data;
	int ret;

	ret = gpio_port_get_raw(port, value);
	if (ret == 0) {
   1c47c:	b1a8      	cbz	r0, 1c4aa <main+0x86>
			(const struct gpio_driver_data *)port->data;

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1c47e:	682b      	ldr	r3, [r5, #0]
   1c480:	05d9      	lsls	r1, r3, #23
   1c482:	d41b      	bmi.n	1c4bc <main+0x98>
	return api->port_set_bits_raw(port, pins);
   1c484:	68a3      	ldr	r3, [r4, #8]
   1c486:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   1c488:	f44f 7180 	mov.w	r1, #256	; 0x100
   1c48c:	4620      	mov	r0, r4
   1c48e:	4798      	blx	r3
	return api->port_toggle_bits(port, pins);
   1c490:	68a3      	ldr	r3, [r4, #8]
   1c492:	2140      	movs	r1, #64	; 0x40
   1c494:	4620      	mov	r0, r4
   1c496:	695b      	ldr	r3, [r3, #20]
   1c498:	4798      	blx	r3
		/* Update the LED to the status of the button */
		gpio_pin_set_dt(&red_led,val);

		/*Toggle the green LED*/
		ret = gpio_pin_toggle_dt(&green_led);
		if (ret <0){
   1c49a:	2800      	cmp	r0, #0
   1c49c:	db14      	blt.n	1c4c8 <main+0xa4>
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm0 = { .val = timeout };
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
   1c49e:	2100      	movs	r1, #0
   1c4a0:	f640 40cd 	movw	r0, #3277	; 0xccd
   1c4a4:	f007 fcd8 	bl	23e58 <z_impl_k_sleep>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
   1c4a8:	e7e3      	b.n	1c472 <main+0x4e>
		*value ^= data->invert;
   1c4aa:	682a      	ldr	r2, [r5, #0]
   1c4ac:	9b01      	ldr	r3, [sp, #4]
   1c4ae:	4053      	eors	r3, r2
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1c4b0:	05d2      	lsls	r2, r2, #23
		ret = (value & (gpio_port_pins_t)BIT(pin)) != 0 ? 1 : 0;
   1c4b2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1c4b6:	d404      	bmi.n	1c4c2 <main+0x9e>
	if (value != 0)	{
   1c4b8:	2b00      	cmp	r3, #0
   1c4ba:	d1e3      	bne.n	1c484 <main+0x60>
	return api->port_clear_bits_raw(port, pins);
   1c4bc:	68a3      	ldr	r3, [r4, #8]
   1c4be:	691b      	ldr	r3, [r3, #16]
   1c4c0:	e7e2      	b.n	1c488 <main+0x64>
	if (value != 0)	{
   1c4c2:	2b00      	cmp	r3, #0
   1c4c4:	d0de      	beq.n	1c484 <main+0x60>
   1c4c6:	e7f9      	b.n	1c4bc <main+0x98>
			return;
		}
		k_msleep(SLEEP_TIME_MS); // Put the main thread to sleep for 100ms for power optimization
	}
}
   1c4c8:	b003      	add	sp, #12
   1c4ca:	bd30      	pop	{r4, r5, pc}
   1c4cc:	00026240 	.word	0x00026240
   1c4d0:	00026658 	.word	0x00026658
   1c4d4:	00026660 	.word	0x00026660
   1c4d8:	00026668 	.word	0x00026668

0001c4dc <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
   1c4dc:	4b01      	ldr	r3, [pc, #4]	; (1c4e4 <char_out+0x8>)
   1c4de:	681b      	ldr	r3, [r3, #0]
   1c4e0:	4718      	bx	r3
   1c4e2:	bf00      	nop
   1c4e4:	2000a0b0 	.word	0x2000a0b0

0001c4e8 <__printk_hook_install>:
	_char_out = fn;
   1c4e8:	4b01      	ldr	r3, [pc, #4]	; (1c4f0 <__printk_hook_install+0x8>)
   1c4ea:	6018      	str	r0, [r3, #0]
}
   1c4ec:	4770      	bx	lr
   1c4ee:	bf00      	nop
   1c4f0:	2000a0b0 	.word	0x2000a0b0

0001c4f4 <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
   1c4f4:	b507      	push	{r0, r1, r2, lr}
   1c4f6:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
   1c4f8:	2100      	movs	r1, #0
   1c4fa:	4602      	mov	r2, r0
   1c4fc:	9100      	str	r1, [sp, #0]
   1c4fe:	4803      	ldr	r0, [pc, #12]	; (1c50c <vprintk+0x18>)
   1c500:	f000 f914 	bl	1c72c <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
   1c504:	b003      	add	sp, #12
   1c506:	f85d fb04 	ldr.w	pc, [sp], #4
   1c50a:	bf00      	nop
   1c50c:	0001c4dd 	.word	0x0001c4dd

0001c510 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   1c510:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1c514:	8b05      	ldrh	r5, [r0, #24]
{
   1c516:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   1c518:	0728      	lsls	r0, r5, #28
{
   1c51a:	4690      	mov	r8, r2
	if (processing) {
   1c51c:	d411      	bmi.n	1c542 <process_event+0x32>

	sys_slist_init(&clients);
	do {
		onoff_transition_fn transit = NULL;

		if (evt == EVT_RECHECK) {
   1c51e:	2902      	cmp	r1, #2
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1c520:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
   1c524:	f040 80cd 	bne.w	1c6c2 <process_event+0x1b2>
			evt = process_recheck(mgr);
   1c528:	4620      	mov	r0, r4
   1c52a:	f008 f9a7 	bl	2487c <process_recheck>
		}

		if (evt == EVT_NOP) {
   1c52e:	b178      	cbz	r0, 1c550 <process_event+0x40>
			break;
		}

		res = 0;
		if (evt == EVT_COMPLETE) {
   1c530:	3801      	subs	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c532:	8b21      	ldrh	r1, [r4, #24]
   1c534:	2804      	cmp	r0, #4
   1c536:	d811      	bhi.n	1c55c <process_event+0x4c>
   1c538:	e8df f000 	tbb	[pc, r0]
   1c53c:	856d10c3 	.word	0x856d10c3
   1c540:	95          	.byte	0x95
   1c541:	00          	.byte	0x00
		if (evt == EVT_COMPLETE) {
   1c542:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   1c544:	bf0c      	ite	eq
   1c546:	f045 0510 	orreq.w	r5, r5, #16
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c54a:	f045 0520 	orrne.w	r5, r5, #32
   1c54e:	8325      	strh	r5, [r4, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   1c550:	f388 8811 	msr	BASEPRI, r8
   1c554:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   1c558:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c55c:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1c560:	45aa      	cmp	sl, r5
   1c562:	f000 80a6 	beq.w	1c6b2 <process_event+0x1a2>
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
   1c566:	2700      	movs	r7, #0
   1c568:	46b9      	mov	r9, r7
   1c56a:	463e      	mov	r6, r7
   1c56c:	68a3      	ldr	r3, [r4, #8]
   1c56e:	2b00      	cmp	r3, #0
   1c570:	f000 80bd 	beq.w	1c6ee <process_event+0x1de>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   1c574:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   1c578:	8321      	strh	r1, [r4, #24]
   1c57a:	f388 8811 	msr	BASEPRI, r8
   1c57e:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   1c582:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   1c584:	2900      	cmp	r1, #0
   1c586:	f000 80bb 	beq.w	1c700 <process_event+0x1f0>
	return node->next;
   1c58a:	680d      	ldr	r5, [r1, #0]
   1c58c:	2900      	cmp	r1, #0
   1c58e:	f000 80b7 	beq.w	1c700 <process_event+0x1f0>
		mon->callback(mgr, mon, state, res);
   1c592:	4633      	mov	r3, r6
   1c594:	4652      	mov	r2, sl
   1c596:	4620      	mov	r0, r4
   1c598:	f8d1 8004 	ldr.w	r8, [r1, #4]
   1c59c:	47c0      	blx	r8
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   1c59e:	2d00      	cmp	r5, #0
   1c5a0:	d076      	beq.n	1c690 <process_event+0x180>
   1c5a2:	682b      	ldr	r3, [r5, #0]
   1c5a4:	4629      	mov	r1, r5
   1c5a6:	461d      	mov	r5, r3
   1c5a8:	e7f0      	b.n	1c58c <process_event+0x7c>
   1c5aa:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   1c5ae:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   1c5b0:	2a01      	cmp	r2, #1
   1c5b2:	d81b      	bhi.n	1c5ec <process_event+0xdc>
	list->head = NULL;
   1c5b4:	2200      	movs	r2, #0
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5b6:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   1c5ba:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   1c5bc:	6827      	ldr	r7, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5be:	b289      	uxth	r1, r1
	list->tail = NULL;
   1c5c0:	e9c4 2200 	strd	r2, r2, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   1c5c4:	d109      	bne.n	1c5da <process_event+0xca>
   1c5c6:	463b      	mov	r3, r7
   1c5c8:	e003      	b.n	1c5d2 <process_event+0xc2>
				mgr->refs += 1U;
   1c5ca:	8b62      	ldrh	r2, [r4, #26]
   1c5cc:	3201      	adds	r2, #1
   1c5ce:	8362      	strh	r2, [r4, #26]
	return node->next;
   1c5d0:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   1c5d2:	2b00      	cmp	r3, #0
   1c5d4:	d1f9      	bne.n	1c5ca <process_event+0xba>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5d6:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
   1c5da:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c5dc:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   1c5de:	f008 f94d 	bl	2487c <process_recheck>
   1c5e2:	2800      	cmp	r0, #0
   1c5e4:	d07b      	beq.n	1c6de <process_event+0x1ce>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c5e6:	f041 0120 	orr.w	r1, r1, #32
   1c5ea:	e077      	b.n	1c6dc <process_event+0x1cc>
	} else if (state == ONOFF_STATE_TO_OFF) {
   1c5ec:	2b04      	cmp	r3, #4
   1c5ee:	d10a      	bne.n	1c606 <process_event+0xf6>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5f0:	f021 0107 	bic.w	r1, r1, #7
   1c5f4:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
   1c5f6:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c5f8:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   1c5fa:	f008 f93f 	bl	2487c <process_recheck>
   1c5fe:	b110      	cbz	r0, 1c606 <process_event+0xf6>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c600:	f041 0120 	orr.w	r1, r1, #32
   1c604:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c606:	8b21      	ldrh	r1, [r4, #24]
   1c608:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1c60c:	45aa      	cmp	sl, r5
   1c60e:	d050      	beq.n	1c6b2 <process_event+0x1a2>
   1c610:	2700      	movs	r7, #0
		onoff_transition_fn transit = NULL;
   1c612:	46b9      	mov	r9, r7
   1c614:	e7aa      	b.n	1c56c <process_event+0x5c>
			transit = mgr->transitions->start;
   1c616:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c618:	f021 0107 	bic.w	r1, r1, #7
   1c61c:	f041 0106 	orr.w	r1, r1, #6
				   && !sys_slist_is_empty(&mgr->monitors);
   1c620:	2d06      	cmp	r5, #6
			transit = mgr->transitions->start;
   1c622:	f8d3 9000 	ldr.w	r9, [r3]
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c626:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   1c628:	d12d      	bne.n	1c686 <process_event+0x176>
		    || (transit != NULL)) {
   1c62a:	f1b9 0f00 	cmp.w	r9, #0
   1c62e:	d040      	beq.n	1c6b2 <process_event+0x1a2>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   1c630:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   1c634:	8321      	strh	r1, [r4, #24]
   1c636:	f388 8811 	msr	BASEPRI, r8
   1c63a:	f3bf 8f6f 	isb	sy
				transit(mgr, transition_complete);
   1c63e:	4620      	mov	r0, r4
   1c640:	4939      	ldr	r1, [pc, #228]	; (1c728 <process_event+0x218>)
   1c642:	47c8      	blx	r9
   1c644:	e029      	b.n	1c69a <process_event+0x18a>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c646:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->stop;
   1c64a:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c64c:	f041 0104 	orr.w	r1, r1, #4
   1c650:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
   1c652:	2d04      	cmp	r5, #4
			transit = mgr->transitions->stop;
   1c654:	f8d3 9004 	ldr.w	r9, [r3, #4]
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c658:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   1c65a:	d0e6      	beq.n	1c62a <process_event+0x11a>
   1c65c:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c65e:	f04f 0a04 	mov.w	sl, #4
		res = 0;
   1c662:	463e      	mov	r6, r7
   1c664:	e782      	b.n	1c56c <process_event+0x5c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c666:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->reset;
   1c66a:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c66c:	f041 0105 	orr.w	r1, r1, #5
   1c670:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
   1c672:	2d05      	cmp	r5, #5
			transit = mgr->transitions->reset;
   1c674:	f8d3 9008 	ldr.w	r9, [r3, #8]
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c678:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   1c67a:	d0d6      	beq.n	1c62a <process_event+0x11a>
   1c67c:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c67e:	f04f 0a05 	mov.w	sl, #5
		res = 0;
   1c682:	463e      	mov	r6, r7
   1c684:	e772      	b.n	1c56c <process_event+0x5c>
				   && !sys_slist_is_empty(&mgr->monitors);
   1c686:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c688:	f04f 0a06 	mov.w	sl, #6
		res = 0;
   1c68c:	463e      	mov	r6, r7
   1c68e:	e76d      	b.n	1c56c <process_event+0x5c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   1c690:	462b      	mov	r3, r5
   1c692:	e787      	b.n	1c5a4 <process_event+0x94>
			if (transit != NULL) {
   1c694:	f1b9 0f00 	cmp.w	r9, #0
   1c698:	d1d1      	bne.n	1c63e <process_event+0x12e>
	__asm__ volatile(
   1c69a:	f04f 0320 	mov.w	r3, #32
   1c69e:	f3ef 8811 	mrs	r8, BASEPRI
   1c6a2:	f383 8812 	msr	BASEPRI_MAX, r3
   1c6a6:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   1c6aa:	8b23      	ldrh	r3, [r4, #24]
   1c6ac:	f023 0308 	bic.w	r3, r3, #8
   1c6b0:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   1c6b2:	8b25      	ldrh	r5, [r4, #24]
   1c6b4:	06ea      	lsls	r2, r5, #27
   1c6b6:	d52e      	bpl.n	1c716 <process_event+0x206>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   1c6b8:	f025 0310 	bic.w	r3, r5, #16
   1c6bc:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   1c6be:	f005 0507 	and.w	r5, r5, #7
			res = mgr->last_res;
   1c6c2:	6966      	ldr	r6, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1c6c4:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   1c6c6:	2e00      	cmp	r6, #0
   1c6c8:	f6bf af6f 	bge.w	1c5aa <process_event+0x9a>
	list->head = NULL;
   1c6cc:	2300      	movs	r3, #0
		*clients = mgr->clients;
   1c6ce:	6827      	ldr	r7, [r4, #0]
	list->tail = NULL;
   1c6d0:	e9c4 3300 	strd	r3, r3, [r4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c6d4:	f021 0107 	bic.w	r1, r1, #7
   1c6d8:	f041 0101 	orr.w	r1, r1, #1
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c6dc:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c6de:	8b21      	ldrh	r1, [r4, #24]
   1c6e0:	f04f 0900 	mov.w	r9, #0
   1c6e4:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1c6e8:	45aa      	cmp	sl, r5
   1c6ea:	f47f af3f 	bne.w	1c56c <process_event+0x5c>
		    || !sys_slist_is_empty(&clients)
   1c6ee:	2f00      	cmp	r7, #0
   1c6f0:	d09b      	beq.n	1c62a <process_event+0x11a>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   1c6f2:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   1c6f6:	8321      	strh	r1, [r4, #24]
	__asm__ volatile(
   1c6f8:	f388 8811 	msr	BASEPRI, r8
   1c6fc:	f3bf 8f6f 	isb	sy
			if (!sys_slist_is_empty(&clients)) {
   1c700:	2f00      	cmp	r7, #0
   1c702:	d0c7      	beq.n	1c694 <process_event+0x184>
	return node->next;
   1c704:	683d      	ldr	r5, [r7, #0]
		notify_one(mgr, cli, state, res);
   1c706:	4639      	mov	r1, r7
   1c708:	4633      	mov	r3, r6
   1c70a:	4652      	mov	r2, sl
   1c70c:	4620      	mov	r0, r4
   1c70e:	f008 f8e1 	bl	248d4 <notify_one>
	list->head = node;
   1c712:	462f      	mov	r7, r5
	while (!sys_slist_is_empty(list)) {
   1c714:	e7f4      	b.n	1c700 <process_event+0x1f0>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   1c716:	06ab      	lsls	r3, r5, #26
   1c718:	f57f af1a 	bpl.w	1c550 <process_event+0x40>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   1c71c:	f025 0320 	bic.w	r3, r5, #32
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   1c720:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   1c722:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
   1c726:	e6ff      	b.n	1c528 <process_event+0x18>
   1c728:	00024901 	.word	0x00024901

0001c72c <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
   1c72c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c730:	4681      	mov	r9, r0
   1c732:	468b      	mov	fp, r1
   1c734:	4617      	mov	r7, r2
   1c736:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   1c738:	2500      	movs	r5, #0
{
   1c73a:	b095      	sub	sp, #84	; 0x54
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   1c73c:	7838      	ldrb	r0, [r7, #0]
   1c73e:	b908      	cbnz	r0, 1c744 <z_cbvprintf_impl+0x18>
			OUTC(' ');
			--width;
		}
	}

	return count;
   1c740:	4628      	mov	r0, r5
   1c742:	e357      	b.n	1cdf4 <z_cbvprintf_impl+0x6c8>
			OUTC(*fp++);
   1c744:	1c7b      	adds	r3, r7, #1
		if (*fp != '%') {
   1c746:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
   1c748:	9303      	str	r3, [sp, #12]
		if (*fp != '%') {
   1c74a:	d006      	beq.n	1c75a <z_cbvprintf_impl+0x2e>
			OUTC('%');
   1c74c:	4659      	mov	r1, fp
   1c74e:	47c8      	blx	r9
   1c750:	2800      	cmp	r0, #0
   1c752:	f2c0 834f 	blt.w	1cdf4 <z_cbvprintf_impl+0x6c8>
   1c756:	3501      	adds	r5, #1
		if (bps == NULL) {
   1c758:	e1fb      	b.n	1cb52 <z_cbvprintf_impl+0x426>
		} state = {
   1c75a:	2218      	movs	r2, #24
   1c75c:	2100      	movs	r1, #0
   1c75e:	a80e      	add	r0, sp, #56	; 0x38
   1c760:	f008 fc56 	bl	25010 <memset>
	if (*sp == '%') {
   1c764:	787b      	ldrb	r3, [r7, #1]
   1c766:	2b25      	cmp	r3, #37	; 0x25
   1c768:	d07d      	beq.n	1c866 <z_cbvprintf_impl+0x13a>
   1c76a:	2300      	movs	r3, #0
   1c76c:	4698      	mov	r8, r3
   1c76e:	469e      	mov	lr, r3
   1c770:	469c      	mov	ip, r3
   1c772:	461e      	mov	r6, r3
   1c774:	1c78      	adds	r0, r7, #1
   1c776:	4601      	mov	r1, r0
		switch (*sp) {
   1c778:	f810 2b01 	ldrb.w	r2, [r0], #1
   1c77c:	2a2b      	cmp	r2, #43	; 0x2b
   1c77e:	f000 80a1 	beq.w	1c8c4 <z_cbvprintf_impl+0x198>
   1c782:	f200 8098 	bhi.w	1c8b6 <z_cbvprintf_impl+0x18a>
   1c786:	2a20      	cmp	r2, #32
   1c788:	f000 809f 	beq.w	1c8ca <z_cbvprintf_impl+0x19e>
   1c78c:	2a23      	cmp	r2, #35	; 0x23
   1c78e:	f000 809f 	beq.w	1c8d0 <z_cbvprintf_impl+0x1a4>
   1c792:	b12b      	cbz	r3, 1c7a0 <z_cbvprintf_impl+0x74>
   1c794:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c798:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1c79c:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c7a0:	f1b8 0f00 	cmp.w	r8, #0
   1c7a4:	d005      	beq.n	1c7b2 <z_cbvprintf_impl+0x86>
   1c7a6:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7aa:	f043 0320 	orr.w	r3, r3, #32
   1c7ae:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c7b2:	f1be 0f00 	cmp.w	lr, #0
   1c7b6:	d005      	beq.n	1c7c4 <z_cbvprintf_impl+0x98>
   1c7b8:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7bc:	f043 0310 	orr.w	r3, r3, #16
   1c7c0:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c7c4:	f1bc 0f00 	cmp.w	ip, #0
   1c7c8:	d005      	beq.n	1c7d6 <z_cbvprintf_impl+0xaa>
   1c7ca:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7ce:	f043 0308 	orr.w	r3, r3, #8
   1c7d2:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c7d6:	b12e      	cbz	r6, 1c7e4 <z_cbvprintf_impl+0xb8>
   1c7d8:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7dc:	f043 0304 	orr.w	r3, r3, #4
   1c7e0:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (conv->flag_zero && conv->flag_dash) {
   1c7e4:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7e8:	f003 0044 	and.w	r0, r3, #68	; 0x44
   1c7ec:	2844      	cmp	r0, #68	; 0x44
   1c7ee:	d103      	bne.n	1c7f8 <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
   1c7f0:	f36f 1386 	bfc	r3, #6, #1
   1c7f4:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	conv->width_present = true;
   1c7f8:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
   1c7fc:	2a2a      	cmp	r2, #42	; 0x2a
	conv->width_present = true;
   1c7fe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1c802:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
   1c806:	d17f      	bne.n	1c908 <z_cbvprintf_impl+0x1dc>
		conv->width_star = true;
   1c808:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
   1c80c:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
   1c80e:	f042 0201 	orr.w	r2, r2, #1
   1c812:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	conv->prec_present = (*sp == '.');
   1c816:	781a      	ldrb	r2, [r3, #0]
   1c818:	2a2e      	cmp	r2, #46	; 0x2e
   1c81a:	bf0c      	ite	eq
   1c81c:	2101      	moveq	r1, #1
   1c81e:	2100      	movne	r1, #0
   1c820:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c824:	f361 0241 	bfi	r2, r1, #1, #1
   1c828:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	if (!conv->prec_present) {
   1c82c:	d178      	bne.n	1c920 <z_cbvprintf_impl+0x1f4>
	if (*sp == '*') {
   1c82e:	785a      	ldrb	r2, [r3, #1]
   1c830:	2a2a      	cmp	r2, #42	; 0x2a
   1c832:	d06e      	beq.n	1c912 <z_cbvprintf_impl+0x1e6>
	size_t val = 0;
   1c834:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   1c836:	f04f 0c0a 	mov.w	ip, #10
	++sp;
   1c83a:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   1c83c:	4619      	mov	r1, r3
   1c83e:	f811 0b01 	ldrb.w	r0, [r1], #1
   1c842:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
   1c846:	2e09      	cmp	r6, #9
   1c848:	f240 8095 	bls.w	1c976 <z_cbvprintf_impl+0x24a>
	conv->unsupported |= ((conv->prec_value < 0)
   1c84c:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	conv->prec_value = prec;
   1c850:	9212      	str	r2, [sp, #72]	; 0x48
	conv->unsupported |= ((conv->prec_value < 0)
   1c852:	f3c1 0040 	ubfx	r0, r1, #1, #1
   1c856:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
   1c85a:	460a      	mov	r2, r1
   1c85c:	f360 0241 	bfi	r2, r0, #1, #1
   1c860:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
   1c864:	e05c      	b.n	1c920 <z_cbvprintf_impl+0x1f4>
		conv->specifier = *sp++;
   1c866:	1cba      	adds	r2, r7, #2
   1c868:	9203      	str	r2, [sp, #12]
   1c86a:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->width_star) {
   1c86e:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
   1c872:	07da      	lsls	r2, r3, #31
   1c874:	f140 812e 	bpl.w	1cad4 <z_cbvprintf_impl+0x3a8>
			width = va_arg(ap, int);
   1c878:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
   1c87c:	f1b8 0f00 	cmp.w	r8, #0
   1c880:	da07      	bge.n	1c892 <z_cbvprintf_impl+0x166>
				conv->flag_dash = true;
   1c882:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				width = -width;
   1c886:	f1c8 0800 	rsb	r8, r8, #0
				conv->flag_dash = true;
   1c88a:	f042 0204 	orr.w	r2, r2, #4
   1c88e:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
		if (conv->prec_star) {
   1c892:	075e      	lsls	r6, r3, #29
   1c894:	f140 8127 	bpl.w	1cae6 <z_cbvprintf_impl+0x3ba>
			int arg = va_arg(ap, int);
   1c898:	f854 ab04 	ldr.w	sl, [r4], #4
			if (arg < 0) {
   1c89c:	f1ba 0f00 	cmp.w	sl, #0
   1c8a0:	f280 8126 	bge.w	1caf0 <z_cbvprintf_impl+0x3c4>
				conv->prec_present = false;
   1c8a4:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
   1c8a8:	f36f 0341 	bfc	r3, #1, #1
   1c8ac:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
		int precision = -1;
   1c8b0:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
   1c8b4:	e11c      	b.n	1caf0 <z_cbvprintf_impl+0x3c4>
		switch (*sp) {
   1c8b6:	2a2d      	cmp	r2, #45	; 0x2d
   1c8b8:	d00d      	beq.n	1c8d6 <z_cbvprintf_impl+0x1aa>
   1c8ba:	2a30      	cmp	r2, #48	; 0x30
   1c8bc:	f47f af69 	bne.w	1c792 <z_cbvprintf_impl+0x66>
   1c8c0:	2301      	movs	r3, #1
	} while (loop);
   1c8c2:	e758      	b.n	1c776 <z_cbvprintf_impl+0x4a>
		switch (*sp) {
   1c8c4:	f04f 0c01 	mov.w	ip, #1
   1c8c8:	e755      	b.n	1c776 <z_cbvprintf_impl+0x4a>
   1c8ca:	f04f 0e01 	mov.w	lr, #1
   1c8ce:	e752      	b.n	1c776 <z_cbvprintf_impl+0x4a>
   1c8d0:	f04f 0801 	mov.w	r8, #1
   1c8d4:	e74f      	b.n	1c776 <z_cbvprintf_impl+0x4a>
   1c8d6:	2601      	movs	r6, #1
   1c8d8:	e74d      	b.n	1c776 <z_cbvprintf_impl+0x4a>
		val = 10U * val + *sp++ - '0';
   1c8da:	4603      	mov	r3, r0
   1c8dc:	fb0e 6202 	mla	r2, lr, r2, r6
   1c8e0:	3a30      	subs	r2, #48	; 0x30
   1c8e2:	4618      	mov	r0, r3
   1c8e4:	f810 6b01 	ldrb.w	r6, [r0], #1
   1c8e8:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
   1c8ec:	f1bc 0f09 	cmp.w	ip, #9
   1c8f0:	d9f3      	bls.n	1c8da <z_cbvprintf_impl+0x1ae>
	if (sp != wp) {
   1c8f2:	4299      	cmp	r1, r3
   1c8f4:	d08f      	beq.n	1c816 <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
   1c8f6:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
		conv->width_value = width;
   1c8fa:	9211      	str	r2, [sp, #68]	; 0x44
				      || (width != (size_t)conv->width_value));
   1c8fc:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
   1c8fe:	f362 0141 	bfi	r1, r2, #1, #1
   1c902:	f88d 1040 	strb.w	r1, [sp, #64]	; 0x40
   1c906:	e786      	b.n	1c816 <z_cbvprintf_impl+0xea>
   1c908:	460b      	mov	r3, r1
	size_t val = 0;
   1c90a:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   1c90c:	f04f 0e0a 	mov.w	lr, #10
   1c910:	e7e7      	b.n	1c8e2 <z_cbvprintf_impl+0x1b6>
		conv->prec_star = true;
   1c912:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
   1c916:	3302      	adds	r3, #2
		conv->prec_star = true;
   1c918:	f042 0204 	orr.w	r2, r2, #4
   1c91c:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	switch (*sp) {
   1c920:	781a      	ldrb	r2, [r3, #0]
   1c922:	2a6c      	cmp	r2, #108	; 0x6c
   1c924:	d047      	beq.n	1c9b6 <z_cbvprintf_impl+0x28a>
   1c926:	d82b      	bhi.n	1c980 <z_cbvprintf_impl+0x254>
   1c928:	2a68      	cmp	r2, #104	; 0x68
   1c92a:	d031      	beq.n	1c990 <z_cbvprintf_impl+0x264>
   1c92c:	2a6a      	cmp	r2, #106	; 0x6a
   1c92e:	d04b      	beq.n	1c9c8 <z_cbvprintf_impl+0x29c>
   1c930:	2a4c      	cmp	r2, #76	; 0x4c
   1c932:	d051      	beq.n	1c9d8 <z_cbvprintf_impl+0x2ac>
	conv->specifier = *sp++;
   1c934:	461a      	mov	r2, r3
   1c936:	f812 3b01 	ldrb.w	r3, [r2], #1
	switch (conv->specifier) {
   1c93a:	2b78      	cmp	r3, #120	; 0x78
	conv->specifier = *sp++;
   1c93c:	9203      	str	r2, [sp, #12]
   1c93e:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->length_mod == LENGTH_UPPER_L) {
   1c942:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
	switch (conv->specifier) {
   1c946:	f200 80be 	bhi.w	1cac6 <z_cbvprintf_impl+0x39a>
   1c94a:	2b6d      	cmp	r3, #109	; 0x6d
   1c94c:	d851      	bhi.n	1c9f2 <z_cbvprintf_impl+0x2c6>
   1c94e:	2b69      	cmp	r3, #105	; 0x69
   1c950:	f200 80b9 	bhi.w	1cac6 <z_cbvprintf_impl+0x39a>
   1c954:	2b57      	cmp	r3, #87	; 0x57
   1c956:	d867      	bhi.n	1ca28 <z_cbvprintf_impl+0x2fc>
   1c958:	2b41      	cmp	r3, #65	; 0x41
   1c95a:	d003      	beq.n	1c964 <z_cbvprintf_impl+0x238>
   1c95c:	3b45      	subs	r3, #69	; 0x45
   1c95e:	2b02      	cmp	r3, #2
   1c960:	f200 80b1 	bhi.w	1cac6 <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_FP;
   1c964:	2204      	movs	r2, #4
   1c966:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1c96a:	f362 0302 	bfi	r3, r2, #0, #3
   1c96e:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
			unsupported = true;
   1c972:	2301      	movs	r3, #1
			break;
   1c974:	e073      	b.n	1ca5e <z_cbvprintf_impl+0x332>
		val = 10U * val + *sp++ - '0';
   1c976:	fb0c 0202 	mla	r2, ip, r2, r0
   1c97a:	460b      	mov	r3, r1
   1c97c:	3a30      	subs	r2, #48	; 0x30
   1c97e:	e75d      	b.n	1c83c <z_cbvprintf_impl+0x110>
	switch (*sp) {
   1c980:	2a74      	cmp	r2, #116	; 0x74
   1c982:	d025      	beq.n	1c9d0 <z_cbvprintf_impl+0x2a4>
   1c984:	2a7a      	cmp	r2, #122	; 0x7a
   1c986:	d1d5      	bne.n	1c934 <z_cbvprintf_impl+0x208>
		conv->length_mod = LENGTH_Z;
   1c988:	2106      	movs	r1, #6
   1c98a:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c98e:	e00c      	b.n	1c9aa <z_cbvprintf_impl+0x27e>
		if (*++sp == 'h') {
   1c990:	785a      	ldrb	r2, [r3, #1]
   1c992:	2a68      	cmp	r2, #104	; 0x68
   1c994:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c998:	d106      	bne.n	1c9a8 <z_cbvprintf_impl+0x27c>
			conv->length_mod = LENGTH_HH;
   1c99a:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
   1c99c:	f361 02c6 	bfi	r2, r1, #3, #4
   1c9a0:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
			++sp;
   1c9a4:	3302      	adds	r3, #2
   1c9a6:	e7c5      	b.n	1c934 <z_cbvprintf_impl+0x208>
			conv->length_mod = LENGTH_H;
   1c9a8:	2102      	movs	r1, #2
   1c9aa:	f361 02c6 	bfi	r2, r1, #3, #4
   1c9ae:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		if (*++sp == 'h') {
   1c9b2:	3301      	adds	r3, #1
   1c9b4:	e7be      	b.n	1c934 <z_cbvprintf_impl+0x208>
		if (*++sp == 'l') {
   1c9b6:	785a      	ldrb	r2, [r3, #1]
   1c9b8:	2a6c      	cmp	r2, #108	; 0x6c
   1c9ba:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c9be:	d101      	bne.n	1c9c4 <z_cbvprintf_impl+0x298>
			conv->length_mod = LENGTH_LL;
   1c9c0:	2104      	movs	r1, #4
   1c9c2:	e7eb      	b.n	1c99c <z_cbvprintf_impl+0x270>
			conv->length_mod = LENGTH_L;
   1c9c4:	2103      	movs	r1, #3
   1c9c6:	e7f0      	b.n	1c9aa <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_J;
   1c9c8:	2105      	movs	r1, #5
   1c9ca:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c9ce:	e7ec      	b.n	1c9aa <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_T;
   1c9d0:	2107      	movs	r1, #7
   1c9d2:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c9d6:	e7e8      	b.n	1c9aa <z_cbvprintf_impl+0x27e>
		conv->unsupported = true;
   1c9d8:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
   1c9dc:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
   1c9e0:	f022 0202 	bic.w	r2, r2, #2
   1c9e4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   1c9e8:	f042 0202 	orr.w	r2, r2, #2
   1c9ec:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
		break;
   1c9f0:	e7df      	b.n	1c9b2 <z_cbvprintf_impl+0x286>
	switch (conv->specifier) {
   1c9f2:	3b6e      	subs	r3, #110	; 0x6e
   1c9f4:	b2d9      	uxtb	r1, r3
   1c9f6:	2301      	movs	r3, #1
   1c9f8:	408b      	lsls	r3, r1
   1c9fa:	f240 4182 	movw	r1, #1154	; 0x482
   1c9fe:	420b      	tst	r3, r1
   1ca00:	d137      	bne.n	1ca72 <z_cbvprintf_impl+0x346>
   1ca02:	f013 0f24 	tst.w	r3, #36	; 0x24
   1ca06:	d151      	bne.n	1caac <z_cbvprintf_impl+0x380>
   1ca08:	07d8      	lsls	r0, r3, #31
   1ca0a:	d55c      	bpl.n	1cac6 <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_PTR;
   1ca0c:	2103      	movs	r1, #3
   1ca0e:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ca12:	f361 0302 	bfi	r3, r1, #0, #3
   1ca16:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca1a:	f002 0378 	and.w	r3, r2, #120	; 0x78
   1ca1e:	f1a3 0140 	sub.w	r1, r3, #64	; 0x40
   1ca22:	424b      	negs	r3, r1
   1ca24:	414b      	adcs	r3, r1
   1ca26:	e01a      	b.n	1ca5e <z_cbvprintf_impl+0x332>
   1ca28:	2001      	movs	r0, #1
	switch (conv->specifier) {
   1ca2a:	f1a3 0158 	sub.w	r1, r3, #88	; 0x58
   1ca2e:	b2c9      	uxtb	r1, r1
   1ca30:	fa00 f101 	lsl.w	r1, r0, r1
   1ca34:	f411 4f62 	tst.w	r1, #57856	; 0xe200
   1ca38:	d194      	bne.n	1c964 <z_cbvprintf_impl+0x238>
   1ca3a:	f640 0601 	movw	r6, #2049	; 0x801
   1ca3e:	4231      	tst	r1, r6
   1ca40:	d11d      	bne.n	1ca7e <z_cbvprintf_impl+0x352>
   1ca42:	f411 3f04 	tst.w	r1, #135168	; 0x21000
   1ca46:	d03e      	beq.n	1cac6 <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_SINT;
   1ca48:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ca4c:	f360 0302 	bfi	r3, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca50:	f002 0278 	and.w	r2, r2, #120	; 0x78
   1ca54:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_SINT;
   1ca56:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca5a:	d034      	beq.n	1cac6 <z_cbvprintf_impl+0x39a>
	bool unsupported = false;
   1ca5c:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
   1ca5e:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
   1ca62:	f3c2 0140 	ubfx	r1, r2, #1, #1
   1ca66:	430b      	orrs	r3, r1
   1ca68:	f363 0241 	bfi	r2, r3, #1, #1
   1ca6c:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
   1ca70:	e6fd      	b.n	1c86e <z_cbvprintf_impl+0x142>
		conv->specifier_cat = SPECIFIER_UINT;
   1ca72:	2102      	movs	r1, #2
   1ca74:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ca78:	f361 0302 	bfi	r3, r1, #0, #3
   1ca7c:	e7e8      	b.n	1ca50 <z_cbvprintf_impl+0x324>
   1ca7e:	2002      	movs	r0, #2
   1ca80:	f89d 1042 	ldrb.w	r1, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca84:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
   1ca88:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca8c:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
   1ca8e:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
			conv->invalid = true;
   1ca92:	bf02      	ittt	eq
   1ca94:	f89d 1040 	ldrbeq.w	r1, [sp, #64]	; 0x40
   1ca98:	f041 0101 	orreq.w	r1, r1, #1
   1ca9c:	f88d 1040 	strbeq.w	r1, [sp, #64]	; 0x40
		if (conv->specifier == 'c') {
   1caa0:	2b63      	cmp	r3, #99	; 0x63
   1caa2:	d1db      	bne.n	1ca5c <z_cbvprintf_impl+0x330>
			unsupported = (conv->length_mod != LENGTH_NONE);
   1caa4:	1e13      	subs	r3, r2, #0
   1caa6:	bf18      	it	ne
   1caa8:	2301      	movne	r3, #1
   1caaa:	e7d8      	b.n	1ca5e <z_cbvprintf_impl+0x332>
		conv->specifier_cat = SPECIFIER_PTR;
   1caac:	2103      	movs	r1, #3
   1caae:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
   1cab2:	f012 0f78 	tst.w	r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
   1cab6:	f361 0302 	bfi	r3, r1, #0, #3
   1caba:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
   1cabe:	bf14      	ite	ne
   1cac0:	2301      	movne	r3, #1
   1cac2:	2300      	moveq	r3, #0
   1cac4:	e7cb      	b.n	1ca5e <z_cbvprintf_impl+0x332>
		conv->invalid = true;
   1cac6:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1caca:	f043 0301 	orr.w	r3, r3, #1
   1cace:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
		break;
   1cad2:	e7c3      	b.n	1ca5c <z_cbvprintf_impl+0x330>
		} else if (conv->width_present) {
   1cad4:	f99d 2040 	ldrsb.w	r2, [sp, #64]	; 0x40
   1cad8:	2a00      	cmp	r2, #0
		int width = -1;
   1cada:	bfac      	ite	ge
   1cadc:	f04f 38ff 	movge.w	r8, #4294967295	; 0xffffffff
			width = conv->width_value;
   1cae0:	f8dd 8044 	ldrlt.w	r8, [sp, #68]	; 0x44
   1cae4:	e6d5      	b.n	1c892 <z_cbvprintf_impl+0x166>
		} else if (conv->prec_present) {
   1cae6:	0798      	lsls	r0, r3, #30
   1cae8:	f57f aee2 	bpl.w	1c8b0 <z_cbvprintf_impl+0x184>
			precision = conv->prec_value;
   1caec:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
		conv->pad0_value = 0;
   1caf0:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
   1caf2:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
			= (enum specifier_cat_enum)conv->specifier_cat;
   1caf6:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
			= (enum length_mod_enum)conv->length_mod;
   1cafa:	f89d 1041 	ldrb.w	r1, [sp, #65]	; 0x41
		enum specifier_cat_enum specifier_cat
   1cafe:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
   1cb02:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
   1cb04:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
   1cb08:	d133      	bne.n	1cb72 <z_cbvprintf_impl+0x446>
			switch (length_mod) {
   1cb0a:	1ecb      	subs	r3, r1, #3
   1cb0c:	2b04      	cmp	r3, #4
   1cb0e:	d804      	bhi.n	1cb1a <z_cbvprintf_impl+0x3ee>
   1cb10:	e8df f003 	tbb	[pc, r3]
   1cb14:	21464621 	.word	0x21464621
   1cb18:	21          	.byte	0x21
   1cb19:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
   1cb1a:	6823      	ldr	r3, [r4, #0]
			if (length_mod == LENGTH_HH) {
   1cb1c:	2901      	cmp	r1, #1
				value->sint = va_arg(ap, int);
   1cb1e:	ea4f 72e3 	mov.w	r2, r3, asr #31
   1cb22:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
   1cb26:	d11c      	bne.n	1cb62 <z_cbvprintf_impl+0x436>
				value->sint = (signed char)value->sint;
   1cb28:	f99d 3038 	ldrsb.w	r3, [sp, #56]	; 0x38
   1cb2c:	17da      	asrs	r2, r3, #31
   1cb2e:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
				value->sint = va_arg(ap, int);
   1cb32:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
   1cb34:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1cb38:	f013 0603 	ands.w	r6, r3, #3
   1cb3c:	d050      	beq.n	1cbe0 <z_cbvprintf_impl+0x4b4>
			OUTS(sp, fp);
   1cb3e:	463a      	mov	r2, r7
   1cb40:	4659      	mov	r1, fp
   1cb42:	4648      	mov	r0, r9
   1cb44:	9b03      	ldr	r3, [sp, #12]
   1cb46:	f007 fff9 	bl	24b3c <outs>
   1cb4a:	2800      	cmp	r0, #0
   1cb4c:	f2c0 8152 	blt.w	1cdf4 <z_cbvprintf_impl+0x6c8>
   1cb50:	4405      	add	r5, r0
			continue;
   1cb52:	9f03      	ldr	r7, [sp, #12]
   1cb54:	e5f2      	b.n	1c73c <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   1cb56:	f854 3b04 	ldr.w	r3, [r4], #4
   1cb5a:	17da      	asrs	r2, r3, #31
				value->uint = (unsigned char)value->uint;
   1cb5c:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
   1cb60:	e7e8      	b.n	1cb34 <z_cbvprintf_impl+0x408>
			} else if (length_mod == LENGTH_H) {
   1cb62:	2902      	cmp	r1, #2
   1cb64:	d1e5      	bne.n	1cb32 <z_cbvprintf_impl+0x406>
				value->sint = (short)value->sint;
   1cb66:	b21a      	sxth	r2, r3
   1cb68:	f343 33c0 	sbfx	r3, r3, #15, #1
   1cb6c:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   1cb70:	e7df      	b.n	1cb32 <z_cbvprintf_impl+0x406>
		} else if (specifier_cat == SPECIFIER_UINT) {
   1cb72:	2b02      	cmp	r3, #2
   1cb74:	d124      	bne.n	1cbc0 <z_cbvprintf_impl+0x494>
			switch (length_mod) {
   1cb76:	1ecb      	subs	r3, r1, #3
   1cb78:	2b04      	cmp	r3, #4
   1cb7a:	d804      	bhi.n	1cb86 <z_cbvprintf_impl+0x45a>
   1cb7c:	e8df f003 	tbb	[pc, r3]
   1cb80:	18101018 	.word	0x18101018
   1cb84:	18          	.byte	0x18
   1cb85:	00          	.byte	0x00
			if (length_mod == LENGTH_HH) {
   1cb86:	2901      	cmp	r1, #1
   1cb88:	f04f 0200 	mov.w	r2, #0
				value->uint = va_arg(ap, unsigned int);
   1cb8c:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
   1cb90:	d014      	beq.n	1cbbc <z_cbvprintf_impl+0x490>
			} else if (length_mod == LENGTH_H) {
   1cb92:	2902      	cmp	r1, #2
				value->uint = va_arg(ap, unsigned int);
   1cb94:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			} else if (length_mod == LENGTH_H) {
   1cb98:	d1cc      	bne.n	1cb34 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned short)value->uint;
   1cb9a:	b29b      	uxth	r3, r3
			value->ptr = va_arg(ap, void *);
   1cb9c:	930e      	str	r3, [sp, #56]	; 0x38
   1cb9e:	e7c9      	b.n	1cb34 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap,
   1cba0:	3407      	adds	r4, #7
   1cba2:	f024 0407 	bic.w	r4, r4, #7
				value->uint =
   1cba6:	e8f4 2302 	ldrd	r2, r3, [r4], #8
   1cbaa:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
   1cbae:	e7c1      	b.n	1cb34 <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap, size_t);
   1cbb0:	f854 3b04 	ldr.w	r3, [r4], #4
   1cbb4:	930e      	str	r3, [sp, #56]	; 0x38
   1cbb6:	2300      	movs	r3, #0
   1cbb8:	930f      	str	r3, [sp, #60]	; 0x3c
			} else if (length_mod == LENGTH_H) {
   1cbba:	e7bb      	b.n	1cb34 <z_cbvprintf_impl+0x408>
				value->uint = (unsigned char)value->uint;
   1cbbc:	b2db      	uxtb	r3, r3
   1cbbe:	e7cd      	b.n	1cb5c <z_cbvprintf_impl+0x430>
		} else if (specifier_cat == SPECIFIER_FP) {
   1cbc0:	2b04      	cmp	r3, #4
   1cbc2:	d108      	bne.n	1cbd6 <z_cbvprintf_impl+0x4aa>
					(sint_value_type)va_arg(ap, long long);
   1cbc4:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
   1cbc6:	f024 0407 	bic.w	r4, r4, #7
   1cbca:	e9d4 2300 	ldrd	r2, r3, [r4]
   1cbce:	3408      	adds	r4, #8
   1cbd0:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   1cbd4:	e7ae      	b.n	1cb34 <z_cbvprintf_impl+0x408>
		} else if (specifier_cat == SPECIFIER_PTR) {
   1cbd6:	2b03      	cmp	r3, #3
   1cbd8:	d1ac      	bne.n	1cb34 <z_cbvprintf_impl+0x408>
			value->ptr = va_arg(ap, void *);
   1cbda:	f854 3b04 	ldr.w	r3, [r4], #4
   1cbde:	e7dd      	b.n	1cb9c <z_cbvprintf_impl+0x470>
		switch (conv->specifier) {
   1cbe0:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
   1cbe4:	2878      	cmp	r0, #120	; 0x78
   1cbe6:	d8b4      	bhi.n	1cb52 <z_cbvprintf_impl+0x426>
   1cbe8:	2862      	cmp	r0, #98	; 0x62
   1cbea:	d81c      	bhi.n	1cc26 <z_cbvprintf_impl+0x4fa>
   1cbec:	2825      	cmp	r0, #37	; 0x25
   1cbee:	f43f adad 	beq.w	1c74c <z_cbvprintf_impl+0x20>
   1cbf2:	2858      	cmp	r0, #88	; 0x58
   1cbf4:	d1ad      	bne.n	1cb52 <z_cbvprintf_impl+0x426>
			bps = encode_uint(value->uint, conv, buf, bpe);
   1cbf6:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1cbfa:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cbfe:	9300      	str	r3, [sp, #0]
   1cc00:	aa10      	add	r2, sp, #64	; 0x40
   1cc02:	ab08      	add	r3, sp, #32
   1cc04:	f007 ff54 	bl	24ab0 <encode_uint>
			if (precision >= 0) {
   1cc08:	f1ba 0f00 	cmp.w	sl, #0
			bps = encode_uint(value->uint, conv, buf, bpe);
   1cc0c:	4607      	mov	r7, r0
			if (precision >= 0) {
   1cc0e:	f280 8099 	bge.w	1cd44 <z_cbvprintf_impl+0x618>
		if (bps == NULL) {
   1cc12:	2f00      	cmp	r7, #0
   1cc14:	d09d      	beq.n	1cb52 <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
   1cc16:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cc1a:	1bd8      	subs	r0, r3, r7
		if (sign != 0) {
   1cc1c:	2e00      	cmp	r6, #0
   1cc1e:	f000 80c0 	beq.w	1cda2 <z_cbvprintf_impl+0x676>
			nj_len += 1U;
   1cc22:	3001      	adds	r0, #1
   1cc24:	e0bd      	b.n	1cda2 <z_cbvprintf_impl+0x676>
		switch (conv->specifier) {
   1cc26:	3863      	subs	r0, #99	; 0x63
   1cc28:	2815      	cmp	r0, #21
   1cc2a:	d892      	bhi.n	1cb52 <z_cbvprintf_impl+0x426>
   1cc2c:	a201      	add	r2, pc, #4	; (adr r2, 1cc34 <z_cbvprintf_impl+0x508>)
   1cc2e:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
   1cc32:	bf00      	nop
   1cc34:	0001cd09 	.word	0x0001cd09
   1cc38:	0001cd1b 	.word	0x0001cd1b
   1cc3c:	0001cb53 	.word	0x0001cb53
   1cc40:	0001cb53 	.word	0x0001cb53
   1cc44:	0001cb53 	.word	0x0001cb53
   1cc48:	0001cb53 	.word	0x0001cb53
   1cc4c:	0001cd1b 	.word	0x0001cd1b
   1cc50:	0001cb53 	.word	0x0001cb53
   1cc54:	0001cb53 	.word	0x0001cb53
   1cc58:	0001cb53 	.word	0x0001cb53
   1cc5c:	0001cb53 	.word	0x0001cb53
   1cc60:	0001cda7 	.word	0x0001cda7
   1cc64:	0001cd3f 	.word	0x0001cd3f
   1cc68:	0001cd65 	.word	0x0001cd65
   1cc6c:	0001cb53 	.word	0x0001cb53
   1cc70:	0001cb53 	.word	0x0001cb53
   1cc74:	0001cc8d 	.word	0x0001cc8d
   1cc78:	0001cb53 	.word	0x0001cb53
   1cc7c:	0001cd3f 	.word	0x0001cd3f
   1cc80:	0001cb53 	.word	0x0001cb53
   1cc84:	0001cb53 	.word	0x0001cb53
   1cc88:	0001cd3f 	.word	0x0001cd3f
			if (precision >= 0) {
   1cc8c:	f1ba 0f00 	cmp.w	sl, #0
			bps = (const char *)value->ptr;
   1cc90:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			if (precision >= 0) {
   1cc92:	db35      	blt.n	1cd00 <z_cbvprintf_impl+0x5d4>
				len = strnlen(bps, precision);
   1cc94:	4651      	mov	r1, sl
   1cc96:	4638      	mov	r0, r7
   1cc98:	f008 f9a6 	bl	24fe8 <strnlen>
			bpe = bps + len;
   1cc9c:	eb07 0a00 	add.w	sl, r7, r0
		if (bps == NULL) {
   1cca0:	2f00      	cmp	r7, #0
   1cca2:	f43f af56 	beq.w	1cb52 <z_cbvprintf_impl+0x426>
		char sign = 0;
   1cca6:	2600      	movs	r6, #0
		if (conv->altform_0c) {
   1cca8:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ccac:	f013 0210 	ands.w	r2, r3, #16
   1ccb0:	9205      	str	r2, [sp, #20]
   1ccb2:	f000 8092 	beq.w	1cdda <z_cbvprintf_impl+0x6ae>
			nj_len += 2U;
   1ccb6:	3002      	adds	r0, #2
		if (conv->pad_fp) {
   1ccb8:	065b      	lsls	r3, r3, #25
		nj_len += conv->pad0_value;
   1ccba:	9a11      	ldr	r2, [sp, #68]	; 0x44
			nj_len += conv->pad0_pre_exp;
   1ccbc:	bf48      	it	mi
   1ccbe:	9b12      	ldrmi	r3, [sp, #72]	; 0x48
		nj_len += conv->pad0_value;
   1ccc0:	4410      	add	r0, r2
			nj_len += conv->pad0_pre_exp;
   1ccc2:	bf48      	it	mi
   1ccc4:	18c0      	addmi	r0, r0, r3
		if (width > 0) {
   1ccc6:	f1b8 0f00 	cmp.w	r8, #0
		nj_len += conv->pad0_value;
   1ccca:	9204      	str	r2, [sp, #16]
		if (width > 0) {
   1cccc:	f340 809f 	ble.w	1ce0e <z_cbvprintf_impl+0x6e2>
			if (!conv->flag_dash) {
   1ccd0:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
			width -= (int)nj_len;
   1ccd4:	eba8 0800 	sub.w	r8, r8, r0
			if (!conv->flag_dash) {
   1ccd8:	f3c2 0380 	ubfx	r3, r2, #2, #1
   1ccdc:	0750      	lsls	r0, r2, #29
   1ccde:	9306      	str	r3, [sp, #24]
   1cce0:	f100 8095 	bmi.w	1ce0e <z_cbvprintf_impl+0x6e2>
				if (conv->flag_zero) {
   1cce4:	0651      	lsls	r1, r2, #25
   1cce6:	f140 8088 	bpl.w	1cdfa <z_cbvprintf_impl+0x6ce>
					if (sign != 0) {
   1ccea:	b13e      	cbz	r6, 1ccfc <z_cbvprintf_impl+0x5d0>
						OUTC(sign);
   1ccec:	4659      	mov	r1, fp
   1ccee:	4630      	mov	r0, r6
   1ccf0:	47c8      	blx	r9
   1ccf2:	2800      	cmp	r0, #0
   1ccf4:	db7e      	blt.n	1cdf4 <z_cbvprintf_impl+0x6c8>
   1ccf6:	9b06      	ldr	r3, [sp, #24]
   1ccf8:	3501      	adds	r5, #1
   1ccfa:	461e      	mov	r6, r3
					pad = '0';
   1ccfc:	2230      	movs	r2, #48	; 0x30
   1ccfe:	e07d      	b.n	1cdfc <z_cbvprintf_impl+0x6d0>
				len = strlen(bps);
   1cd00:	4638      	mov	r0, r7
   1cd02:	f008 f96a 	bl	24fda <strlen>
   1cd06:	e7c9      	b.n	1cc9c <z_cbvprintf_impl+0x570>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   1cd08:	9b0e      	ldr	r3, [sp, #56]	; 0x38
		char sign = 0;
   1cd0a:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
   1cd0c:	2001      	movs	r0, #1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   1cd0e:	f88d 3020 	strb.w	r3, [sp, #32]
			bps = buf;
   1cd12:	af08      	add	r7, sp, #32
			bpe = buf + 1;
   1cd14:	f10d 0a21 	add.w	sl, sp, #33	; 0x21
   1cd18:	e7c6      	b.n	1cca8 <z_cbvprintf_impl+0x57c>
			if (conv->flag_plus) {
   1cd1a:	0719      	lsls	r1, r3, #28
			} else if (conv->flag_space) {
   1cd1c:	bf5a      	itte	pl
   1cd1e:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
   1cd22:	015e      	lslpl	r6, r3, #5
				sign = '+';
   1cd24:	262b      	movmi	r6, #43	; 0x2b
			sint = value->sint;
   1cd26:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
			if (sint < 0) {
   1cd2a:	2b00      	cmp	r3, #0
   1cd2c:	f6bf af63 	bge.w	1cbf6 <z_cbvprintf_impl+0x4ca>
				value->uint = (uint_value_type)-sint;
   1cd30:	4252      	negs	r2, r2
   1cd32:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
   1cd36:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
   1cd38:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   1cd3c:	e75b      	b.n	1cbf6 <z_cbvprintf_impl+0x4ca>
		switch (conv->specifier) {
   1cd3e:	2600      	movs	r6, #0
   1cd40:	e759      	b.n	1cbf6 <z_cbvprintf_impl+0x4ca>
		char sign = 0;
   1cd42:	2600      	movs	r6, #0
				conv->flag_zero = false;
   1cd44:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				size_t len = bpe - bps;
   1cd48:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cd4c:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
   1cd4e:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
   1cd52:	459a      	cmp	sl, r3
				conv->flag_zero = false;
   1cd54:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				if (len < (size_t)precision) {
   1cd58:	f67f af5b 	bls.w	1cc12 <z_cbvprintf_impl+0x4e6>
					conv->pad0_value = precision - (int)len;
   1cd5c:	ebaa 0303 	sub.w	r3, sl, r3
   1cd60:	9311      	str	r3, [sp, #68]	; 0x44
   1cd62:	e756      	b.n	1cc12 <z_cbvprintf_impl+0x4e6>
			if (value->ptr != NULL) {
   1cd64:	980e      	ldr	r0, [sp, #56]	; 0x38
   1cd66:	b390      	cbz	r0, 1cdce <z_cbvprintf_impl+0x6a2>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   1cd68:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cd6c:	9300      	str	r3, [sp, #0]
   1cd6e:	2100      	movs	r1, #0
   1cd70:	ab08      	add	r3, sp, #32
   1cd72:	aa10      	add	r2, sp, #64	; 0x40
   1cd74:	f007 fe9c 	bl	24ab0 <encode_uint>
				conv->altform_0c = true;
   1cd78:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
   1cd7c:	f1ba 0f00 	cmp.w	sl, #0
				conv->altform_0c = true;
   1cd80:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   1cd84:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
   1cd88:	f043 0310 	orr.w	r3, r3, #16
				bps = encode_uint((uintptr_t)value->ptr, conv,
   1cd8c:	4607      	mov	r7, r0
				conv->altform_0c = true;
   1cd8e:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
   1cd92:	dad6      	bge.n	1cd42 <z_cbvprintf_impl+0x616>
		if (bps == NULL) {
   1cd94:	2800      	cmp	r0, #0
   1cd96:	f43f aedc 	beq.w	1cb52 <z_cbvprintf_impl+0x426>
		char sign = 0;
   1cd9a:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
   1cd9c:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cda0:	1a18      	subs	r0, r3, r0
		if (sign != 0) {
   1cda2:	469a      	mov	sl, r3
   1cda4:	e780      	b.n	1cca8 <z_cbvprintf_impl+0x57c>
				store_count(conv, value->ptr, count);
   1cda6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	switch ((enum length_mod_enum)conv->length_mod) {
   1cda8:	2907      	cmp	r1, #7
   1cdaa:	f63f aed2 	bhi.w	1cb52 <z_cbvprintf_impl+0x426>
   1cdae:	e8df f001 	tbb	[pc, r1]
   1cdb2:	040c      	.short	0x040c
   1cdb4:	08080c06 	.word	0x08080c06
   1cdb8:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
   1cdba:	701d      	strb	r5, [r3, #0]
		if (bps == NULL) {
   1cdbc:	e6c9      	b.n	1cb52 <z_cbvprintf_impl+0x426>
		*(short *)dp = (short)count;
   1cdbe:	801d      	strh	r5, [r3, #0]
		if (bps == NULL) {
   1cdc0:	e6c7      	b.n	1cb52 <z_cbvprintf_impl+0x426>
		*(intmax_t *)dp = (intmax_t)count;
   1cdc2:	17ea      	asrs	r2, r5, #31
   1cdc4:	e9c3 5200 	strd	r5, r2, [r3]
		if (bps == NULL) {
   1cdc8:	e6c3      	b.n	1cb52 <z_cbvprintf_impl+0x426>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   1cdca:	601d      	str	r5, [r3, #0]
		if (bps == NULL) {
   1cdcc:	e6c1      	b.n	1cb52 <z_cbvprintf_impl+0x426>
   1cdce:	4f2f      	ldr	r7, [pc, #188]	; (1ce8c <z_cbvprintf_impl+0x760>)
		char sign = 0;
   1cdd0:	4606      	mov	r6, r0
			bpe = bps + 5;
   1cdd2:	f107 0a05 	add.w	sl, r7, #5
		size_t nj_len = (bpe - bps);
   1cdd6:	2005      	movs	r0, #5
   1cdd8:	e766      	b.n	1cca8 <z_cbvprintf_impl+0x57c>
		} else if (conv->altform_0) {
   1cdda:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
   1cddc:	bf48      	it	mi
   1cdde:	3001      	addmi	r0, #1
   1cde0:	e76a      	b.n	1ccb8 <z_cbvprintf_impl+0x58c>
					OUTC(pad);
   1cde2:	4610      	mov	r0, r2
   1cde4:	9307      	str	r3, [sp, #28]
   1cde6:	9206      	str	r2, [sp, #24]
   1cde8:	4659      	mov	r1, fp
   1cdea:	47c8      	blx	r9
   1cdec:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   1cdf0:	2800      	cmp	r0, #0
   1cdf2:	da04      	bge.n	1cdfe <z_cbvprintf_impl+0x6d2>
#undef OUTS
#undef OUTC
}
   1cdf4:	b015      	add	sp, #84	; 0x54
   1cdf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
   1cdfa:	2220      	movs	r2, #32
					pad = '0';
   1cdfc:	4643      	mov	r3, r8
				while (width-- > 0) {
   1cdfe:	4619      	mov	r1, r3
   1ce00:	2900      	cmp	r1, #0
   1ce02:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
   1ce06:	dcec      	bgt.n	1cde2 <z_cbvprintf_impl+0x6b6>
   1ce08:	4445      	add	r5, r8
   1ce0a:	4698      	mov	r8, r3
   1ce0c:	1a6d      	subs	r5, r5, r1
		if (sign != 0) {
   1ce0e:	b12e      	cbz	r6, 1ce1c <z_cbvprintf_impl+0x6f0>
			OUTC(sign);
   1ce10:	4659      	mov	r1, fp
   1ce12:	4630      	mov	r0, r6
   1ce14:	47c8      	blx	r9
   1ce16:	2800      	cmp	r0, #0
   1ce18:	dbec      	blt.n	1cdf4 <z_cbvprintf_impl+0x6c8>
   1ce1a:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
   1ce1c:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ce20:	06da      	lsls	r2, r3, #27
   1ce22:	d401      	bmi.n	1ce28 <z_cbvprintf_impl+0x6fc>
   1ce24:	071b      	lsls	r3, r3, #28
   1ce26:	d505      	bpl.n	1ce34 <z_cbvprintf_impl+0x708>
				OUTC('0');
   1ce28:	4659      	mov	r1, fp
   1ce2a:	2030      	movs	r0, #48	; 0x30
   1ce2c:	47c8      	blx	r9
   1ce2e:	2800      	cmp	r0, #0
   1ce30:	dbe0      	blt.n	1cdf4 <z_cbvprintf_impl+0x6c8>
   1ce32:	3501      	adds	r5, #1
			if (conv->altform_0c) {
   1ce34:	9b05      	ldr	r3, [sp, #20]
   1ce36:	b133      	cbz	r3, 1ce46 <z_cbvprintf_impl+0x71a>
				OUTC(conv->specifier);
   1ce38:	4659      	mov	r1, fp
   1ce3a:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
   1ce3e:	47c8      	blx	r9
   1ce40:	2800      	cmp	r0, #0
   1ce42:	dbd7      	blt.n	1cdf4 <z_cbvprintf_impl+0x6c8>
   1ce44:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   1ce46:	9e04      	ldr	r6, [sp, #16]
   1ce48:	442e      	add	r6, r5
   1ce4a:	e005      	b.n	1ce58 <z_cbvprintf_impl+0x72c>
				OUTC('0');
   1ce4c:	4659      	mov	r1, fp
   1ce4e:	2030      	movs	r0, #48	; 0x30
   1ce50:	47c8      	blx	r9
   1ce52:	2800      	cmp	r0, #0
   1ce54:	dbce      	blt.n	1cdf4 <z_cbvprintf_impl+0x6c8>
   1ce56:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   1ce58:	1b73      	subs	r3, r6, r5
   1ce5a:	2b00      	cmp	r3, #0
   1ce5c:	dcf6      	bgt.n	1ce4c <z_cbvprintf_impl+0x720>
			OUTS(bps, bpe);
   1ce5e:	4653      	mov	r3, sl
   1ce60:	463a      	mov	r2, r7
   1ce62:	4659      	mov	r1, fp
   1ce64:	4648      	mov	r0, r9
   1ce66:	f007 fe69 	bl	24b3c <outs>
   1ce6a:	2800      	cmp	r0, #0
   1ce6c:	dbc2      	blt.n	1cdf4 <z_cbvprintf_impl+0x6c8>
   1ce6e:	4405      	add	r5, r0
		while (width > 0) {
   1ce70:	44a8      	add	r8, r5
   1ce72:	eba8 0305 	sub.w	r3, r8, r5
   1ce76:	2b00      	cmp	r3, #0
   1ce78:	f77f ae6b 	ble.w	1cb52 <z_cbvprintf_impl+0x426>
			OUTC(' ');
   1ce7c:	4659      	mov	r1, fp
   1ce7e:	2020      	movs	r0, #32
   1ce80:	47c8      	blx	r9
   1ce82:	2800      	cmp	r0, #0
   1ce84:	dbb6      	blt.n	1cdf4 <z_cbvprintf_impl+0x6c8>
   1ce86:	3501      	adds	r5, #1
			--width;
   1ce88:	e7f3      	b.n	1ce72 <z_cbvprintf_impl+0x746>
   1ce8a:	bf00      	nop
   1ce8c:	000269e5 	.word	0x000269e5

0001ce90 <z_arm_on_enter_cpu_idle>:
		DIV_ROUND_UP(200 * CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
				 1000000);
	static uint32_t timestamps[5];
	static bool timestamps_filled;
	static uint8_t current;
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
   1ce90:	2305      	movs	r3, #5

	return true;
}

bool z_arm_on_enter_cpu_idle(void)
{
   1ce92:	b570      	push	{r4, r5, r6, lr}
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
   1ce94:	4d14      	ldr	r5, [pc, #80]	; (1cee8 <z_arm_on_enter_cpu_idle+0x58>)
   1ce96:	4e15      	ldr	r6, [pc, #84]	; (1ceec <z_arm_on_enter_cpu_idle+0x5c>)
   1ce98:	782c      	ldrb	r4, [r5, #0]
   1ce9a:	3401      	adds	r4, #1
   1ce9c:	fbb4 f3f3 	udiv	r3, r4, r3
   1cea0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1cea4:	1ae4      	subs	r4, r4, r3
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   1cea6:	f008 fc85 	bl	257b4 <sys_clock_cycle_get_32>
	if (timestamps_filled &&
   1ceaa:	4a11      	ldr	r2, [pc, #68]	; (1cef0 <z_arm_on_enter_cpu_idle+0x60>)
   1ceac:	7813      	ldrb	r3, [r2, #0]
   1ceae:	b123      	cbz	r3, 1ceba <z_arm_on_enter_cpu_idle+0x2a>
	    (now - timestamps[oldest]) < (window_cycles + 1)) {
   1ceb0:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   1ceb4:	1ac0      	subs	r0, r0, r3
	if (timestamps_filled &&
   1ceb6:	2807      	cmp	r0, #7
   1ceb8:	d913      	bls.n	1cee2 <z_arm_on_enter_cpu_idle+0x52>
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1ceba:	4b0e      	ldr	r3, [pc, #56]	; (1cef4 <z_arm_on_enter_cpu_idle+0x64>)
   1cebc:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
	if (nrf_power_event_check(NRF_POWER, NRF_POWER_EVENT_SLEEPENTER)) {
   1cec0:	b141      	cbz	r1, 1ced4 <z_arm_on_enter_cpu_idle+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1cec2:	2100      	movs	r1, #0
   1cec4:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   1cec8:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
   1cecc:	702c      	strb	r4, [r5, #0]
		if (current == 0) {
   1cece:	b90c      	cbnz	r4, 1ced4 <z_arm_on_enter_cpu_idle+0x44>
			timestamps_filled = true;
   1ced0:	2301      	movs	r3, #1
   1ced2:	7013      	strb	r3, [r2, #0]
	timestamps[current] = k_cycle_get_32();
   1ced4:	782c      	ldrb	r4, [r5, #0]
   1ced6:	f008 fc6d 	bl	257b4 <sys_clock_cycle_get_32>
   1ceda:	f846 0024 	str.w	r0, [r6, r4, lsl #2]
	return true;
   1cede:	2001      	movs	r0, #1
		suppress_message = true;
	}
#endif

	return ok_to_sleep;
}
   1cee0:	bd70      	pop	{r4, r5, r6, pc}
		return false;
   1cee2:	2000      	movs	r0, #0
   1cee4:	e7fc      	b.n	1cee0 <z_arm_on_enter_cpu_idle+0x50>
   1cee6:	bf00      	nop
   1cee8:	2000b5f1 	.word	0x2000b5f1
   1ceec:	2000a730 	.word	0x2000a730
   1cef0:	2000b5f0 	.word	0x2000b5f0
   1cef4:	40005000 	.word	0x40005000

0001cef8 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   1cef8:	b148      	cbz	r0, 1cf0e <arch_busy_wait+0x16>

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
   1cefa:	4b05      	ldr	r3, [pc, #20]	; (1cf10 <arch_busy_wait+0x18>)
   1cefc:	4a05      	ldr	r2, [pc, #20]	; (1cf14 <arch_busy_wait+0x1c>)
   1cefe:	681b      	ldr	r3, [r3, #0]
   1cf00:	fbb3 f3f2 	udiv	r3, r3, r2
    delay_cycles(cycles);
   1cf04:	4358      	muls	r0, r3
   1cf06:	4b04      	ldr	r3, [pc, #16]	; (1cf18 <arch_busy_wait+0x20>)
   1cf08:	f043 0301 	orr.w	r3, r3, #1
   1cf0c:	4718      	bx	r3
}

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   1cf0e:	4770      	bx	lr
   1cf10:	2000a204 	.word	0x2000a204
   1cf14:	000f4240 	.word	0x000f4240
   1cf18:	00026650 	.word	0x00026650

0001cf1c <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   1cf1c:	f008 bc87 	b.w	2582e <SystemInit>

0001cf20 <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   1cf20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1cf24:	4605      	mov	r5, r0
	__asm__ volatile(
   1cf26:	f04f 0320 	mov.w	r3, #32
   1cf2a:	f3ef 8611 	mrs	r6, BASEPRI
   1cf2e:	f383 8812 	msr	BASEPRI_MAX, r3
   1cf32:	f3bf 8f6f 	isb	sy
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_cpus_pm_state[_current_cpu->id].state);
   1cf36:	f04f 090c 	mov.w	r9, #12
	return list->head;
   1cf3a:	4b0d      	ldr	r3, [pc, #52]	; (1cf70 <pm_state_notify+0x50>)
   1cf3c:	4f0d      	ldr	r7, [pc, #52]	; (1cf74 <pm_state_notify+0x54>)
   1cf3e:	681c      	ldr	r4, [r3, #0]
   1cf40:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1cf78 <pm_state_notify+0x58>
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   1cf44:	b92c      	cbnz	r4, 1cf52 <pm_state_notify+0x32>
	__asm__ volatile(
   1cf46:	f386 8811 	msr	BASEPRI, r6
   1cf4a:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   1cf4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			callback = notifier->state_exit;
   1cf52:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
			callback = notifier->state_entry;
   1cf56:	2d00      	cmp	r5, #0
   1cf58:	bf18      	it	ne
   1cf5a:	4613      	movne	r3, r2
		if (callback) {
   1cf5c:	b12b      	cbz	r3, 1cf6a <pm_state_notify+0x4a>
			callback(z_cpus_pm_state[_current_cpu->id].state);
   1cf5e:	f898 2010 	ldrb.w	r2, [r8, #16]
   1cf62:	fb09 f202 	mul.w	r2, r9, r2
   1cf66:	5cb8      	ldrb	r0, [r7, r2]
   1cf68:	4798      	blx	r3
	return node->next;
   1cf6a:	6824      	ldr	r4, [r4, #0]
   1cf6c:	e7ea      	b.n	1cf44 <pm_state_notify+0x24>
   1cf6e:	bf00      	nop
   1cf70:	2000a75c 	.word	0x2000a75c
   1cf74:	2000a750 	.word	0x2000a750
   1cf78:	2000b5b4 	.word	0x2000b5b4

0001cf7c <pm_system_resume>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   1cf7c:	2201      	movs	r2, #1

void pm_system_resume(void)
{
   1cf7e:	b570      	push	{r4, r5, r6, lr}
	uint8_t id = CURRENT_CPU;
   1cf80:	4b16      	ldr	r3, [pc, #88]	; (1cfdc <pm_system_resume+0x60>)
   1cf82:	7c1c      	ldrb	r4, [r3, #16]
   1cf84:	f004 031f 	and.w	r3, r4, #31
   1cf88:	409a      	lsls	r2, r3
	atomic_val_t old;

	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1cf8a:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1cf8c:	4b14      	ldr	r3, [pc, #80]	; (1cfe0 <pm_system_resume+0x64>)
   1cf8e:	0961      	lsrs	r1, r4, #5
   1cf90:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1cf94:	e8d3 1fef 	ldaex	r1, [r3]
   1cf98:	ea01 0500 	and.w	r5, r1, r0
   1cf9c:	e8c3 5fe6 	stlex	r6, r5, [r3]
   1cfa0:	2e00      	cmp	r6, #0
   1cfa2:	d1f7      	bne.n	1cf94 <pm_system_resume+0x18>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   1cfa4:	420a      	tst	r2, r1
   1cfa6:	d013      	beq.n	1cfd0 <pm_system_resume+0x54>
	if (pm_state_exit_post_ops != NULL) {
   1cfa8:	4b0e      	ldr	r3, [pc, #56]	; (1cfe4 <pm_system_resume+0x68>)
   1cfaa:	4d0f      	ldr	r5, [pc, #60]	; (1cfe8 <pm_system_resume+0x6c>)
   1cfac:	b18b      	cbz	r3, 1cfd2 <pm_system_resume+0x56>
		pm_state_exit_post_ops(info->state, info->substate_id);
   1cfae:	230c      	movs	r3, #12
   1cfb0:	4363      	muls	r3, r4
   1cfb2:	18ea      	adds	r2, r5, r3
   1cfb4:	7851      	ldrb	r1, [r2, #1]
   1cfb6:	5ce8      	ldrb	r0, [r5, r3]
   1cfb8:	f007 feb1 	bl	24d1e <pm_state_exit_post_ops>
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
		pm_state_notify(false);
   1cfbc:	2000      	movs	r0, #0
   1cfbe:	f7ff ffaf 	bl	1cf20 <pm_state_notify>
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   1cfc2:	230c      	movs	r3, #12
   1cfc4:	435c      	muls	r4, r3
   1cfc6:	2300      	movs	r3, #0
   1cfc8:	192a      	adds	r2, r5, r4
   1cfca:	512b      	str	r3, [r5, r4]
   1cfcc:	e9c2 3301 	strd	r3, r3, [r2, #4]
			0, 0};
	}
}
   1cfd0:	bd70      	pop	{r4, r5, r6, pc}
   1cfd2:	f383 8811 	msr	BASEPRI, r3
   1cfd6:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   1cfda:	e7ef      	b.n	1cfbc <pm_system_resume+0x40>
   1cfdc:	2000b5b4 	.word	0x2000b5b4
   1cfe0:	2000a764 	.word	0x2000a764
   1cfe4:	00024d1f 	.word	0x00024d1f
   1cfe8:	2000a750 	.word	0x2000a750

0001cfec <pm_system_suspend>:

	return true;
}

bool pm_system_suspend(int32_t ticks)
{
   1cfec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t id = CURRENT_CPU;
   1cff0:	4b32      	ldr	r3, [pc, #200]	; (1d0bc <pm_system_suspend+0xd0>)
{
   1cff2:	4607      	mov	r7, r0
	uint8_t id = CURRENT_CPU;
   1cff4:	7c1d      	ldrb	r5, [r3, #16]
	__asm__ volatile(
   1cff6:	f04f 0320 	mov.w	r3, #32
   1cffa:	f3ef 8811 	mrs	r8, BASEPRI
   1cffe:	f383 8812 	msr	BASEPRI_MAX, r3
   1d002:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key;

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	key = k_spin_lock(&pm_forced_state_lock);
	if (z_cpus_pm_forced_state[id].state != PM_STATE_ACTIVE) {
   1d006:	240c      	movs	r4, #12
   1d008:	436c      	muls	r4, r5
   1d00a:	4b2d      	ldr	r3, [pc, #180]	; (1d0c0 <pm_system_suspend+0xd4>)
   1d00c:	4e2d      	ldr	r6, [pc, #180]	; (1d0c4 <pm_system_suspend+0xd8>)
   1d00e:	5d19      	ldrb	r1, [r3, r4]
   1d010:	191a      	adds	r2, r3, r4
   1d012:	2900      	cmp	r1, #0
   1d014:	d047      	beq.n	1d0a6 <pm_system_suspend+0xba>
		z_cpus_pm_state[id] = z_cpus_pm_forced_state[id];
   1d016:	ca07      	ldmia	r2, {r0, r1, r2}
   1d018:	eb06 0c04 	add.w	ip, r6, r4
   1d01c:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		z_cpus_pm_forced_state[id].state = PM_STATE_ACTIVE;
   1d020:	2200      	movs	r2, #0
   1d022:	551a      	strb	r2, [r3, r4]
	__asm__ volatile(
   1d024:	f388 8811 	msr	BASEPRI, r8
   1d028:	f3bf 8f6f 	isb	sy
			z_cpus_pm_state[id] = *info;
		}
	}
	k_spin_unlock(&pm_forced_state_lock, key);

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
   1d02c:	230c      	movs	r3, #12
   1d02e:	436b      	muls	r3, r5
   1d030:	5cf0      	ldrb	r0, [r6, r3]
   1d032:	18f2      	adds	r2, r6, r3
   1d034:	b3a8      	cbz	r0, 1d0a2 <pm_system_suspend+0xb6>
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);
		return false;
	}

	if (ticks != K_TICKS_FOREVER) {
   1d036:	1c7b      	adds	r3, r7, #1
   1d038:	d010      	beq.n	1d05c <pm_system_suspend+0x70>
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
   1d03a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   1d03e:	2100      	movs	r1, #0
   1d040:	f8d2 c008 	ldr.w	ip, [r2, #8]
   1d044:	4c20      	ldr	r4, [pc, #128]	; (1d0c8 <pm_system_suspend+0xdc>)
   1d046:	2300      	movs	r3, #0
   1d048:	fbec 4100 	umlal	r4, r1, ip, r0
   1d04c:	4a1f      	ldr	r2, [pc, #124]	; (1d0cc <pm_system_suspend+0xe0>)
   1d04e:	4620      	mov	r0, r4
   1d050:	f7ff f880 	bl	1c154 <__aeabi_uldivmod>
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		sys_clock_set_timeout(ticks -
   1d054:	2101      	movs	r1, #1
   1d056:	1a38      	subs	r0, r7, r0
   1d058:	f003 fc24 	bl	208a4 <sys_clock_set_timeout>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   1d05c:	f006 fe42 	bl	23ce4 <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   1d060:	2001      	movs	r0, #1
   1d062:	f7ff ff5d 	bl	1cf20 <pm_state_notify>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1d066:	4b1a      	ldr	r3, [pc, #104]	; (1d0d0 <pm_system_suspend+0xe4>)
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   1d068:	096a      	lsrs	r2, r5, #5
   1d06a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	atomic_val_t mask = ATOMIC_MASK(bit);
   1d06e:	2201      	movs	r2, #1
   1d070:	f005 011f 	and.w	r1, r5, #31
   1d074:	408a      	lsls	r2, r1
   1d076:	e8d3 0fef 	ldaex	r0, [r3]
   1d07a:	4310      	orrs	r0, r2
   1d07c:	e8c3 0fe1 	stlex	r1, r0, [r3]
   1d080:	2900      	cmp	r1, #0
   1d082:	d1f8      	bne.n	1d076 <pm_system_suspend+0x8a>
	if (pm_state_set != NULL) {
   1d084:	4b13      	ldr	r3, [pc, #76]	; (1d0d4 <pm_system_suspend+0xe8>)
   1d086:	b13b      	cbz	r3, 1d098 <pm_system_suspend+0xac>
		pm_state_set(info->state, info->substate_id);
   1d088:	230c      	movs	r3, #12
   1d08a:	fb03 f005 	mul.w	r0, r3, r5
   1d08e:	1833      	adds	r3, r6, r0
   1d090:	7859      	ldrb	r1, [r3, #1]
   1d092:	5c30      	ldrb	r0, [r6, r0]
   1d094:	f007 fe37 	bl	24d06 <pm_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_cpus_pm_state[id].state);
	pm_system_resume();
   1d098:	f7ff ff70 	bl	1cf7c <pm_system_resume>
	k_sched_unlock();
   1d09c:	f006 fe36 	bl	23d0c <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);

	return true;
   1d0a0:	2001      	movs	r0, #1
}
   1d0a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		info = pm_policy_next_state(id, ticks);
   1d0a6:	4601      	mov	r1, r0
   1d0a8:	4628      	mov	r0, r5
   1d0aa:	f000 f815 	bl	1d0d8 <pm_policy_next_state>
		if (info != NULL) {
   1d0ae:	2800      	cmp	r0, #0
   1d0b0:	d0b8      	beq.n	1d024 <pm_system_suspend+0x38>
			z_cpus_pm_state[id] = *info;
   1d0b2:	c807      	ldmia	r0, {r0, r1, r2}
   1d0b4:	4434      	add	r4, r6
   1d0b6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
   1d0ba:	e7b3      	b.n	1d024 <pm_system_suspend+0x38>
   1d0bc:	2000b5b4 	.word	0x2000b5b4
   1d0c0:	2000a744 	.word	0x2000a744
   1d0c4:	2000a750 	.word	0x2000a750
   1d0c8:	000f423f 	.word	0x000f423f
   1d0cc:	000f4240 	.word	0x000f4240
   1d0d0:	2000a764 	.word	0x2000a764
   1d0d4:	00024d07 	.word	0x00024d07

0001d0d8 <pm_policy_next_state>:
	}
}

#ifdef CONFIG_PM_POLICY_DEFAULT
const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
   1d0d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d0dc:	b085      	sub	sp, #20
   1d0de:	460e      	mov	r6, r1
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
   1d0e0:	a903      	add	r1, sp, #12
   1d0e2:	f000 f843 	bl	1d16c <pm_state_cpu_get_all>
   1d0e6:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   1d0ea:	4604      	mov	r4, r0
   1d0ec:	f04f 0b00 	mov.w	fp, #0

		min_residency = k_us_to_ticks_ceil32(state->min_residency_us);
		exit_latency = k_us_to_ticks_ceil32(state->exit_latency_us);

		/* skip state if it brings too much latency */
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   1d0f0:	4b1b      	ldr	r3, [pc, #108]	; (1d160 <pm_policy_next_state+0x88>)
   1d0f2:	9d03      	ldr	r5, [sp, #12]
   1d0f4:	f8d3 a000 	ldr.w	sl, [r3]
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   1d0f8:	1e43      	subs	r3, r0, #1
   1d0fa:	b21b      	sxth	r3, r3
   1d0fc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1d100:	f8df 8060 	ldr.w	r8, [pc, #96]	; 1d164 <pm_policy_next_state+0x8c>
   1d104:	eb05 0583 	add.w	r5, r5, r3, lsl #2
   1d108:	b924      	cbnz	r4, 1d114 <pm_policy_next_state+0x3c>
		    (ticks >= (min_residency + exit_latency))) {
			return state;
		}
	}

	return NULL;
   1d10a:	46a1      	mov	r9, r4
}
   1d10c:	4648      	mov	r0, r9
   1d10e:	b005      	add	sp, #20
   1d110:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d114:	46c4      	mov	ip, r8
   1d116:	4659      	mov	r1, fp
   1d118:	6868      	ldr	r0, [r5, #4]
   1d11a:	2300      	movs	r3, #0
   1d11c:	fbe0 c107 	umlal	ip, r1, r0, r7
   1d120:	4a11      	ldr	r2, [pc, #68]	; (1d168 <pm_policy_next_state+0x90>)
   1d122:	4660      	mov	r0, ip
   1d124:	f7ff f816 	bl	1c154 <__aeabi_uldivmod>
   1d128:	46c4      	mov	ip, r8
   1d12a:	4659      	mov	r1, fp
   1d12c:	9001      	str	r0, [sp, #4]
   1d12e:	68a8      	ldr	r0, [r5, #8]
   1d130:	2300      	movs	r3, #0
   1d132:	fbe0 c107 	umlal	ip, r1, r0, r7
   1d136:	4a0c      	ldr	r2, [pc, #48]	; (1d168 <pm_policy_next_state+0x90>)
   1d138:	4660      	mov	r0, ip
   1d13a:	f7ff f80b 	bl	1c154 <__aeabi_uldivmod>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   1d13e:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
		const struct pm_state_info *state = &cpu_states[i];
   1d142:	46a9      	mov	r9, r5
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   1d144:	d001      	beq.n	1d14a <pm_policy_next_state+0x72>
   1d146:	4582      	cmp	sl, r0
   1d148:	d905      	bls.n	1d156 <pm_policy_next_state+0x7e>
		if ((ticks == K_TICKS_FOREVER) ||
   1d14a:	1c73      	adds	r3, r6, #1
   1d14c:	d0de      	beq.n	1d10c <pm_policy_next_state+0x34>
		    (ticks >= (min_residency + exit_latency))) {
   1d14e:	9b01      	ldr	r3, [sp, #4]
   1d150:	4418      	add	r0, r3
		if ((ticks == K_TICKS_FOREVER) ||
   1d152:	42b0      	cmp	r0, r6
   1d154:	d9da      	bls.n	1d10c <pm_policy_next_state+0x34>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   1d156:	3c01      	subs	r4, #1
   1d158:	b2a4      	uxth	r4, r4
   1d15a:	3d0c      	subs	r5, #12
   1d15c:	e7d4      	b.n	1d108 <pm_policy_next_state+0x30>
   1d15e:	bf00      	nop
   1d160:	2000a0b4 	.word	0x2000a0b4
   1d164:	000f423f 	.word	0x000f423f
   1d168:	000f4240 	.word	0x000f4240

0001d16c <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD_SEP(DT_PATH(cpus), DT_NUM_CPU_POWER_STATES, (,))
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
   1d16c:	b908      	cbnz	r0, 1d172 <pm_state_cpu_get_all+0x6>
		return 0;
	}

	*states = cpus_states[cpu];
   1d16e:	4b02      	ldr	r3, [pc, #8]	; (1d178 <pm_state_cpu_get_all+0xc>)
   1d170:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
   1d172:	2000      	movs	r0, #0
   1d174:	4770      	bx	lr
   1d176:	bf00      	nop
   1d178:	00026670 	.word	0x00026670

0001d17c <class_handler>:
 * usb_enable() is no longer needed.
 */

static int class_handler(struct usb_setup_packet *pSetup,
			 int32_t *len, uint8_t **data)
{
   1d17c:	b4f0      	push	{r4, r5, r6, r7}
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d17e:	4b0c      	ldr	r3, [pc, #48]	; (1d1b0 <class_handler+0x34>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d180:	4e0c      	ldr	r6, [pc, #48]	; (1d1b4 <class_handler+0x38>)
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d182:	6a5f      	ldr	r7, [r3, #36]	; 0x24
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d184:	4b0c      	ldr	r3, [pc, #48]	; (1d1b8 <class_handler+0x3c>)
   1d186:	42b3      	cmp	r3, r6
   1d188:	d303      	bcc.n	1d192 <class_handler+0x16>
			return iface->class_handler(pSetup, len, data);
		}
	}

	return -ENOTSUP;
}
   1d18a:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1d18e:	bcf0      	pop	{r4, r5, r6, r7}
   1d190:	4770      	bx	lr
		if_descr = cfg_data->interface_descriptor;
   1d192:	685d      	ldr	r5, [r3, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d194:	42bd      	cmp	r5, r7
   1d196:	d309      	bcc.n	1d1ac <class_handler+0x30>
		if (iface->class_handler &&
   1d198:	691c      	ldr	r4, [r3, #16]
   1d19a:	b13c      	cbz	r4, 1d1ac <class_handler+0x30>
		    if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
   1d19c:	f895 c002 	ldrb.w	ip, [r5, #2]
   1d1a0:	7905      	ldrb	r5, [r0, #4]
		if (iface->class_handler &&
   1d1a2:	45ac      	cmp	ip, r5
   1d1a4:	d102      	bne.n	1d1ac <class_handler+0x30>
			return iface->class_handler(pSetup, len, data);
   1d1a6:	4623      	mov	r3, r4
}
   1d1a8:	bcf0      	pop	{r4, r5, r6, r7}
			return iface->class_handler(pSetup, len, data);
   1d1aa:	4718      	bx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d1ac:	3324      	adds	r3, #36	; 0x24
   1d1ae:	e7ea      	b.n	1d186 <class_handler+0xa>
   1d1b0:	2000a768 	.word	0x2000a768
   1d1b4:	2000a410 	.word	0x2000a410
   1d1b8:	2000a3ec 	.word	0x2000a3ec

0001d1bc <custom_handler>:

static int custom_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
   1d1bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d1c0:	4605      	mov	r5, r0
   1d1c2:	460e      	mov	r6, r1
   1d1c4:	4617      	mov	r7, r2
	struct usb_interface_cfg_data *iface;

	LOG_DBG("bRequest 0x%02x, wIndex 0x%04x",
		pSetup->bRequest, pSetup->wIndex);

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d1c6:	4c12      	ldr	r4, [pc, #72]	; (1d210 <custom_handler+0x54>)
   1d1c8:	f8df 8048 	ldr.w	r8, [pc, #72]	; 1d214 <custom_handler+0x58>
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d1cc:	f8df 9048 	ldr.w	r9, [pc, #72]	; 1d218 <custom_handler+0x5c>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d1d0:	4544      	cmp	r4, r8
   1d1d2:	d303      	bcc.n	1d1dc <custom_handler+0x20>
			}
		}
	}

	return -ENOTSUP;
}
   1d1d4:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1d1d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if_descr = cfg_data->interface_descriptor;
   1d1dc:	6862      	ldr	r2, [r4, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d1de:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
   1d1e2:	429a      	cmp	r2, r3
   1d1e4:	d312      	bcc.n	1d20c <custom_handler+0x50>
		if (iface->custom_handler == NULL) {
   1d1e6:	69a3      	ldr	r3, [r4, #24]
   1d1e8:	b183      	cbz	r3, 1d20c <custom_handler+0x50>
		if (if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
   1d1ea:	7890      	ldrb	r0, [r2, #2]
   1d1ec:	7929      	ldrb	r1, [r5, #4]
   1d1ee:	4288      	cmp	r0, r1
   1d1f0:	d105      	bne.n	1d1fe <custom_handler+0x42>
			return iface->custom_handler(pSetup, len, data);
   1d1f2:	463a      	mov	r2, r7
   1d1f4:	4631      	mov	r1, r6
   1d1f6:	4628      	mov	r0, r5
}
   1d1f8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return iface->custom_handler(pSetup, len, data);
   1d1fc:	4718      	bx	r3
			if (if_descr->bInterfaceClass == USB_BCC_AUDIO) {
   1d1fe:	7952      	ldrb	r2, [r2, #5]
   1d200:	2a01      	cmp	r2, #1
   1d202:	d103      	bne.n	1d20c <custom_handler+0x50>
				(void)iface->custom_handler(pSetup, len, data);
   1d204:	463a      	mov	r2, r7
   1d206:	4631      	mov	r1, r6
   1d208:	4628      	mov	r0, r5
   1d20a:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d20c:	3424      	adds	r4, #36	; 0x24
   1d20e:	e7df      	b.n	1d1d0 <custom_handler+0x14>
   1d210:	2000a3ec 	.word	0x2000a3ec
   1d214:	2000a410 	.word	0x2000a410
   1d218:	2000a768 	.word	0x2000a768

0001d21c <vendor_handler>:

static int vendor_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
   1d21c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d220:	4605      	mov	r5, r0
   1d222:	460e      	mov	r6, r1
   1d224:	4617      	mov	r7, r2
		if (!usb_handle_os_desc_feature(pSetup, len, data)) {
			return 0;
		}
	}

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d226:	4c0a      	ldr	r4, [pc, #40]	; (1d250 <vendor_handler+0x34>)
   1d228:	f8df 8028 	ldr.w	r8, [pc, #40]	; 1d254 <vendor_handler+0x38>
   1d22c:	4544      	cmp	r4, r8
   1d22e:	d302      	bcc.n	1d236 <vendor_handler+0x1a>
				return 0;
			}
		}
	}

	return -ENOTSUP;
   1d230:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1d234:	e009      	b.n	1d24a <vendor_handler+0x2e>
		if (iface->vendor_handler) {
   1d236:	6963      	ldr	r3, [r4, #20]
   1d238:	b90b      	cbnz	r3, 1d23e <vendor_handler+0x22>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d23a:	3424      	adds	r4, #36	; 0x24
   1d23c:	e7f6      	b.n	1d22c <vendor_handler+0x10>
			if (!iface->vendor_handler(pSetup, len, data)) {
   1d23e:	463a      	mov	r2, r7
   1d240:	4631      	mov	r1, r6
   1d242:	4628      	mov	r0, r5
   1d244:	4798      	blx	r3
   1d246:	2800      	cmp	r0, #0
   1d248:	d1f7      	bne.n	1d23a <vendor_handler+0x1e>
}
   1d24a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1d24e:	bf00      	nop
   1d250:	2000a3ec 	.word	0x2000a3ec
   1d254:	2000a410 	.word	0x2000a410

0001d258 <disable_endpoint>:
{
   1d258:	b510      	push	{r4, lr}
   1d25a:	4604      	mov	r4, r0
	ret = usb_dc_ep_disable(ep_addr);
   1d25c:	f007 ff16 	bl	2508c <usb_dc_ep_disable>
	if (ret == -EALREADY) {
   1d260:	f110 0f78 	cmn.w	r0, #120	; 0x78
   1d264:	d000      	beq.n	1d268 <disable_endpoint+0x10>
	} else if (ret) {
   1d266:	b950      	cbnz	r0, 1d27e <disable_endpoint+0x26>
	ep_bm = get_ep_bm_from_addr(ep_addr);
   1d268:	4620      	mov	r0, r4
   1d26a:	f007 fd7f 	bl	24d6c <get_ep_bm_from_addr>
	usb_dev.ep_bm &= ~ep_bm;
   1d26e:	4a04      	ldr	r2, [pc, #16]	; (1d280 <disable_endpoint+0x28>)
   1d270:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
   1d274:	ea23 0300 	bic.w	r3, r3, r0
	return 0;
   1d278:	2000      	movs	r0, #0
	usb_dev.ep_bm &= ~ep_bm;
   1d27a:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
}
   1d27e:	bd10      	pop	{r4, pc}
   1d280:	2000a768 	.word	0x2000a768

0001d284 <usb_reset_alt_setting>:
	memset(usb_dev.alt_setting, 0, ARRAY_SIZE(usb_dev.alt_setting));
   1d284:	2208      	movs	r2, #8
   1d286:	2100      	movs	r1, #0
   1d288:	4801      	ldr	r0, [pc, #4]	; (1d290 <usb_reset_alt_setting+0xc>)
   1d28a:	f007 bec1 	b.w	25010 <memset>
   1d28e:	bf00      	nop
   1d290:	2000a823 	.word	0x2000a823

0001d294 <is_ep_valid.part.0>:
static bool is_ep_valid(uint8_t ep)
   1d294:	b570      	push	{r4, r5, r6, lr}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d296:	4b0b      	ldr	r3, [pc, #44]	; (1d2c4 <is_ep_valid.part.0+0x30>)
   1d298:	4c0b      	ldr	r4, [pc, #44]	; (1d2c8 <is_ep_valid.part.0+0x34>)
   1d29a:	42a3      	cmp	r3, r4
   1d29c:	d301      	bcc.n	1d2a2 <is_ep_valid.part.0+0xe>
	return false;
   1d29e:	2000      	movs	r0, #0
}
   1d2a0:	bd70      	pop	{r4, r5, r6, pc}
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d2a2:	2200      	movs	r2, #0
		ep_data = cfg_data->endpoint;
   1d2a4:	6a19      	ldr	r1, [r3, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d2a6:	7f1e      	ldrb	r6, [r3, #28]
			if (ep_data[n].ep_addr == ep) {
   1d2a8:	3904      	subs	r1, #4
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d2aa:	b2d5      	uxtb	r5, r2
   1d2ac:	42ae      	cmp	r6, r5
   1d2ae:	d801      	bhi.n	1d2b4 <is_ep_valid.part.0+0x20>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d2b0:	3324      	adds	r3, #36	; 0x24
   1d2b2:	e7f2      	b.n	1d29a <is_ep_valid.part.0+0x6>
			if (ep_data[n].ep_addr == ep) {
   1d2b4:	3201      	adds	r2, #1
   1d2b6:	f811 5032 	ldrb.w	r5, [r1, r2, lsl #3]
   1d2ba:	4285      	cmp	r5, r0
   1d2bc:	d1f5      	bne.n	1d2aa <is_ep_valid.part.0+0x16>
		return true;
   1d2be:	2001      	movs	r0, #1
   1d2c0:	e7ee      	b.n	1d2a0 <is_ep_valid.part.0+0xc>
   1d2c2:	bf00      	nop
   1d2c4:	2000a3ec 	.word	0x2000a3ec
   1d2c8:	2000a410 	.word	0x2000a410

0001d2cc <usb_handle_request.constprop.0>:
static bool usb_handle_request(struct usb_setup_packet *setup,
   1d2cc:	b508      	push	{r3, lr}
	handler = usb_dev.req_handlers[type];
   1d2ce:	4809      	ldr	r0, [pc, #36]	; (1d2f4 <usb_handle_request.constprop.0+0x28>)
	uint32_t type = setup->RequestType.type;
   1d2d0:	7803      	ldrb	r3, [r0, #0]
   1d2d2:	f3c3 1341 	ubfx	r3, r3, #5, #2
	handler = usb_dev.req_handlers[type];
   1d2d6:	330a      	adds	r3, #10
   1d2d8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	if (handler == NULL) {
   1d2dc:	b13b      	cbz	r3, 1d2ee <usb_handle_request.constprop.0+0x22>
	if ((*handler)(setup, len, data) < 0) {
   1d2de:	f100 0208 	add.w	r2, r0, #8
   1d2e2:	f100 0110 	add.w	r1, r0, #16
   1d2e6:	4798      	blx	r3
   1d2e8:	43c0      	mvns	r0, r0
   1d2ea:	0fc0      	lsrs	r0, r0, #31
}
   1d2ec:	bd08      	pop	{r3, pc}
		return false;
   1d2ee:	4618      	mov	r0, r3
   1d2f0:	e7fc      	b.n	1d2ec <usb_handle_request.constprop.0+0x20>
   1d2f2:	bf00      	nop
   1d2f4:	2000a768 	.word	0x2000a768

0001d2f8 <forward_status_cb>:
	if (status == USB_DC_DISCONNECTED) {
   1d2f8:	2804      	cmp	r0, #4
{
   1d2fa:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d2fe:	4604      	mov	r4, r0
   1d300:	460f      	mov	r7, r1
   1d302:	f8df 9094 	ldr.w	r9, [pc, #148]	; 1d398 <forward_status_cb+0xa0>
	if (status == USB_DC_DISCONNECTED) {
   1d306:	d016      	beq.n	1d336 <forward_status_cb+0x3e>
	if (status == USB_DC_DISCONNECTED || status == USB_DC_RESET) {
   1d308:	2801      	cmp	r0, #1
   1d30a:	d12d      	bne.n	1d368 <forward_status_cb+0x70>
		if (usb_dev.configured) {
   1d30c:	f8df 808c 	ldr.w	r8, [pc, #140]	; 1d39c <forward_status_cb+0xa4>
   1d310:	f898 30b9 	ldrb.w	r3, [r8, #185]	; 0xb9
   1d314:	b343      	cbz	r3, 1d368 <forward_status_cb+0x70>
			usb_cancel_transfers();
   1d316:	f000 fdb9 	bl	1de8c <usb_cancel_transfers>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d31a:	4d21      	ldr	r5, [pc, #132]	; (1d3a0 <forward_status_cb+0xa8>)
   1d31c:	454d      	cmp	r5, r9
   1d31e:	d220      	bcs.n	1d362 <forward_status_cb+0x6a>
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d320:	f04f 0a00 	mov.w	sl, #0
		ep_data = cfg_data->endpoint;
   1d324:	f8d5 b020 	ldr.w	fp, [r5, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d328:	7f2b      	ldrb	r3, [r5, #28]
   1d32a:	fa5f f68a 	uxtb.w	r6, sl
   1d32e:	42b3      	cmp	r3, r6
   1d330:	d804      	bhi.n	1d33c <forward_status_cb+0x44>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d332:	3524      	adds	r5, #36	; 0x24
   1d334:	e7f2      	b.n	1d31c <forward_status_cb+0x24>
		usb_reset_alt_setting();
   1d336:	f7ff ffa5 	bl	1d284 <usb_reset_alt_setting>
	if (status == USB_DC_DISCONNECTED || status == USB_DC_RESET) {
   1d33a:	e7e7      	b.n	1d30c <forward_status_cb+0x14>
			ret = endpoint_callback(&ep_data[n]);
   1d33c:	eb0b 06c6 	add.w	r6, fp, r6, lsl #3
	ret = usb_dc_ep_disable(ep_data->ep_addr);
   1d340:	7930      	ldrb	r0, [r6, #4]
   1d342:	f007 fea3 	bl	2508c <usb_dc_ep_disable>
   1d346:	4602      	mov	r2, r0
	ep_bm = get_ep_bm_from_addr(ep_data->ep_addr);
   1d348:	7930      	ldrb	r0, [r6, #4]
   1d34a:	f007 fd0f 	bl	24d6c <get_ep_bm_from_addr>
	usb_dev.ep_bm &= ~ep_bm;
   1d34e:	f8d8 30c4 	ldr.w	r3, [r8, #196]	; 0xc4
			if (ret < 0) {
   1d352:	2a00      	cmp	r2, #0
	usb_dev.ep_bm &= ~ep_bm;
   1d354:	ea23 0300 	bic.w	r3, r3, r0
   1d358:	f8c8 30c4 	str.w	r3, [r8, #196]	; 0xc4
			if (ret < 0) {
   1d35c:	f10a 0a01 	add.w	sl, sl, #1
   1d360:	dae2      	bge.n	1d328 <forward_status_cb+0x30>
			usb_dev.configured = false;
   1d362:	2300      	movs	r3, #0
   1d364:	f888 30b9 	strb.w	r3, [r8, #185]	; 0xb9
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d368:	4d0d      	ldr	r5, [pc, #52]	; (1d3a0 <forward_status_cb+0xa8>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d36a:	454d      	cmp	r5, r9
   1d36c:	d308      	bcc.n	1d380 <forward_status_cb+0x88>
	if (usb_dev.user_status_callback) {
   1d36e:	4b0b      	ldr	r3, [pc, #44]	; (1d39c <forward_status_cb+0xa4>)
   1d370:	6a1b      	ldr	r3, [r3, #32]
   1d372:	b16b      	cbz	r3, 1d390 <forward_status_cb+0x98>
		usb_dev.user_status_callback(status, param);
   1d374:	4639      	mov	r1, r7
   1d376:	4620      	mov	r0, r4
}
   1d378:	b001      	add	sp, #4
   1d37a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		usb_dev.user_status_callback(status, param);
   1d37e:	4718      	bx	r3
		if (cfg_data->cb_usb_status) {
   1d380:	68eb      	ldr	r3, [r5, #12]
   1d382:	b11b      	cbz	r3, 1d38c <forward_status_cb+0x94>
			cfg_data->cb_usb_status(cfg_data, status, param);
   1d384:	463a      	mov	r2, r7
   1d386:	4621      	mov	r1, r4
   1d388:	4628      	mov	r0, r5
   1d38a:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d38c:	3524      	adds	r5, #36	; 0x24
   1d38e:	e7ec      	b.n	1d36a <forward_status_cb+0x72>
}
   1d390:	b001      	add	sp, #4
   1d392:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d396:	bf00      	nop
   1d398:	2000a410 	.word	0x2000a410
   1d39c:	2000a768 	.word	0x2000a768
   1d3a0:	2000a3ec 	.word	0x2000a3ec

0001d3a4 <usb_halt_endpoint_req.isra.0>:
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
   1d3a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t ep = setup->wIndex;
   1d3a6:	b2c4      	uxtb	r4, r0
	if (USB_EP_GET_IDX(ep) == 0) {
   1d3a8:	0663      	lsls	r3, r4, #25
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
   1d3aa:	460d      	mov	r5, r1
	uint8_t ep = setup->wIndex;
   1d3ac:	f88d 4007 	strb.w	r4, [sp, #7]
	if (USB_EP_GET_IDX(ep) == 0) {
   1d3b0:	d007      	beq.n	1d3c2 <usb_halt_endpoint_req.isra.0+0x1e>
   1d3b2:	4620      	mov	r0, r4
   1d3b4:	f7ff ff6e 	bl	1d294 <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
   1d3b8:	b178      	cbz	r0, 1d3da <usb_halt_endpoint_req.isra.0+0x36>
	return (usb_dev.configuration != 0);
   1d3ba:	4b0d      	ldr	r3, [pc, #52]	; (1d3f0 <usb_halt_endpoint_req.isra.0+0x4c>)
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
   1d3bc:	f893 00ba 	ldrb.w	r0, [r3, #186]	; 0xba
   1d3c0:	b158      	cbz	r0, 1d3da <usb_halt_endpoint_req.isra.0+0x36>
			usb_dc_ep_set_stall(ep);
   1d3c2:	4620      	mov	r0, r4
   1d3c4:	4e0a      	ldr	r6, [pc, #40]	; (1d3f0 <usb_halt_endpoint_req.isra.0+0x4c>)
		if (halt) {
   1d3c6:	b155      	cbz	r5, 1d3de <usb_halt_endpoint_req.isra.0+0x3a>
			usb_dc_ep_set_stall(ep);
   1d3c8:	f002 f816 	bl	1f3f8 <usb_dc_ep_set_stall>
			if (usb_dev.status_callback) {
   1d3cc:	69f3      	ldr	r3, [r6, #28]
   1d3ce:	b11b      	cbz	r3, 1d3d8 <usb_halt_endpoint_req.isra.0+0x34>
				usb_dev.status_callback(USB_DC_SET_HALT, &ep);
   1d3d0:	2008      	movs	r0, #8
   1d3d2:	f10d 0107 	add.w	r1, sp, #7
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
   1d3d6:	4798      	blx	r3
		return true;
   1d3d8:	2001      	movs	r0, #1
}
   1d3da:	b002      	add	sp, #8
   1d3dc:	bd70      	pop	{r4, r5, r6, pc}
			usb_dc_ep_clear_stall(ep);
   1d3de:	f002 f833 	bl	1f448 <usb_dc_ep_clear_stall>
			if (usb_dev.status_callback) {
   1d3e2:	69f3      	ldr	r3, [r6, #28]
   1d3e4:	2b00      	cmp	r3, #0
   1d3e6:	d0f7      	beq.n	1d3d8 <usb_halt_endpoint_req.isra.0+0x34>
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
   1d3e8:	2009      	movs	r0, #9
   1d3ea:	f10d 0107 	add.w	r1, sp, #7
   1d3ee:	e7f2      	b.n	1d3d6 <usb_halt_endpoint_req.isra.0+0x32>
   1d3f0:	2000a768 	.word	0x2000a768

0001d3f4 <set_endpoint>:
{
   1d3f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ep_cfg.ep_addr = ep_desc->bEndpointAddress;
   1d3f6:	7886      	ldrb	r6, [r0, #2]
	if (ep_bm & usb_dev.ep_bm) {
   1d3f8:	4c1e      	ldr	r4, [pc, #120]	; (1d474 <set_endpoint+0x80>)
	ep_cfg.ep_addr = ep_desc->bEndpointAddress;
   1d3fa:	f88d 6000 	strb.w	r6, [sp]
	ep_cfg.ep_mps = sys_le16_to_cpu(ep_desc->wMaxPacketSize);
   1d3fe:	7903      	ldrb	r3, [r0, #4]
   1d400:	7942      	ldrb	r2, [r0, #5]
   1d402:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1d406:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
   1d40a:	78c3      	ldrb	r3, [r0, #3]
	ep_bm = get_ep_bm_from_addr(ep_desc->bEndpointAddress);
   1d40c:	4630      	mov	r0, r6
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
   1d40e:	f003 0303 	and.w	r3, r3, #3
   1d412:	f88d 3004 	strb.w	r3, [sp, #4]
	ep_bm = get_ep_bm_from_addr(ep_desc->bEndpointAddress);
   1d416:	f007 fca9 	bl	24d6c <get_ep_bm_from_addr>
	if (ep_bm & usb_dev.ep_bm) {
   1d41a:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
	ep_bm = get_ep_bm_from_addr(ep_desc->bEndpointAddress);
   1d41e:	4605      	mov	r5, r0
	if (ep_bm & usb_dev.ep_bm) {
   1d420:	4218      	tst	r0, r3
   1d422:	d00b      	beq.n	1d43c <set_endpoint+0x48>
	usb_cancel_transfer(ep_cfg.ep_addr);
   1d424:	4630      	mov	r0, r6
   1d426:	f000 fd13 	bl	1de50 <usb_cancel_transfer>
	return disable_endpoint(ep_cfg.ep_addr) ? false : true;
   1d42a:	4630      	mov	r0, r6
   1d42c:	f7ff ff14 	bl	1d258 <disable_endpoint>
		if (!k_is_in_isr()) {
   1d430:	f008 fbc5 	bl	25bbe <k_is_in_isr>
   1d434:	b910      	cbnz	r0, 1d43c <set_endpoint+0x48>
		union { uintptr_t x; int32_t val; } parm0 = { .val = us };
		return (int32_t) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_USLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_usleep(us);
   1d436:	2096      	movs	r0, #150	; 0x96
   1d438:	f006 fd28 	bl	23e8c <z_impl_k_usleep>
	ret = usb_dc_ep_configure(&ep_cfg);
   1d43c:	4668      	mov	r0, sp
   1d43e:	f001 ffb7 	bl	1f3b0 <usb_dc_ep_configure>
	if (ret == -EALREADY) {
   1d442:	f110 0f78 	cmn.w	r0, #120	; 0x78
   1d446:	d003      	beq.n	1d450 <set_endpoint+0x5c>
	} else if (ret) {
   1d448:	b110      	cbz	r0, 1d450 <set_endpoint+0x5c>
		return false;
   1d44a:	2000      	movs	r0, #0
}
   1d44c:	b002      	add	sp, #8
   1d44e:	bd70      	pop	{r4, r5, r6, pc}
	ret = usb_dc_ep_enable(ep_cfg.ep_addr);
   1d450:	f89d 0000 	ldrb.w	r0, [sp]
   1d454:	f002 f834 	bl	1f4c0 <usb_dc_ep_enable>
	if (ret == -EALREADY) {
   1d458:	f110 0f78 	cmn.w	r0, #120	; 0x78
   1d45c:	d001      	beq.n	1d462 <set_endpoint+0x6e>
	} else if (ret) {
   1d45e:	2800      	cmp	r0, #0
   1d460:	d1f3      	bne.n	1d44a <set_endpoint+0x56>
	usb_dev.configured = true;
   1d462:	2001      	movs	r0, #1
	usb_dev.ep_bm |= ep_bm;
   1d464:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
	usb_dev.configured = true;
   1d468:	f884 00b9 	strb.w	r0, [r4, #185]	; 0xb9
	usb_dev.ep_bm |= ep_bm;
   1d46c:	432b      	orrs	r3, r5
   1d46e:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	return true;
   1d472:	e7eb      	b.n	1d44c <set_endpoint+0x58>
   1d474:	2000a768 	.word	0x2000a768

0001d478 <usb_handle_standard_request>:
{
   1d478:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (usb_dev.custom_req_handler &&
   1d47c:	4d92      	ldr	r5, [pc, #584]	; (1d6c8 <usb_handle_standard_request+0x250>)
{
   1d47e:	4604      	mov	r4, r0
	if (usb_dev.custom_req_handler &&
   1d480:	69ab      	ldr	r3, [r5, #24]
{
   1d482:	460e      	mov	r6, r1
   1d484:	4617      	mov	r7, r2
	if (usb_dev.custom_req_handler &&
   1d486:	b9c3      	cbnz	r3, 1d4ba <usb_handle_standard_request+0x42>
	switch (setup->RequestType.recipient) {
   1d488:	7820      	ldrb	r0, [r4, #0]
   1d48a:	f000 001f 	and.w	r0, r0, #31
   1d48e:	2801      	cmp	r0, #1
   1d490:	d076      	beq.n	1d580 <usb_handle_standard_request+0x108>
   1d492:	2802      	cmp	r0, #2
   1d494:	f000 80dc 	beq.w	1d650 <usb_handle_standard_request+0x1d8>
   1d498:	bb00      	cbnz	r0, 1d4dc <usb_handle_standard_request+0x64>
	if (usb_reqtype_is_to_host(setup)) {
   1d49a:	f994 1000 	ldrsb.w	r1, [r4]
	uint8_t *data = *data_buf;
   1d49e:	683a      	ldr	r2, [r7, #0]
	if (usb_reqtype_is_to_host(setup)) {
   1d4a0:	2900      	cmp	r1, #0
		switch (setup->bRequest) {
   1d4a2:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   1d4a4:	da2e      	bge.n	1d504 <usb_handle_standard_request+0x8c>
		switch (setup->bRequest) {
   1d4a6:	2b06      	cmp	r3, #6
   1d4a8:	d00c      	beq.n	1d4c4 <usb_handle_standard_request+0x4c>
   1d4aa:	2b08      	cmp	r3, #8
   1d4ac:	d025      	beq.n	1d4fa <usb_handle_standard_request+0x82>
   1d4ae:	b9ab      	cbnz	r3, 1d4dc <usb_handle_standard_request+0x64>
	data[1] = 0U;
   1d4b0:	7053      	strb	r3, [r2, #1]
		data[0] |= USB_GET_STATUS_SELF_POWERED;
   1d4b2:	2301      	movs	r3, #1
   1d4b4:	7013      	strb	r3, [r2, #0]
		*len = 2;
   1d4b6:	2302      	movs	r3, #2
   1d4b8:	e103      	b.n	1d6c2 <usb_handle_standard_request+0x24a>
	    !usb_dev.custom_req_handler(setup, len, data_buf)) {
   1d4ba:	4798      	blx	r3
	if (usb_dev.custom_req_handler &&
   1d4bc:	2800      	cmp	r0, #0
   1d4be:	d1e3      	bne.n	1d488 <usb_handle_standard_request+0x10>
		return 0;
   1d4c0:	2000      	movs	r0, #0
   1d4c2:	e00d      	b.n	1d4e0 <usb_handle_standard_request+0x68>
			return usb_get_descriptor(setup, len, data_buf);
   1d4c4:	8863      	ldrh	r3, [r4, #2]
	type = USB_GET_DESCRIPTOR_TYPE(setup->wValue);
   1d4c6:	0a19      	lsrs	r1, r3, #8
	if ((type == USB_DESC_INTERFACE) || (type == USB_DESC_ENDPOINT) ||
   1d4c8:	1f0a      	subs	r2, r1, #4
   1d4ca:	2a01      	cmp	r2, #1
	type = USB_GET_DESCRIPTOR_TYPE(setup->wValue);
   1d4cc:	468c      	mov	ip, r1
	if ((type == USB_DESC_INTERFACE) || (type == USB_DESC_ENDPOINT) ||
   1d4ce:	d905      	bls.n	1d4dc <usb_handle_standard_request+0x64>
   1d4d0:	2907      	cmp	r1, #7
   1d4d2:	d803      	bhi.n	1d4dc <usb_handle_standard_request+0x64>
	index = USB_GET_DESCRIPTOR_INDEX(setup->wValue);
   1d4d4:	b2da      	uxtb	r2, r3
	p = (uint8_t *)usb_dev.descriptors;
   1d4d6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	while (p[DESC_bLength] != 0U) {
   1d4d8:	781c      	ldrb	r4, [r3, #0]
   1d4da:	b91c      	cbnz	r4, 1d4e4 <usb_handle_standard_request+0x6c>
			rc = -EINVAL;
   1d4dc:	f06f 0015 	mvn.w	r0, #21
}
   1d4e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (p[DESC_bDescriptorType] == type) {
   1d4e4:	785d      	ldrb	r5, [r3, #1]
   1d4e6:	4565      	cmp	r5, ip
   1d4e8:	d103      	bne.n	1d4f2 <usb_handle_standard_request+0x7a>
			if (cur_index == index) {
   1d4ea:	4282      	cmp	r2, r0
   1d4ec:	f000 80e4 	beq.w	1d6b8 <usb_handle_standard_request+0x240>
			cur_index++;
   1d4f0:	3001      	adds	r0, #1
		p += p[DESC_bLength];
   1d4f2:	4423      	add	r3, r4
   1d4f4:	e7f0      	b.n	1d4d8 <usb_handle_standard_request+0x60>
			*len = p[DESC_bLength];
   1d4f6:	781b      	ldrb	r3, [r3, #0]
   1d4f8:	e0e3      	b.n	1d6c2 <usb_handle_standard_request+0x24a>
			data[0] = usb_dev.configuration;
   1d4fa:	f895 30ba 	ldrb.w	r3, [r5, #186]	; 0xba
   1d4fe:	7013      	strb	r3, [r2, #0]
				*len = 1;
   1d500:	2301      	movs	r3, #1
   1d502:	e0de      	b.n	1d6c2 <usb_handle_standard_request+0x24a>
		switch (setup->bRequest) {
   1d504:	2b05      	cmp	r3, #5
   1d506:	d011      	beq.n	1d52c <usb_handle_standard_request+0xb4>
   1d508:	2b09      	cmp	r3, #9
   1d50a:	d1e7      	bne.n	1d4dc <usb_handle_standard_request+0x64>
	if (setup->wValue == 0U) {
   1d50c:	8863      	ldrh	r3, [r4, #2]
	uint8_t *p = (uint8_t *)usb_dev.descriptors;
   1d50e:	6a6e      	ldr	r6, [r5, #36]	; 0x24
	if (setup->wValue == 0U) {
   1d510:	2b00      	cmp	r3, #0
   1d512:	d132      	bne.n	1d57a <usb_handle_standard_request+0x102>
		usb_reset_alt_setting();
   1d514:	f7ff feb6 	bl	1d284 <usb_reset_alt_setting>
		usb_dev.configuration = setup->wValue;
   1d518:	8863      	ldrh	r3, [r4, #2]
   1d51a:	f885 30ba 	strb.w	r3, [r5, #186]	; 0xba
		if (usb_dev.status_callback) {
   1d51e:	69eb      	ldr	r3, [r5, #28]
   1d520:	2b00      	cmp	r3, #0
   1d522:	d0cd      	beq.n	1d4c0 <usb_handle_standard_request+0x48>
			usb_dev.status_callback(USB_DC_CONFIGURED,
   1d524:	2003      	movs	r0, #3
   1d526:	4969      	ldr	r1, [pc, #420]	; (1d6cc <usb_handle_standard_request+0x254>)
   1d528:	4798      	blx	r3
   1d52a:	e7c9      	b.n	1d4c0 <usb_handle_standard_request+0x48>
			return !usb_dc_set_address(setup->wValue);
   1d52c:	78a0      	ldrb	r0, [r4, #2]
   1d52e:	f001 ff2d 	bl	1f38c <usb_dc_set_address>
		if (usb_handle_std_device_req(setup, len, data_buf) == false) {
   1d532:	2800      	cmp	r0, #0
   1d534:	d0c4      	beq.n	1d4c0 <usb_handle_standard_request+0x48>
   1d536:	e7d1      	b.n	1d4dc <usb_handle_standard_request+0x64>
		switch (p[DESC_bDescriptorType]) {
   1d538:	7873      	ldrb	r3, [r6, #1]
   1d53a:	2b04      	cmp	r3, #4
   1d53c:	d010      	beq.n	1d560 <usb_handle_standard_request+0xe8>
   1d53e:	2b05      	cmp	r3, #5
   1d540:	d011      	beq.n	1d566 <usb_handle_standard_request+0xee>
   1d542:	2b02      	cmp	r3, #2
   1d544:	d104      	bne.n	1d550 <usb_handle_standard_request+0xd8>
			cur_config = p[CONF_DESC_bConfigurationValue];
   1d546:	7977      	ldrb	r7, [r6, #5]
			if (cur_config == setup->wValue) {
   1d548:	8863      	ldrh	r3, [r4, #2]
				found = true;
   1d54a:	42bb      	cmp	r3, r7
   1d54c:	bf08      	it	eq
   1d54e:	2001      	moveq	r0, #1
		p += p[DESC_bLength];
   1d550:	7833      	ldrb	r3, [r6, #0]
   1d552:	441e      	add	r6, r3
	while (p[DESC_bLength] != 0U) {
   1d554:	7833      	ldrb	r3, [r6, #0]
   1d556:	2b00      	cmp	r3, #0
   1d558:	d1ee      	bne.n	1d538 <usb_handle_standard_request+0xc0>
	if (found) {
   1d55a:	2800      	cmp	r0, #0
   1d55c:	d0be      	beq.n	1d4dc <usb_handle_standard_request+0x64>
   1d55e:	e7d9      	b.n	1d514 <usb_handle_standard_request+0x9c>
			cur_alt_setting =
   1d560:	f896 8003 	ldrb.w	r8, [r6, #3]
			break;
   1d564:	e7f4      	b.n	1d550 <usb_handle_standard_request+0xd8>
			if ((cur_config != setup->wValue) ||
   1d566:	8863      	ldrh	r3, [r4, #2]
   1d568:	42bb      	cmp	r3, r7
   1d56a:	d1f1      	bne.n	1d550 <usb_handle_standard_request+0xd8>
   1d56c:	f1b8 0f00 	cmp.w	r8, #0
   1d570:	d1ee      	bne.n	1d550 <usb_handle_standard_request+0xd8>
			found = set_endpoint((struct usb_ep_descriptor *)p);
   1d572:	4630      	mov	r0, r6
   1d574:	f7ff ff3e 	bl	1d3f4 <set_endpoint>
			break;
   1d578:	e7ea      	b.n	1d550 <usb_handle_standard_request+0xd8>
	uint8_t cur_config = 0xFF;
   1d57a:	27ff      	movs	r7, #255	; 0xff
	uint8_t cur_alt_setting = 0xFF;
   1d57c:	46b8      	mov	r8, r7
   1d57e:	e7e9      	b.n	1d554 <usb_handle_standard_request+0xdc>
	if (!is_device_configured() ||
   1d580:	f895 30ba 	ldrb.w	r3, [r5, #186]	; 0xba
   1d584:	f8d7 c000 	ldr.w	ip, [r7]
   1d588:	2b00      	cmp	r3, #0
   1d58a:	d0a7      	beq.n	1d4dc <usb_handle_standard_request+0x64>
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
   1d58c:	6a6f      	ldr	r7, [r5, #36]	; 0x24
	   (!is_interface_valid((uint8_t)setup->wIndex))) {
   1d58e:	88a2      	ldrh	r2, [r4, #4]
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
   1d590:	463b      	mov	r3, r7
	   (!is_interface_valid((uint8_t)setup->wIndex))) {
   1d592:	f894 e004 	ldrb.w	lr, [r4, #4]
	while (p[DESC_bLength] != 0U) {
   1d596:	7818      	ldrb	r0, [r3, #0]
   1d598:	2800      	cmp	r0, #0
   1d59a:	d09f      	beq.n	1d4dc <usb_handle_standard_request+0x64>
		if (p[DESC_bDescriptorType] == USB_DESC_CONFIGURATION) {
   1d59c:	7859      	ldrb	r1, [r3, #1]
   1d59e:	2902      	cmp	r1, #2
   1d5a0:	d104      	bne.n	1d5ac <usb_handle_standard_request+0x134>
			if (interface < cfg_descr->bNumInterfaces) {
   1d5a2:	f893 8004 	ldrb.w	r8, [r3, #4]
   1d5a6:	45f0      	cmp	r8, lr
   1d5a8:	f200 8092 	bhi.w	1d6d0 <usb_handle_standard_request+0x258>
		p += p[DESC_bLength];
   1d5ac:	4403      	add	r3, r0
   1d5ae:	e7f2      	b.n	1d596 <usb_handle_standard_request+0x11e>
			data[0] = 0U;
   1d5b0:	f88c 3000 	strb.w	r3, [ip]
			data[1] = 0U;
   1d5b4:	f88c 3001 	strb.w	r3, [ip, #1]
			*len = 2;
   1d5b8:	6031      	str	r1, [r6, #0]
			return true;
   1d5ba:	e781      	b.n	1d4c0 <usb_handle_standard_request+0x48>
		p += p[DESC_bLength];
   1d5bc:	441f      	add	r7, r3
   1d5be:	e093      	b.n	1d6e8 <usb_handle_standard_request+0x270>
		if (setup->bRequest == USB_SREQ_SET_INTERFACE) {
   1d5c0:	2b0b      	cmp	r3, #11
   1d5c2:	d18b      	bne.n	1d4dc <usb_handle_standard_request+0x64>
	bool ret = false;
   1d5c4:	2600      	movs	r6, #0
	uint8_t cur_iface = 0xFF;
   1d5c6:	f04f 08ff 	mov.w	r8, #255	; 0xff
	const uint8_t *if_desc = NULL;
   1d5ca:	46b2      	mov	sl, r6
	uint8_t cur_alt_setting = 0xFF;
   1d5cc:	46c1      	mov	r9, r8
   1d5ce:	e006      	b.n	1d5de <usb_handle_standard_request+0x166>
		switch (p[DESC_bDescriptorType]) {
   1d5d0:	787b      	ldrb	r3, [r7, #1]
   1d5d2:	2b04      	cmp	r3, #4
   1d5d4:	d00f      	beq.n	1d5f6 <usb_handle_standard_request+0x17e>
   1d5d6:	2b05      	cmp	r3, #5
   1d5d8:	d021      	beq.n	1d61e <usb_handle_standard_request+0x1a6>
		p += p[DESC_bLength];
   1d5da:	783b      	ldrb	r3, [r7, #0]
   1d5dc:	441f      	add	r7, r3
	while (p[DESC_bLength] != 0U) {
   1d5de:	783b      	ldrb	r3, [r7, #0]
   1d5e0:	2b00      	cmp	r3, #0
   1d5e2:	d1f5      	bne.n	1d5d0 <usb_handle_standard_request+0x158>
	if (usb_dev.status_callback) {
   1d5e4:	69eb      	ldr	r3, [r5, #28]
   1d5e6:	b113      	cbz	r3, 1d5ee <usb_handle_standard_request+0x176>
		usb_dev.status_callback(USB_DC_INTERFACE, if_desc);
   1d5e8:	4651      	mov	r1, sl
   1d5ea:	2007      	movs	r0, #7
   1d5ec:	4798      	blx	r3
		if (usb_handle_std_interface_req(setup, len, data_buf) == false) {
   1d5ee:	2e00      	cmp	r6, #0
   1d5f0:	f47f af66 	bne.w	1d4c0 <usb_handle_standard_request+0x48>
   1d5f4:	e772      	b.n	1d4dc <usb_handle_standard_request+0x64>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
   1d5f6:	f897 8002 	ldrb.w	r8, [r7, #2]
			if (cur_iface == setup->wIndex &&
   1d5fa:	88a3      	ldrh	r3, [r4, #4]
			cur_alt_setting = p[INTF_DESC_bAlternateSetting];
   1d5fc:	f897 9003 	ldrb.w	r9, [r7, #3]
			if (cur_iface == setup->wIndex &&
   1d600:	4598      	cmp	r8, r3
   1d602:	d1ea      	bne.n	1d5da <usb_handle_standard_request+0x162>
			    cur_alt_setting == setup->wValue) {
   1d604:	8863      	ldrh	r3, [r4, #2]
			if (cur_iface == setup->wIndex &&
   1d606:	4599      	cmp	r9, r3
   1d608:	d1e7      	bne.n	1d5da <usb_handle_standard_request+0x162>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
   1d60a:	f1b8 0f07 	cmp.w	r8, #7
   1d60e:	d81c      	bhi.n	1d64a <usb_handle_standard_request+0x1d2>
		usb_dev.alt_setting[iface] = alt_setting;
   1d610:	eb05 0308 	add.w	r3, r5, r8
		return true;
   1d614:	46ba      	mov	sl, r7
   1d616:	2601      	movs	r6, #1
				ret = usb_set_alt_setting(setup->wIndex,
   1d618:	f883 90bb 	strb.w	r9, [r3, #187]	; 0xbb
		return true;
   1d61c:	e7dd      	b.n	1d5da <usb_handle_standard_request+0x162>
			if (cur_iface == setup->wIndex) {
   1d61e:	88a3      	ldrh	r3, [r4, #4]
   1d620:	4543      	cmp	r3, r8
   1d622:	d1da      	bne.n	1d5da <usb_handle_standard_request+0x162>
	if (cur_alt_setting != alt_setting) {
   1d624:	78a3      	ldrb	r3, [r4, #2]
   1d626:	454b      	cmp	r3, r9
   1d628:	d00a      	beq.n	1d640 <usb_handle_standard_request+0x1c8>
		ret = reset_endpoint(ep_desc);
   1d62a:	78be      	ldrb	r6, [r7, #2]
	usb_cancel_transfer(ep_cfg.ep_addr);
   1d62c:	4630      	mov	r0, r6
   1d62e:	f000 fc0f 	bl	1de50 <usb_cancel_transfer>
	return disable_endpoint(ep_cfg.ep_addr) ? false : true;
   1d632:	4630      	mov	r0, r6
   1d634:	f7ff fe10 	bl	1d258 <disable_endpoint>
   1d638:	fab0 f680 	clz	r6, r0
   1d63c:	0976      	lsrs	r6, r6, #5
   1d63e:	e7cc      	b.n	1d5da <usb_handle_standard_request+0x162>
		ret = set_endpoint(ep_desc);
   1d640:	4638      	mov	r0, r7
   1d642:	f7ff fed7 	bl	1d3f4 <set_endpoint>
   1d646:	4606      	mov	r6, r0
   1d648:	e7c7      	b.n	1d5da <usb_handle_standard_request+0x162>
   1d64a:	46ba      	mov	sl, r7
	return false;
   1d64c:	2600      	movs	r6, #0
   1d64e:	e7c4      	b.n	1d5da <usb_handle_standard_request+0x162>
	if (usb_reqtype_is_to_host(setup)) {
   1d650:	f994 2000 	ldrsb.w	r2, [r4]
		switch (setup->bRequest) {
   1d654:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   1d656:	2a00      	cmp	r2, #0
   1d658:	da18      	bge.n	1d68c <usb_handle_standard_request+0x214>
		if (setup->bRequest == USB_SREQ_GET_STATUS) {
   1d65a:	2b00      	cmp	r3, #0
   1d65c:	f47f af3e 	bne.w	1d4dc <usb_handle_standard_request+0x64>
	uint8_t ep = setup->wIndex;
   1d660:	7924      	ldrb	r4, [r4, #4]
   1d662:	683f      	ldr	r7, [r7, #0]
	if (USB_EP_GET_IDX(ep) == 0) {
   1d664:	0663      	lsls	r3, r4, #25
   1d666:	d00a      	beq.n	1d67e <usb_handle_standard_request+0x206>
   1d668:	4620      	mov	r0, r4
   1d66a:	f7ff fe13 	bl	1d294 <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
   1d66e:	2800      	cmp	r0, #0
   1d670:	f43f af34 	beq.w	1d4dc <usb_handle_standard_request+0x64>
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
   1d674:	f895 30ba 	ldrb.w	r3, [r5, #186]	; 0xba
   1d678:	2b00      	cmp	r3, #0
   1d67a:	f43f af2f 	beq.w	1d4dc <usb_handle_standard_request+0x64>
		usb_dc_ep_is_stalled(ep, &data[0]);
   1d67e:	4639      	mov	r1, r7
   1d680:	4620      	mov	r0, r4
   1d682:	f001 ff01 	bl	1f488 <usb_dc_ep_is_stalled>
		data[1] = 0U;
   1d686:	2300      	movs	r3, #0
   1d688:	707b      	strb	r3, [r7, #1]
   1d68a:	e714      	b.n	1d4b6 <usb_handle_standard_request+0x3e>
		switch (setup->bRequest) {
   1d68c:	2b01      	cmp	r3, #1
   1d68e:	d008      	beq.n	1d6a2 <usb_handle_standard_request+0x22a>
   1d690:	2b03      	cmp	r3, #3
   1d692:	f47f af23 	bne.w	1d4dc <usb_handle_standard_request+0x64>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
   1d696:	8863      	ldrh	r3, [r4, #2]
   1d698:	2b00      	cmp	r3, #0
   1d69a:	f47f af1f 	bne.w	1d4dc <usb_handle_standard_request+0x64>
				return usb_halt_endpoint_req(setup, true);
   1d69e:	2101      	movs	r1, #1
   1d6a0:	e003      	b.n	1d6aa <usb_handle_standard_request+0x232>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
   1d6a2:	8861      	ldrh	r1, [r4, #2]
   1d6a4:	2900      	cmp	r1, #0
   1d6a6:	f47f af19 	bne.w	1d4dc <usb_handle_standard_request+0x64>
				return usb_halt_endpoint_req(setup, true);
   1d6aa:	88a0      	ldrh	r0, [r4, #4]
   1d6ac:	f7ff fe7a 	bl	1d3a4 <usb_halt_endpoint_req.isra.0>
		if (usb_handle_std_endpoint_req(setup, len, data_buf) == false) {
   1d6b0:	2800      	cmp	r0, #0
   1d6b2:	f47f af05 	bne.w	1d4c0 <usb_handle_standard_request+0x48>
   1d6b6:	e711      	b.n	1d4dc <usb_handle_standard_request+0x64>
		if (type == USB_DESC_CONFIGURATION) {
   1d6b8:	2902      	cmp	r1, #2
		*data = p;
   1d6ba:	603b      	str	r3, [r7, #0]
		if (type == USB_DESC_CONFIGURATION) {
   1d6bc:	f47f af1b 	bne.w	1d4f6 <usb_handle_standard_request+0x7e>
			*len = (p[CONF_DESC_wTotalLength]) |
   1d6c0:	885b      	ldrh	r3, [r3, #2]
		*len = 2;
   1d6c2:	6033      	str	r3, [r6, #0]
		return true;
   1d6c4:	e6fc      	b.n	1d4c0 <usb_handle_standard_request+0x48>
   1d6c6:	bf00      	nop
   1d6c8:	2000a768 	.word	0x2000a768
   1d6cc:	2000a822 	.word	0x2000a822
	if (usb_reqtype_is_to_host(setup)) {
   1d6d0:	f994 0000 	ldrsb.w	r0, [r4]
		switch (setup->bRequest) {
   1d6d4:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   1d6d6:	2800      	cmp	r0, #0
   1d6d8:	f6bf af72 	bge.w	1d5c0 <usb_handle_standard_request+0x148>
		switch (setup->bRequest) {
   1d6dc:	2b00      	cmp	r3, #0
   1d6de:	f43f af67 	beq.w	1d5b0 <usb_handle_standard_request+0x138>
   1d6e2:	2b0a      	cmp	r3, #10
   1d6e4:	f47f aefa 	bne.w	1d4dc <usb_handle_standard_request+0x64>
	while (p[DESC_bLength] != 0U) {
   1d6e8:	783b      	ldrb	r3, [r7, #0]
   1d6ea:	2b00      	cmp	r3, #0
   1d6ec:	f43f aef6 	beq.w	1d4dc <usb_handle_standard_request+0x64>
		if (p[DESC_bDescriptorType] == USB_DESC_INTERFACE) {
   1d6f0:	7879      	ldrb	r1, [r7, #1]
   1d6f2:	2904      	cmp	r1, #4
   1d6f4:	f47f af62 	bne.w	1d5bc <usb_handle_standard_request+0x144>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
   1d6f8:	78b9      	ldrb	r1, [r7, #2]
			if (cur_iface == setup->wIndex) {
   1d6fa:	428a      	cmp	r2, r1
   1d6fc:	f47f af5e 	bne.w	1d5bc <usb_handle_standard_request+0x144>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
   1d700:	2a07      	cmp	r2, #7
	return 0;
   1d702:	bf8e      	itee	hi
   1d704:	2300      	movhi	r3, #0
		return usb_dev.alt_setting[iface];
   1d706:	1952      	addls	r2, r2, r5
   1d708:	f892 30bb 	ldrbls.w	r3, [r2, #187]	; 0xbb
				data[0] = usb_get_alt_setting(cur_iface);
   1d70c:	f88c 3000 	strb.w	r3, [ip]
   1d710:	e6f6      	b.n	1d500 <usb_handle_standard_request+0x88>
   1d712:	bf00      	nop

0001d714 <usb_data_to_host>:
{
   1d714:	b513      	push	{r0, r1, r4, lr}
	if (usb_dev.zlp_flag == false) {
   1d716:	4c13      	ldr	r4, [pc, #76]	; (1d764 <usb_data_to_host+0x50>)
   1d718:	7d23      	ldrb	r3, [r4, #20]
   1d71a:	b9cb      	cbnz	r3, 1d750 <usb_data_to_host+0x3c>
		uint32_t chunk = usb_dev.data_buf_residue;
   1d71c:	68e2      	ldr	r2, [r4, #12]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
   1d71e:	ab01      	add	r3, sp, #4
   1d720:	2080      	movs	r0, #128	; 0x80
   1d722:	68a1      	ldr	r1, [r4, #8]
		uint32_t chunk = usb_dev.data_buf_residue;
   1d724:	9201      	str	r2, [sp, #4]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
   1d726:	f007 fb30 	bl	24d8a <usb_write>
		usb_dev.data_buf += chunk;
   1d72a:	9a01      	ldr	r2, [sp, #4]
   1d72c:	68a3      	ldr	r3, [r4, #8]
   1d72e:	4413      	add	r3, r2
   1d730:	60a3      	str	r3, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
   1d732:	68e3      	ldr	r3, [r4, #12]
   1d734:	1a9b      	subs	r3, r3, r2
   1d736:	60e3      	str	r3, [r4, #12]
		if (!usb_dev.data_buf_residue && chunk &&
   1d738:	b943      	cbnz	r3, 1d74c <usb_data_to_host+0x38>
   1d73a:	b13a      	cbz	r2, 1d74c <usb_data_to_host+0x38>
		    usb_dev.setup.wLength > usb_dev.data_buf_len) {
   1d73c:	6923      	ldr	r3, [r4, #16]
   1d73e:	88e2      	ldrh	r2, [r4, #6]
		if (!usb_dev.data_buf_residue && chunk &&
   1d740:	429a      	cmp	r2, r3
   1d742:	dd03      	ble.n	1d74c <usb_data_to_host+0x38>
			if (!(usb_dev.data_buf_len % USB_MAX_CTRL_MPS)) {
   1d744:	069b      	lsls	r3, r3, #26
   1d746:	d101      	bne.n	1d74c <usb_data_to_host+0x38>
				usb_dev.zlp_flag = true;
   1d748:	2301      	movs	r3, #1
   1d74a:	7523      	strb	r3, [r4, #20]
}
   1d74c:	b002      	add	sp, #8
   1d74e:	bd10      	pop	{r4, pc}
		usb_dev.zlp_flag = false;
   1d750:	2300      	movs	r3, #0
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
   1d752:	2080      	movs	r0, #128	; 0x80
   1d754:	461a      	mov	r2, r3
   1d756:	4619      	mov	r1, r3
		usb_dev.zlp_flag = false;
   1d758:	7523      	strb	r3, [r4, #20]
}
   1d75a:	b002      	add	sp, #8
   1d75c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
   1d760:	f001 bed8 	b.w	1f514 <usb_dc_ep_write>
   1d764:	2000a768 	.word	0x2000a768

0001d768 <usb_handle_control_transfer>:
	uint32_t chunk = 0U;
   1d768:	2300      	movs	r3, #0
{
   1d76a:	b530      	push	{r4, r5, lr}
   1d76c:	b085      	sub	sp, #20
   1d76e:	4602      	mov	r2, r0
   1d770:	460d      	mov	r5, r1
	uint32_t chunk = 0U;
   1d772:	9301      	str	r3, [sp, #4]
	if (ep == USB_CONTROL_EP_OUT && ep_status == USB_DC_EP_SETUP) {
   1d774:	2800      	cmp	r0, #0
   1d776:	d158      	bne.n	1d82a <usb_handle_control_transfer+0xc2>
   1d778:	2900      	cmp	r1, #0
   1d77a:	d135      	bne.n	1d7e8 <usb_handle_control_transfer+0x80>
		if (usb_dc_ep_read(ep, (uint8_t *)&setup_raw,
   1d77c:	2208      	movs	r2, #8
   1d77e:	460b      	mov	r3, r1
   1d780:	eb0d 0102 	add.w	r1, sp, r2
   1d784:	f007 fc9b 	bl	250be <usb_dc_ep_read>
   1d788:	2800      	cmp	r0, #0
   1d78a:	da04      	bge.n	1d796 <usb_handle_control_transfer+0x2e>
			usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
   1d78c:	2080      	movs	r0, #128	; 0x80
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
   1d78e:	f001 fe33 	bl	1f3f8 <usb_dc_ep_set_stall>
}
   1d792:	b005      	add	sp, #20
   1d794:	bd30      	pop	{r4, r5, pc}
		setup->bmRequestType = setup_raw.bmRequestType;
   1d796:	4c2a      	ldr	r4, [pc, #168]	; (1d840 <usb_handle_control_transfer+0xd8>)
   1d798:	9a02      	ldr	r2, [sp, #8]
		usb_dev.data_buf_residue = 0;
   1d79a:	e9c4 5503 	strd	r5, r5, [r4, #12]
		setup->bmRequestType = setup_raw.bmRequestType;
   1d79e:	6022      	str	r2, [r4, #0]
		setup->wIndex = sys_le16_to_cpu(setup_raw.wIndex);
   1d7a0:	9a03      	ldr	r2, [sp, #12]
		setup->wLength = sys_le16_to_cpu(setup_raw.wLength);
   1d7a2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
		setup->wIndex = sys_le16_to_cpu(setup_raw.wIndex);
   1d7a6:	6062      	str	r2, [r4, #4]
		usb_dev.data_buf = usb_dev.req_data;
   1d7a8:	f104 0238 	add.w	r2, r4, #56	; 0x38
   1d7ac:	60a2      	str	r2, [r4, #8]
		if (usb_reqtype_is_to_device(setup)) {
   1d7ae:	f99d 2008 	ldrsb.w	r2, [sp, #8]
		usb_dev.zlp_flag = false;
   1d7b2:	7525      	strb	r5, [r4, #20]
		if (usb_reqtype_is_to_device(setup)) {
   1d7b4:	2a00      	cmp	r2, #0
   1d7b6:	db0a      	blt.n	1d7ce <usb_handle_control_transfer+0x66>
			if (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {
   1d7b8:	2b80      	cmp	r3, #128	; 0x80
   1d7ba:	d904      	bls.n	1d7c6 <usb_handle_control_transfer+0x5e>
				usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
   1d7bc:	2080      	movs	r0, #128	; 0x80
   1d7be:	f001 fe1b 	bl	1f3f8 <usb_dc_ep_set_stall>
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
   1d7c2:	2000      	movs	r0, #0
   1d7c4:	e7e3      	b.n	1d78e <usb_handle_control_transfer+0x26>
			if (setup->wLength) {
   1d7c6:	b113      	cbz	r3, 1d7ce <usb_handle_control_transfer+0x66>
				usb_dev.data_buf_residue = setup->wLength;
   1d7c8:	e9c4 3303 	strd	r3, r3, [r4, #12]
				return;
   1d7cc:	e7e1      	b.n	1d792 <usb_handle_control_transfer+0x2a>
		if (!usb_handle_request(setup,
   1d7ce:	f7ff fd7d 	bl	1d2cc <usb_handle_request.constprop.0>
   1d7d2:	2800      	cmp	r0, #0
   1d7d4:	d0da      	beq.n	1d78c <usb_handle_control_transfer+0x24>
		usb_dev.data_buf_residue = MIN(usb_dev.data_buf_len,
   1d7d6:	88e2      	ldrh	r2, [r4, #6]
   1d7d8:	6923      	ldr	r3, [r4, #16]
   1d7da:	429a      	cmp	r2, r3
   1d7dc:	bfd4      	ite	le
   1d7de:	60e2      	strle	r2, [r4, #12]
   1d7e0:	60e3      	strgt	r3, [r4, #12]
			usb_data_to_host();
   1d7e2:	f7ff ff97 	bl	1d714 <usb_data_to_host>
   1d7e6:	e7d4      	b.n	1d792 <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue <= 0) {
   1d7e8:	4c15      	ldr	r4, [pc, #84]	; (1d840 <usb_handle_control_transfer+0xd8>)
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   1d7ea:	ab01      	add	r3, sp, #4
   1d7ec:	e9d4 1502 	ldrd	r1, r5, [r4, #8]
		if (usb_dev.data_buf_residue <= 0) {
   1d7f0:	2d00      	cmp	r5, #0
   1d7f2:	dc04      	bgt.n	1d7fe <usb_handle_control_transfer+0x96>
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   1d7f4:	f007 fc63 	bl	250be <usb_dc_ep_read>
   1d7f8:	2800      	cmp	r0, #0
   1d7fa:	daca      	bge.n	1d792 <usb_handle_control_transfer+0x2a>
   1d7fc:	e7c6      	b.n	1d78c <usb_handle_control_transfer+0x24>
		if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   1d7fe:	462a      	mov	r2, r5
   1d800:	f007 fc5d 	bl	250be <usb_dc_ep_read>
   1d804:	2800      	cmp	r0, #0
   1d806:	dbd9      	blt.n	1d7bc <usb_handle_control_transfer+0x54>
		usb_dev.data_buf += chunk;
   1d808:	9a01      	ldr	r2, [sp, #4]
   1d80a:	68a3      	ldr	r3, [r4, #8]
   1d80c:	4413      	add	r3, r2
   1d80e:	60a3      	str	r3, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
   1d810:	68e3      	ldr	r3, [r4, #12]
   1d812:	1a9b      	subs	r3, r3, r2
   1d814:	60e3      	str	r3, [r4, #12]
		if (usb_dev.data_buf_residue == 0) {
   1d816:	2b00      	cmp	r3, #0
   1d818:	d1bb      	bne.n	1d792 <usb_handle_control_transfer+0x2a>
			usb_dev.data_buf = usb_dev.req_data;
   1d81a:	f104 0338 	add.w	r3, r4, #56	; 0x38
   1d81e:	60a3      	str	r3, [r4, #8]
			if (!usb_handle_request(setup,
   1d820:	f7ff fd54 	bl	1d2cc <usb_handle_request.constprop.0>
   1d824:	2800      	cmp	r0, #0
   1d826:	d1dc      	bne.n	1d7e2 <usb_handle_control_transfer+0x7a>
   1d828:	e7b0      	b.n	1d78c <usb_handle_control_transfer+0x24>
	} else if (ep == USB_CONTROL_EP_IN) {
   1d82a:	2880      	cmp	r0, #128	; 0x80
   1d82c:	d1b1      	bne.n	1d792 <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue != 0 || usb_dev.zlp_flag == true) {
   1d82e:	4b04      	ldr	r3, [pc, #16]	; (1d840 <usb_handle_control_transfer+0xd8>)
   1d830:	68da      	ldr	r2, [r3, #12]
   1d832:	2a00      	cmp	r2, #0
   1d834:	d1d5      	bne.n	1d7e2 <usb_handle_control_transfer+0x7a>
   1d836:	7d1b      	ldrb	r3, [r3, #20]
   1d838:	2b00      	cmp	r3, #0
   1d83a:	d1d2      	bne.n	1d7e2 <usb_handle_control_transfer+0x7a>
   1d83c:	e7a9      	b.n	1d792 <usb_handle_control_transfer+0x2a>
   1d83e:	bf00      	nop
   1d840:	2000a768 	.word	0x2000a768

0001d844 <usb_set_config>:
	usb_dev.descriptors = usb_descriptors;
   1d844:	4b05      	ldr	r3, [pc, #20]	; (1d85c <usb_set_config+0x18>)
	usb_dev.req_handlers[type] = handler;
   1d846:	4a06      	ldr	r2, [pc, #24]	; (1d860 <usb_set_config+0x1c>)
	usb_dev.descriptors = usb_descriptors;
   1d848:	6258      	str	r0, [r3, #36]	; 0x24
	usb_dev.req_handlers[type] = handler;
   1d84a:	629a      	str	r2, [r3, #40]	; 0x28
   1d84c:	4a05      	ldr	r2, [pc, #20]	; (1d864 <usb_set_config+0x20>)

	/* register class request handlers for each interface*/
	usb_register_custom_req_handler(custom_handler);

	return 0;
}
   1d84e:	2000      	movs	r0, #0
	usb_dev.req_handlers[type] = handler;
   1d850:	62da      	str	r2, [r3, #44]	; 0x2c
   1d852:	4a05      	ldr	r2, [pc, #20]	; (1d868 <usb_set_config+0x24>)
   1d854:	631a      	str	r2, [r3, #48]	; 0x30
	usb_dev.custom_req_handler = handler;
   1d856:	4a05      	ldr	r2, [pc, #20]	; (1d86c <usb_set_config+0x28>)
   1d858:	619a      	str	r2, [r3, #24]
}
   1d85a:	4770      	bx	lr
   1d85c:	2000a768 	.word	0x2000a768
   1d860:	0001d479 	.word	0x0001d479
   1d864:	0001d17d 	.word	0x0001d17d
   1d868:	0001d21d 	.word	0x0001d21d
   1d86c:	0001d1bd 	.word	0x0001d1bd

0001d870 <usb_enable>:

int usb_enable(usb_dc_status_callback status_cb)
{
   1d870:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1d874:	4604      	mov	r4, r0
	 * This should only be called once.
	 */
	LOG_DBG("lock usb_enable_lock mutex");
	k_mutex_lock(&usb_enable_lock, K_FOREVER);

	if (usb_dev.enabled == true) {
   1d876:	4d3b      	ldr	r5, [pc, #236]	; (1d964 <usb_enable+0xf4>)
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke3(parm0.x, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   1d878:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1d87c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1d880:	4839      	ldr	r0, [pc, #228]	; (1d968 <usb_enable+0xf8>)
   1d882:	f005 fd7f 	bl	23384 <z_impl_k_mutex_lock>
   1d886:	f895 60b8 	ldrb.w	r6, [r5, #184]	; 0xb8
   1d88a:	2e00      	cmp	r6, #0
   1d88c:	d167      	bne.n	1d95e <usb_enable+0xee>
	usb_dev.status_callback = cb;
   1d88e:	4837      	ldr	r0, [pc, #220]	; (1d96c <usb_enable+0xfc>)
	ret = usb_vbus_set(true);
	if (ret < 0) {
		goto out;
	}

	usb_dev.user_status_callback = status_cb;
   1d890:	622c      	str	r4, [r5, #32]
	usb_dev.status_callback = cb;
   1d892:	61e8      	str	r0, [r5, #28]
	usb_register_status_callback(forward_status_cb);
	usb_dc_set_status_callback(forward_status_cb);
   1d894:	f001 ff58 	bl	1f748 <usb_dc_set_status_callback>

	ret = usb_dc_attach();
   1d898:	f001 fd46 	bl	1f328 <usb_dc_attach>
	if (ret < 0) {
   1d89c:	1e04      	subs	r4, r0, #0
   1d89e:	db42      	blt.n	1d926 <usb_enable+0xb6>
		goto out;
	}

	ret = usb_transfer_init();
   1d8a0:	f000 fb18 	bl	1ded4 <usb_transfer_init>
	if (ret < 0) {
   1d8a4:	1e04      	subs	r4, r0, #0
   1d8a6:	db3e      	blt.n	1d926 <usb_enable+0xb6>
		goto out;
	}

	/* Configure control EP */
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
   1d8a8:	2340      	movs	r3, #64	; 0x40
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;

	ep0_cfg.ep_addr = USB_CONTROL_EP_OUT;
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d8aa:	4668      	mov	r0, sp
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
   1d8ac:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;
   1d8b0:	f88d 6004 	strb.w	r6, [sp, #4]
	ep0_cfg.ep_addr = USB_CONTROL_EP_OUT;
   1d8b4:	f88d 6000 	strb.w	r6, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d8b8:	f001 fd7a 	bl	1f3b0 <usb_dc_ep_configure>
	if (ret < 0) {
   1d8bc:	1e04      	subs	r4, r0, #0
   1d8be:	db32      	blt.n	1d926 <usb_enable+0xb6>
		goto out;
	}

	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
   1d8c0:	2780      	movs	r7, #128	; 0x80
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d8c2:	4668      	mov	r0, sp
	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
   1d8c4:	f88d 7000 	strb.w	r7, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d8c8:	f001 fd72 	bl	1f3b0 <usb_dc_ep_configure>
	if (ret < 0) {
   1d8cc:	1e04      	subs	r4, r0, #0
   1d8ce:	db2a      	blt.n	1d926 <usb_enable+0xb6>
		goto out;
	}

	/* Register endpoint 0 handlers*/
	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_OUT,
   1d8d0:	4630      	mov	r0, r6
   1d8d2:	4927      	ldr	r1, [pc, #156]	; (1d970 <usb_enable+0x100>)
   1d8d4:	f001 ff24 	bl	1f720 <usb_dc_ep_set_callback>
				     usb_handle_control_transfer);
	if (ret < 0) {
   1d8d8:	1e04      	subs	r4, r0, #0
   1d8da:	db24      	blt.n	1d926 <usb_enable+0xb6>
		goto out;
	}

	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_IN,
   1d8dc:	4638      	mov	r0, r7
   1d8de:	4924      	ldr	r1, [pc, #144]	; (1d970 <usb_enable+0x100>)
   1d8e0:	f001 ff1e 	bl	1f720 <usb_dc_ep_set_callback>
				     usb_handle_control_transfer);
	if (ret < 0) {
   1d8e4:	1e04      	subs	r4, r0, #0
   1d8e6:	db1e      	blt.n	1d926 <usb_enable+0xb6>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d8e8:	4c22      	ldr	r4, [pc, #136]	; (1d974 <usb_enable+0x104>)
   1d8ea:	f8df 808c 	ldr.w	r8, [pc, #140]	; 1d978 <usb_enable+0x108>
   1d8ee:	4544      	cmp	r4, r8
   1d8f0:	d320      	bcc.n	1d934 <usb_enable+0xc4>
	if (ret < 0) {
		goto out;
	}

	/* Enable control EP */
	ret = usb_dc_ep_enable(USB_CONTROL_EP_OUT);
   1d8f2:	2000      	movs	r0, #0
   1d8f4:	f001 fde4 	bl	1f4c0 <usb_dc_ep_enable>
	if (ret < 0) {
   1d8f8:	1e04      	subs	r4, r0, #0
   1d8fa:	db14      	blt.n	1d926 <usb_enable+0xb6>
		goto out;
	}
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_OUT);
   1d8fc:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4

	ret = usb_dc_ep_enable(USB_CONTROL_EP_IN);
   1d900:	2080      	movs	r0, #128	; 0x80
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_OUT);
   1d902:	f043 0301 	orr.w	r3, r3, #1
   1d906:	f8c5 30c4 	str.w	r3, [r5, #196]	; 0xc4
	ret = usb_dc_ep_enable(USB_CONTROL_EP_IN);
   1d90a:	f001 fdd9 	bl	1f4c0 <usb_dc_ep_enable>
	if (ret < 0) {
   1d90e:	1e04      	subs	r4, r0, #0
   1d910:	db09      	blt.n	1d926 <usb_enable+0xb6>
		goto out;
	}
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_IN);
   1d912:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4

	usb_dev.enabled = true;
	ret = 0;
   1d916:	2400      	movs	r4, #0
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_IN);
   1d918:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1d91c:	f8c5 30c4 	str.w	r3, [r5, #196]	; 0xc4
	usb_dev.enabled = true;
   1d920:	2301      	movs	r3, #1
   1d922:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
		union { uintptr_t x; struct k_mutex * val; } parm0 = { .val = mutex };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
   1d926:	4810      	ldr	r0, [pc, #64]	; (1d968 <usb_enable+0xf8>)
   1d928:	f005 fda6 	bl	23478 <z_impl_k_mutex_unlock>
out:
	LOG_DBG("unlock usb_enable_lock mutex");
	k_mutex_unlock(&usb_enable_lock);
	return ret;
}
   1d92c:	4620      	mov	r0, r4
   1d92e:	b002      	add	sp, #8
   1d930:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d934:	2600      	movs	r6, #0
		ep_data = cfg_data->endpoint;
   1d936:	6a27      	ldr	r7, [r4, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d938:	7f22      	ldrb	r2, [r4, #28]
   1d93a:	b2f3      	uxtb	r3, r6
   1d93c:	429a      	cmp	r2, r3
   1d93e:	d801      	bhi.n	1d944 <usb_enable+0xd4>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d940:	3424      	adds	r4, #36	; 0x24
   1d942:	e7d4      	b.n	1d8ee <usb_enable+0x7e>
			if (usb_dc_ep_set_callback(ep_data[n].ep_addr,
   1d944:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
   1d948:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
   1d94c:	7910      	ldrb	r0, [r2, #4]
   1d94e:	f001 fee7 	bl	1f720 <usb_dc_ep_set_callback>
   1d952:	3601      	adds	r6, #1
   1d954:	2800      	cmp	r0, #0
   1d956:	d0ef      	beq.n	1d938 <usb_enable+0xc8>
   1d958:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1d95c:	e7e3      	b.n	1d926 <usb_enable+0xb6>
		ret = -EALREADY;
   1d95e:	f06f 0477 	mvn.w	r4, #119	; 0x77
   1d962:	e7e0      	b.n	1d926 <usb_enable+0xb6>
   1d964:	2000a768 	.word	0x2000a768
   1d968:	2000a308 	.word	0x2000a308
   1d96c:	0001d2f9 	.word	0x0001d2f9
   1d970:	0001d769 	.word	0x0001d769
   1d974:	2000a3ec 	.word	0x2000a3ec
   1d978:	2000a410 	.word	0x2000a410

0001d97c <usb_device_init>:
/*
 * This function configures the USB device stack based on USB descriptor and
 * usb_cfg_data.
 */
static int usb_device_init(void)
{
   1d97c:	b510      	push	{r4, lr}
	uint8_t *device_descriptor;

	if (usb_dev.enabled == true) {
   1d97e:	4b0a      	ldr	r3, [pc, #40]	; (1d9a8 <usb_device_init+0x2c>)
   1d980:	f893 40b8 	ldrb.w	r4, [r3, #184]	; 0xb8
   1d984:	b94c      	cbnz	r4, 1d99a <usb_device_init+0x1e>
		return -EALREADY;
	}

	/* register device descriptor */
	device_descriptor = usb_get_device_descriptor();
   1d986:	f000 f855 	bl	1da34 <usb_get_device_descriptor>
	if (!device_descriptor) {
   1d98a:	b148      	cbz	r0, 1d9a0 <usb_device_init+0x24>
		LOG_ERR("Failed to configure USB device stack");
		return -1;
	}

	usb_set_config(device_descriptor);
   1d98c:	f7ff ff5a 	bl	1d844 <usb_set_config>

	if (IS_ENABLED(CONFIG_USB_DEVICE_INITIALIZE_AT_BOOT)) {
		return usb_enable(NULL);
   1d990:	4620      	mov	r0, r4
	}

	return 0;
}
   1d992:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return usb_enable(NULL);
   1d996:	f7ff bf6b 	b.w	1d870 <usb_enable>
		return -EALREADY;
   1d99a:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
   1d99e:	bd10      	pop	{r4, pc}
		return -1;
   1d9a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1d9a4:	e7fb      	b.n	1d99e <usb_device_init+0x22>
   1d9a6:	bf00      	nop
   1d9a8:	2000a768 	.word	0x2000a768

0001d9ac <usb_update_sn_string_descriptor>:
 * case the device ID returned by the HWINFO driver is bigger, the lower
 * part is used for the USB Serial Number, as that part is usually having
 * more entropy.
 */
__weak uint8_t *usb_update_sn_string_descriptor(void)
{
   1d9ac:	b530      	push	{r4, r5, lr}
	 * unless the user requested a longer serial number.
	 */
	const int usblen = sizeof(CONFIG_USB_DEVICE_SN) / 2;
	uint8_t hwid[MAX(16, sizeof(CONFIG_USB_DEVICE_SN) / 2)];
	static uint8_t sn[sizeof(CONFIG_USB_DEVICE_SN) + 1];
	const char hex[] = "0123456789ABCDEF";
   1d9ae:	4b1f      	ldr	r3, [pc, #124]	; (1da2c <usb_update_sn_string_descriptor+0x80>)
{
   1d9b0:	b08b      	sub	sp, #44	; 0x2c
	const char hex[] = "0123456789ABCDEF";
   1d9b2:	aa05      	add	r2, sp, #20
   1d9b4:	f103 0510 	add.w	r5, r3, #16
   1d9b8:	4614      	mov	r4, r2
   1d9ba:	6818      	ldr	r0, [r3, #0]
   1d9bc:	6859      	ldr	r1, [r3, #4]
   1d9be:	3308      	adds	r3, #8
   1d9c0:	c403      	stmia	r4!, {r0, r1}
   1d9c2:	42ab      	cmp	r3, r5
   1d9c4:	4622      	mov	r2, r4
   1d9c6:	d1f7      	bne.n	1d9b8 <usb_update_sn_string_descriptor+0xc>
   1d9c8:	781b      	ldrb	r3, [r3, #0]
	int hwlen, skip;

	memset(hwid, 0, sizeof(hwid));
   1d9ca:	2210      	movs	r2, #16
	const char hex[] = "0123456789ABCDEF";
   1d9cc:	7023      	strb	r3, [r4, #0]
	memset(hwid, 0, sizeof(hwid));
   1d9ce:	2100      	movs	r1, #0
   1d9d0:	a801      	add	r0, sp, #4
   1d9d2:	f007 fb1d 	bl	25010 <memset>
	memset(sn, 0, sizeof(sn));
   1d9d6:	2212      	movs	r2, #18
   1d9d8:	2100      	movs	r1, #0
   1d9da:	4815      	ldr	r0, [pc, #84]	; (1da30 <usb_update_sn_string_descriptor+0x84>)
   1d9dc:	f007 fb18 	bl	25010 <memset>
		union { uintptr_t x; size_t val; } parm1 = { .val = length };
		return (ssize_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_HWINFO_GET_DEVICE_ID);
	}
#endif
	compiler_barrier();
	return z_impl_hwinfo_get_device_id(buffer, length);
   1d9e0:	2110      	movs	r1, #16
   1d9e2:	a801      	add	r0, sp, #4
   1d9e4:	f002 f9b8 	bl	1fd58 <z_impl_hwinfo_get_device_id>

	hwlen = hwinfo_get_device_id(hwid, sizeof(hwid));
	if (hwlen > 0) {
   1d9e8:	2800      	cmp	r0, #0
   1d9ea:	dd1b      	ble.n	1da24 <usb_update_sn_string_descriptor+0x78>
		skip = MAX(0, hwlen - usblen);
   1d9ec:	2808      	cmp	r0, #8
   1d9ee:	bfb8      	it	lt
   1d9f0:	2008      	movlt	r0, #8
   1d9f2:	ab01      	add	r3, sp, #4
   1d9f4:	3809      	subs	r0, #9
   1d9f6:	181a      	adds	r2, r3, r0
		LOG_HEXDUMP_DBG(&hwid[skip], usblen, "Serial Number");
		for (int i = 0; i < usblen; i++) {
   1d9f8:	2000      	movs	r0, #0
   1d9fa:	490d      	ldr	r1, [pc, #52]	; (1da30 <usb_update_sn_string_descriptor+0x84>)
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   1d9fc:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   1da00:	ac0a      	add	r4, sp, #40	; 0x28
   1da02:	eb04 1413 	add.w	r4, r4, r3, lsr #4
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   1da06:	f003 030f 	and.w	r3, r3, #15
   1da0a:	3328      	adds	r3, #40	; 0x28
   1da0c:	446b      	add	r3, sp
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   1da0e:	f814 4c14 	ldrb.w	r4, [r4, #-20]
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   1da12:	f813 3c14 	ldrb.w	r3, [r3, #-20]
		for (int i = 0; i < usblen; i++) {
   1da16:	3001      	adds	r0, #1
   1da18:	2808      	cmp	r0, #8
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   1da1a:	700c      	strb	r4, [r1, #0]
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   1da1c:	704b      	strb	r3, [r1, #1]
		for (int i = 0; i < usblen; i++) {
   1da1e:	f101 0102 	add.w	r1, r1, #2
   1da22:	d1eb      	bne.n	1d9fc <usb_update_sn_string_descriptor+0x50>
		}
	}

	return sn;
}
   1da24:	4802      	ldr	r0, [pc, #8]	; (1da30 <usb_update_sn_string_descriptor+0x84>)
   1da26:	b00b      	add	sp, #44	; 0x2c
   1da28:	bd30      	pop	{r4, r5, pc}
   1da2a:	bf00      	nop
   1da2c:	000269fd 	.word	0x000269fd
   1da30:	2000b5f2 	.word	0x2000b5f2

0001da34 <usb_get_device_descriptor>:
	return 0;
}


uint8_t *usb_get_device_descriptor(void)
{
   1da34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1da38:	4c63      	ldr	r4, [pc, #396]	; (1dbc8 <usb_get_device_descriptor+0x194>)
   1da3a:	b085      	sub	sp, #20
	uint8_t str_descr_idx = 0U;
   1da3c:	2600      	movs	r6, #0
	uint32_t requested_ep = BIT(16) | BIT(0);
   1da3e:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
	uint8_t numof_ifaces = 0U;
   1da42:	46b1      	mov	r9, r6
	struct usb_cfg_data *cfg_data = NULL;
   1da44:	4635      	mov	r5, r6
	struct usb_cfg_descriptor *cfg_descr = NULL;
   1da46:	46b2      	mov	sl, r6
	while (head->bLength != 0U) {
   1da48:	7823      	ldrb	r3, [r4, #0]
   1da4a:	b92b      	cbnz	r3, 1da58 <usb_get_device_descriptor+0x24>
	if ((head + 1) != __usb_descriptor_end) {
   1da4c:	4b5f      	ldr	r3, [pc, #380]	; (1dbcc <usb_get_device_descriptor+0x198>)
   1da4e:	3402      	adds	r4, #2
   1da50:	429c      	cmp	r4, r3
   1da52:	d1f3      	bne.n	1da3c <usb_get_device_descriptor+0x8>
	if (usb_fix_descriptor(__usb_descriptor_start)) {
		LOG_ERR("Failed to fixup USB descriptor");
		return NULL;
	}

	return (uint8_t *) __usb_descriptor_start;
   1da54:	485c      	ldr	r0, [pc, #368]	; (1dbc8 <usb_get_device_descriptor+0x194>)
   1da56:	e01c      	b.n	1da92 <usb_get_device_descriptor+0x5e>
		switch (head->bDescriptorType) {
   1da58:	7863      	ldrb	r3, [r4, #1]
   1da5a:	2b05      	cmp	r3, #5
   1da5c:	d805      	bhi.n	1da6a <usb_get_device_descriptor+0x36>
   1da5e:	e8df f003 	tbb	[pc, r3]
   1da62:	0479      	.short	0x0479
   1da64:	25077903 	.word	0x25077903
   1da68:	46a2      	mov	sl, r4
		head = (struct usb_desc_header *)((uint8_t *)head + head->bLength);
   1da6a:	7823      	ldrb	r3, [r4, #0]
   1da6c:	441c      	add	r4, r3
   1da6e:	e7eb      	b.n	1da48 <usb_get_device_descriptor+0x14>
			if (if_descr->bAlternateSetting) {
   1da70:	78e3      	ldrb	r3, [r4, #3]
   1da72:	2b00      	cmp	r3, #0
   1da74:	d1f9      	bne.n	1da6a <usb_get_device_descriptor+0x36>
			if (if_descr->bInterfaceNumber == 0U) {
   1da76:	78a3      	ldrb	r3, [r4, #2]
   1da78:	b173      	cbz	r3, 1da98 <usb_get_device_descriptor+0x64>
			numof_ifaces++;
   1da7a:	f109 0901 	add.w	r9, r9, #1
   1da7e:	fa5f f989 	uxtb.w	r9, r9
			break;
   1da82:	e7f2      	b.n	1da6a <usb_get_device_descriptor+0x36>
		if (cfg_data->interface_descriptor == iface) {
   1da84:	686a      	ldr	r2, [r5, #4]
   1da86:	4294      	cmp	r4, r2
   1da88:	d009      	beq.n	1da9e <usb_get_device_descriptor+0x6a>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1da8a:	3524      	adds	r5, #36	; 0x24
   1da8c:	429d      	cmp	r5, r3
   1da8e:	d3f9      	bcc.n	1da84 <usb_get_device_descriptor+0x50>
		return NULL;
   1da90:	2000      	movs	r0, #0
}
   1da92:	b005      	add	sp, #20
   1da94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1da98:	4d4d      	ldr	r5, [pc, #308]	; (1dbd0 <usb_get_device_descriptor+0x19c>)
   1da9a:	4b4e      	ldr	r3, [pc, #312]	; (1dbd4 <usb_get_device_descriptor+0x1a0>)
   1da9c:	e7f6      	b.n	1da8c <usb_get_device_descriptor+0x58>
				if (cfg_data->interface_config) {
   1da9e:	68ab      	ldr	r3, [r5, #8]
   1daa0:	2b00      	cmp	r3, #0
   1daa2:	d0ea      	beq.n	1da7a <usb_get_device_descriptor+0x46>
					cfg_data->interface_config(head,
   1daa4:	4649      	mov	r1, r9
   1daa6:	4620      	mov	r0, r4
   1daa8:	4798      	blx	r3
   1daaa:	e7e6      	b.n	1da7a <usb_get_device_descriptor+0x46>
			if (!cfg_data) {
   1daac:	2d00      	cmp	r5, #0
   1daae:	d0ef      	beq.n	1da90 <usb_get_device_descriptor+0x5c>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
   1dab0:	2300      	movs	r3, #0
   1dab2:	2101      	movs	r1, #1
   1dab4:	7f2a      	ldrb	r2, [r5, #28]
   1dab6:	4293      	cmp	r3, r2
   1dab8:	d2ea      	bcs.n	1da90 <usb_get_device_descriptor+0x5c>
		if (ep_descr->bEndpointAddress != ep_data[i].ep_addr) {
   1daba:	6a2a      	ldr	r2, [r5, #32]
   1dabc:	78a7      	ldrb	r7, [r4, #2]
   1dabe:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   1dac2:	7910      	ldrb	r0, [r2, #4]
   1dac4:	4287      	cmp	r7, r0
   1dac6:	d001      	beq.n	1dacc <usb_get_device_descriptor+0x98>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
   1dac8:	3301      	adds	r3, #1
   1daca:	e7f3      	b.n	1dab4 <usb_get_device_descriptor+0x80>
   1dacc:	2701      	movs	r7, #1
			ep_cfg.ep_type = (ep_descr->bmAttributes &
   1dace:	78e0      	ldrb	r0, [r4, #3]
   1dad0:	fa5f f887 	uxtb.w	r8, r7
   1dad4:	f000 0003 	and.w	r0, r0, #3
   1dad8:	f88d 000c 	strb.w	r0, [sp, #12]
			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
   1dadc:	7920      	ldrb	r0, [r4, #4]
   1dade:	f894 c005 	ldrb.w	ip, [r4, #5]
   1dae2:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
   1dae6:	f8ad 000a 	strh.w	r0, [sp, #10]
			if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   1daea:	f994 0002 	ldrsb.w	r0, [r4, #2]
   1daee:	2800      	cmp	r0, #0
   1daf0:	da25      	bge.n	1db3e <usb_get_device_descriptor+0x10a>
				if ((*requested_ep & (1U << (idx + 16U)))) {
   1daf2:	f107 0010 	add.w	r0, r7, #16
   1daf6:	fa01 f000 	lsl.w	r0, r1, r0
   1dafa:	ea10 0f0b 	tst.w	r0, fp
   1dafe:	d125      	bne.n	1db4c <usb_get_device_descriptor+0x118>
				ep_cfg.ep_addr = (USB_EP_DIR_IN | idx);
   1db00:	f048 0080 	orr.w	r0, r8, #128	; 0x80
   1db04:	f88d 0008 	strb.w	r0, [sp, #8]
			if (!usb_dc_ep_check_cap(&ep_cfg)) {
   1db08:	a802      	add	r0, sp, #8
   1db0a:	e9cd 3200 	strd	r3, r2, [sp]
   1db0e:	f007 faa5 	bl	2505c <usb_dc_ep_check_cap>
   1db12:	e9dd 3200 	ldrd	r3, r2, [sp]
   1db16:	2101      	movs	r1, #1
   1db18:	b9c0      	cbnz	r0, 1db4c <usb_get_device_descriptor+0x118>
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
   1db1a:	f89d 3008 	ldrb.w	r3, [sp, #8]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   1db1e:	f013 0f80 	tst.w	r3, #128	; 0x80
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
   1db22:	70a3      	strb	r3, [r4, #2]
				ep_data[i].ep_addr = ep_cfg.ep_addr;
   1db24:	7113      	strb	r3, [r2, #4]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   1db26:	460b      	mov	r3, r1
					*requested_ep |= (1U << (idx + 16U));
   1db28:	bf1d      	ittte	ne
   1db2a:	f108 0810 	addne.w	r8, r8, #16
   1db2e:	fa5f f888 	uxtbne.w	r8, r8
   1db32:	fa01 f308 	lslne.w	r3, r1, r8
					*requested_ep |= (1U << idx);
   1db36:	40bb      	lsleq	r3, r7
   1db38:	ea4b 0b03 	orr.w	fp, fp, r3
				return 0;
   1db3c:	e795      	b.n	1da6a <usb_get_device_descriptor+0x36>
				if ((*requested_ep & (1U << (idx)))) {
   1db3e:	fa01 f007 	lsl.w	r0, r1, r7
   1db42:	ea10 0f0b 	tst.w	r0, fp
   1db46:	d101      	bne.n	1db4c <usb_get_device_descriptor+0x118>
   1db48:	4640      	mov	r0, r8
   1db4a:	e7db      	b.n	1db04 <usb_get_device_descriptor+0xd0>
		for (uint8_t idx = 1; idx < 16U; idx++) {
   1db4c:	3701      	adds	r7, #1
   1db4e:	2f10      	cmp	r7, #16
   1db50:	d1bd      	bne.n	1dace <usb_get_device_descriptor+0x9a>
   1db52:	e7b9      	b.n	1dac8 <usb_get_device_descriptor+0x94>
			if (str_descr_idx == USB_DESC_SERIAL_NUMBER_IDX) {
   1db54:	2e03      	cmp	r6, #3
   1db56:	d11d      	bne.n	1db94 <usb_get_device_descriptor+0x160>
	uint8_t *runtime_sn =  usb_update_sn_string_descriptor();
   1db58:	f7ff ff28 	bl	1d9ac <usb_update_sn_string_descriptor>
	if (!runtime_sn) {
   1db5c:	4607      	mov	r7, r0
   1db5e:	b168      	cbz	r0, 1db7c <usb_get_device_descriptor+0x148>
	runtime_sn_len = strlen(runtime_sn);
   1db60:	f007 fa3b 	bl	24fda <strlen>
	if (!runtime_sn_len) {
   1db64:	4680      	mov	r8, r0
   1db66:	b148      	cbz	r0, 1db7c <usb_get_device_descriptor+0x148>
	default_sn_len = strlen(CONFIG_USB_DEVICE_SN);
   1db68:	481b      	ldr	r0, [pc, #108]	; (1dbd8 <usb_get_device_descriptor+0x1a4>)
   1db6a:	f007 fa36 	bl	24fda <strlen>
	if (runtime_sn_len != default_sn_len) {
   1db6e:	4580      	cmp	r8, r0
   1db70:	d104      	bne.n	1db7c <usb_get_device_descriptor+0x148>
	memcpy(sn->bString, runtime_sn, runtime_sn_len);
   1db72:	4642      	mov	r2, r8
   1db74:	4639      	mov	r1, r7
   1db76:	1ca0      	adds	r0, r4, #2
   1db78:	f007 fa3f 	bl	24ffa <memcpy>
	for (int i = idx_max; i >= 0; i -= 2) {
   1db7c:	f06f 0102 	mvn.w	r1, #2
	int idx_max = USB_BSTRING_UTF16LE_IDX_MAX(str_descr->bLength);
   1db80:	7823      	ldrb	r3, [r4, #0]
	for (int i = idx_max; i >= 0; i -= 2) {
   1db82:	1b09      	subs	r1, r1, r4
   1db84:	18e2      	adds	r2, r4, r3
   1db86:	eb04 0353 	add.w	r3, r4, r3, lsr #1
   1db8a:	42d1      	cmn	r1, r2
   1db8c:	d513      	bpl.n	1dbb6 <usb_get_device_descriptor+0x182>
			str_descr_idx += 1U;
   1db8e:	3601      	adds	r6, #1
   1db90:	b2f6      	uxtb	r6, r6
			break;
   1db92:	e76a      	b.n	1da6a <usb_get_device_descriptor+0x36>
			if (str_descr_idx) {
   1db94:	2e00      	cmp	r6, #0
   1db96:	d1f1      	bne.n	1db7c <usb_get_device_descriptor+0x148>
				if (!cfg_descr) {
   1db98:	f1ba 0f00 	cmp.w	sl, #0
   1db9c:	f43f af78 	beq.w	1da90 <usb_get_device_descriptor+0x5c>
				sys_put_le16((uint8_t *)head - (uint8_t *)cfg_descr,
   1dba0:	eba4 030a 	sub.w	r3, r4, sl
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
   1dba4:	f88a 3002 	strb.w	r3, [sl, #2]
	dst[1] = val >> 8;
   1dba8:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1dbac:	f88a 3003 	strb.w	r3, [sl, #3]
				cfg_descr->bNumInterfaces = numof_ifaces;
   1dbb0:	f88a 9004 	strb.w	r9, [sl, #4]
   1dbb4:	e7eb      	b.n	1db8e <usb_get_device_descriptor+0x15a>
		buf[i] = 0U;
   1dbb6:	f04f 0000 	mov.w	r0, #0
   1dbba:	f802 0c01 	strb.w	r0, [r2, #-1]
		buf[i - 1] = buf[ascii_idx_max--];
   1dbbe:	f813 0901 	ldrb.w	r0, [r3], #-1
   1dbc2:	f802 0d02 	strb.w	r0, [r2, #-2]!
	for (int i = idx_max; i >= 0; i -= 2) {
   1dbc6:	e7e0      	b.n	1db8a <usb_get_device_descriptor+0x156>
   1dbc8:	2000a32c 	.word	0x2000a32c
   1dbcc:	2000a3eb 	.word	0x2000a3eb
   1dbd0:	2000a3ec 	.word	0x2000a3ec
   1dbd4:	2000a410 	.word	0x2000a410
   1dbd8:	000269fd 	.word	0x000269fd

0001dbdc <usb_ep_get_transfer>:
static struct usb_transfer_data ut_data[CONFIG_USB_MAX_NUM_TRANSFERS];

/* Transfer management */
static struct usb_transfer_data *usb_ep_get_transfer(uint8_t ep)
{
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dbdc:	4b09      	ldr	r3, [pc, #36]	; (1dc04 <usb_ep_get_transfer+0x28>)
   1dbde:	2100      	movs	r1, #0
   1dbe0:	461a      	mov	r2, r3
{
   1dbe2:	b510      	push	{r4, lr}
		if (ut_data[i].ep == ep && ut_data[i].status != 0) {
   1dbe4:	781c      	ldrb	r4, [r3, #0]
   1dbe6:	4284      	cmp	r4, r0
   1dbe8:	d104      	bne.n	1dbf4 <usb_ep_get_transfer+0x18>
   1dbea:	685c      	ldr	r4, [r3, #4]
   1dbec:	b114      	cbz	r4, 1dbf4 <usb_ep_get_transfer+0x18>
			return &ut_data[i];
   1dbee:	eb02 1081 	add.w	r0, r2, r1, lsl #6
		}
	}

	return NULL;
}
   1dbf2:	bd10      	pop	{r4, pc}
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dbf4:	3101      	adds	r1, #1
   1dbf6:	2904      	cmp	r1, #4
   1dbf8:	f103 0340 	add.w	r3, r3, #64	; 0x40
   1dbfc:	d1f2      	bne.n	1dbe4 <usb_ep_get_transfer+0x8>
	return NULL;
   1dbfe:	2000      	movs	r0, #0
   1dc00:	e7f7      	b.n	1dbf2 <usb_ep_get_transfer+0x16>
   1dc02:	bf00      	nop
   1dc04:	2000a830 	.word	0x2000a830

0001dc08 <usb_transfer_work>:

	return false;
}

static void usb_transfer_work(struct k_work *item)
{
   1dc08:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	uint8_t ep;

	trans = CONTAINER_OF(item, struct usb_transfer_data, work);
	ep = trans->ep;

	if (trans->status != -EBUSY) {
   1dc0c:	f850 3c28 	ldr.w	r3, [r0, #-40]
{
   1dc10:	4604      	mov	r4, r0
	if (trans->status != -EBUSY) {
   1dc12:	3310      	adds	r3, #16
	ep = trans->ep;
   1dc14:	f810 6c2c 	ldrb.w	r6, [r0, #-44]
	if (trans->status != -EBUSY) {
   1dc18:	d110      	bne.n	1dc3c <usb_transfer_work+0x34>
		/* transfer cancelled or already completed */
		LOG_DBG("Transfer cancelled or completed, ep 0x%02x", ep);
		goto done;
	}

	if (trans->flags & USB_TRANS_WRITE) {
   1dc1a:	6903      	ldr	r3, [r0, #16]
		if (!trans->bsize) {
   1dc1c:	f850 2c20 	ldr.w	r2, [r0, #-32]
	if (trans->flags & USB_TRANS_WRITE) {
   1dc20:	0799      	lsls	r1, r3, #30
   1dc22:	d53c      	bpl.n	1dc9e <usb_transfer_work+0x96>
		if (!trans->bsize) {
   1dc24:	bb02      	cbnz	r2, 1dc68 <usb_transfer_work+0x60>
			if (!(trans->flags & USB_TRANS_NO_ZLP)) {
   1dc26:	f013 0304 	ands.w	r3, r3, #4
   1dc2a:	d104      	bne.n	1dc36 <usb_transfer_work+0x2e>
				LOG_DBG("Transfer ZLP");
				usb_write(ep, NULL, 0, NULL);
   1dc2c:	461a      	mov	r2, r3
   1dc2e:	4619      	mov	r1, r3
   1dc30:	4630      	mov	r0, r6
   1dc32:	f007 f8aa 	bl	24d8a <usb_write>
			}
			trans->status = 0;
   1dc36:	2300      	movs	r3, #0

		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
		if (ret) {
			LOG_ERR("Transfer error %d, ep 0x%02x", ret, ep);
			/* transfer error */
			trans->status = -EINVAL;
   1dc38:	f844 3c28 	str.w	r3, [r4, #-40]
		/* we expect mote data, clear NAK */
		usb_dc_ep_read_continue(ep);
	}

done:
	if (trans->status != -EBUSY && trans->cb) { /* Transfer complete */
   1dc3c:	f854 3c28 	ldr.w	r3, [r4, #-40]
   1dc40:	3310      	adds	r3, #16
   1dc42:	d00e      	beq.n	1dc62 <usb_transfer_work+0x5a>
   1dc44:	f854 5c18 	ldr.w	r5, [r4, #-24]
   1dc48:	b15d      	cbz	r5, 1dc62 <usb_transfer_work+0x5a>
		usb_transfer_callback cb = trans->cb;
		int tsize = trans->tsize;
   1dc4a:	f854 7c1c 	ldr.w	r7, [r4, #-28]
		void *priv = trans->priv;
   1dc4e:	f854 8c14 	ldr.w	r8, [r4, #-20]

		if (k_is_in_isr()) {
   1dc52:	f007 ffb4 	bl	25bbe <k_is_in_isr>
   1dc56:	2800      	cmp	r0, #0
   1dc58:	d04c      	beq.n	1dcf4 <usb_transfer_work+0xec>
			/* reschedule completion in thread context */
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dc5a:	4621      	mov	r1, r4
   1dc5c:	482b      	ldr	r0, [pc, #172]	; (1dd0c <usb_transfer_work+0x104>)
   1dc5e:	f008 f8a2 	bl	25da6 <k_work_submit_to_queue>
		k_sem_give(&trans->sem);

		/* Transfer completion callback */
		cb(ep, tsize, priv);
	}
}
   1dc62:	b002      	add	sp, #8
   1dc64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
   1dc68:	f850 1c24 	ldr.w	r1, [r0, #-36]
   1dc6c:	ab01      	add	r3, sp, #4
   1dc6e:	4630      	mov	r0, r6
   1dc70:	f007 f88b 	bl	24d8a <usb_write>
		if (ret) {
   1dc74:	b110      	cbz	r0, 1dc7c <usb_transfer_work+0x74>
			trans->status = -EINVAL;
   1dc76:	f06f 0315 	mvn.w	r3, #21
   1dc7a:	e7dd      	b.n	1dc38 <usb_transfer_work+0x30>
		trans->buffer += bytes;
   1dc7c:	9a01      	ldr	r2, [sp, #4]
   1dc7e:	f854 3c24 	ldr.w	r3, [r4, #-36]
   1dc82:	4413      	add	r3, r2
   1dc84:	f844 3c24 	str.w	r3, [r4, #-36]
		trans->bsize -= bytes;
   1dc88:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1dc8c:	1a9b      	subs	r3, r3, r2
   1dc8e:	f844 3c20 	str.w	r3, [r4, #-32]
		trans->tsize += bytes;
   1dc92:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   1dc96:	4413      	add	r3, r2
   1dc98:	f844 3c1c 	str.w	r3, [r4, #-28]
   1dc9c:	e7ce      	b.n	1dc3c <usb_transfer_work+0x34>
		ret = usb_dc_ep_read_wait(ep, trans->buffer, trans->bsize,
   1dc9e:	f850 1c24 	ldr.w	r1, [r0, #-36]
   1dca2:	ab01      	add	r3, sp, #4
   1dca4:	4630      	mov	r0, r6
   1dca6:	f001 fcb1 	bl	1f60c <usb_dc_ep_read_wait>
		if (ret) {
   1dcaa:	2800      	cmp	r0, #0
   1dcac:	d1e3      	bne.n	1dc76 <usb_transfer_work+0x6e>
		trans->buffer += bytes;
   1dcae:	9d01      	ldr	r5, [sp, #4]
   1dcb0:	f854 3c24 	ldr.w	r3, [r4, #-36]
   1dcb4:	442b      	add	r3, r5
   1dcb6:	f844 3c24 	str.w	r3, [r4, #-36]
		trans->bsize -= bytes;
   1dcba:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1dcbe:	1b5b      	subs	r3, r3, r5
   1dcc0:	f844 3c20 	str.w	r3, [r4, #-32]
		trans->tsize += bytes;
   1dcc4:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   1dcc8:	442b      	add	r3, r5
   1dcca:	f844 3c1c 	str.w	r3, [r4, #-28]
		if (!bytes || (bytes % usb_dc_ep_mps(ep)) || !trans->bsize) {
   1dcce:	2d00      	cmp	r5, #0
   1dcd0:	d0b1      	beq.n	1dc36 <usb_transfer_work+0x2e>
   1dcd2:	4630      	mov	r0, r6
   1dcd4:	f001 fd3e 	bl	1f754 <usb_dc_ep_mps>
   1dcd8:	fbb5 f3f0 	udiv	r3, r5, r0
   1dcdc:	fb03 5510 	mls	r5, r3, r0, r5
   1dce0:	2d00      	cmp	r5, #0
   1dce2:	d1a8      	bne.n	1dc36 <usb_transfer_work+0x2e>
   1dce4:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1dce8:	2b00      	cmp	r3, #0
   1dcea:	d0a4      	beq.n	1dc36 <usb_transfer_work+0x2e>
		usb_dc_ep_read_continue(ep);
   1dcec:	4630      	mov	r0, r6
   1dcee:	f001 fcd5 	bl	1f69c <usb_dc_ep_read_continue>
   1dcf2:	e7a3      	b.n	1dc3c <usb_transfer_work+0x34>
		trans->cb = NULL;
   1dcf4:	f844 0c18 	str.w	r0, [r4, #-24]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   1dcf8:	f1a4 0010 	sub.w	r0, r4, #16
   1dcfc:	f005 fc2c 	bl	23558 <z_impl_k_sem_give>
		cb(ep, tsize, priv);
   1dd00:	4642      	mov	r2, r8
   1dd02:	4639      	mov	r1, r7
   1dd04:	4630      	mov	r0, r6
   1dd06:	47a8      	blx	r5
   1dd08:	e7ab      	b.n	1dc62 <usb_transfer_work+0x5a>
   1dd0a:	bf00      	nop
   1dd0c:	2000a410 	.word	0x2000a410

0001dd10 <usb_transfer_ep_callback>:

void usb_transfer_ep_callback(uint8_t ep, enum usb_dc_ep_cb_status_code status)
{
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);

	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
   1dd10:	1e4b      	subs	r3, r1, #1
   1dd12:	2b01      	cmp	r3, #1
{
   1dd14:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1dd16:	4606      	mov	r6, r0
   1dd18:	460d      	mov	r5, r1
	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
   1dd1a:	d80f      	bhi.n	1dd3c <usb_transfer_ep_callback+0x2c>
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);
   1dd1c:	f7ff ff5e 	bl	1dbdc <usb_ep_get_transfer>
		return;
	}

	if (!trans) {
   1dd20:	4604      	mov	r4, r0
   1dd22:	b968      	cbnz	r0, 1dd40 <usb_transfer_ep_callback+0x30>
		if (status == USB_DC_EP_DATA_OUT) {
   1dd24:	2d01      	cmp	r5, #1
   1dd26:	d109      	bne.n	1dd3c <usb_transfer_ep_callback+0x2c>
			 * so drain it).
			 */
			do {
				uint8_t data;

				usb_dc_ep_read_wait(ep, &data, 1, &bytes);
   1dd28:	ab01      	add	r3, sp, #4
   1dd2a:	2201      	movs	r2, #1
   1dd2c:	4630      	mov	r0, r6
   1dd2e:	f10d 0103 	add.w	r1, sp, #3
   1dd32:	f001 fc6b 	bl	1f60c <usb_dc_ep_read_wait>
			} while (bytes);
   1dd36:	9b01      	ldr	r3, [sp, #4]
   1dd38:	2b00      	cmp	r3, #0
   1dd3a:	d1f5      	bne.n	1dd28 <usb_transfer_ep_callback+0x18>
		/* Read (out) needs to be done from ep_callback */
		usb_transfer_work(&trans->work);
	} else {
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
	}
}
   1dd3c:	b002      	add	sp, #8
   1dd3e:	bd70      	pop	{r4, r5, r6, pc}
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
   1dd40:	f007 ff3d 	bl	25bbe <k_is_in_isr>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dd44:	f104 012c 	add.w	r1, r4, #44	; 0x2c
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
   1dd48:	b108      	cbz	r0, 1dd4e <usb_transfer_ep_callback+0x3e>
   1dd4a:	2d01      	cmp	r5, #1
   1dd4c:	d105      	bne.n	1dd5a <usb_transfer_ep_callback+0x4a>
		usb_transfer_work(&trans->work);
   1dd4e:	4608      	mov	r0, r1
}
   1dd50:	b002      	add	sp, #8
   1dd52:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		usb_transfer_work(&trans->work);
   1dd56:	f7ff bf57 	b.w	1dc08 <usb_transfer_work>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dd5a:	4803      	ldr	r0, [pc, #12]	; (1dd68 <usb_transfer_ep_callback+0x58>)
}
   1dd5c:	b002      	add	sp, #8
   1dd5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dd62:	f008 b820 	b.w	25da6 <k_work_submit_to_queue>
   1dd66:	bf00      	nop
   1dd68:	2000a410 	.word	0x2000a410

0001dd6c <usb_transfer>:

int usb_transfer(uint8_t ep, uint8_t *data, size_t dlen, unsigned int flags,
		 usb_transfer_callback cb, void *cb_data)
{
   1dd6c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1dd70:	4606      	mov	r6, r0
   1dd72:	4615      	mov	r5, r2
   1dd74:	4698      	mov	r8, r3
   1dd76:	9101      	str	r1, [sp, #4]
	struct usb_transfer_data *trans = NULL;
	int key, ret = 0;

	/* Parallel transfer to same endpoint is not supported. */
	if (usb_transfer_is_busy(ep)) {
   1dd78:	f007 f84d 	bl	24e16 <usb_transfer_is_busy>
   1dd7c:	4604      	mov	r4, r0
   1dd7e:	2800      	cmp	r0, #0
   1dd80:	d15c      	bne.n	1de3c <usb_transfer+0xd0>
	__asm__ volatile(
   1dd82:	f04f 0320 	mov.w	r3, #32
   1dd86:	f3ef 8a11 	mrs	sl, BASEPRI
   1dd8a:	f383 8812 	msr	BASEPRI_MAX, r3
   1dd8e:	f3bf 8f6f 	isb	sy
	LOG_DBG("Transfer start, ep 0x%02x, data %p, dlen %zd",
		ep, data, dlen);

	key = irq_lock();

	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dd92:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 1de44 <usb_transfer+0xd8>
	return z_impl_k_sem_take(sem, timeout);
   1dd96:	2200      	movs	r2, #0
   1dd98:	2300      	movs	r3, #0
   1dd9a:	4658      	mov	r0, fp
   1dd9c:	f005 fbfc 	bl	23598 <z_impl_k_sem_take>
		if (!k_sem_take(&ut_data[i].sem, K_NO_WAIT)) {
   1dda0:	b970      	cbnz	r0, 1ddc0 <usb_transfer+0x54>
		LOG_ERR("No transfer slot available");
		ret = -ENOMEM;
		goto done;
	}

	if (trans->status == -EBUSY) {
   1dda2:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 1de48 <usb_transfer+0xdc>
   1dda6:	01a7      	lsls	r7, r4, #6
   1dda8:	eb09 1484 	add.w	r4, r9, r4, lsl #6
   1ddac:	6863      	ldr	r3, [r4, #4]
   1ddae:	f113 0f10 	cmn.w	r3, #16
   1ddb2:	d114      	bne.n	1ddde <usb_transfer+0x72>
   1ddb4:	9301      	str	r3, [sp, #4]
	z_impl_k_sem_give(sem);
   1ddb6:	4658      	mov	r0, fp
   1ddb8:	f005 fbce 	bl	23558 <z_impl_k_sem_give>
		/* A transfer is already ongoing and not completed */
		LOG_ERR("A transfer is already ongoing, ep 0x%02x", ep);
		k_sem_give(&trans->sem);
		ret = -EBUSY;
		goto done;
   1ddbc:	9b01      	ldr	r3, [sp, #4]
   1ddbe:	e006      	b.n	1ddce <usb_transfer+0x62>
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1ddc0:	3401      	adds	r4, #1
   1ddc2:	2c04      	cmp	r4, #4
   1ddc4:	f10b 0b40 	add.w	fp, fp, #64	; 0x40
   1ddc8:	d1e5      	bne.n	1dd96 <usb_transfer+0x2a>
		ret = -ENOMEM;
   1ddca:	f06f 030b 	mvn.w	r3, #11
	__asm__ volatile(
   1ddce:	f38a 8811 	msr	BASEPRI, sl
   1ddd2:	f3bf 8f6f 	isb	sy
	}

done:
	irq_unlock(key);
	return ret;
}
   1ddd6:	4618      	mov	r0, r3
   1ddd8:	b003      	add	sp, #12
   1ddda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	trans->buffer = data;
   1ddde:	9b01      	ldr	r3, [sp, #4]
	trans->tsize = 0;
   1dde0:	6120      	str	r0, [r4, #16]
	trans->bsize = dlen;
   1dde2:	e9c4 3502 	strd	r3, r5, [r4, #8]
	trans->cb = cb;
   1dde6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
   1dde8:	4630      	mov	r0, r6
	trans->cb = cb;
   1ddea:	6163      	str	r3, [r4, #20]
	trans->priv = cb_data;
   1ddec:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	trans->ep = ep;
   1ddee:	f809 6007 	strb.w	r6, [r9, r7]
	trans->priv = cb_data;
   1ddf2:	61a3      	str	r3, [r4, #24]
	trans->status = -EBUSY;
   1ddf4:	f06f 030f 	mvn.w	r3, #15
	trans->flags = flags;
   1ddf8:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
	trans->status = -EBUSY;
   1ddfc:	6063      	str	r3, [r4, #4]
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
   1ddfe:	f001 fca9 	bl	1f754 <usb_dc_ep_mps>
   1de02:	b158      	cbz	r0, 1de1c <usb_transfer+0xb0>
   1de04:	4630      	mov	r0, r6
   1de06:	f001 fca5 	bl	1f754 <usb_dc_ep_mps>
   1de0a:	fbb5 f3f0 	udiv	r3, r5, r0
   1de0e:	fb03 5510 	mls	r5, r3, r0, r5
   1de12:	b11d      	cbz	r5, 1de1c <usb_transfer+0xb0>
		trans->flags |= USB_TRANS_NO_ZLP;
   1de14:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1de16:	f043 0304 	orr.w	r3, r3, #4
   1de1a:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (flags & USB_TRANS_WRITE) {
   1de1c:	f018 0f02 	tst.w	r8, #2
   1de20:	d007      	beq.n	1de32 <usb_transfer+0xc6>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de22:	f107 012c 	add.w	r1, r7, #44	; 0x2c
   1de26:	4809      	ldr	r0, [pc, #36]	; (1de4c <usb_transfer+0xe0>)
   1de28:	4449      	add	r1, r9
   1de2a:	f007 ffbc 	bl	25da6 <k_work_submit_to_queue>
	int key, ret = 0;
   1de2e:	2300      	movs	r3, #0
   1de30:	e7cd      	b.n	1ddce <usb_transfer+0x62>
		ret = usb_dc_ep_read_continue(ep);
   1de32:	4630      	mov	r0, r6
   1de34:	f001 fc32 	bl	1f69c <usb_dc_ep_read_continue>
   1de38:	4603      	mov	r3, r0
   1de3a:	e7c8      	b.n	1ddce <usb_transfer+0x62>
		return -EBUSY;
   1de3c:	f06f 030f 	mvn.w	r3, #15
   1de40:	e7c9      	b.n	1ddd6 <usb_transfer+0x6a>
   1de42:	bf00      	nop
   1de44:	2000a84c 	.word	0x2000a84c
   1de48:	2000a830 	.word	0x2000a830
   1de4c:	2000a410 	.word	0x2000a410

0001de50 <usb_cancel_transfer>:

void usb_cancel_transfer(uint8_t ep)
{
   1de50:	b510      	push	{r4, lr}
	__asm__ volatile(
   1de52:	f04f 0320 	mov.w	r3, #32
   1de56:	f3ef 8411 	mrs	r4, BASEPRI
   1de5a:	f383 8812 	msr	BASEPRI_MAX, r3
   1de5e:	f3bf 8f6f 	isb	sy
	struct usb_transfer_data *trans;
	unsigned int key;

	key = irq_lock();

	trans = usb_ep_get_transfer(ep);
   1de62:	f7ff febb 	bl	1dbdc <usb_ep_get_transfer>
	if (!trans) {
   1de66:	b150      	cbz	r0, 1de7e <usb_cancel_transfer+0x2e>
		goto done;
	}

	if (trans->status != -EBUSY) {
   1de68:	6843      	ldr	r3, [r0, #4]
   1de6a:	3310      	adds	r3, #16
   1de6c:	d107      	bne.n	1de7e <usb_cancel_transfer+0x2e>
		goto done;
	}

	trans->status = -ECANCELED;
   1de6e:	f06f 038b 	mvn.w	r3, #139	; 0x8b
	k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de72:	f100 012c 	add.w	r1, r0, #44	; 0x2c
	trans->status = -ECANCELED;
   1de76:	6043      	str	r3, [r0, #4]
	k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de78:	4803      	ldr	r0, [pc, #12]	; (1de88 <usb_cancel_transfer+0x38>)
   1de7a:	f007 ff94 	bl	25da6 <k_work_submit_to_queue>
	__asm__ volatile(
   1de7e:	f384 8811 	msr	BASEPRI, r4
   1de82:	f3bf 8f6f 	isb	sy

done:
	irq_unlock(key);
}
   1de86:	bd10      	pop	{r4, pc}
   1de88:	2000a410 	.word	0x2000a410

0001de8c <usb_cancel_transfers>:

void usb_cancel_transfers(void)
{
   1de8c:	b570      	push	{r4, r5, r6, lr}
   1de8e:	2504      	movs	r5, #4
   1de90:	4c0e      	ldr	r4, [pc, #56]	; (1decc <usb_cancel_transfers+0x40>)
	__asm__ volatile(
   1de92:	f04f 0320 	mov.w	r3, #32
   1de96:	f3ef 8611 	mrs	r6, BASEPRI
   1de9a:	f383 8812 	msr	BASEPRI_MAX, r3
   1de9e:	f3bf 8f6f 	isb	sy
		struct usb_transfer_data *trans = &ut_data[i];
		unsigned int key;

		key = irq_lock();

		if (trans->status == -EBUSY) {
   1dea2:	6863      	ldr	r3, [r4, #4]
   1dea4:	3310      	adds	r3, #16
   1dea6:	d107      	bne.n	1deb8 <usb_cancel_transfers+0x2c>
			trans->status = -ECANCELED;
   1dea8:	f06f 038b 	mvn.w	r3, #139	; 0x8b
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1deac:	4808      	ldr	r0, [pc, #32]	; (1ded0 <usb_cancel_transfers+0x44>)
			trans->status = -ECANCELED;
   1deae:	6063      	str	r3, [r4, #4]
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1deb0:	f104 012c 	add.w	r1, r4, #44	; 0x2c
   1deb4:	f007 ff77 	bl	25da6 <k_work_submit_to_queue>
	__asm__ volatile(
   1deb8:	f386 8811 	msr	BASEPRI, r6
   1debc:	f3bf 8f6f 	isb	sy
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dec0:	3d01      	subs	r5, #1
   1dec2:	f104 0440 	add.w	r4, r4, #64	; 0x40
   1dec6:	d1e4      	bne.n	1de92 <usb_cancel_transfers+0x6>
			LOG_DBG("Cancel transfer for ep: 0x%02x", trans->ep);
		}

		irq_unlock(key);
	}
}
   1dec8:	bd70      	pop	{r4, r5, r6, pc}
   1deca:	bf00      	nop
   1decc:	2000a830 	.word	0x2000a830
   1ded0:	2000a410 	.word	0x2000a410

0001ded4 <usb_transfer_init>:
	return pdata.tsize;
}

/* Init transfer slots */
int usb_transfer_init(void)
{
   1ded4:	b570      	push	{r4, r5, r6, lr}
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1ded6:	2500      	movs	r5, #0
   1ded8:	4c09      	ldr	r4, [pc, #36]	; (1df00 <usb_transfer_init+0x2c>)
		k_work_init(&ut_data[i].work, usb_transfer_work);
   1deda:	4e0a      	ldr	r6, [pc, #40]	; (1df04 <usb_transfer_init+0x30>)
   1dedc:	4631      	mov	r1, r6
   1dede:	4620      	mov	r0, r4
   1dee0:	f007 ff44 	bl	25d6c <k_work_init>
	return z_impl_k_sem_init(sem, initial_count, limit);
   1dee4:	2201      	movs	r2, #1
   1dee6:	f1a4 0010 	sub.w	r0, r4, #16
   1deea:	4611      	mov	r1, r2
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1deec:	3501      	adds	r5, #1
   1deee:	f007 ff00 	bl	25cf2 <z_impl_k_sem_init>
   1def2:	2d04      	cmp	r5, #4
   1def4:	f104 0440 	add.w	r4, r4, #64	; 0x40
   1def8:	d1f0      	bne.n	1dedc <usb_transfer_init+0x8>
		k_sem_init(&ut_data[i].sem, 1, 1);
	}

	return 0;
}
   1defa:	2000      	movs	r0, #0
   1defc:	bd70      	pop	{r4, r5, r6, pc}
   1defe:	bf00      	nop
   1df00:	2000a85c 	.word	0x2000a85c
   1df04:	0001dc09 	.word	0x0001dc09

0001df08 <cdc_acm_class_handle_req>:
 *
 * @return  0 on success, negative errno code on fail.
 */
int cdc_acm_class_handle_req(struct usb_setup_packet *setup,
			     int32_t *len, uint8_t **data)
{
   1df08:	b570      	push	{r4, r5, r6, lr}
   1df0a:	4604      	mov	r4, r0
   1df0c:	460e      	mov	r6, r1
	struct cdc_acm_dev_data_t *dev_data;
	struct usb_dev_data *common;
	uint32_t rate;
	uint32_t new_rate;

	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
   1df0e:	7901      	ldrb	r1, [r0, #4]
   1df10:	4812      	ldr	r0, [pc, #72]	; (1df5c <cdc_acm_class_handle_req+0x54>)
{
   1df12:	4615      	mov	r5, r2
	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
   1df14:	f006 ff5c 	bl	24dd0 <usb_get_dev_data_by_iface>
					   (uint8_t)setup->wIndex);
	if (common == NULL) {
   1df18:	b1e8      	cbz	r0, 1df56 <cdc_acm_class_handle_req+0x4e>
		return -ENODEV;
	}

	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);

	if (usb_reqtype_is_to_device(setup)) {
   1df1a:	f994 2000 	ldrsb.w	r2, [r4]
		switch (setup->bRequest) {
   1df1e:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_device(setup)) {
   1df20:	2a00      	cmp	r2, #0
   1df22:	db11      	blt.n	1df48 <cdc_acm_class_handle_req+0x40>
		switch (setup->bRequest) {
   1df24:	2b20      	cmp	r3, #32
   1df26:	d004      	beq.n	1df32 <cdc_acm_class_handle_req+0x2a>
   1df28:	2b22      	cmp	r3, #34	; 0x22
   1df2a:	d009      	beq.n	1df40 <cdc_acm_class_handle_req+0x38>
		}
	}

	LOG_DBG("CDC ACM bmRequestType 0x%02x bRequest 0x%02x unsupported",
		setup->bmRequestType, setup->bRequest);
	return -ENOTSUP;
   1df2c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1df30:	e005      	b.n	1df3e <cdc_acm_class_handle_req+0x36>
			memcpy(&dev_data->line_coding, *data,
   1df32:	2207      	movs	r2, #7
   1df34:	6829      	ldr	r1, [r5, #0]
   1df36:	3810      	subs	r0, #16
   1df38:	f007 f85f 	bl	24ffa <memcpy>
			return 0;
   1df3c:	2000      	movs	r0, #0
}
   1df3e:	bd70      	pop	{r4, r5, r6, pc}
			dev_data->line_state = (uint8_t)setup->wValue;
   1df40:	8863      	ldrh	r3, [r4, #2]
   1df42:	f800 3c09 	strb.w	r3, [r0, #-9]
			return 0;
   1df46:	e7f9      	b.n	1df3c <cdc_acm_class_handle_req+0x34>
		if (setup->bRequest == GET_LINE_CODING) {
   1df48:	2b21      	cmp	r3, #33	; 0x21
   1df4a:	d1ef      	bne.n	1df2c <cdc_acm_class_handle_req+0x24>
			*len = sizeof(dev_data->line_coding);
   1df4c:	2307      	movs	r3, #7
			*data = (uint8_t *)(&dev_data->line_coding);
   1df4e:	3810      	subs	r0, #16
   1df50:	6028      	str	r0, [r5, #0]
			*len = sizeof(dev_data->line_coding);
   1df52:	6033      	str	r3, [r6, #0]
			return 0;
   1df54:	e7f2      	b.n	1df3c <cdc_acm_class_handle_req+0x34>
		return -ENODEV;
   1df56:	f06f 0012 	mvn.w	r0, #18
   1df5a:	e7f0      	b.n	1df3e <cdc_acm_class_handle_req+0x36>
   1df5c:	2000a930 	.word	0x2000a930

0001df60 <cdc_acm_int_in>:
 *
 * @param ep        Endpoint address.
 * @param ep_status Endpoint status code.
 */
static void cdc_acm_int_in(uint8_t ep, enum usb_dc_ep_cb_status_code ep_status)
{
   1df60:	4601      	mov	r1, r0
   1df62:	b508      	push	{r3, lr}
	struct cdc_acm_dev_data_t *dev_data;
	struct usb_dev_data *common;

	ARG_UNUSED(ep_status);

	common = usb_get_dev_data_by_ep(&cdc_acm_data_devlist, ep);
   1df64:	4803      	ldr	r0, [pc, #12]	; (1df74 <cdc_acm_int_in+0x14>)
   1df66:	f006 ff40 	bl	24dea <usb_get_dev_data_by_ep>
	if (common == NULL) {
   1df6a:	b110      	cbz	r0, 1df72 <cdc_acm_int_in+0x12>
		return;
	}

	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);

	dev_data->notification_sent = 1U;
   1df6c:	2301      	movs	r3, #1
   1df6e:	f800 3c07 	strb.w	r3, [r0, #-7]
	LOG_DBG("CDC_IntIN EP[%x]\r", ep);
}
   1df72:	bd08      	pop	{r3, pc}
   1df74:	2000a930 	.word	0x2000a930

0001df78 <cdc_acm_irq_rx_enable>:
 */
static void cdc_acm_irq_rx_enable(const struct device *dev)
{
	struct cdc_acm_dev_data_t * const dev_data = dev->data;

	dev_data->rx_irq_ena = true;
   1df78:	2301      	movs	r3, #1
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1df7a:	6901      	ldr	r1, [r0, #16]
	dev_data->rx_irq_ena = true;
   1df7c:	f881 304b 	strb.w	r3, [r1, #75]	; 0x4b

	if (dev_data->cb && dev_data->rx_ready) {
   1df80:	680b      	ldr	r3, [r1, #0]
   1df82:	b133      	cbz	r3, 1df92 <cdc_acm_irq_rx_enable+0x1a>
   1df84:	f891 3049 	ldrb.w	r3, [r1, #73]	; 0x49
   1df88:	b11b      	cbz	r3, 1df92 <cdc_acm_irq_rx_enable+0x1a>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1df8a:	4802      	ldr	r0, [pc, #8]	; (1df94 <cdc_acm_irq_rx_enable+0x1c>)
   1df8c:	3108      	adds	r1, #8
   1df8e:	f007 bf0a 	b.w	25da6 <k_work_submit_to_queue>
	}
}
   1df92:	4770      	bx	lr
   1df94:	2000a410 	.word	0x2000a410

0001df98 <cdc_acm_irq_tx_enable>:
	dev_data->tx_irq_ena = true;
   1df98:	2301      	movs	r3, #1
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1df9a:	6901      	ldr	r1, [r0, #16]
	dev_data->tx_irq_ena = true;
   1df9c:	f881 304a 	strb.w	r3, [r1, #74]	; 0x4a
	if (dev_data->cb && dev_data->tx_ready) {
   1dfa0:	680b      	ldr	r3, [r1, #0]
   1dfa2:	b133      	cbz	r3, 1dfb2 <cdc_acm_irq_tx_enable+0x1a>
   1dfa4:	f891 3048 	ldrb.w	r3, [r1, #72]	; 0x48
   1dfa8:	b11b      	cbz	r3, 1dfb2 <cdc_acm_irq_tx_enable+0x1a>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1dfaa:	4802      	ldr	r0, [pc, #8]	; (1dfb4 <cdc_acm_irq_tx_enable+0x1c>)
   1dfac:	3108      	adds	r1, #8
   1dfae:	f007 befa 	b.w	25da6 <k_work_submit_to_queue>
}
   1dfb2:	4770      	bx	lr
   1dfb4:	2000a410 	.word	0x2000a410

0001dfb8 <cdc_acm_reset_port>:
	dev_data->tx_ready = false;
   1dfb8:	2100      	movs	r1, #0
{
   1dfba:	4603      	mov	r3, r0
	dev_data->line_coding = (struct cdc_acm_line_coding)
   1dfbc:	4a0c      	ldr	r2, [pc, #48]	; (1dff0 <cdc_acm_reset_port+0x38>)
	dev_data->tx_ready = false;
   1dfbe:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
	dev_data->line_coding = (struct cdc_acm_line_coding)
   1dfc2:	6810      	ldr	r0, [r2, #0]
	dev_data->serial_state = 0;
   1dfc4:	f883 109c 	strb.w	r1, [r3, #156]	; 0x9c
	dev_data->line_coding = (struct cdc_acm_line_coding)
   1dfc8:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
   1dfcc:	8890      	ldrh	r0, [r2, #4]
   1dfce:	7992      	ldrb	r2, [r2, #6]
   1dfd0:	f8a3 0098 	strh.w	r0, [r3, #152]	; 0x98
   1dfd4:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
	dev_data->line_state = 0;
   1dfd8:	f883 109b 	strb.w	r1, [r3, #155]	; 0x9b
	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
   1dfdc:	2240      	movs	r2, #64	; 0x40
	dev_data->configured = false;
   1dfde:	f8a3 109e 	strh.w	r1, [r3, #158]	; 0x9e
	dev_data->rx_paused = false;
   1dfe2:	f883 10a0 	strb.w	r1, [r3, #160]	; 0xa0
	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
   1dfe6:	f103 004c 	add.w	r0, r3, #76	; 0x4c
   1dfea:	f007 b811 	b.w	25010 <memset>
   1dfee:	bf00      	nop
   1dff0:	00026640 	.word	0x00026640

0001dff4 <cdc_acm_fifo_fill>:
{
   1dff4:	b538      	push	{r3, r4, r5, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1dff6:	6905      	ldr	r5, [r0, #16]
	if (!dev_data->configured || dev_data->suspended) {
   1dff8:	f895 009e 	ldrb.w	r0, [r5, #158]	; 0x9e
   1dffc:	b188      	cbz	r0, 1e022 <cdc_acm_fifo_fill+0x2e>
   1dffe:	f895 309f 	ldrb.w	r3, [r5, #159]	; 0x9f
   1e002:	b97b      	cbnz	r3, 1e024 <cdc_acm_fifo_fill+0x30>
	dev_data->tx_ready = false;
   1e004:	f885 3048 	strb.w	r3, [r5, #72]	; 0x48
	wrote = ring_buf_put(dev_data->tx_ringbuf, tx_data, len);
   1e008:	f8d5 0090 	ldr.w	r0, [r5, #144]	; 0x90
   1e00c:	f006 fddf 	bl	24bce <ring_buf_put>
   1e010:	4604      	mov	r4, r0
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_NO_WAIT);
   1e012:	2200      	movs	r2, #0
   1e014:	2300      	movs	r3, #0
   1e016:	4804      	ldr	r0, [pc, #16]	; (1e028 <cdc_acm_fifo_fill+0x34>)
   1e018:	f105 0118 	add.w	r1, r5, #24
   1e01c:	f005 fc30 	bl	23880 <k_work_schedule_for_queue>
	return wrote;
   1e020:	4620      	mov	r0, r4
}
   1e022:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   1e024:	2000      	movs	r0, #0
   1e026:	e7fc      	b.n	1e022 <cdc_acm_fifo_fill+0x2e>
   1e028:	2000a410 	.word	0x2000a410

0001e02c <cdc_acm_poll_out>:
 * is not ready, no data is transferred to the buffer, that is, c is dropped.
 * If the USB subsystem is ready and the buffer is full, the first character
 * from the tx_ringbuf is removed to make room for the new character.
 */
static void cdc_acm_poll_out(const struct device *dev, unsigned char c)
{
   1e02c:	b513      	push	{r0, r1, r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1e02e:	6904      	ldr	r4, [r0, #16]
{
   1e030:	f88d 1007 	strb.w	r1, [sp, #7]

	if (!dev_data->configured || dev_data->suspended) {
   1e034:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
   1e038:	b1a3      	cbz	r3, 1e064 <cdc_acm_poll_out+0x38>
   1e03a:	f894 309f 	ldrb.w	r3, [r4, #159]	; 0x9f
   1e03e:	b98b      	cbnz	r3, 1e064 <cdc_acm_poll_out+0x38>
		return;
	}

	dev_data->tx_ready = false;

	if (!ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
   1e040:	f10d 0107 	add.w	r1, sp, #7
   1e044:	2201      	movs	r2, #1
   1e046:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
	dev_data->tx_ready = false;
   1e04a:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	if (!ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
   1e04e:	f006 fdbe 	bl	24bce <ring_buf_put>
   1e052:	4601      	mov	r1, r0
   1e054:	b140      	cbz	r0, 1e068 <cdc_acm_poll_out+0x3c>

	/* Schedule with minimal timeout to make it possible to send more than
	 * one byte per USB transfer. The latency increase is negligible while
	 * the increased throughput and reduced CPU usage is easily observable.
	 */
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_MSEC(1));
   1e056:	2221      	movs	r2, #33	; 0x21
   1e058:	2300      	movs	r3, #0
   1e05a:	480c      	ldr	r0, [pc, #48]	; (1e08c <cdc_acm_poll_out+0x60>)
   1e05c:	f104 0118 	add.w	r1, r4, #24
   1e060:	f005 fc0e 	bl	23880 <k_work_schedule_for_queue>
}
   1e064:	b002      	add	sp, #8
   1e066:	bd10      	pop	{r4, pc}
		if (!ring_buf_get(dev_data->tx_ringbuf, NULL, 1) ||
   1e068:	2201      	movs	r2, #1
   1e06a:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
   1e06e:	f006 fdfe 	bl	24c6e <ring_buf_get>
   1e072:	2800      	cmp	r0, #0
   1e074:	d0f6      	beq.n	1e064 <cdc_acm_poll_out+0x38>
		    !ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
   1e076:	2201      	movs	r2, #1
   1e078:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
   1e07c:	f10d 0107 	add.w	r1, sp, #7
   1e080:	f006 fda5 	bl	24bce <ring_buf_put>
		if (!ring_buf_get(dev_data->tx_ringbuf, NULL, 1) ||
   1e084:	2800      	cmp	r0, #0
   1e086:	d1e6      	bne.n	1e056 <cdc_acm_poll_out+0x2a>
   1e088:	e7ec      	b.n	1e064 <cdc_acm_poll_out+0x38>
   1e08a:	bf00      	nop
   1e08c:	2000a410 	.word	0x2000a410

0001e090 <tx_work_handler>:
{
   1e090:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct usb_cfg_data *cfg = (void *)dev->config;
   1e092:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
{
   1e096:	4605      	mov	r5, r0
	uint8_t ep = cfg->endpoint[ACM_IN_EP_IDX].ep_addr;
   1e098:	685b      	ldr	r3, [r3, #4]
{
   1e09a:	b085      	sub	sp, #20
	uint8_t ep = cfg->endpoint[ACM_IN_EP_IDX].ep_addr;
   1e09c:	6a1b      	ldr	r3, [r3, #32]
   1e09e:	7d1f      	ldrb	r7, [r3, #20]
	if (usb_transfer_is_busy(ep)) {
   1e0a0:	4638      	mov	r0, r7
   1e0a2:	f006 feb8 	bl	24e16 <usb_transfer_is_busy>
   1e0a6:	4606      	mov	r6, r0
   1e0a8:	b9e0      	cbnz	r0, 1e0e4 <tx_work_handler+0x54>
	len = ring_buf_get_claim(dev_data->tx_ringbuf, &data,
   1e0aa:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1e0ae:	6fa8      	ldr	r0, [r5, #120]	; 0x78
   1e0b0:	a903      	add	r1, sp, #12
   1e0b2:	f006 fdab 	bl	24c0c <ring_buf_get_claim>
	if (!len) {
   1e0b6:	4604      	mov	r4, r0
   1e0b8:	b1a0      	cbz	r0, 1e0e4 <tx_work_handler+0x54>
	if (!(len % CONFIG_CDC_ACM_BULK_EP_MPS)) {
   1e0ba:	0683      	lsls	r3, r0, #26
	struct cdc_acm_dev_data_t *dev_data =
   1e0bc:	f1a5 0318 	sub.w	r3, r5, #24
	dev_data->tx_ready = false;
   1e0c0:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
	usb_transfer(ep, data, len, USB_TRANS_WRITE,
   1e0c4:	9301      	str	r3, [sp, #4]
   1e0c6:	4b08      	ldr	r3, [pc, #32]	; (1e0e8 <tx_work_handler+0x58>)
		len -= 1;
   1e0c8:	bf08      	it	eq
   1e0ca:	f100 34ff 	addeq.w	r4, r0, #4294967295	; 0xffffffff
	usb_transfer(ep, data, len, USB_TRANS_WRITE,
   1e0ce:	9903      	ldr	r1, [sp, #12]
   1e0d0:	9300      	str	r3, [sp, #0]
   1e0d2:	4622      	mov	r2, r4
   1e0d4:	2302      	movs	r3, #2
   1e0d6:	4638      	mov	r0, r7
   1e0d8:	f7ff fe48 	bl	1dd6c <usb_transfer>
	ring_buf_get_finish(dev_data->tx_ringbuf, len);
   1e0dc:	4621      	mov	r1, r4
   1e0de:	6fa8      	ldr	r0, [r5, #120]	; 0x78
   1e0e0:	f006 fdb0 	bl	24c44 <ring_buf_get_finish>
}
   1e0e4:	b005      	add	sp, #20
   1e0e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e0e8:	0001e0ed 	.word	0x0001e0ed

0001e0ec <cdc_acm_write_cb>:
	dev_data->tx_ready = true;
   1e0ec:	2301      	movs	r3, #1
{
   1e0ee:	b510      	push	{r4, lr}
	dev_data->tx_ready = true;
   1e0f0:	f882 3048 	strb.w	r3, [r2, #72]	; 0x48
	if (dev_data->cb && dev_data->tx_irq_ena) {
   1e0f4:	6813      	ldr	r3, [r2, #0]
{
   1e0f6:	4614      	mov	r4, r2
	if (dev_data->cb && dev_data->tx_irq_ena) {
   1e0f8:	b13b      	cbz	r3, 1e10a <cdc_acm_write_cb+0x1e>
   1e0fa:	f892 304a 	ldrb.w	r3, [r2, #74]	; 0x4a
   1e0fe:	b123      	cbz	r3, 1e10a <cdc_acm_write_cb+0x1e>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e100:	480a      	ldr	r0, [pc, #40]	; (1e12c <cdc_acm_write_cb+0x40>)
   1e102:	f102 0108 	add.w	r1, r2, #8
   1e106:	f007 fe4e 	bl	25da6 <k_work_submit_to_queue>
	if (ring_buf_is_empty(dev_data->tx_ringbuf)) {
   1e10a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   1e10e:	689a      	ldr	r2, [r3, #8]
   1e110:	691b      	ldr	r3, [r3, #16]
   1e112:	429a      	cmp	r2, r3
   1e114:	d008      	beq.n	1e128 <cdc_acm_write_cb+0x3c>
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_NO_WAIT);
   1e116:	f104 0118 	add.w	r1, r4, #24
   1e11a:	2200      	movs	r2, #0
}
   1e11c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_NO_WAIT);
   1e120:	2300      	movs	r3, #0
   1e122:	4802      	ldr	r0, [pc, #8]	; (1e12c <cdc_acm_write_cb+0x40>)
   1e124:	f005 bbac 	b.w	23880 <k_work_schedule_for_queue>
}
   1e128:	bd10      	pop	{r4, pc}
   1e12a:	bf00      	nop
   1e12c:	2000a410 	.word	0x2000a410

0001e130 <cdc_acm_init>:
	parent->next = child;
   1e130:	2300      	movs	r3, #0
{
   1e132:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1e134:	6904      	ldr	r4, [r0, #16]
   1e136:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
   1e13a:	4b0c      	ldr	r3, [pc, #48]	; (1e16c <cdc_acm_init+0x3c>)
	dev_data->common.dev = dev;
   1e13c:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
   1e140:	6859      	ldr	r1, [r3, #4]
	sys_slist_append(&cdc_acm_data_devlist, &dev_data->common.node);
   1e142:	f104 02a8 	add.w	r2, r4, #168	; 0xa8
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   1e146:	b969      	cbnz	r1, 1e164 <cdc_acm_init+0x34>
	list->head = node;
   1e148:	e9c3 2200 	strd	r2, r2, [r3]
	k_work_init(&dev_data->cb_work, cdc_acm_irq_callback_work_handler);
   1e14c:	f104 0008 	add.w	r0, r4, #8
   1e150:	4907      	ldr	r1, [pc, #28]	; (1e170 <cdc_acm_init+0x40>)
   1e152:	f007 fe0b 	bl	25d6c <k_work_init>
	k_work_init_delayable(&dev_data->tx_work, tx_work_handler);
   1e156:	f104 0018 	add.w	r0, r4, #24
   1e15a:	4906      	ldr	r1, [pc, #24]	; (1e174 <cdc_acm_init+0x44>)
   1e15c:	f007 fe34 	bl	25dc8 <k_work_init_delayable>
}
   1e160:	2000      	movs	r0, #0
   1e162:	bd10      	pop	{r4, pc}
	parent->next = child;
   1e164:	600a      	str	r2, [r1, #0]
	list->tail = node;
   1e166:	605a      	str	r2, [r3, #4]
}
   1e168:	e7f0      	b.n	1e14c <cdc_acm_init+0x1c>
   1e16a:	bf00      	nop
   1e16c:	2000a930 	.word	0x2000a930
   1e170:	00024e41 	.word	0x00024e41
   1e174:	0001e091 	.word	0x0001e091

0001e178 <cdc_acm_read_cb>:
{
   1e178:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1e17a:	4614      	mov	r4, r2
	wrote = ring_buf_put(dev_data->rx_ringbuf, dev_data->rx_buf, size);
   1e17c:	f102 064c 	add.w	r6, r2, #76	; 0x4c
	if (size <= 0) {
   1e180:	1e0a      	subs	r2, r1, #0
{
   1e182:	4605      	mov	r5, r0
	if (size <= 0) {
   1e184:	dd1f      	ble.n	1e1c6 <cdc_acm_read_cb+0x4e>
	wrote = ring_buf_put(dev_data->rx_ringbuf, dev_data->rx_buf, size);
   1e186:	4631      	mov	r1, r6
   1e188:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   1e18c:	f006 fd1f 	bl	24bce <ring_buf_put>
	dev_data->rx_ready = true;
   1e190:	2301      	movs	r3, #1
   1e192:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
	if (dev_data->cb && dev_data->rx_irq_ena) {
   1e196:	6823      	ldr	r3, [r4, #0]
   1e198:	b13b      	cbz	r3, 1e1aa <cdc_acm_read_cb+0x32>
   1e19a:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
   1e19e:	b123      	cbz	r3, 1e1aa <cdc_acm_read_cb+0x32>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e1a0:	480e      	ldr	r0, [pc, #56]	; (1e1dc <cdc_acm_read_cb+0x64>)
   1e1a2:	f104 0108 	add.w	r1, r4, #8
   1e1a6:	f007 fdfe 	bl	25da6 <k_work_submit_to_queue>
	if (ring_buf_space_get(dev_data->rx_ringbuf) < sizeof(dev_data->rx_buf)) {
   1e1aa:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 *
 * @return Ring buffer free space (in bytes).
 */
static inline uint32_t ring_buf_space_get(struct ring_buf *buf)
{
	return buf->size - (buf->put_head - buf->get_tail);
   1e1ae:	684b      	ldr	r3, [r1, #4]
   1e1b0:	694a      	ldr	r2, [r1, #20]
   1e1b2:	1a9a      	subs	r2, r3, r2
   1e1b4:	69cb      	ldr	r3, [r1, #28]
   1e1b6:	1a9b      	subs	r3, r3, r2
   1e1b8:	2b3f      	cmp	r3, #63	; 0x3f
   1e1ba:	d804      	bhi.n	1e1c6 <cdc_acm_read_cb+0x4e>
		dev_data->rx_paused = true;
   1e1bc:	2301      	movs	r3, #1
   1e1be:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
}
   1e1c2:	b002      	add	sp, #8
   1e1c4:	bd70      	pop	{r4, r5, r6, pc}
	usb_transfer(ep, dev_data->rx_buf, sizeof(dev_data->rx_buf),
   1e1c6:	4b06      	ldr	r3, [pc, #24]	; (1e1e0 <cdc_acm_read_cb+0x68>)
   1e1c8:	2240      	movs	r2, #64	; 0x40
   1e1ca:	9300      	str	r3, [sp, #0]
   1e1cc:	4631      	mov	r1, r6
   1e1ce:	2301      	movs	r3, #1
   1e1d0:	4628      	mov	r0, r5
   1e1d2:	9401      	str	r4, [sp, #4]
   1e1d4:	f7ff fdca 	bl	1dd6c <usb_transfer>
   1e1d8:	e7f3      	b.n	1e1c2 <cdc_acm_read_cb+0x4a>
   1e1da:	bf00      	nop
   1e1dc:	2000a410 	.word	0x2000a410
   1e1e0:	0001e179 	.word	0x0001e179

0001e1e4 <cdc_acm_dev_status_cb>:
{
   1e1e4:	b538      	push	{r3, r4, r5, lr}
   1e1e6:	460d      	mov	r5, r1
	common = usb_get_dev_data_by_cfg(&cdc_acm_data_devlist, cfg);
   1e1e8:	4601      	mov	r1, r0
   1e1ea:	481e      	ldr	r0, [pc, #120]	; (1e264 <cdc_acm_dev_status_cb+0x80>)
   1e1ec:	f006 fde5 	bl	24dba <usb_get_dev_data_by_cfg>
	if (common == NULL) {
   1e1f0:	4604      	mov	r4, r0
   1e1f2:	b380      	cbz	r0, 1e256 <cdc_acm_dev_status_cb+0x72>
	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);
   1e1f4:	4602      	mov	r2, r0
	struct usb_cfg_data *cfg = (void *)dev->config;
   1e1f6:	f852 39a4 	ldr.w	r3, [r2], #-164
	switch (status) {
   1e1fa:	1e69      	subs	r1, r5, #1
	struct usb_cfg_data *cfg = (void *)dev->config;
   1e1fc:	685b      	ldr	r3, [r3, #4]
	switch (status) {
   1e1fe:	2905      	cmp	r1, #5
   1e200:	d829      	bhi.n	1e256 <cdc_acm_dev_status_cb+0x72>
   1e202:	e8df f001 	tbb	[pc, r1]
   1e206:	2820      	.short	0x2820
   1e208:	29252003 	.word	0x29252003
		if (!dev_data->configured) {
   1e20c:	f814 1c06 	ldrb.w	r1, [r4, #-6]
   1e210:	b931      	cbnz	r1, 1e220 <cdc_acm_dev_status_cb+0x3c>
			cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr, 0,
   1e212:	6a1b      	ldr	r3, [r3, #32]
   1e214:	7b18      	ldrb	r0, [r3, #12]
   1e216:	f7ff ffaf 	bl	1e178 <cdc_acm_read_cb>
			dev_data->configured = true;
   1e21a:	2301      	movs	r3, #1
   1e21c:	f804 3c06 	strb.w	r3, [r4, #-6]
		if (!dev_data->tx_ready) {
   1e220:	f814 3c5c 	ldrb.w	r3, [r4, #-92]
   1e224:	b9bb      	cbnz	r3, 1e256 <cdc_acm_dev_status_cb+0x72>
			dev_data->tx_ready = true;
   1e226:	2301      	movs	r3, #1
   1e228:	f804 3c5c 	strb.w	r3, [r4, #-92]
			if (dev_data->cb != NULL && dev_data->tx_irq_ena) {
   1e22c:	f854 3ca4 	ldr.w	r3, [r4, #-164]
   1e230:	b18b      	cbz	r3, 1e256 <cdc_acm_dev_status_cb+0x72>
   1e232:	f814 3c5a 	ldrb.w	r3, [r4, #-90]
   1e236:	b173      	cbz	r3, 1e256 <cdc_acm_dev_status_cb+0x72>
				k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e238:	f1a4 019c 	sub.w	r1, r4, #156	; 0x9c
   1e23c:	480a      	ldr	r0, [pc, #40]	; (1e268 <cdc_acm_dev_status_cb+0x84>)
}
   1e23e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e242:	f007 bdb0 	b.w	25da6 <k_work_submit_to_queue>
		cdc_acm_reset_port(dev_data);
   1e246:	4610      	mov	r0, r2
}
   1e248:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		cdc_acm_reset_port(dev_data);
   1e24c:	f7ff beb4 	b.w	1dfb8 <cdc_acm_reset_port>
		dev_data->suspended = true;
   1e250:	2301      	movs	r3, #1
			dev_data->suspended = false;
   1e252:	f804 3c05 	strb.w	r3, [r4, #-5]
}
   1e256:	bd38      	pop	{r3, r4, r5, pc}
		if (dev_data->suspended) {
   1e258:	f814 3c05 	ldrb.w	r3, [r4, #-5]
   1e25c:	2b00      	cmp	r3, #0
   1e25e:	d0fa      	beq.n	1e256 <cdc_acm_dev_status_cb+0x72>
			dev_data->suspended = false;
   1e260:	2300      	movs	r3, #0
   1e262:	e7f6      	b.n	1e252 <cdc_acm_dev_status_cb+0x6e>
   1e264:	2000a930 	.word	0x2000a930
   1e268:	2000a410 	.word	0x2000a410

0001e26c <z_usb_work_q_init>:
K_KERNEL_STACK_DEFINE(z_usb_work_q_stack, CONFIG_USB_WORKQUEUE_STACK_SIZE);

struct k_work_q z_usb_work_q;

static int z_usb_work_q_init(void)
{
   1e26c:	b537      	push	{r0, r1, r2, r4, r5, lr}

	k_work_queue_start(&z_usb_work_q,
   1e26e:	2400      	movs	r4, #0
   1e270:	4d08      	ldr	r5, [pc, #32]	; (1e294 <z_usb_work_q_init+0x28>)
   1e272:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1e276:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1e27a:	4628      	mov	r0, r5
   1e27c:	4906      	ldr	r1, [pc, #24]	; (1e298 <z_usb_work_q_init+0x2c>)
   1e27e:	9400      	str	r4, [sp, #0]
   1e280:	f005 fac6 	bl	23810 <k_work_queue_start>
	return z_impl_k_thread_name_set(thread, str);
   1e284:	4905      	ldr	r1, [pc, #20]	; (1e29c <z_usb_work_q_init+0x30>)
   1e286:	4628      	mov	r0, r5
   1e288:	f007 fc9f 	bl	25bca <z_impl_k_thread_name_set>
			   K_KERNEL_STACK_SIZEOF(z_usb_work_q_stack),
			   CONFIG_USB_WORKQUEUE_PRIORITY, NULL);
	k_thread_name_set(&z_usb_work_q.thread, "usbworkq");

	return 0;
}
   1e28c:	4620      	mov	r0, r4
   1e28e:	b003      	add	sp, #12
   1e290:	bd30      	pop	{r4, r5, pc}
   1e292:	bf00      	nop
   1e294:	2000a410 	.word	0x2000a410
   1e298:	2000b630 	.word	0x2000b630
   1e29c:	00026a43 	.word	0x00026a43

0001e2a0 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   1e2a0:	4901      	ldr	r1, [pc, #4]	; (1e2a8 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   1e2a2:	2210      	movs	r2, #16
	str	r2, [r1]
   1e2a4:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   1e2a6:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   1e2a8:	e000ed10 	.word	0xe000ed10

0001e2ac <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   1e2ac:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   1e2ae:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   1e2b0:	f380 8811 	msr	BASEPRI, r0
	isb
   1e2b4:	f3bf 8f6f 	isb	sy
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
   1e2b8:	b501      	push	{r0, lr}
   1e2ba:	f7fe fde9 	bl	1ce90 <z_arm_on_enter_cpu_idle>
   1e2be:	2800      	cmp	r0, #0
   1e2c0:	d002      	beq.n	1e2c8 <_skip_0>
   1e2c2:	f3bf 8f4f 	dsb	sy
   1e2c6:	bf30      	wfi

0001e2c8 <_skip_0>:
   1e2c8:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   1e2cc:	b662      	cpsie	i
	isb
   1e2ce:	f3bf 8f6f 	isb	sy

	bx	lr
   1e2d2:	4770      	bx	lr

0001e2d4 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   1e2d4:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   1e2d6:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   1e2d8:	f381 8811 	msr	BASEPRI, r1

	_sleep_if_allowed wfe
   1e2dc:	b501      	push	{r0, lr}
   1e2de:	f7fe fdd7 	bl	1ce90 <z_arm_on_enter_cpu_idle>
   1e2e2:	2800      	cmp	r0, #0
   1e2e4:	d002      	beq.n	1e2ec <_skip_1>
   1e2e6:	f3bf 8f4f 	dsb	sy
   1e2ea:	bf20      	wfe

0001e2ec <_skip_1>:
   1e2ec:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

	msr	BASEPRI, r0
   1e2f0:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   1e2f4:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   1e2f6:	4770      	bx	lr

0001e2f8 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   1e2f8:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   1e2fa:	2800      	cmp	r0, #0
   1e2fc:	db07      	blt.n	1e30e <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1e2fe:	2301      	movs	r3, #1
   1e300:	0941      	lsrs	r1, r0, #5
   1e302:	4a03      	ldr	r2, [pc, #12]	; (1e310 <arch_irq_enable+0x18>)
   1e304:	f000 001f 	and.w	r0, r0, #31
   1e308:	4083      	lsls	r3, r0
   1e30a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
   1e30e:	4770      	bx	lr
   1e310:	e000e100 	.word	0xe000e100

0001e314 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
   1e314:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   1e316:	2800      	cmp	r0, #0
   1e318:	db0c      	blt.n	1e334 <arch_irq_disable+0x20>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1e31a:	2201      	movs	r2, #1
   1e31c:	4906      	ldr	r1, [pc, #24]	; (1e338 <arch_irq_disable+0x24>)
   1e31e:	0943      	lsrs	r3, r0, #5
   1e320:	f000 001f 	and.w	r0, r0, #31
   1e324:	4082      	lsls	r2, r0
   1e326:	3320      	adds	r3, #32
   1e328:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   1e32c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e330:	f3bf 8f6f 	isb	sy
}
   1e334:	4770      	bx	lr
   1e336:	bf00      	nop
   1e338:	e000e100 	.word	0xe000e100

0001e33c <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   1e33c:	4b05      	ldr	r3, [pc, #20]	; (1e354 <arch_irq_is_enabled+0x18>)
   1e33e:	0942      	lsrs	r2, r0, #5
   1e340:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   1e344:	2301      	movs	r3, #1
   1e346:	f000 001f 	and.w	r0, r0, #31
   1e34a:	fa03 f000 	lsl.w	r0, r3, r0
}
   1e34e:	4010      	ands	r0, r2
   1e350:	4770      	bx	lr
   1e352:	bf00      	nop
   1e354:	e000e100 	.word	0xe000e100

0001e358 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   1e358:	b240      	sxtb	r0, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   1e35a:	2800      	cmp	r0, #0
		prio += _IRQ_PRIO_OFFSET;
   1e35c:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e360:	bfac      	ite	ge
   1e362:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e366:	4b06      	ldrlt	r3, [pc, #24]	; (1e380 <z_arm_irq_priority_set+0x28>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e368:	ea4f 1141 	mov.w	r1, r1, lsl #5
   1e36c:	b2c9      	uxtb	r1, r1
   1e36e:	bfab      	itete	ge
   1e370:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e374:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e378:	f880 1300 	strbge.w	r1, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e37c:	5419      	strblt	r1, [r3, r0]
}
   1e37e:	4770      	bx	lr
   1e380:	e000ed14 	.word	0xe000ed14

0001e384 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   1e384:	bf30      	wfi
    b z_SysNmiOnReset
   1e386:	f7ff bffd 	b.w	1e384 <z_SysNmiOnReset>
   1e38a:	bf00      	nop

0001e38c <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   1e38c:	4a0b      	ldr	r2, [pc, #44]	; (1e3bc <z_arm_prep_c+0x30>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
   1e38e:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   1e390:	4b0b      	ldr	r3, [pc, #44]	; (1e3c0 <z_arm_prep_c+0x34>)
   1e392:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   1e396:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
   1e398:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e39c:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   1e3a0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e3a4:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   1e3a8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   1e3ac:	f004 fe28 	bl	23000 <z_bss_zero>
	z_data_copy();
   1e3b0:	f005 fdfe 	bl	23fb0 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   1e3b4:	f000 fa08 	bl	1e7c8 <z_arm_interrupt_init>
	z_cstart();
   1e3b8:	f004 fe62 	bl	23080 <z_cstart>
   1e3bc:	0001c000 	.word	0x0001c000
   1e3c0:	e000ed00 	.word	0xe000ed00

0001e3c4 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   1e3c4:	4a09      	ldr	r2, [pc, #36]	; (1e3ec <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   1e3c6:	490a      	ldr	r1, [pc, #40]	; (1e3f0 <arch_swap+0x2c>)
	_current->arch.basepri = key;
   1e3c8:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   1e3ca:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   1e3cc:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
   1e3ce:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1e3d0:	4908      	ldr	r1, [pc, #32]	; (1e3f4 <arch_swap+0x30>)
   1e3d2:	684b      	ldr	r3, [r1, #4]
   1e3d4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   1e3d8:	604b      	str	r3, [r1, #4]
   1e3da:	2300      	movs	r3, #0
   1e3dc:	f383 8811 	msr	BASEPRI, r3
   1e3e0:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   1e3e4:	6893      	ldr	r3, [r2, #8]
}
   1e3e6:	6f98      	ldr	r0, [r3, #120]	; 0x78
   1e3e8:	4770      	bx	lr
   1e3ea:	bf00      	nop
   1e3ec:	2000b5b4 	.word	0x2000b5b4
   1e3f0:	00026994 	.word	0x00026994
   1e3f4:	e000ed00 	.word	0xe000ed00

0001e3f8 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   1e3f8:	4915      	ldr	r1, [pc, #84]	; (1e450 <z_arm_pendsv+0x58>)
    ldr r2, [r1, #_kernel_offset_to_current]
   1e3fa:	688a      	ldr	r2, [r1, #8]

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
   1e3fc:	f882 e07d 	strb.w	lr, [r2, #125]	; 0x7d
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   1e400:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   1e404:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   1e406:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   1e40a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   1e40e:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   1e410:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   1e414:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   1e418:	4f0e      	ldr	r7, [pc, #56]	; (1e454 <z_arm_pendsv+0x5c>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   1e41a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   1e41e:	698a      	ldr	r2, [r1, #24]

    str r2, [r1, #_kernel_offset_to_current]
   1e420:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   1e422:	603e      	str	r6, [r7, #0]

#endif

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Restore EXC_RETURN value. */
    ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
   1e424:	f992 e07d 	ldrsb.w	lr, [r2, #125]	; 0x7d

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   1e428:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
   1e42a:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   1e42c:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   1e42e:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   1e432:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   1e436:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   1e43a:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   1e43e:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   1e442:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   1e444:	f006 fd9d 	bl	24f82 <configure_builtin_stack_guard>
    pop {r2, lr}
   1e448:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   1e44c:	4770      	bx	lr
   1e44e:	0000      	.short	0x0000
    ldr r1, =_kernel
   1e450:	2000b5b4 	.word	0x2000b5b4
    ldr v4, =_SCS_ICSR
   1e454:	e000ed04 	.word	0xe000ed04

0001e458 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   1e458:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   1e45c:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   1e45e:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   1e462:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   1e466:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   1e468:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   1e46c:	2902      	cmp	r1, #2
    beq _oops
   1e46e:	d0ff      	beq.n	1e470 <_oops>

0001e470 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   1e470:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
   1e472:	f006 fd77 	bl	24f64 <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
   1e476:	bd01      	pop	{r0, pc}

0001e478 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   1e478:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   1e47c:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
   1e47e:	490c      	ldr	r1, [pc, #48]	; (1e4b0 <arch_new_thread+0x38>)
	iframe->a2 = (uint32_t)p1;
   1e480:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   1e484:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
   1e486:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
   1e48a:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   1e48e:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
   1e490:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
   1e494:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   1e498:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   1e49c:	f842 3c04 	str.w	r3, [r2, #-4]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   1e4a0:	2300      	movs	r3, #0
   1e4a2:	6743      	str	r3, [r0, #116]	; 0x74

#if defined(CONFIG_ARM_STORE_EXC_RETURN) || defined(CONFIG_USERSPACE)
	thread->arch.mode = 0;
   1e4a4:	f44f 433c 	mov.w	r3, #48128	; 0xbc00
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   1e4a8:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   1e4aa:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.mode = 0;
   1e4ac:	67c3      	str	r3, [r0, #124]	; 0x7c
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   1e4ae:	4770      	bx	lr
   1e4b0:	000244a9 	.word	0x000244a9

0001e4b4 <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   1e4b4:	4b08      	ldr	r3, [pc, #32]	; (1e4d8 <arch_switch_to_main_thread+0x24>)
   1e4b6:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   1e4b8:	6e43      	ldr	r3, [r0, #100]	; 0x64
   1e4ba:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   1e4be:	4610      	mov	r0, r2
   1e4c0:	f381 8809 	msr	PSP, r1
   1e4c4:	2100      	movs	r1, #0
   1e4c6:	b663      	cpsie	if
   1e4c8:	f381 8811 	msr	BASEPRI, r1
   1e4cc:	f3bf 8f6f 	isb	sy
   1e4d0:	2200      	movs	r2, #0
   1e4d2:	2300      	movs	r3, #0
   1e4d4:	f005 ffe8 	bl	244a8 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   1e4d8:	2000b5b4 	.word	0x2000b5b4

0001e4dc <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   1e4dc:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   1e4de:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   1e4e0:	4a0b      	ldr	r2, [pc, #44]	; (1e510 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   1e4e2:	6950      	ldr	r0, [r2, #20]
	cmp r0, #0
   1e4e4:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   1e4e6:	bf1e      	ittt	ne
	movne	r1, #0
   1e4e8:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   1e4ea:	6151      	strne	r1, [r2, #20]
		blne	z_pm_save_idle_exit
   1e4ec:	f007 fb72 	blne	25bd4 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   1e4f0:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   1e4f2:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   1e4f6:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   1e4fa:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   1e4fe:	4905      	ldr	r1, [pc, #20]	; (1e514 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   1e500:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   1e502:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   1e504:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   1e506:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   1e50a:	4903      	ldr	r1, [pc, #12]	; (1e518 <_isr_wrapper+0x3c>)
	bx r1
   1e50c:	4708      	bx	r1
   1e50e:	0000      	.short	0x0000
	ldr r2, =_kernel
   1e510:	2000b5b4 	.word	0x2000b5b4
	ldr r1, =_sw_isr_table
   1e514:	00026318 	.word	0x00026318
	ldr r1, =z_arm_int_exit
   1e518:	0001e51d 	.word	0x0001e51d

0001e51c <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   1e51c:	4b04      	ldr	r3, [pc, #16]	; (1e530 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   1e51e:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   1e520:	6998      	ldr	r0, [r3, #24]
	cmp r0, r1
   1e522:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   1e524:	d003      	beq.n	1e52e <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   1e526:	4903      	ldr	r1, [pc, #12]	; (1e534 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   1e528:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   1e52c:	600a      	str	r2, [r1, #0]

0001e52e <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   1e52e:	4770      	bx	lr
	ldr r3, =_kernel
   1e530:	2000b5b4 	.word	0x2000b5b4
	ldr r1, =_SCS_ICSR
   1e534:	e000ed04 	.word	0xe000ed04

0001e538 <usage_fault.constprop.0>:
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   1e538:	4b15      	ldr	r3, [pc, #84]	; (1e590 <usage_fault.constprop.0+0x58>)
   1e53a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
   1e53c:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
		reason = K_ERR_ARM_USAGE_DIV_0;
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   1e540:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
   1e542:	bf14      	ite	ne
   1e544:	201e      	movne	r0, #30
   1e546:	201d      	moveq	r0, #29
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
   1e548:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
		PR_FAULT_INFO("  Unaligned memory access");
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   1e54c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
   1e54e:	bf18      	it	ne
   1e550:	201f      	movne	r0, #31
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   1e552:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   1e556:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_STACK_CHK_FAIL;
   1e558:	bf18      	it	ne
   1e55a:	2002      	movne	r0, #2
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
   1e55c:	f412 2f00 	tst.w	r2, #524288	; 0x80000
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   1e560:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
   1e562:	bf18      	it	ne
   1e564:	2021      	movne	r0, #33	; 0x21
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
   1e566:	f412 2f80 	tst.w	r2, #262144	; 0x40000
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   1e56a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
   1e56c:	bf18      	it	ne
   1e56e:	2022      	movne	r0, #34	; 0x22
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
   1e570:	f412 3f00 	tst.w	r2, #131072	; 0x20000
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   1e574:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
   1e576:	bf18      	it	ne
   1e578:	2023      	movne	r0, #35	; 0x23
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
   1e57a:	f412 3f80 	tst.w	r2, #65536	; 0x10000
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   1e57e:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	return reason;
}
   1e580:	bf18      	it	ne
   1e582:	2024      	movne	r0, #36	; 0x24
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   1e584:	ea6f 4202 	mvn.w	r2, r2, lsl #16
   1e588:	ea6f 4212 	mvn.w	r2, r2, lsr #16
   1e58c:	629a      	str	r2, [r3, #40]	; 0x28
}
   1e58e:	4770      	bx	lr
   1e590:	e000ed00 	.word	0xe000ed00

0001e594 <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1e594:	b510      	push	{r4, lr}
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   1e596:	4b19      	ldr	r3, [pc, #100]	; (1e5fc <bus_fault.constprop.0+0x68>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1e598:	4602      	mov	r2, r0
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   1e59a:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   1e59c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
   1e59e:	f410 5f80 	tst.w	r0, #4096	; 0x1000
   1e5a2:	bf14      	ite	ne
   1e5a4:	2017      	movne	r0, #23
   1e5a6:	2016      	moveq	r0, #22
		reason = K_ERR_ARM_BUS_UNSTACKING;
   1e5a8:	f414 6f00 	tst.w	r4, #2048	; 0x800
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   1e5ac:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_UNSTACKING;
   1e5ae:	bf18      	it	ne
   1e5b0:	2018      	movne	r0, #24
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   1e5b2:	05a4      	lsls	r4, r4, #22
   1e5b4:	d509      	bpl.n	1e5ca <bus_fault.constprop.0+0x36>
		STORE_xFAR(bfar, SCB->BFAR);
   1e5b6:	6b98      	ldr	r0, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   1e5b8:	6a98      	ldr	r0, [r3, #40]	; 0x28
   1e5ba:	0400      	lsls	r0, r0, #16
   1e5bc:	d504      	bpl.n	1e5c8 <bus_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
   1e5be:	b11a      	cbz	r2, 1e5c8 <bus_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   1e5c0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e5c2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   1e5c6:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
   1e5c8:	2019      	movs	r0, #25
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   1e5ca:	4b0c      	ldr	r3, [pc, #48]	; (1e5fc <bus_fault.constprop.0+0x68>)
   1e5cc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
   1e5ce:	f412 6f80 	tst.w	r2, #1024	; 0x400
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   1e5d2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
   1e5d4:	bf18      	it	ne
   1e5d6:	201a      	movne	r0, #26
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   1e5d8:	05d2      	lsls	r2, r2, #23
   1e5da:	d40c      	bmi.n	1e5f6 <bus_fault.constprop.0+0x62>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   1e5dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
   1e5de:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   1e5e2:	bf18      	it	ne
   1e5e4:	201c      	movne	r0, #28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   1e5e6:	4a05      	ldr	r2, [pc, #20]	; (1e5fc <bus_fault.constprop.0+0x68>)
   1e5e8:	6a93      	ldr	r3, [r2, #40]	; 0x28
   1e5ea:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   1e5ee:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   1e5f0:	2300      	movs	r3, #0
   1e5f2:	700b      	strb	r3, [r1, #0]
}
   1e5f4:	bd10      	pop	{r4, pc}
		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
   1e5f6:	201b      	movs	r0, #27
   1e5f8:	e7f5      	b.n	1e5e6 <bus_fault.constprop.0+0x52>
   1e5fa:	bf00      	nop
   1e5fc:	e000ed00 	.word	0xe000ed00

0001e600 <mem_manage_fault.constprop.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   1e600:	b510      	push	{r4, lr}
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   1e602:	4b1c      	ldr	r3, [pc, #112]	; (1e674 <mem_manage_fault.constprop.0+0x74>)
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   1e604:	4602      	mov	r2, r0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   1e606:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   1e608:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
   1e60a:	f010 0f10 	tst.w	r0, #16
   1e60e:	bf14      	ite	ne
   1e610:	2011      	movne	r0, #17
   1e612:	2010      	moveq	r0, #16
		reason = K_ERR_ARM_MEM_UNSTACKING;
   1e614:	f014 0f08 	tst.w	r4, #8
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   1e618:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_UNSTACKING;
   1e61a:	bf18      	it	ne
   1e61c:	2012      	movne	r0, #18
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   1e61e:	07a4      	lsls	r4, r4, #30
   1e620:	d509      	bpl.n	1e636 <mem_manage_fault.constprop.0+0x36>
		uint32_t temp = SCB->MMFAR;
   1e622:	6b58      	ldr	r0, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   1e624:	6a98      	ldr	r0, [r3, #40]	; 0x28
   1e626:	0600      	lsls	r0, r0, #24
   1e628:	d504      	bpl.n	1e634 <mem_manage_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
   1e62a:	b11a      	cbz	r2, 1e634 <mem_manage_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   1e62c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e62e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   1e632:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
   1e634:	2013      	movs	r0, #19
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   1e636:	4b0f      	ldr	r3, [pc, #60]	; (1e674 <mem_manage_fault.constprop.0+0x74>)
   1e638:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
   1e63a:	f012 0f01 	tst.w	r2, #1
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   1e63e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
   1e640:	bf18      	it	ne
   1e642:	2014      	movne	r0, #20
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
   1e644:	f012 0f20 	tst.w	r2, #32
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   1e648:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
   1e64a:	bf18      	it	ne
   1e64c:	2015      	movne	r0, #21
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   1e64e:	06d4      	lsls	r4, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   1e650:	bf58      	it	pl
   1e652:	6a9b      	ldrpl	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   1e654:	4b07      	ldr	r3, [pc, #28]	; (1e674 <mem_manage_fault.constprop.0+0x74>)
   1e656:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e658:	0692      	lsls	r2, r2, #26
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
   1e65a:	bf42      	ittt	mi
   1e65c:	6a5a      	ldrmi	r2, [r3, #36]	; 0x24
   1e65e:	f422 5200 	bicmi.w	r2, r2, #8192	; 0x2000
   1e662:	625a      	strmi	r2, [r3, #36]	; 0x24
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   1e664:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e666:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   1e66a:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   1e66c:	2300      	movs	r3, #0
   1e66e:	700b      	strb	r3, [r1, #0]
}
   1e670:	bd10      	pop	{r4, pc}
   1e672:	bf00      	nop
   1e674:	e000ed00 	.word	0xe000ed00

0001e678 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   1e678:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   1e67a:	4b47      	ldr	r3, [pc, #284]	; (1e798 <z_arm_fault+0x120>)
{
   1e67c:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   1e67e:	685b      	ldr	r3, [r3, #4]
   1e680:	2600      	movs	r6, #0
{
   1e682:	b08a      	sub	sp, #40	; 0x28
   1e684:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1e688:	f386 8811 	msr	BASEPRI, r6
   1e68c:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   1e690:	f002 407f 	and.w	r0, r2, #4278190080	; 0xff000000
   1e694:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
   1e698:	d116      	bne.n	1e6c8 <z_arm_fault+0x50>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   1e69a:	07d0      	lsls	r0, r2, #31
   1e69c:	d414      	bmi.n	1e6c8 <z_arm_fault+0x50>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   1e69e:	0654      	lsls	r4, r2, #25
   1e6a0:	d403      	bmi.n	1e6aa <z_arm_fault+0x32>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   1e6a2:	0710      	lsls	r0, r2, #28
   1e6a4:	d404      	bmi.n	1e6b0 <z_arm_fault+0x38>
			*nested_exc = true;
   1e6a6:	2601      	movs	r6, #1
   1e6a8:	e004      	b.n	1e6b4 <z_arm_fault+0x3c>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   1e6aa:	f012 0204 	ands.w	r2, r2, #4
   1e6ae:	d000      	beq.n	1e6b2 <z_arm_fault+0x3a>
			ptr_esf = (z_arch_esf_t *)psp;
   1e6b0:	460d      	mov	r5, r1
	*nested_exc = false;
   1e6b2:	2600      	movs	r6, #0
	*recoverable = false;
   1e6b4:	2200      	movs	r2, #0
	switch (fault) {
   1e6b6:	3b03      	subs	r3, #3
	*recoverable = false;
   1e6b8:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
   1e6bc:	2b03      	cmp	r3, #3
   1e6be:	d805      	bhi.n	1e6cc <z_arm_fault+0x54>
   1e6c0:	e8df f003 	tbb	[pc, r3]
   1e6c4:	59605c1e 	.word	0x59605c1e
		return NULL;
   1e6c8:	4635      	mov	r5, r6
   1e6ca:	e7f3      	b.n	1e6b4 <z_arm_fault+0x3c>
   1e6cc:	2400      	movs	r4, #0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   1e6ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1e6d2:	b99b      	cbnz	r3, 1e6fc <z_arm_fault+0x84>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   1e6d4:	2220      	movs	r2, #32
   1e6d6:	4629      	mov	r1, r5
   1e6d8:	a802      	add	r0, sp, #8
   1e6da:	f006 fc8e 	bl	24ffa <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   1e6de:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1e6e0:	2e00      	cmp	r6, #0
   1e6e2:	d053      	beq.n	1e78c <z_arm_fault+0x114>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   1e6e4:	f3c3 0208 	ubfx	r2, r3, #0, #9
   1e6e8:	b922      	cbnz	r2, 1e6f4 <z_arm_fault+0x7c>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   1e6ea:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   1e6ee:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1e6f2:	9309      	str	r3, [sp, #36]	; 0x24

	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
		reason = K_ERR_CPU_EXCEPTION;
	}

	z_arm_fatal_error(reason, &esf_copy);
   1e6f4:	4620      	mov	r0, r4
   1e6f6:	a902      	add	r1, sp, #8
   1e6f8:	f006 fc32 	bl	24f60 <z_arm_fatal_error>
}
   1e6fc:	b00a      	add	sp, #40	; 0x28
   1e6fe:	bd70      	pop	{r4, r5, r6, pc}
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   1e700:	4b25      	ldr	r3, [pc, #148]	; (1e798 <z_arm_fault+0x120>)
   1e702:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1e704:	0791      	lsls	r1, r2, #30
   1e706:	d4e1      	bmi.n	1e6cc <z_arm_fault+0x54>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   1e708:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1e70a:	2a00      	cmp	r2, #0
   1e70c:	dbde      	blt.n	1e6cc <z_arm_fault+0x54>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   1e70e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1e710:	0052      	lsls	r2, r2, #1
   1e712:	d5db      	bpl.n	1e6cc <z_arm_fault+0x54>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
   1e714:	695a      	ldr	r2, [r3, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
   1e716:	69a9      	ldr	r1, [r5, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
   1e718:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   1e71c:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
   1e71e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e722:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
   1e726:	695a      	ldr	r2, [r3, #20]
	uint16_t fault_insn = *(ret_addr - 1);
   1e728:	f831 1c02 	ldrh.w	r1, [r1, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
   1e72c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   1e730:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
   1e732:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e736:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   1e73a:	f64d 7202 	movw	r2, #57090	; 0xdf02
   1e73e:	4291      	cmp	r1, r2
   1e740:	d101      	bne.n	1e746 <z_arm_fault+0xce>
			reason = esf->basic.r0;
   1e742:	682c      	ldr	r4, [r5, #0]
   1e744:	e7c3      	b.n	1e6ce <z_arm_fault+0x56>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
   1e746:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e748:	b2d2      	uxtb	r2, r2
   1e74a:	b132      	cbz	r2, 1e75a <z_arm_fault+0xe2>
			reason = mem_manage_fault(esf, 1, recoverable);
   1e74c:	2001      	movs	r0, #1
   1e74e:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   1e752:	f7ff ff55 	bl	1e600 <mem_manage_fault.constprop.0>
		reason = usage_fault(esf);
   1e756:	4604      	mov	r4, r0
		break;
   1e758:	e7b9      	b.n	1e6ce <z_arm_fault+0x56>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
   1e75a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e75c:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
   1e760:	d005      	beq.n	1e76e <z_arm_fault+0xf6>
			reason = bus_fault(esf, 1, recoverable);
   1e762:	2001      	movs	r0, #1
   1e764:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   1e768:	f7ff ff14 	bl	1e594 <bus_fault.constprop.0>
   1e76c:	e7f3      	b.n	1e756 <z_arm_fault+0xde>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
   1e76e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1e770:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   1e774:	d3aa      	bcc.n	1e6cc <z_arm_fault+0x54>
		reason = usage_fault(esf);
   1e776:	f7ff fedf 	bl	1e538 <usage_fault.constprop.0>
   1e77a:	e7ec      	b.n	1e756 <z_arm_fault+0xde>
		reason = mem_manage_fault(esf, 0, recoverable);
   1e77c:	2000      	movs	r0, #0
   1e77e:	f10d 0107 	add.w	r1, sp, #7
   1e782:	e7e6      	b.n	1e752 <z_arm_fault+0xda>
		reason = bus_fault(esf, 0, recoverable);
   1e784:	2000      	movs	r0, #0
   1e786:	f10d 0107 	add.w	r1, sp, #7
   1e78a:	e7ed      	b.n	1e768 <z_arm_fault+0xf0>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1e78c:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   1e790:	f023 0301 	bic.w	r3, r3, #1
   1e794:	e7ad      	b.n	1e6f2 <z_arm_fault+0x7a>
   1e796:	bf00      	nop
   1e798:	e000ed00 	.word	0xe000ed00

0001e79c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   1e79c:	4b04      	ldr	r3, [pc, #16]	; (1e7b0 <z_arm_fault_init+0x14>)
   1e79e:	695a      	ldr	r2, [r3, #20]
   1e7a0:	f042 0210 	orr.w	r2, r2, #16
   1e7a4:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   1e7a6:	695a      	ldr	r2, [r3, #20]
   1e7a8:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   1e7ac:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
   1e7ae:	4770      	bx	lr
   1e7b0:	e000ed00 	.word	0xe000ed00

0001e7b4 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   1e7b4:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   1e7b8:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   1e7bc:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   1e7be:	4672      	mov	r2, lr
	bl z_arm_fault
   1e7c0:	f7ff ff5a 	bl	1e678 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   1e7c4:	bd01      	pop	{r0, pc}
   1e7c6:	bf00      	nop

0001e7c8 <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   1e7c8:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e7ca:	2120      	movs	r1, #32
   1e7cc:	4803      	ldr	r0, [pc, #12]	; (1e7dc <z_arm_interrupt_init+0x14>)
   1e7ce:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   1e7d0:	3301      	adds	r3, #1
   1e7d2:	2b45      	cmp	r3, #69	; 0x45
   1e7d4:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   1e7d8:	d1f9      	bne.n	1e7ce <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   1e7da:	4770      	bx	lr
   1e7dc:	e000e100 	.word	0xe000e100

0001e7e0 <__start>:
    strb r0, [r1]
#endif /* CONFIG_DEBUG_THREAD_INFO */

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
   1e7e0:	2000      	movs	r0, #0
    msr CONTROL, r0
   1e7e2:	f380 8814 	msr	CONTROL, r0
    isb
   1e7e6:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
   1e7ea:	2000      	movs	r0, #0
    msr MSPLIM, r0
   1e7ec:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
   1e7f0:	f380 880b 	msr	PSPLIM, r0
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   1e7f4:	f7fe fb92 	bl	1cf1c <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
   1e7f8:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
   1e7fa:	490e      	ldr	r1, [pc, #56]	; (1e834 <__start+0x54>)
    str r0, [r1]
   1e7fc:	6008      	str	r0, [r1, #0]
    dsb
   1e7fe:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   1e802:	480d      	ldr	r0, [pc, #52]	; (1e838 <__start+0x58>)
    msr msp, r0
   1e804:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
   1e808:	f000 f83e 	bl	1e888 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   1e80c:	2020      	movs	r0, #32
    msr BASEPRI, r0
   1e80e:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   1e812:	480a      	ldr	r0, [pc, #40]	; (1e83c <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   1e814:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   1e818:	1840      	adds	r0, r0, r1
    msr PSP, r0
   1e81a:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   1e81e:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   1e822:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   1e824:	4308      	orrs	r0, r1
    msr CONTROL, r0
   1e826:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   1e82a:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   1e82e:	f7ff fdad 	bl	1e38c <z_arm_prep_c>
   1e832:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
   1e834:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   1e838:	2000cb70 	.word	0x2000cb70
    ldr r0, =z_interrupt_stacks
   1e83c:	2000be30 	.word	0x2000be30

0001e840 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
   1e840:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   1e844:	4905      	ldr	r1, [pc, #20]	; (1e85c <sys_arch_reboot+0x1c>)
   1e846:	4b06      	ldr	r3, [pc, #24]	; (1e860 <sys_arch_reboot+0x20>)
   1e848:	68ca      	ldr	r2, [r1, #12]
   1e84a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   1e84e:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   1e850:	60cb      	str	r3, [r1, #12]
   1e852:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   1e856:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   1e858:	e7fd      	b.n	1e856 <sys_arch_reboot+0x16>
   1e85a:	bf00      	nop
   1e85c:	e000ed00 	.word	0xe000ed00
   1e860:	05fa0004 	.word	0x05fa0004

0001e864 <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
   1e864:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
   1e866:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
   1e868:	4906      	ldr	r1, [pc, #24]	; (1e884 <z_arm_clear_arm_mpu_config+0x20>)
   1e86a:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
	int num_regions =
   1e86e:	f3c2 2207 	ubfx	r2, r2, #8, #8
	for (i = 0; i < num_regions; i++) {
   1e872:	4293      	cmp	r3, r2
   1e874:	db00      	blt.n	1e878 <z_arm_clear_arm_mpu_config+0x14>
		ARM_MPU_ClrRegion(i);
	}
}
   1e876:	4770      	bx	lr
  mpu->RNR = rnr;
   1e878:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
  mpu->RLAR = 0U;
   1e87c:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0
	for (i = 0; i < num_regions; i++) {
   1e880:	3301      	adds	r3, #1
   1e882:	e7f6      	b.n	1e872 <z_arm_clear_arm_mpu_config+0xe>
   1e884:	e000ed00 	.word	0xe000ed00

0001e888 <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
   1e888:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
   1e88a:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
   1e88c:	2400      	movs	r4, #0
   1e88e:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
   1e892:	f7ff ffe7 	bl	1e864 <z_arm_clear_arm_mpu_config>
   1e896:	4623      	mov	r3, r4
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
   1e898:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1e89c:	4a0c      	ldr	r2, [pc, #48]	; (1e8d0 <z_arm_init_arch_hw_at_boot+0x48>)
   1e89e:	f103 0120 	add.w	r1, r3, #32
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   1e8a2:	3301      	adds	r3, #1
   1e8a4:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
   1e8a6:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   1e8aa:	d1f8      	bne.n	1e89e <z_arm_init_arch_hw_at_boot+0x16>
   1e8ac:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
   1e8ae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1e8b2:	4a07      	ldr	r2, [pc, #28]	; (1e8d0 <z_arm_init_arch_hw_at_boot+0x48>)
   1e8b4:	f103 0160 	add.w	r1, r3, #96	; 0x60
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   1e8b8:	3301      	adds	r3, #1
   1e8ba:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
   1e8bc:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   1e8c0:	d1f8      	bne.n	1e8b4 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
   1e8c2:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
   1e8c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e8c8:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
   1e8cc:	bd10      	pop	{r4, pc}
   1e8ce:	bf00      	nop
   1e8d0:	e000e100 	.word	0xe000e100

0001e8d4 <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   1e8d4:	4b08      	ldr	r3, [pc, #32]	; (1e8f8 <z_impl_k_thread_abort+0x24>)
   1e8d6:	689b      	ldr	r3, [r3, #8]
   1e8d8:	4283      	cmp	r3, r0
   1e8da:	d10b      	bne.n	1e8f4 <z_impl_k_thread_abort+0x20>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1e8dc:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   1e8e0:	b143      	cbz	r3, 1e8f4 <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1e8e2:	4b06      	ldr	r3, [pc, #24]	; (1e8fc <z_impl_k_thread_abort+0x28>)
   1e8e4:	685a      	ldr	r2, [r3, #4]
   1e8e6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   1e8ea:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
   1e8ec:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   1e8ee:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   1e8f2:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
   1e8f4:	f005 baea 	b.w	23ecc <z_thread_abort>
   1e8f8:	2000b5b4 	.word	0x2000b5b4
   1e8fc:	e000ed00 	.word	0xe000ed00

0001e900 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   1e900:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	 * into account the unused SRAM area, as well.
	 */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   1e902:	4c09      	ldr	r4, [pc, #36]	; (1e928 <z_arm_configure_static_mpu_regions+0x28>)
   1e904:	4a09      	ldr	r2, [pc, #36]	; (1e92c <z_arm_configure_static_mpu_regions+0x2c>)
   1e906:	4623      	mov	r3, r4
   1e908:	2101      	movs	r1, #1
   1e90a:	4809      	ldr	r0, [pc, #36]	; (1e930 <z_arm_configure_static_mpu_regions+0x30>)
   1e90c:	f000 f8ea 	bl	1eae4 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   1e910:	2300      	movs	r3, #0
   1e912:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   1e914:	4b07      	ldr	r3, [pc, #28]	; (1e934 <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1e916:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   1e918:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1e91a:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   1e91c:	9301      	str	r3, [sp, #4]
   1e91e:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1e920:	f000 f8ea 	bl	1eaf8 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   1e924:	b004      	add	sp, #16
   1e926:	bd10      	pop	{r4, pc}
   1e928:	20080000 	.word	0x20080000
   1e92c:	2000a000 	.word	0x2000a000
   1e930:	000266bc 	.word	0x000266bc
   1e934:	2000a410 	.word	0x2000a410

0001e938 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
   1e938:	b510      	push	{r4, lr}
	mpu_set_region(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
		| (region_conf->attr.rbar &
   1e93a:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   1e93c:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   1e93e:	f004 021f 	and.w	r2, r4, #31
		(region_conf->base & MPU_RBAR_BASE_Msk)
   1e942:	f023 031f 	bic.w	r3, r3, #31
		| (region_conf->attr.rbar &
   1e946:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   1e948:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   1e94a:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   1e94c:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = rnr;
   1e950:	4905      	ldr	r1, [pc, #20]	; (1e968 <region_init+0x30>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   1e952:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   1e956:	f043 0301 	orr.w	r3, r3, #1
	MPU->RNR = rnr;
   1e95a:	f8c1 0098 	str.w	r0, [r1, #152]	; 0x98
	MPU->RBAR = rbar;
   1e95e:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
	MPU->RLAR = rlar;
   1e962:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   1e966:	bd10      	pop	{r4, pc}
   1e968:	e000ed00 	.word	0xe000ed00

0001e96c <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   1e96c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e970:	460f      	mov	r7, r1
   1e972:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   1e974:	4606      	mov	r6, r0
   1e976:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = rnr;
   1e97a:	4d4e      	ldr	r5, [pc, #312]	; (1eab4 <mpu_configure_regions_and_partition.constprop.0+0x148>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   1e97c:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   1e97e:	45b8      	cmp	r8, r7
   1e980:	f280 8094 	bge.w	1eaac <mpu_configure_regions_and_partition.constprop.0+0x140>
		if (regions[i].size == 0U) {
   1e984:	f8d6 9004 	ldr.w	r9, [r6, #4]
   1e988:	f1b9 0f00 	cmp.w	r9, #0
   1e98c:	d036      	beq.n	1e9fc <mpu_configure_regions_and_partition.constprop.0+0x90>
		&&
   1e98e:	f1b9 0f1f 	cmp.w	r9, #31
   1e992:	f240 8089 	bls.w	1eaa8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		&&
   1e996:	f019 0f1f 	tst.w	r9, #31
   1e99a:	f040 8085 	bne.w	1eaa8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		((part->start &
   1e99e:	f8d6 a000 	ldr.w	sl, [r6]
		&&
   1e9a2:	f01a 0f1f 	tst.w	sl, #31
   1e9a6:	d17f      	bne.n	1eaa8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1e9a8:	4650      	mov	r0, sl
   1e9aa:	f006 faf0 	bl	24f8e <arm_cmse_mpu_region_get>
   1e9ae:	4683      	mov	fp, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1e9b0:	eb09 000a 	add.w	r0, r9, sl
   1e9b4:	3801      	subs	r0, #1
   1e9b6:	f006 faea 	bl	24f8e <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   1e9ba:	4583      	cmp	fp, r0
   1e9bc:	d174      	bne.n	1eaa8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		 * inside which the new region will be configured.
		 */
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
   1e9be:	f11b 0f16 	cmn.w	fp, #22
   1e9c2:	d071      	beq.n	1eaa8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
   1e9c4:	455c      	cmp	r4, fp
   1e9c6:	dd6f      	ble.n	1eaa8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	MPU->RNR = rnr;
   1e9c8:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
   1e9cc:	f8d5 109c 	ldr.w	r1, [r5, #156]	; 0x9c
	MPU->RNR = rnr;
   1e9d0:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RLAR;
   1e9d4:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	return mpu_get_rbar() & MPU_RBAR_BASE_Msk;
   1e9d8:	f021 011f 	bic.w	r1, r1, #31
	return (mpu_get_rlar() & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   1e9dc:	f043 0a1f 	orr.w	sl, r3, #31
		 * The new memory region is to be placed inside the underlying
		 * region, possibly splitting the underlying region into two.
		 */
		uint32_t u_reg_base = mpu_region_get_base(u_reg_index);
		uint32_t u_reg_last = mpu_region_get_last_addr(u_reg_index);
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   1e9e0:	e9d6 3200 	ldrd	r3, r2, [r6]
   1e9e4:	441a      	add	r2, r3

		if ((regions[i].start == u_reg_base) &&
   1e9e6:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   1e9e8:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
		if ((regions[i].start == u_reg_base) &&
   1e9ec:	d11e      	bne.n	1ea2c <mpu_configure_regions_and_partition.constprop.0+0xc0>
   1e9ee:	45ca      	cmp	sl, r9
   1e9f0:	d108      	bne.n	1ea04 <mpu_configure_regions_and_partition.constprop.0+0x98>
			 * underlying region. In this case we simply
			 * update the partition attributes of the
			 * underlying region with those of the new
			 * region.
			 */
			mpu_configure_region(u_reg_index, &regions[i]);
   1e9f2:	4631      	mov	r1, r6
   1e9f4:	fa5f f08b 	uxtb.w	r0, fp
   1e9f8:	f006 fad2 	bl	24fa0 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   1e9fc:	f108 0801 	add.w	r8, r8, #1
   1ea00:	360c      	adds	r6, #12
   1ea02:	e7bc      	b.n	1e97e <mpu_configure_regions_and_partition.constprop.0+0x12>
			 */
			mpu_region_set_base(u_reg_index,
				regions[i].start + regions[i].size);

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);
   1ea04:	4631      	mov	r1, r6
	MPU->RNR = rnr;
   1ea06:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
   1ea0a:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
		     | (base & MPU_RBAR_BASE_Msk));
   1ea0e:	f022 021f 	bic.w	r2, r2, #31
	mpu_set_rbar((mpu_get_rbar() & (~MPU_RBAR_BASE_Msk))
   1ea12:	f003 031f 	and.w	r3, r3, #31
		     | (base & MPU_RBAR_BASE_Msk));
   1ea16:	4313      	orrs	r3, r2
	MPU->RBAR = rbar;
   1ea18:	f8c5 309c 	str.w	r3, [r5, #156]	; 0x9c
				mpu_configure_region(reg_index, &regions[i]);
   1ea1c:	b2e0      	uxtb	r0, r4
			 */
			mpu_region_set_limit(u_reg_index,
				regions[i].start - 1);

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);
   1ea1e:	f006 fabf 	bl	24fa0 <mpu_configure_region>

			if (reg_index == -EINVAL) {
   1ea22:	f110 0f16 	cmn.w	r0, #22
   1ea26:	d03f      	beq.n	1eaa8 <mpu_configure_regions_and_partition.constprop.0+0x13c>

			if (reg_index == -EINVAL) {
				return reg_index;
			}

			reg_index++;
   1ea28:	1c44      	adds	r4, r0, #1
   1ea2a:	e7e7      	b.n	1e9fc <mpu_configure_regions_and_partition.constprop.0+0x90>
	MPU->RNR = rnr;
   1ea2c:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RLAR;
   1ea30:	f8d5 20a0 	ldr.w	r2, [r5, #160]	; 0xa0
				regions[i].start - 1);
   1ea34:	3b01      	subs	r3, #1
		     | (limit & MPU_RLAR_LIMIT_Msk));
   1ea36:	f023 031f 	bic.w	r3, r3, #31
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
   1ea3a:	f002 021f 	and.w	r2, r2, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
   1ea3e:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
   1ea40:	45ca      	cmp	sl, r9
				mpu_configure_region(reg_index, &regions[i]);
   1ea42:	4631      	mov	r1, r6
				mpu_configure_region(reg_index, &regions[i]);
   1ea44:	b2e0      	uxtb	r0, r4
	MPU->RLAR = rlar;
   1ea46:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
		} else if (reg_last == u_reg_last) {
   1ea4a:	d0e8      	beq.n	1ea1e <mpu_configure_regions_and_partition.constprop.0+0xb2>
				mpu_configure_region(reg_index, &regions[i]);
   1ea4c:	f006 faa8 	bl	24fa0 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   1ea50:	f110 0f16 	cmn.w	r0, #22
   1ea54:	d028      	beq.n	1eaa8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	MPU->RNR = rnr;
   1ea56:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
   1ea5a:	f8d5 209c 	ldr.w	r2, [r5, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
   1ea5e:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
   1ea62:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
	attr->rbar = mpu_get_rbar() &
   1ea66:	f362 0304 	bfi	r3, r2, #0, #5
   1ea6a:	f88d 3008 	strb.w	r3, [sp, #8]
	return MPU->RLAR;
   1ea6e:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
   1ea72:	f89d 2008 	ldrb.w	r2, [sp, #8]
   1ea76:	085b      	lsrs	r3, r3, #1
   1ea78:	f363 1247 	bfi	r2, r3, #5, #3
   1ea7c:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
   1ea80:	e9d6 3200 	ldrd	r3, r2, [r6]
   1ea84:	4413      	add	r3, r2
   1ea86:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
   1ea88:	f023 031f 	bic.w	r3, r3, #31
			reg_index++;
   1ea8c:	1c41      	adds	r1, r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
   1ea8e:	4453      	add	r3, sl
   1ea90:	eba3 0309 	sub.w	r3, r3, r9
   1ea94:	b2c8      	uxtb	r0, r1
   1ea96:	f023 031f 	bic.w	r3, r3, #31

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   1ea9a:	2807      	cmp	r0, #7
			fill_region.attr.r_limit =
   1ea9c:	9303      	str	r3, [sp, #12]
   1ea9e:	d803      	bhi.n	1eaa8 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
   1eaa0:	4669      	mov	r1, sp
   1eaa2:	f7ff ff49 	bl	1e938 <region_init>
   1eaa6:	e7bf      	b.n	1ea28 <mpu_configure_regions_and_partition.constprop.0+0xbc>
			return -EINVAL;
   1eaa8:	f06f 0415 	mvn.w	r4, #21
		}
	}

	return reg_index;
}
   1eaac:	4620      	mov	r0, r4
   1eaae:	b005      	add	sp, #20
   1eab0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1eab4:	e000ed00 	.word	0xe000ed00

0001eab8 <arm_core_mpu_enable>:
	 * background region for privileged software access if desired.
	 */
#if defined(CONFIG_MPU_DISABLE_BACKGROUND_MAP)
	MPU->CTRL = MPU_CTRL_ENABLE_Msk;
#else
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   1eab8:	2205      	movs	r2, #5
   1eaba:	4b04      	ldr	r3, [pc, #16]	; (1eacc <arm_core_mpu_enable+0x14>)
   1eabc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
   1eac0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1eac4:	f3bf 8f6f 	isb	sy
#endif

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   1eac8:	4770      	bx	lr
   1eaca:	bf00      	nop
   1eacc:	e000ed00 	.word	0xe000ed00

0001ead0 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   1ead0:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   1ead4:	2200      	movs	r2, #0
   1ead6:	4b02      	ldr	r3, [pc, #8]	; (1eae0 <arm_core_mpu_disable+0x10>)
   1ead8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
   1eadc:	4770      	bx	lr
   1eade:	bf00      	nop
   1eae0:	e000ed00 	.word	0xe000ed00

0001eae4 <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	*static_regions, const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   1eae4:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   1eae6:	4c03      	ldr	r4, [pc, #12]	; (1eaf4 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   1eae8:	7822      	ldrb	r2, [r4, #0]
   1eaea:	f7ff ff3f 	bl	1e96c <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   1eaee:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   1eaf0:	bd10      	pop	{r4, pc}
   1eaf2:	bf00      	nop
   1eaf4:	2000b604 	.word	0x2000b604

0001eaf8 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
   1eaf8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1eafc:	4d29      	ldr	r5, [pc, #164]	; (1eba4 <arm_core_mpu_mark_areas_for_dynamic_regions+0xac>)
   1eafe:	468a      	mov	sl, r1

/* This internal function marks and stores the configuration of memory areas
 * where dynamic region programming is allowed. Return zero on success, or
 * -EINVAL on error.
 */
static int mpu_mark_areas_for_dynamic_regions(
   1eb00:	4606      	mov	r6, r0
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1eb02:	f04f 0800 	mov.w	r8, #0
   1eb06:	46ab      	mov	fp, r5
	MPU->RNR = rnr;
   1eb08:	4f27      	ldr	r7, [pc, #156]	; (1eba8 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb0>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1eb0a:	45d0      	cmp	r8, sl
   1eb0c:	da1b      	bge.n	1eb46 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
   1eb0e:	f8d6 9004 	ldr.w	r9, [r6, #4]
   1eb12:	f1b9 0f00 	cmp.w	r9, #0
   1eb16:	d03f      	beq.n	1eb98 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   1eb18:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1eb1a:	4608      	mov	r0, r1
   1eb1c:	9101      	str	r1, [sp, #4]
   1eb1e:	f006 fa36 	bl	24f8e <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1eb22:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1eb24:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1eb26:	eb09 0001 	add.w	r0, r9, r1
   1eb2a:	3801      	subs	r0, #1
   1eb2c:	f006 fa2f 	bl	24f8e <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   1eb30:	4284      	cmp	r4, r0
   1eb32:	f04f 0214 	mov.w	r2, #20
   1eb36:	4b1d      	ldr	r3, [pc, #116]	; (1ebac <arm_core_mpu_mark_areas_for_dynamic_regions+0xb4>)
   1eb38:	d008      	beq.n	1eb4c <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
   1eb3a:	fb02 f308 	mul.w	r3, r2, r8
   1eb3e:	f06f 0215 	mvn.w	r2, #21
   1eb42:	f84b 2003 	str.w	r2, [fp, r3]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
   1eb46:	b003      	add	sp, #12
   1eb48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   1eb4c:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
   1eb50:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   1eb52:	d0f8      	beq.n	1eb46 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   1eb54:	7819      	ldrb	r1, [r3, #0]
   1eb56:	42a1      	cmp	r1, r4
   1eb58:	ddf5      	ble.n	1eb46 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = mpu_get_rbar() &
   1eb5a:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = rnr;
   1eb5e:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
   1eb62:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
	return MPU->RBAR;
   1eb66:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
   1eb6a:	f100 0108 	add.w	r1, r0, #8
   1eb6e:	7b00      	ldrb	r0, [r0, #12]
   1eb70:	f364 0004 	bfi	r0, r4, #0, #5
   1eb74:	7108      	strb	r0, [r1, #4]
	return MPU->RLAR;
   1eb76:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
   1eb7a:	790c      	ldrb	r4, [r1, #4]
   1eb7c:	0840      	lsrs	r0, r0, #1
   1eb7e:	f360 1447 	bfi	r4, r0, #5, #3
   1eb82:	710c      	strb	r4, [r1, #4]
	return MPU->RBAR;
   1eb84:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
	region_conf->base = mpu_get_rbar() & MPU_RBAR_BASE_Msk;
   1eb88:	f021 011f 	bic.w	r1, r1, #31
   1eb8c:	6069      	str	r1, [r5, #4]
	return MPU->RLAR;
   1eb8e:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
	region_conf->attr.r_limit = mpu_get_rlar() & MPU_RLAR_LIMIT_Msk;
   1eb92:	f021 011f 	bic.w	r1, r1, #31
   1eb96:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1eb98:	f108 0801 	add.w	r8, r8, #1
   1eb9c:	3514      	adds	r5, #20
   1eb9e:	360c      	adds	r6, #12
   1eba0:	e7b3      	b.n	1eb0a <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
   1eba2:	bf00      	nop
   1eba4:	2000a938 	.word	0x2000a938
   1eba8:	e000ed00 	.word	0xe000ed00
   1ebac:	2000b604 	.word	0x2000b604

0001ebb0 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   1ebb0:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   1ebb2:	4d0e      	ldr	r5, [pc, #56]	; (1ebec <z_arm_mpu_init+0x3c>)
   1ebb4:	682c      	ldr	r4, [r5, #0]
   1ebb6:	2c08      	cmp	r4, #8
   1ebb8:	d815      	bhi.n	1ebe6 <z_arm_mpu_init+0x36>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1ebba:	2000      	movs	r0, #0
	arm_core_mpu_disable();
   1ebbc:	f7ff ff88 	bl	1ead0 <arm_core_mpu_disable>
	MPU->MAIR0 = mair0;
   1ebc0:	4b0b      	ldr	r3, [pc, #44]	; (1ebf0 <z_arm_mpu_init+0x40>)
   1ebc2:	4a0c      	ldr	r2, [pc, #48]	; (1ebf4 <z_arm_mpu_init+0x44>)
   1ebc4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1ebc8:	4284      	cmp	r4, r0
   1ebca:	d105      	bne.n	1ebd8 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   1ebcc:	4b0a      	ldr	r3, [pc, #40]	; (1ebf8 <z_arm_mpu_init+0x48>)
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   1ebce:	2000      	movs	r0, #0
	static_regions_num = mpu_config.num_regions;
   1ebd0:	701c      	strb	r4, [r3, #0]
	arm_core_mpu_enable();
   1ebd2:	f7ff ff71 	bl	1eab8 <arm_core_mpu_enable>
}
   1ebd6:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   1ebd8:	6869      	ldr	r1, [r5, #4]
   1ebda:	eb01 1100 	add.w	r1, r1, r0, lsl #4
   1ebde:	f7ff feab 	bl	1e938 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1ebe2:	3001      	adds	r0, #1
   1ebe4:	e7f0      	b.n	1ebc8 <z_arm_mpu_init+0x18>
		return -1;
   1ebe6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1ebea:	e7f4      	b.n	1ebd6 <z_arm_mpu_init+0x26>
   1ebec:	000266c8 	.word	0x000266c8
   1ebf0:	e000ed00 	.word	0xe000ed00
   1ebf4:	0044ffaa 	.word	0x0044ffaa
   1ebf8:	2000b604 	.word	0x2000b604

0001ebfc <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
   1ebfc:	4b01      	ldr	r3, [pc, #4]	; (1ec04 <__stdout_hook_install+0x8>)
   1ebfe:	6018      	str	r0, [r3, #0]
}
   1ec00:	4770      	bx	lr
   1ec02:	bf00      	nop
   1ec04:	2000a110 	.word	0x2000a110

0001ec08 <setup>:
	 * this case do the remainder of actions to properly configure and
	 * boot the Network MCU.
	 */

	/* Release the Network MCU, 'Release force off signal' */
	NRF_RESET->NETWORK.FORCEOFF = RESET_NETWORK_FORCEOFF_FORCEOFF_Release;
   1ec08:	2000      	movs	r0, #0
   1ec0a:	4b02      	ldr	r3, [pc, #8]	; (1ec14 <setup+0xc>)
   1ec0c:	f8c3 0614 	str.w	r0, [r3, #1556]	; 0x614
	if (IS_ENABLED(CONFIG_BOARD_ENABLE_CPUNET)) {
		enable_cpunet();
	}

	return 0;
}
   1ec10:	4770      	bx	lr
   1ec12:	bf00      	nop
   1ec14:	40005000 	.word	0x40005000

0001ec18 <usbd_evt_put>:
 * @brief Enqueue USBD event.
 *
 * @param Pointer to the previously allocated and filled event structure.
 */
static inline void usbd_evt_put(struct usbd_event *ev)
{
   1ec18:	4601      	mov	r1, r0
	k_fifo_put(&usbd_evt_fifo, ev);
   1ec1a:	4801      	ldr	r0, [pc, #4]	; (1ec20 <usbd_evt_put+0x8>)
   1ec1c:	f007 b85e 	b.w	25cdc <k_queue_append>
   1ec20:	2000a31c 	.word	0x2000a31c

0001ec24 <usbd_work_schedule>:
	k_work_submit_to_queue(&usbd_work_queue, &get_usbd_ctx()->usb_work);
   1ec24:	4901      	ldr	r1, [pc, #4]	; (1ec2c <usbd_work_schedule+0x8>)
   1ec26:	4802      	ldr	r0, [pc, #8]	; (1ec30 <usbd_work_schedule+0xc>)
   1ec28:	f007 b8bd 	b.w	25da6 <k_work_submit_to_queue>
   1ec2c:	2000a974 	.word	0x2000a974
   1ec30:	2000a4b0 	.word	0x2000a4b0

0001ec34 <endpoint_ctx>:
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1ec34:	0602      	lsls	r2, r0, #24
	uint8_t ep_num = USB_EP_GET_IDX(ep);
   1ec36:	f000 037f 	and.w	r3, r0, #127	; 0x7f
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1ec3a:	d512      	bpl.n	1ec62 <endpoint_ctx+0x2e>
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
   1ec3c:	2b08      	cmp	r3, #8
   1ec3e:	d105      	bne.n	1ec4c <endpoint_ctx+0x18>
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec40:	0701      	lsls	r1, r0, #28
	ep_num = NRF_USBD_EP_NR_GET(ep);
   1ec42:	f000 030f 	and.w	r3, r0, #15
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec46:	d506      	bpl.n	1ec56 <endpoint_ctx+0x22>
			return &ctx->ep_ctx[EP_ISOIN_INDEX];
   1ec48:	480e      	ldr	r0, [pc, #56]	; (1ec84 <endpoint_ctx+0x50>)
   1ec4a:	4770      	bx	lr
			if (ep_num >= CFG_EPIN_CNT) {
   1ec4c:	f010 0f78 	tst.w	r0, #120	; 0x78
   1ec50:	d112      	bne.n	1ec78 <endpoint_ctx+0x44>
	ep_num = NRF_USBD_EP_NR_GET(ep);
   1ec52:	f000 030f 	and.w	r3, r0, #15
			return &ctx->ep_ctx[ep_num];
   1ec56:	204c      	movs	r0, #76	; 0x4c
   1ec58:	eb00 1043 	add.w	r0, r0, r3, lsl #5
   1ec5c:	4b0a      	ldr	r3, [pc, #40]	; (1ec88 <endpoint_ctx+0x54>)
   1ec5e:	4418      	add	r0, r3
   1ec60:	4770      	bx	lr
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
   1ec62:	2b08      	cmp	r3, #8
   1ec64:	d105      	bne.n	1ec72 <endpoint_ctx+0x3e>
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec66:	0702      	lsls	r2, r0, #28
	ep_num = NRF_USBD_EP_NR_GET(ep);
   1ec68:	f000 030f 	and.w	r3, r0, #15
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec6c:	d506      	bpl.n	1ec7c <endpoint_ctx+0x48>
			return &ctx->ep_ctx[EP_ISOOUT_INDEX];
   1ec6e:	4807      	ldr	r0, [pc, #28]	; (1ec8c <endpoint_ctx+0x58>)
   1ec70:	4770      	bx	lr
			if (ep_num >= CFG_EPOUT_CNT) {
   1ec72:	f010 0f78 	tst.w	r0, #120	; 0x78
   1ec76:	d0f6      	beq.n	1ec66 <endpoint_ctx+0x32>
		return NULL;
   1ec78:	2000      	movs	r0, #0
}
   1ec7a:	4770      	bx	lr
			return &ctx->ep_ctx[CFG_EPIN_CNT +
   1ec7c:	4804      	ldr	r0, [pc, #16]	; (1ec90 <endpoint_ctx+0x5c>)
   1ec7e:	eb00 1043 	add.w	r0, r0, r3, lsl #5
   1ec82:	4770      	bx	lr
   1ec84:	2000aa98 	.word	0x2000aa98
   1ec88:	2000a94c 	.word	0x2000a94c
   1ec8c:	2000abb8 	.word	0x2000abb8
   1ec90:	2000aab8 	.word	0x2000aab8

0001ec94 <usbd_evt_get>:
	return z_impl_k_queue_get(queue, timeout);
   1ec94:	2200      	movs	r2, #0
   1ec96:	2300      	movs	r3, #0
   1ec98:	4801      	ldr	r0, [pc, #4]	; (1eca0 <usbd_evt_get+0xc>)
   1ec9a:	f004 bc29 	b.w	234f0 <z_impl_k_queue_get>
   1ec9e:	bf00      	nop
   1eca0:	2000a31c 	.word	0x2000a31c

0001eca4 <usbd_evt_flush>:

/**
 * @brief Drop all enqueued events.
 */
static inline void usbd_evt_flush(void)
{
   1eca4:	b510      	push	{r4, lr}
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1eca6:	4c05      	ldr	r4, [pc, #20]	; (1ecbc <usbd_evt_flush+0x18>)
	struct usbd_event *ev;

	do {
		ev = usbd_evt_get();
   1eca8:	f7ff fff4 	bl	1ec94 <usbd_evt_get>
		if (ev) {
   1ecac:	b120      	cbz	r0, 1ecb8 <usbd_evt_flush+0x14>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1ecae:	1d01      	adds	r1, r0, #4
   1ecb0:	4620      	mov	r0, r4
   1ecb2:	f006 ff5b 	bl	25b6c <k_mem_slab_free>
			usbd_evt_free(ev);
		}
	} while (ev != NULL);
   1ecb6:	e7f7      	b.n	1eca8 <usbd_evt_flush+0x4>
}
   1ecb8:	bd10      	pop	{r4, pc}
   1ecba:	bf00      	nop
   1ecbc:	2000a2d8 	.word	0x2000a2d8

0001ecc0 <usbd_evt_alloc>:
 * This function should be called prior to usbd_evt_put().
 *
 * @returns Pointer to the allocated event or NULL if there was no space left.
 */
static inline struct usbd_event *usbd_evt_alloc(void)
{
   1ecc0:	b507      	push	{r0, r1, r2, lr}
	struct usbd_event *ev;
	struct usbd_mem_block block;

	if (k_mem_slab_alloc(&fifo_elem_slab,
   1ecc2:	2300      	movs	r3, #0
   1ecc4:	2200      	movs	r2, #0
   1ecc6:	480e      	ldr	r0, [pc, #56]	; (1ed00 <usbd_evt_alloc+0x40>)
   1ecc8:	a901      	add	r1, sp, #4
   1ecca:	f004 fa59 	bl	23180 <k_mem_slab_alloc>
   1ecce:	b190      	cbz	r0, 1ecf6 <usbd_evt_alloc+0x36>
		 * Allocation may fail if workqueue thread is starved or event
		 * queue size is too small (CONFIG_USB_NRFX_EVT_QUEUE_SIZE).
		 * Wipe all events, free the space and schedule
		 * reinitialization.
		 */
		usbd_evt_flush();
   1ecd0:	f7ff ffe8 	bl	1eca4 <usbd_evt_flush>

		if (k_mem_slab_alloc(&fifo_elem_slab, (void **)&block.data, K_NO_WAIT)) {
   1ecd4:	2200      	movs	r2, #0
   1ecd6:	2300      	movs	r3, #0
   1ecd8:	4809      	ldr	r0, [pc, #36]	; (1ed00 <usbd_evt_alloc+0x40>)
   1ecda:	a901      	add	r1, sp, #4
   1ecdc:	f004 fa50 	bl	23180 <k_mem_slab_alloc>
   1ece0:	b938      	cbnz	r0, 1ecf2 <usbd_evt_alloc+0x32>
			return NULL;
		}

		ev = (struct usbd_event *)block.data;
		ev->block = block;
		ev->evt_type = USBD_EVT_REINIT;
   1ece2:	2304      	movs	r3, #4
		ev = (struct usbd_event *)block.data;
   1ece4:	9801      	ldr	r0, [sp, #4]
		ev->block = block;
   1ece6:	6040      	str	r0, [r0, #4]
		ev->evt_type = USBD_EVT_REINIT;
   1ece8:	7403      	strb	r3, [r0, #16]
		usbd_evt_put(ev);
   1ecea:	f7ff ff95 	bl	1ec18 <usbd_evt_put>
		usbd_work_schedule();
   1ecee:	f7ff ff99 	bl	1ec24 <usbd_work_schedule>

		return NULL;
   1ecf2:	2000      	movs	r0, #0
   1ecf4:	e001      	b.n	1ecfa <usbd_evt_alloc+0x3a>
	}

	ev = (struct usbd_event *)block.data;
   1ecf6:	9801      	ldr	r0, [sp, #4]
	ev->block = block;
   1ecf8:	6040      	str	r0, [r0, #4]

	return ev;
}
   1ecfa:	b003      	add	sp, #12
   1ecfc:	f85d fb04 	ldr.w	pc, [sp], #4
   1ed00:	2000a2d8 	.word	0x2000a2d8

0001ed04 <submit_dc_power_event>:

static void submit_dc_power_event(enum usbd_periph_state state)
{
   1ed04:	b510      	push	{r4, lr}
   1ed06:	4604      	mov	r4, r0
	struct usbd_event *ev = usbd_evt_alloc();
   1ed08:	f7ff ffda 	bl	1ecc0 <usbd_evt_alloc>

	if (!ev) {
   1ed0c:	b160      	cbz	r0, 1ed28 <submit_dc_power_event+0x24>
		return;
	}

	ev->evt_type = USBD_EVT_POWER;
   1ed0e:	2200      	movs	r2, #0
	ev->evt.pwr_evt.state = state;
   1ed10:	7204      	strb	r4, [r0, #8]
	ev->evt_type = USBD_EVT_POWER;
   1ed12:	7402      	strb	r2, [r0, #16]

	usbd_evt_put(ev);
   1ed14:	f7ff ff80 	bl	1ec18 <usbd_evt_put>

	if (usbd_ctx.attached) {
   1ed18:	4b04      	ldr	r3, [pc, #16]	; (1ed2c <submit_dc_power_event+0x28>)
   1ed1a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1ed1e:	b11b      	cbz	r3, 1ed28 <submit_dc_power_event+0x24>
		usbd_work_schedule();
	}
}
   1ed20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usbd_work_schedule();
   1ed24:	f7ff bf7e 	b.w	1ec24 <usbd_work_schedule>
}
   1ed28:	bd10      	pop	{r4, pc}
   1ed2a:	bf00      	nop
   1ed2c:	2000a94c 	.word	0x2000a94c

0001ed30 <usbd_event_transfer_data>:
		}
	}
}

static void usbd_event_transfer_data(nrfx_usbd_evt_t const *const p_event)
{
   1ed30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct nrf_usbd_ep_ctx *ep_ctx =
		endpoint_ctx(p_event->data.eptransfer.ep);
   1ed32:	7887      	ldrb	r7, [r0, #2]
{
   1ed34:	4606      	mov	r6, r0
		endpoint_ctx(p_event->data.eptransfer.ep);
   1ed36:	4638      	mov	r0, r7
   1ed38:	f7ff ff7c 	bl	1ec34 <endpoint_ctx>

	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ed3c:	063b      	lsls	r3, r7, #24
		endpoint_ctx(p_event->data.eptransfer.ep);
   1ed3e:	4604      	mov	r4, r0
		switch (p_event->data.eptransfer.status) {
   1ed40:	78f5      	ldrb	r5, [r6, #3]
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ed42:	d512      	bpl.n	1ed6a <usbd_event_transfer_data+0x3a>
		switch (p_event->data.eptransfer.status) {
   1ed44:	2d00      	cmp	r5, #0
   1ed46:	d143      	bne.n	1edd0 <usbd_event_transfer_data+0xa0>
		case NRFX_USBD_EP_OK: {
			struct usbd_event *ev = usbd_evt_alloc();
   1ed48:	f7ff ffba 	bl	1ecc0 <usbd_evt_alloc>

			if (!ev) {
   1ed4c:	4603      	mov	r3, r0
   1ed4e:	2800      	cmp	r0, #0
   1ed50:	d03e      	beq.n	1edd0 <usbd_event_transfer_data+0xa0>

			LOG_DBG("write complete, ep 0x%02x",
				(uint32_t)p_event->data.eptransfer.ep);

			ep_ctx->write_in_progress = false;
			ev->evt_type = USBD_EVT_EP;
   1ed52:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
   1ed54:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
   1ed56:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
   1ed58:	2203      	movs	r2, #3
   1ed5a:	7302      	strb	r2, [r0, #12]
				(uint32_t)p_event->data.eptransfer.ep);

			ep_ctx->read_pending = true;
			ev->evt_type = USBD_EVT_EP;
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
			ev->evt.ep_evt.ep = ep_ctx;
   1ed5c:	609c      	str	r4, [r3, #8]

			ev->evt_type = USBD_EVT_EP;
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
			ev->evt.ep_evt.ep = ep_ctx;

			usbd_evt_put(ev);
   1ed5e:	f7ff ff5b 	bl	1ec18 <usbd_evt_put>
				p_event->data.eptransfer.ep);
		}
		break;
		}
	}
}
   1ed62:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			usbd_work_schedule();
   1ed66:	f7ff bf5d 	b.w	1ec24 <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
   1ed6a:	b14d      	cbz	r5, 1ed80 <usbd_event_transfer_data+0x50>
   1ed6c:	2d01      	cmp	r5, #1
   1ed6e:	d12f      	bne.n	1edd0 <usbd_event_transfer_data+0xa0>
			struct usbd_event *ev = usbd_evt_alloc();
   1ed70:	f7ff ffa6 	bl	1ecc0 <usbd_evt_alloc>
			if (!ev) {
   1ed74:	4603      	mov	r3, r0
   1ed76:	b358      	cbz	r0, 1edd0 <usbd_event_transfer_data+0xa0>
			ep_ctx->read_pending = true;
   1ed78:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
   1ed7a:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1ed7c:	7305      	strb	r5, [r0, #12]
   1ed7e:	e7ed      	b.n	1ed5c <usbd_event_transfer_data+0x2c>
			struct usbd_event *ev = usbd_evt_alloc();
   1ed80:	f7ff ff9e 	bl	1ecc0 <usbd_evt_alloc>
			if (!ev) {
   1ed84:	b320      	cbz	r0, 1edd0 <usbd_event_transfer_data+0xa0>
				p_event->data.eptransfer.ep);
   1ed86:	78b2      	ldrb	r2, [r6, #2]

NRF_STATIC_INLINE uint32_t nrf_usbd_ep_amount_get(NRF_USBD_Type const * p_reg, uint8_t ep)
{
    uint32_t ret;

    if (NRF_USBD_EPIN_CHECK(ep))
   1ed88:	4b12      	ldr	r3, [pc, #72]	; (1edd4 <usbd_event_transfer_data+0xa4>)
   1ed8a:	f012 0f80 	tst.w	r2, #128	; 0x80
   1ed8e:	f002 0108 	and.w	r1, r2, #8
   1ed92:	d011      	beq.n	1edb8 <usbd_event_transfer_data+0x88>
    {
        if (NRF_USBD_EPISO_CHECK(ep))
   1ed94:	b141      	cbz	r1, 1eda8 <usbd_event_transfer_data+0x78>
        {
            ret = p_reg->ISOIN.AMOUNT;
   1ed96:	f8d3 36a8 	ldr.w	r3, [r3, #1704]	; 0x6a8
			ep_ctx->buf.len = nrf_usbd_ep_amount_get(NRF_USBD,
   1ed9a:	60e3      	str	r3, [r4, #12]
			ev->evt_type = USBD_EVT_EP;
   1ed9c:	2301      	movs	r3, #1
   1ed9e:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1eda0:	2302      	movs	r3, #2
			ev->evt.ep_evt.ep = ep_ctx;
   1eda2:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1eda4:	7303      	strb	r3, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   1eda6:	e7da      	b.n	1ed5e <usbd_event_transfer_data+0x2e>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPIN[epnr].AMOUNT;
   1eda8:	2114      	movs	r1, #20
   1edaa:	f002 020f 	and.w	r2, r2, #15
   1edae:	fb01 3302 	mla	r3, r1, r2, r3
   1edb2:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
   1edb6:	e7f0      	b.n	1ed9a <usbd_event_transfer_data+0x6a>
        }
    }
    else
    {
        if (NRF_USBD_EPISO_CHECK(ep))
   1edb8:	b111      	cbz	r1, 1edc0 <usbd_event_transfer_data+0x90>
        {
            ret = p_reg->ISOOUT.AMOUNT;
   1edba:	f8d3 37a8 	ldr.w	r3, [r3, #1960]	; 0x7a8
   1edbe:	e7ec      	b.n	1ed9a <usbd_event_transfer_data+0x6a>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPOUT[epnr].AMOUNT;
   1edc0:	2114      	movs	r1, #20
   1edc2:	f002 020f 	and.w	r2, r2, #15
   1edc6:	fb01 3302 	mla	r3, r1, r2, r3
   1edca:	f8d3 3708 	ldr.w	r3, [r3, #1800]	; 0x708
   1edce:	e7e4      	b.n	1ed9a <usbd_event_transfer_data+0x6a>
}
   1edd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1edd2:	bf00      	nop
   1edd4:	40036000 	.word	0x40036000

0001edd8 <usb_dc_power_event_handler>:
	switch (event) {
   1edd8:	2801      	cmp	r0, #1
{
   1edda:	b507      	push	{r0, r1, r2, lr}
	switch (event) {
   1eddc:	d00f      	beq.n	1edfe <usb_dc_power_event_handler+0x26>
   1edde:	2802      	cmp	r0, #2
   1ede0:	d00e      	beq.n	1ee00 <usb_dc_power_event_handler+0x28>
   1ede2:	b948      	cbnz	r0, 1edf8 <usb_dc_power_event_handler+0x20>
	z_impl_k_timer_start(timer, duration, period);
   1ede4:	2200      	movs	r2, #0
   1ede6:	2300      	movs	r3, #0
   1ede8:	4808      	ldr	r0, [pc, #32]	; (1ee0c <usb_dc_power_event_handler+0x34>)
   1edea:	e9cd 2300 	strd	r2, r3, [sp]
   1edee:	f645 129a 	movw	r2, #22938	; 0x599a
   1edf2:	2300      	movs	r3, #0
   1edf4:	f005 faa8 	bl	24348 <z_impl_k_timer_start>
}
   1edf8:	b003      	add	sp, #12
   1edfa:	f85d fb04 	ldr.w	pc, [sp], #4
	switch (event) {
   1edfe:	2000      	movs	r0, #0
}
   1ee00:	b003      	add	sp, #12
   1ee02:	f85d eb04 	ldr.w	lr, [sp], #4
	submit_dc_power_event(new_state);
   1ee06:	f7ff bf7d 	b.w	1ed04 <submit_dc_power_event>
   1ee0a:	bf00      	nop
   1ee0c:	2000a2a0 	.word	0x2000a2a0

0001ee10 <usb_init>:
	}
	return 0;
}

static int usb_init(void)
{
   1ee10:	b513      	push	{r0, r1, r4, lr}

#ifdef CONFIG_HAS_HW_NRF_USBREG
	/* Use CLOCK/POWER priority for compatibility with other series where
	 * USB events are handled by CLOCK interrupt handler.
	 */
	IRQ_CONNECT(USBREGULATOR_IRQn,
   1ee12:	2200      	movs	r2, #0
   1ee14:	2101      	movs	r1, #1
   1ee16:	2037      	movs	r0, #55	; 0x37
   1ee18:	f7ff fa9e 	bl	1e358 <z_arm_irq_priority_set>
		    DT_IRQ(DT_INST(0, nordic_nrf_clock), priority),
		    nrfx_isr, nrfx_usbreg_irq_handler, 0);
	irq_enable(USBREGULATOR_IRQn);
   1ee1c:	2037      	movs	r0, #55	; 0x37
   1ee1e:	f7ff fa6b 	bl	1e2f8 <arch_irq_enable>

	static const nrfx_power_usbevt_config_t usbevt_config = {
		.handler = usb_dc_power_event_handler
	};

	err = nrfx_usbd_init(usbd_event_handler);
   1ee22:	4812      	ldr	r0, [pc, #72]	; (1ee6c <usb_init+0x5c>)
   1ee24:	f003 fb58 	bl	224d8 <nrfx_usbd_init>
	if (err != NRFX_SUCCESS) {
   1ee28:	4b11      	ldr	r3, [pc, #68]	; (1ee70 <usb_init+0x60>)
   1ee2a:	4298      	cmp	r0, r3
   1ee2c:	d11a      	bne.n	1ee64 <usb_init+0x54>
	 * a problem here.
	 */
	(void)nrfx_power_init(&power_config);
	nrfx_power_usbevt_init(&usbevt_config);

	k_work_queue_start(&usbd_work_queue,
   1ee2e:	2400      	movs	r4, #0
	(void)nrfx_power_init(&power_config);
   1ee30:	4810      	ldr	r0, [pc, #64]	; (1ee74 <usb_init+0x64>)
   1ee32:	f002 fb41 	bl	214b8 <nrfx_power_init>
	nrfx_power_usbevt_init(&usbevt_config);
   1ee36:	4810      	ldr	r0, [pc, #64]	; (1ee78 <usb_init+0x68>)
   1ee38:	f003 ffea 	bl	22e10 <nrfx_usbreg_init>
	k_work_queue_start(&usbd_work_queue,
   1ee3c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1ee40:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1ee44:	490d      	ldr	r1, [pc, #52]	; (1ee7c <usb_init+0x6c>)
   1ee46:	480e      	ldr	r0, [pc, #56]	; (1ee80 <usb_init+0x70>)
   1ee48:	9400      	str	r4, [sp, #0]
   1ee4a:	f004 fce1 	bl	23810 <k_work_queue_start>
	return z_impl_k_thread_name_set(thread, str);
   1ee4e:	490d      	ldr	r1, [pc, #52]	; (1ee84 <usb_init+0x74>)
   1ee50:	480b      	ldr	r0, [pc, #44]	; (1ee80 <usb_init+0x70>)
   1ee52:	f006 feba 	bl	25bca <z_impl_k_thread_name_set>
			   usbd_work_queue_stack,
			   K_KERNEL_STACK_SIZEOF(usbd_work_queue_stack),
			   CONFIG_SYSTEM_WORKQUEUE_PRIORITY, NULL);

	k_thread_name_set(&usbd_work_queue.thread, "usbd_workq");
	k_work_init(&ctx->usb_work, usbd_work_handler);
   1ee56:	480c      	ldr	r0, [pc, #48]	; (1ee88 <usb_init+0x78>)
   1ee58:	490c      	ldr	r1, [pc, #48]	; (1ee8c <usb_init+0x7c>)
   1ee5a:	f006 ff87 	bl	25d6c <k_work_init>

	return 0;
   1ee5e:	4620      	mov	r0, r4
}
   1ee60:	b002      	add	sp, #8
   1ee62:	bd10      	pop	{r4, pc}
		return -EIO;
   1ee64:	f06f 0004 	mvn.w	r0, #4
   1ee68:	e7fa      	b.n	1ee60 <usb_init+0x50>
   1ee6a:	bf00      	nop
   1ee6c:	0001eec9 	.word	0x0001eec9
   1ee70:	0bad0000 	.word	0x0bad0000
   1ee74:	00026a7e 	.word	0x00026a7e
   1ee78:	000266f0 	.word	0x000266f0
   1ee7c:	2000ba30 	.word	0x2000ba30
   1ee80:	2000a4b0 	.word	0x2000a4b0
   1ee84:	00026a73 	.word	0x00026a73
   1ee88:	2000a974 	.word	0x2000a974
   1ee8c:	0001f04d 	.word	0x0001f04d

0001ee90 <hfxo_stop.constprop.0.isra.0>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1ee90:	2300      	movs	r3, #0
static int hfxo_stop(struct nrf_usbd_ctx *ctx)
   1ee92:	b510      	push	{r4, lr}
   1ee94:	490b      	ldr	r1, [pc, #44]	; (1eec4 <hfxo_stop.constprop.0.isra.0+0x34>)
   1ee96:	e8d1 2fef 	ldaex	r2, [r1]
   1ee9a:	2a01      	cmp	r2, #1
   1ee9c:	d103      	bne.n	1eea6 <hfxo_stop.constprop.0.isra.0+0x16>
   1ee9e:	e8c1 3fe0 	stlex	r0, r3, [r1]
   1eea2:	2800      	cmp	r0, #0
   1eea4:	d1f7      	bne.n	1ee96 <hfxo_stop.constprop.0.isra.0+0x6>
	if (atomic_cas(&ctx->clk_requested, 1, 0)) {
   1eea6:	d10c      	bne.n	1eec2 <hfxo_stop.constprop.0.isra.0+0x32>
		return onoff_cancel_or_release(ctx->hfxo_mgr, &ctx->hfxo_cli);
   1eea8:	f851 4c04 	ldr.w	r4, [r1, #-4]
 * @retval negative other errors produced by onoff_release().
 */
static inline int onoff_cancel_or_release(struct onoff_manager *mgr,
					  struct onoff_client *cli)
{
	int rv = onoff_cancel(mgr, cli);
   1eeac:	3914      	subs	r1, #20
   1eeae:	4620      	mov	r0, r4
   1eeb0:	f005 fdc4 	bl	24a3c <onoff_cancel>

	if (rv == -EALREADY) {
   1eeb4:	3078      	adds	r0, #120	; 0x78
   1eeb6:	d104      	bne.n	1eec2 <hfxo_stop.constprop.0.isra.0+0x32>
		rv = onoff_release(mgr);
   1eeb8:	4620      	mov	r0, r4
}
   1eeba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1eebe:	f005 bd98 	b.w	249f2 <onoff_release>
   1eec2:	bd10      	pop	{r4, pc}
   1eec4:	2000a96c 	.word	0x2000a96c

0001eec8 <usbd_event_handler>:
{
   1eec8:	b5f0      	push	{r4, r5, r6, r7, lr}
   1eeca:	4606      	mov	r6, r0
   1eecc:	b089      	sub	sp, #36	; 0x24
	struct usbd_event evt = {0};
   1eece:	2214      	movs	r2, #20
   1eed0:	2100      	movs	r1, #0
   1eed2:	a803      	add	r0, sp, #12
   1eed4:	f006 f89c 	bl	25010 <memset>
	switch (p_event->type) {
   1eed8:	7833      	ldrb	r3, [r6, #0]
   1eeda:	3b01      	subs	r3, #1
   1eedc:	2b05      	cmp	r3, #5
   1eede:	d821      	bhi.n	1ef24 <usbd_event_handler+0x5c>
   1eee0:	e8df f003 	tbb	[pc, r3]
   1eee4:	1414037a 	.word	0x1414037a
   1eee8:	166a      	.short	0x166a
   1eeea:	2303      	movs	r3, #3
		evt.evt_type = USBD_EVT_POWER;
   1eeec:	2400      	movs	r4, #0
		evt.evt.pwr_evt.state = USBD_SUSPENDED;
   1eeee:	f88d 3014 	strb.w	r3, [sp, #20]
		ev = usbd_evt_alloc();
   1eef2:	f7ff fee5 	bl	1ecc0 <usbd_evt_alloc>
		if (!ev) {
   1eef6:	4603      	mov	r3, r0
   1eef8:	b1a0      	cbz	r0, 1ef24 <usbd_event_handler+0x5c>
		ev->evt = evt.evt;
   1eefa:	f100 0208 	add.w	r2, r0, #8
		ev->evt_type = evt.evt_type;
   1eefe:	7404      	strb	r4, [r0, #16]
		ev->evt = evt.evt;
   1ef00:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
   1ef04:	e882 0003 	stmia.w	r2, {r0, r1}
		usbd_evt_put(ev);
   1ef08:	4618      	mov	r0, r3
   1ef0a:	e01d      	b.n	1ef48 <usbd_event_handler+0x80>
	switch (p_event->type) {
   1ef0c:	2304      	movs	r3, #4
   1ef0e:	e7ed      	b.n	1eeec <usbd_event_handler+0x24>
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
   1ef10:	78b7      	ldrb	r7, [r6, #2]
   1ef12:	4638      	mov	r0, r7
   1ef14:	f7ff fe8e 	bl	1ec34 <endpoint_ctx>
		switch (ep_ctx->cfg.type) {
   1ef18:	7a83      	ldrb	r3, [r0, #10]
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
   1ef1a:	4604      	mov	r4, r0
		switch (ep_ctx->cfg.type) {
   1ef1c:	b123      	cbz	r3, 1ef28 <usbd_event_handler+0x60>
   1ef1e:	3b01      	subs	r3, #1
   1ef20:	2b02      	cmp	r3, #2
   1ef22:	d943      	bls.n	1efac <usbd_event_handler+0xe4>
}
   1ef24:	b009      	add	sp, #36	; 0x24
   1ef26:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ef28:	063b      	lsls	r3, r7, #24
		switch (p_event->data.eptransfer.status) {
   1ef2a:	78f5      	ldrb	r5, [r6, #3]
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ef2c:	d513      	bpl.n	1ef56 <usbd_event_handler+0x8e>
		switch (p_event->data.eptransfer.status) {
   1ef2e:	2d00      	cmp	r5, #0
   1ef30:	d1f8      	bne.n	1ef24 <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
   1ef32:	f7ff fec5 	bl	1ecc0 <usbd_evt_alloc>
			if (!ev) {
   1ef36:	4603      	mov	r3, r0
   1ef38:	2800      	cmp	r0, #0
   1ef3a:	d0f3      	beq.n	1ef24 <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
   1ef3c:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
   1ef3e:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
   1ef40:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
   1ef42:	2203      	movs	r2, #3
   1ef44:	7302      	strb	r2, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   1ef46:	609c      	str	r4, [r3, #8]
		usbd_evt_put(ev);
   1ef48:	f7ff fe66 	bl	1ec18 <usbd_evt_put>
}
   1ef4c:	b009      	add	sp, #36	; 0x24
   1ef4e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		usbd_work_schedule();
   1ef52:	f7ff be67 	b.w	1ec24 <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
   1ef56:	b155      	cbz	r5, 1ef6e <usbd_event_handler+0xa6>
   1ef58:	2d01      	cmp	r5, #1
   1ef5a:	d1e3      	bne.n	1ef24 <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
   1ef5c:	f7ff feb0 	bl	1ecc0 <usbd_evt_alloc>
			if (!ev) {
   1ef60:	4603      	mov	r3, r0
   1ef62:	2800      	cmp	r0, #0
   1ef64:	d0de      	beq.n	1ef24 <usbd_event_handler+0x5c>
			ep_ctx->read_pending = true;
   1ef66:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
   1ef68:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1ef6a:	7305      	strb	r5, [r0, #12]
   1ef6c:	e7eb      	b.n	1ef46 <usbd_event_handler+0x7e>
			struct usbd_event *ev = usbd_evt_alloc();
   1ef6e:	f7ff fea7 	bl	1ecc0 <usbd_evt_alloc>
			if (!ev) {
   1ef72:	4607      	mov	r7, r0
   1ef74:	2800      	cmp	r0, #0
   1ef76:	d0d5      	beq.n	1ef24 <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
   1ef78:	2301      	movs	r3, #1
   1ef7a:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ef7c:	2302      	movs	r3, #2
			ev->evt.ep_evt.ep = ep_ctx;
   1ef7e:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ef80:	7303      	strb	r3, [r0, #12]
			err_code = nrfx_usbd_ep_status_get(
   1ef82:	f104 010c 	add.w	r1, r4, #12
   1ef86:	78b0      	ldrb	r0, [r6, #2]
   1ef88:	f006 fd75 	bl	25a76 <nrfx_usbd_ep_status_get>
			if (ctx->ctrl_read_len > ep_ctx->buf.len) {
   1ef8c:	4a13      	ldr	r2, [pc, #76]	; (1efdc <usbd_event_handler+0x114>)
   1ef8e:	68e1      	ldr	r1, [r4, #12]
   1ef90:	f8b2 328c 	ldrh.w	r3, [r2, #652]	; 0x28c
   1ef94:	428b      	cmp	r3, r1
   1ef96:	d906      	bls.n	1efa6 <usbd_event_handler+0xde>
				ctx->ctrl_read_len -= ep_ctx->buf.len;
   1ef98:	1a5b      	subs	r3, r3, r1
   1ef9a:	f8a2 328c 	strh.w	r3, [r2, #652]	; 0x28c
				nrfx_usbd_setup_data_clear();
   1ef9e:	f003 fcd1 	bl	22944 <nrfx_usbd_setup_data_clear>
			usbd_evt_put(ev);
   1efa2:	4638      	mov	r0, r7
   1efa4:	e7d0      	b.n	1ef48 <usbd_event_handler+0x80>
				ctx->ctrl_read_len = 0U;
   1efa6:	f8a2 528c 	strh.w	r5, [r2, #652]	; 0x28c
   1efaa:	e7fa      	b.n	1efa2 <usbd_event_handler+0xda>
			usbd_event_transfer_data(p_event);
   1efac:	4630      	mov	r0, r6
}
   1efae:	b009      	add	sp, #36	; 0x24
   1efb0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			usbd_event_transfer_data(p_event);
   1efb4:	f7ff bebc 	b.w	1ed30 <usbd_event_transfer_data>
		nrfx_usbd_setup_get(&drv_setup);
   1efb8:	a801      	add	r0, sp, #4
   1efba:	f003 fc9d 	bl	228f8 <nrfx_usbd_setup_get>
		if ((drv_setup.bRequest != USB_SREQ_SET_ADDRESS)
   1efbe:	f89d 3005 	ldrb.w	r3, [sp, #5]
   1efc2:	2b05      	cmp	r3, #5
   1efc4:	d104      	bne.n	1efd0 <usbd_event_handler+0x108>
		    || (USB_REQTYPE_GET_TYPE(drv_setup.bmRequestType)
   1efc6:	f89d 3004 	ldrb.w	r3, [sp, #4]
   1efca:	f013 0f60 	tst.w	r3, #96	; 0x60
   1efce:	d0a9      	beq.n	1ef24 <usbd_event_handler+0x5c>
			evt.evt.ep_evt.ep = ep_ctx;
   1efd0:	4b03      	ldr	r3, [pc, #12]	; (1efe0 <usbd_event_handler+0x118>)
			evt.evt_type = USBD_EVT_EP;
   1efd2:	2401      	movs	r4, #1
			evt.evt.ep_evt.ep = ep_ctx;
   1efd4:	9305      	str	r3, [sp, #20]
	if (put_evt) {
   1efd6:	e78c      	b.n	1eef2 <usbd_event_handler+0x2a>
	switch (p_event->type) {
   1efd8:	2402      	movs	r4, #2
   1efda:	e78a      	b.n	1eef2 <usbd_event_handler+0x2a>
   1efdc:	2000a94c 	.word	0x2000a94c
   1efe0:	2000aab8 	.word	0x2000aab8

0001efe4 <eps_ctx_init>:
{
   1efe4:	b538      	push	{r3, r4, r5, lr}
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   1efe6:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
   1efe8:	f064 007f 	orn	r0, r4, #127	; 0x7f
   1efec:	b2c0      	uxtb	r0, r0
   1efee:	f7ff fe21 	bl	1ec34 <endpoint_ctx>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   1eff2:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
   1eff4:	f006 f818 	bl	25028 <ep_ctx_reset>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   1eff8:	2c08      	cmp	r4, #8
   1effa:	d1f5      	bne.n	1efe8 <eps_ctx_init+0x4>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   1effc:	2400      	movs	r4, #0
   1effe:	4d0e      	ldr	r5, [pc, #56]	; (1f038 <eps_ctx_init+0x54>)
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
   1f000:	b2e0      	uxtb	r0, r4
   1f002:	f7ff fe17 	bl	1ec34 <endpoint_ctx>
		if (!ep_ctx->buf.block.data) {
   1f006:	6903      	ldr	r3, [r0, #16]
   1f008:	b903      	cbnz	r3, 1f00c <eps_ctx_init+0x28>
			ep_ctx->buf.block.data = ep_out_bufs[i];
   1f00a:	6105      	str	r5, [r0, #16]
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   1f00c:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
   1f00e:	f006 f80b 	bl	25028 <ep_ctx_reset>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   1f012:	2c08      	cmp	r4, #8
   1f014:	f105 0540 	add.w	r5, r5, #64	; 0x40
   1f018:	d1f2      	bne.n	1f000 <eps_ctx_init+0x1c>
		ep_ctx_reset(ep_ctx);
   1f01a:	4808      	ldr	r0, [pc, #32]	; (1f03c <eps_ctx_init+0x58>)
   1f01c:	f006 f804 	bl	25028 <ep_ctx_reset>
		if (!ep_ctx->buf.block.data) {
   1f020:	4b07      	ldr	r3, [pc, #28]	; (1f040 <eps_ctx_init+0x5c>)
   1f022:	f8d3 227c 	ldr.w	r2, [r3, #636]	; 0x27c
   1f026:	b912      	cbnz	r2, 1f02e <eps_ctx_init+0x4a>
			ep_ctx->buf.block.data = ep_isoout_bufs[0];
   1f028:	4a06      	ldr	r2, [pc, #24]	; (1f044 <eps_ctx_init+0x60>)
   1f02a:	f8c3 227c 	str.w	r2, [r3, #636]	; 0x27c
		ep_ctx_reset(ep_ctx);
   1f02e:	4806      	ldr	r0, [pc, #24]	; (1f048 <eps_ctx_init+0x64>)
   1f030:	f005 fffa 	bl	25028 <ep_ctx_reset>
}
   1f034:	2000      	movs	r0, #0
   1f036:	bd38      	pop	{r3, r4, r5, pc}
   1f038:	2000afdc 	.word	0x2000afdc
   1f03c:	2000aa98 	.word	0x2000aa98
   1f040:	2000a94c 	.word	0x2000a94c
   1f044:	2000abdc 	.word	0x2000abdc
   1f048:	2000abb8 	.word	0x2000abb8

0001f04c <usbd_work_handler>:
{
   1f04c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1f050:	4607      	mov	r7, r0
	return get_usbd_ctx()->ready;
   1f052:	4cad      	ldr	r4, [pc, #692]	; (1f308 <usbd_work_handler+0x2bc>)
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f054:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 1f30c <usbd_work_handler+0x2c0>
{
   1f058:	b085      	sub	sp, #20
	while ((ev = usbd_evt_get()) != NULL) {
   1f05a:	f7ff fe1b 	bl	1ec94 <usbd_evt_get>
   1f05e:	b910      	cbnz	r0, 1f066 <usbd_work_handler+0x1a>
}
   1f060:	b005      	add	sp, #20
   1f062:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return get_usbd_ctx()->ready;
   1f066:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
   1f06a:	7c02      	ldrb	r2, [r0, #16]
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f06c:	f100 0904 	add.w	r9, r0, #4
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
   1f070:	b93b      	cbnz	r3, 1f082 <usbd_work_handler+0x36>
   1f072:	2a00      	cmp	r2, #0
   1f074:	f000 8088 	beq.w	1f188 <usbd_work_handler+0x13c>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f078:	4649      	mov	r1, r9
   1f07a:	48a4      	ldr	r0, [pc, #656]	; (1f30c <usbd_work_handler+0x2c0>)
   1f07c:	f006 fd76 	bl	25b6c <k_mem_slab_free>
}
   1f080:	e7eb      	b.n	1f05a <usbd_work_handler+0xe>
		switch (ev->evt_type) {
   1f082:	2a04      	cmp	r2, #4
   1f084:	d844      	bhi.n	1f110 <usbd_work_handler+0xc4>
   1f086:	e8df f012 	tbh	[pc, r2, lsl #1]
   1f08a:	007f      	.short	0x007f
   1f08c:	00fe0005 	.word	0x00fe0005
   1f090:	012f0114 	.word	0x012f0114
	switch (ep_evt->evt_type) {
   1f094:	7b03      	ldrb	r3, [r0, #12]
	struct nrf_usbd_ep_ctx *ep_ctx = ep_evt->ep;
   1f096:	6885      	ldr	r5, [r0, #8]
	switch (ep_evt->evt_type) {
   1f098:	2b03      	cmp	r3, #3
   1f09a:	d839      	bhi.n	1f110 <usbd_work_handler+0xc4>
   1f09c:	e8df f003 	tbb	[pc, r3]
   1f0a0:	615c3f02 	.word	0x615c3f02
	usbd_setup = (struct usb_setup_packet *)ep_ctx->buf.data;
   1f0a4:	696e      	ldr	r6, [r5, #20]
	memset(usbd_setup, 0, sizeof(struct usb_setup_packet));
   1f0a6:	2208      	movs	r2, #8
   1f0a8:	2100      	movs	r1, #0
   1f0aa:	4630      	mov	r0, r6
   1f0ac:	f005 ffb0 	bl	25010 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   1f0b0:	4b97      	ldr	r3, [pc, #604]	; (1f310 <usbd_work_handler+0x2c4>)
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   1f0b2:	4898      	ldr	r0, [pc, #608]	; (1f314 <usbd_work_handler+0x2c8>)
   1f0b4:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
   1f0b8:	7032      	strb	r2, [r6, #0]
    return (uint8_t)(p_reg->BREQUEST);
   1f0ba:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
   1f0be:	7072      	strb	r2, [r6, #1]
    const uint16_t val = p_reg->WVALUEL;
   1f0c0:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
   1f0c4:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
   1f0c8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wValue = nrf_usbd_setup_wvalue_get(NRF_USBD);
   1f0cc:	8072      	strh	r2, [r6, #2]
    const uint16_t val = p_reg->WINDEXL;
   1f0ce:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
   1f0d2:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
   1f0d6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wIndex = nrf_usbd_setup_windex_get(NRF_USBD);
   1f0da:	80b2      	strh	r2, [r6, #4]
    const uint16_t val = p_reg->WLENGTHL;
   1f0dc:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
   1f0e0:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   1f0e4:	4631      	mov	r1, r6
   1f0e6:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
   1f0ea:	2208      	movs	r2, #8
	usbd_setup->wLength = nrf_usbd_setup_wlength_get(NRF_USBD);
   1f0ec:	80f3      	strh	r3, [r6, #6]
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
   1f0ee:	60ea      	str	r2, [r5, #12]
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   1f0f0:	f005 ff83 	bl	24ffa <memcpy>
	ep_ctx->cfg.cb(ep_ctx->cfg.addr, USB_DC_EP_SETUP);
   1f0f4:	682b      	ldr	r3, [r5, #0]
   1f0f6:	2100      	movs	r1, #0
   1f0f8:	7a68      	ldrb	r0, [r5, #9]
   1f0fa:	4798      	blx	r3
	if (usb_reqtype_is_to_device(usbd_setup) && usbd_setup->wLength) {
   1f0fc:	f996 3000 	ldrsb.w	r3, [r6]
   1f100:	2b00      	cmp	r3, #0
   1f102:	db08      	blt.n	1f116 <usbd_work_handler+0xca>
   1f104:	88f3      	ldrh	r3, [r6, #6]
   1f106:	b133      	cbz	r3, 1f116 <usbd_work_handler+0xca>
		ctx->ctrl_read_len = usbd_setup->wLength;
   1f108:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
		nrfx_usbd_setup_data_clear();
   1f10c:	f003 fc1a 	bl	22944 <nrfx_usbd_setup_data_clear>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f110:	4649      	mov	r1, r9
   1f112:	4640      	mov	r0, r8
   1f114:	e7b2      	b.n	1f07c <usbd_work_handler+0x30>
		ctx->ctrl_read_len = 0U;
   1f116:	2300      	movs	r3, #0
   1f118:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
   1f11c:	e7f8      	b.n	1f110 <usbd_work_handler+0xc4>
	if (!ep_ctx->read_pending) {
   1f11e:	7f6b      	ldrb	r3, [r5, #29]
   1f120:	2b00      	cmp	r3, #0
   1f122:	d0f5      	beq.n	1f110 <usbd_work_handler+0xc4>
	if (!ep_ctx->read_complete) {
   1f124:	7f2b      	ldrb	r3, [r5, #28]
   1f126:	2b00      	cmp	r3, #0
   1f128:	d0f2      	beq.n	1f110 <usbd_work_handler+0xc4>
	ep_ctx->read_pending = false;
   1f12a:	2600      	movs	r6, #0
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f12c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	ep_ctx->read_pending = false;
   1f130:	776e      	strb	r6, [r5, #29]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f132:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f136:	4878      	ldr	r0, [pc, #480]	; (1f318 <usbd_work_handler+0x2cc>)
	ep_ctx->read_complete = false;
   1f138:	772e      	strb	r6, [r5, #28]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f13a:	f005 ff8b 	bl	25054 <k_mutex_lock.constprop.0.isra.0>
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
   1f13e:	696b      	ldr	r3, [r5, #20]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
   1f140:	a901      	add	r1, sp, #4
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
   1f142:	9301      	str	r3, [sp, #4]
   1f144:	686b      	ldr	r3, [r5, #4]
   1f146:	e9cd 3602 	strd	r3, r6, [sp, #8]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
   1f14a:	7a68      	ldrb	r0, [r5, #9]
   1f14c:	f003 fa06 	bl	2255c <nrfx_usbd_ep_transfer>
	k_mutex_unlock(&ctx->drv_lock);
   1f150:	4871      	ldr	r0, [pc, #452]	; (1f318 <usbd_work_handler+0x2cc>)
   1f152:	f005 ff81 	bl	25058 <k_mutex_unlock.isra.0>
   1f156:	e7db      	b.n	1f110 <usbd_work_handler+0xc4>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   1f158:	2101      	movs	r1, #1
   1f15a:	682b      	ldr	r3, [r5, #0]
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   1f15c:	7a68      	ldrb	r0, [r5, #9]
   1f15e:	4798      	blx	r3
		break;
   1f160:	e7d6      	b.n	1f110 <usbd_work_handler+0xc4>
		if (ep_ctx->cfg.type == USB_DC_EP_CONTROL &&
   1f162:	7aab      	ldrb	r3, [r5, #10]
   1f164:	b96b      	cbnz	r3, 1f182 <usbd_work_handler+0x136>
   1f166:	7feb      	ldrb	r3, [r5, #31]
   1f168:	b95b      	cbnz	r3, 1f182 <usbd_work_handler+0x136>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f16a:	486b      	ldr	r0, [pc, #428]	; (1f318 <usbd_work_handler+0x2cc>)
   1f16c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f170:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f174:	f005 ff6e 	bl	25054 <k_mutex_lock.constprop.0.isra.0>
			nrfx_usbd_setup_clear();
   1f178:	f003 fc18 	bl	229ac <nrfx_usbd_setup_clear>
			k_mutex_unlock(&ctx->drv_lock);
   1f17c:	4866      	ldr	r0, [pc, #408]	; (1f318 <usbd_work_handler+0x2cc>)
   1f17e:	f005 ff6b 	bl	25058 <k_mutex_unlock.isra.0>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   1f182:	2102      	movs	r1, #2
   1f184:	682b      	ldr	r3, [r5, #0]
   1f186:	e7e9      	b.n	1f15c <usbd_work_handler+0x110>
	switch (pwr_evt->state) {
   1f188:	7a02      	ldrb	r2, [r0, #8]
   1f18a:	2a04      	cmp	r2, #4
   1f18c:	d8c0      	bhi.n	1f110 <usbd_work_handler+0xc4>
   1f18e:	e8df f002 	tbb	[pc, r2]
   1f192:	0355      	.short	0x0355
   1f194:	631f      	.short	0x631f
   1f196:	6f          	.byte	0x6f
   1f197:	00          	.byte	0x00
		if (!nrfx_usbd_is_enabled()) {
   1f198:	f003 f968 	bl	2246c <nrfx_usbd_is_enabled>
   1f19c:	4605      	mov	r5, r0
   1f19e:	2800      	cmp	r0, #0
   1f1a0:	d1b6      	bne.n	1f110 <usbd_work_handler+0xc4>
			nrfx_usbd_enable();
   1f1a2:	f003 f90f 	bl	223c4 <nrfx_usbd_enable>
   1f1a6:	2301      	movs	r3, #1
   1f1a8:	495c      	ldr	r1, [pc, #368]	; (1f31c <usbd_work_handler+0x2d0>)
   1f1aa:	e8d1 2fef 	ldaex	r2, [r1]
   1f1ae:	2a00      	cmp	r2, #0
   1f1b0:	d103      	bne.n	1f1ba <usbd_work_handler+0x16e>
   1f1b2:	e8c1 3fe0 	stlex	r0, r3, [r1]
   1f1b6:	2800      	cmp	r0, #0
   1f1b8:	d1f7      	bne.n	1f1aa <usbd_work_handler+0x15e>
	if (atomic_cas(&ctx->clk_requested, 0, 1)) {
   1f1ba:	d1a9      	bne.n	1f110 <usbd_work_handler+0xc4>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   1f1bc:	f841 5c08 	str.w	r5, [r1, #-8]
   1f1c0:	f841 5c10 	str.w	r5, [r1, #-16]
		return onoff_request(ctx->hfxo_mgr, &ctx->hfxo_cli);
   1f1c4:	69e0      	ldr	r0, [r4, #28]
   1f1c6:	3914      	subs	r1, #20
   1f1c8:	6163      	str	r3, [r4, #20]
   1f1ca:	f005 fbba 	bl	24942 <onoff_request>
   1f1ce:	e79f      	b.n	1f110 <usbd_work_handler+0xc4>
	switch (pwr_evt->state) {
   1f1d0:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
   1f1d2:	f065 007f 	orn	r0, r5, #127	; 0x7f
   1f1d6:	b2c0      	uxtb	r0, r0
   1f1d8:	f7ff fd2c 	bl	1ec34 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
   1f1dc:	7a03      	ldrb	r3, [r0, #8]
   1f1de:	b113      	cbz	r3, 1f1e6 <usbd_work_handler+0x19a>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f1e0:	7a40      	ldrb	r0, [r0, #9]
   1f1e2:	f003 fd91 	bl	22d08 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPIN_CNT; i++) {
   1f1e6:	3501      	adds	r5, #1
   1f1e8:	2d08      	cmp	r5, #8
   1f1ea:	d1f2      	bne.n	1f1d2 <usbd_work_handler+0x186>
		if (ep_ctx->cfg.en) {
   1f1ec:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
   1f1f0:	b11b      	cbz	r3, 1f1fa <usbd_work_handler+0x1ae>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f1f2:	f894 0155 	ldrb.w	r0, [r4, #341]	; 0x155
   1f1f6:	f003 fd87 	bl	22d08 <nrfx_usbd_ep_enable>
	switch (pwr_evt->state) {
   1f1fa:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
   1f1fc:	b2e8      	uxtb	r0, r5
   1f1fe:	f7ff fd19 	bl	1ec34 <endpoint_ctx>
		if (ep_ctx->cfg.en) {
   1f202:	7a03      	ldrb	r3, [r0, #8]
   1f204:	b113      	cbz	r3, 1f20c <usbd_work_handler+0x1c0>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f206:	7a40      	ldrb	r0, [r0, #9]
   1f208:	f003 fd7e 	bl	22d08 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPOUT_CNT; i++) {
   1f20c:	3501      	adds	r5, #1
   1f20e:	2d08      	cmp	r5, #8
   1f210:	d1f4      	bne.n	1f1fc <usbd_work_handler+0x1b0>
		if (ep_ctx->cfg.en) {
   1f212:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
   1f216:	b11b      	cbz	r3, 1f220 <usbd_work_handler+0x1d4>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f218:	f894 0275 	ldrb.w	r0, [r4, #629]	; 0x275
   1f21c:	f003 fd74 	bl	22d08 <nrfx_usbd_ep_enable>
		nrfx_usbd_start(true);
   1f220:	2001      	movs	r0, #1
   1f222:	f003 f905 	bl	22430 <nrfx_usbd_start>
		ctx->ready = true;
   1f226:	2301      	movs	r3, #1
   1f228:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
		if (ctx->status_cb) {
   1f22c:	6823      	ldr	r3, [r4, #0]
   1f22e:	2b00      	cmp	r3, #0
   1f230:	f43f af6e 	beq.w	1f110 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_CONNECTED, NULL);
   1f234:	2100      	movs	r1, #0
   1f236:	2002      	movs	r0, #2
				ctx->status_cb(USB_DC_SOF, NULL);
   1f238:	4798      	blx	r3
   1f23a:	e769      	b.n	1f110 <usbd_work_handler+0xc4>
		ctx->ready = false;
   1f23c:	2500      	movs	r5, #0
   1f23e:	f884 5025 	strb.w	r5, [r4, #37]	; 0x25
		nrfx_usbd_disable();
   1f242:	f003 fd1f 	bl	22c84 <nrfx_usbd_disable>
		err = hfxo_stop(ctx);
   1f246:	f7ff fe23 	bl	1ee90 <hfxo_stop.constprop.0.isra.0>
		if (ctx->status_cb) {
   1f24a:	6823      	ldr	r3, [r4, #0]
   1f24c:	2b00      	cmp	r3, #0
   1f24e:	f43f af5f 	beq.w	1f110 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_DISCONNECTED, NULL);
   1f252:	4629      	mov	r1, r5
   1f254:	2004      	movs	r0, #4
   1f256:	e7ef      	b.n	1f238 <usbd_work_handler+0x1ec>
		if (dev_ready()) {
   1f258:	2b00      	cmp	r3, #0
   1f25a:	f43f af59 	beq.w	1f110 <usbd_work_handler+0xc4>
			nrfx_usbd_suspend();
   1f25e:	f003 f90f 	bl	22480 <nrfx_usbd_suspend>
			if (ctx->status_cb) {
   1f262:	6823      	ldr	r3, [r4, #0]
   1f264:	2b00      	cmp	r3, #0
   1f266:	f43f af53 	beq.w	1f110 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_SUSPEND, NULL);
   1f26a:	2100      	movs	r1, #0
   1f26c:	2005      	movs	r0, #5
   1f26e:	e7e3      	b.n	1f238 <usbd_work_handler+0x1ec>
		if (ctx->status_cb && dev_ready()) {
   1f270:	6822      	ldr	r2, [r4, #0]
   1f272:	2a00      	cmp	r2, #0
   1f274:	f43f af4c 	beq.w	1f110 <usbd_work_handler+0xc4>
   1f278:	2b00      	cmp	r3, #0
   1f27a:	f43f af49 	beq.w	1f110 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_RESUME, NULL);
   1f27e:	2100      	movs	r1, #0
   1f280:	2006      	movs	r0, #6
   1f282:	4790      	blx	r2
   1f284:	e744      	b.n	1f110 <usbd_work_handler+0xc4>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f286:	f107 0510 	add.w	r5, r7, #16
   1f28a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f28e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f292:	4628      	mov	r0, r5
   1f294:	f005 fede 	bl	25054 <k_mutex_lock.constprop.0.isra.0>
			eps_ctx_init();
   1f298:	f7ff fea4 	bl	1efe4 <eps_ctx_init>
			k_mutex_unlock(&ctx->drv_lock);
   1f29c:	4628      	mov	r0, r5
   1f29e:	f005 fedb 	bl	25058 <k_mutex_unlock.isra.0>
			if (ctx->status_cb) {
   1f2a2:	f857 3c28 	ldr.w	r3, [r7, #-40]
   1f2a6:	2b00      	cmp	r3, #0
   1f2a8:	f43f af32 	beq.w	1f110 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_RESET, NULL);
   1f2ac:	2100      	movs	r1, #0
   1f2ae:	2001      	movs	r0, #1
   1f2b0:	e7c2      	b.n	1f238 <usbd_work_handler+0x1ec>
	if (ep_ctx->cfg.en) {
   1f2b2:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
   1f2b6:	b17b      	cbz	r3, 1f2d8 <usbd_work_handler+0x28c>
		ep_ctx->read_pending = true;
   1f2b8:	2501      	movs	r5, #1
   1f2ba:	f884 5289 	strb.w	r5, [r4, #649]	; 0x289
		ep_ctx->read_complete = true;
   1f2be:	f884 5288 	strb.w	r5, [r4, #648]	; 0x288
		ev = usbd_evt_alloc();
   1f2c2:	f7ff fcfd 	bl	1ecc0 <usbd_evt_alloc>
		if (!ev) {
   1f2c6:	b138      	cbz	r0, 1f2d8 <usbd_work_handler+0x28c>
		ev->evt.ep_evt.ep = ep_ctx;
   1f2c8:	4a15      	ldr	r2, [pc, #84]	; (1f320 <usbd_work_handler+0x2d4>)
		ev->evt_type = USBD_EVT_EP;
   1f2ca:	7405      	strb	r5, [r0, #16]
		ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1f2cc:	7305      	strb	r5, [r0, #12]
		ev->evt.ep_evt.ep = ep_ctx;
   1f2ce:	6082      	str	r2, [r0, #8]
		usbd_evt_put(ev);
   1f2d0:	f7ff fca2 	bl	1ec18 <usbd_evt_put>
		usbd_work_schedule();
   1f2d4:	f7ff fca6 	bl	1ec24 <usbd_work_schedule>
			if (ctx->status_cb) {
   1f2d8:	f857 3c28 	ldr.w	r3, [r7, #-40]
   1f2dc:	2b00      	cmp	r3, #0
   1f2de:	f43f af17 	beq.w	1f110 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_SOF, NULL);
   1f2e2:	2100      	movs	r1, #0
   1f2e4:	200a      	movs	r0, #10
   1f2e6:	e7a7      	b.n	1f238 <usbd_work_handler+0x1ec>
	nrfx_power_usbevt_disable();
   1f2e8:	f003 fd7a 	bl	22de0 <nrfx_usbreg_disable>
	nrfx_usbd_disable();
   1f2ec:	f003 fcca 	bl	22c84 <nrfx_usbd_disable>
	nrfx_usbd_uninit();
   1f2f0:	f003 f85e 	bl	223b0 <nrfx_usbd_uninit>
	usbd_evt_flush();
   1f2f4:	f7ff fcd6 	bl	1eca4 <usbd_evt_flush>
	ret = eps_ctx_init();
   1f2f8:	f7ff fe74 	bl	1efe4 <eps_ctx_init>
	nrfx_power_usbevt_enable();
   1f2fc:	f003 fd68 	bl	22dd0 <nrfx_usbreg_enable>
	err = nrfx_usbd_init(usbd_event_handler);
   1f300:	4808      	ldr	r0, [pc, #32]	; (1f324 <usbd_work_handler+0x2d8>)
   1f302:	f003 f8e9 	bl	224d8 <nrfx_usbd_init>
}
   1f306:	e703      	b.n	1f110 <usbd_work_handler+0xc4>
   1f308:	2000a94c 	.word	0x2000a94c
   1f30c:	2000a2d8 	.word	0x2000a2d8
   1f310:	40036000 	.word	0x40036000
   1f314:	2000a950 	.word	0x2000a950
   1f318:	2000a984 	.word	0x2000a984
   1f31c:	2000a96c 	.word	0x2000a96c
   1f320:	2000abb8 	.word	0x2000abb8
   1f324:	0001eec9 	.word	0x0001eec9

0001f328 <usb_dc_attach>:
{
   1f328:	b538      	push	{r3, r4, r5, lr}
	if (ctx->attached) {
   1f32a:	4d15      	ldr	r5, [pc, #84]	; (1f380 <usb_dc_attach+0x58>)
   1f32c:	f895 4024 	ldrb.w	r4, [r5, #36]	; 0x24
   1f330:	bb24      	cbnz	r4, 1f37c <usb_dc_attach+0x54>
	return z_impl_k_mutex_init(mutex);
   1f332:	f105 0038 	add.w	r0, r5, #56	; 0x38
   1f336:	f006 fc5c 	bl	25bf2 <z_impl_k_mutex_init>
		z_nrf_clock_control_get_onoff(
   1f33a:	2002      	movs	r0, #2
   1f33c:	f000 fb20 	bl	1f980 <z_nrf_clock_control_get_onoff>
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f340:	4622      	mov	r2, r4
   1f342:	2101      	movs	r1, #1
	ctx->hfxo_mgr =
   1f344:	61e8      	str	r0, [r5, #28]
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f346:	2036      	movs	r0, #54	; 0x36
   1f348:	f7ff f806 	bl	1e358 <z_arm_irq_priority_set>
	nrfx_power_usbevt_enable();
   1f34c:	f003 fd40 	bl	22dd0 <nrfx_usbreg_enable>
	ret = eps_ctx_init();
   1f350:	f7ff fe48 	bl	1efe4 <eps_ctx_init>
	if (ret == 0) {
   1f354:	4604      	mov	r4, r0
   1f356:	b910      	cbnz	r0, 1f35e <usb_dc_attach+0x36>
		ctx->attached = true;
   1f358:	2301      	movs	r3, #1
   1f35a:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
   1f35e:	4b09      	ldr	r3, [pc, #36]	; (1f384 <usb_dc_attach+0x5c>)
	if (!k_fifo_is_empty(&usbd_evt_fifo)) {
   1f360:	681b      	ldr	r3, [r3, #0]
   1f362:	b10b      	cbz	r3, 1f368 <usb_dc_attach+0x40>
		usbd_work_schedule();
   1f364:	f7ff fc5e 	bl	1ec24 <usbd_work_schedule>
    return p_reg->INTENSET & mask;
}

NRF_STATIC_INLINE uint32_t nrf_usbreg_status_get(NRF_USBREG_Type const * p_reg)
{
    return p_reg->USBREGSTATUS;
   1f368:	4b07      	ldr	r3, [pc, #28]	; (1f388 <usb_dc_attach+0x60>)
   1f36a:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_usbreg_state_t nrfx_usbreg_usbstatus_get(void)
{
    uint32_t status = nrf_usbreg_status_get(NRF_USBREGULATOR);
    if (0 == (status & NRF_USBREG_STATUS_VBUSDETECT_MASK))
   1f36e:	07db      	lsls	r3, r3, #31
   1f370:	d502      	bpl.n	1f378 <usb_dc_attach+0x50>
		usb_dc_power_event_handler(NRFX_POWER_USB_EVT_DETECTED);
   1f372:	2000      	movs	r0, #0
   1f374:	f7ff fd30 	bl	1edd8 <usb_dc_power_event_handler>
}
   1f378:	4620      	mov	r0, r4
   1f37a:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   1f37c:	2400      	movs	r4, #0
   1f37e:	e7fb      	b.n	1f378 <usb_dc_attach+0x50>
   1f380:	2000a94c 	.word	0x2000a94c
   1f384:	2000a31c 	.word	0x2000a31c
   1f388:	40037000 	.word	0x40037000

0001f38c <usb_dc_set_address>:
	return get_usbd_ctx()->attached;
   1f38c:	4b07      	ldr	r3, [pc, #28]	; (1f3ac <usb_dc_set_address+0x20>)
	if (!dev_attached() || !dev_ready()) {
   1f38e:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   1f392:	b13a      	cbz	r2, 1f3a4 <usb_dc_set_address+0x18>
   1f394:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
		return -ENODEV;
   1f398:	2b00      	cmp	r3, #0
   1f39a:	bf14      	ite	ne
   1f39c:	2000      	movne	r0, #0
   1f39e:	f06f 0012 	mvneq.w	r0, #18
   1f3a2:	4770      	bx	lr
   1f3a4:	f06f 0012 	mvn.w	r0, #18
}
   1f3a8:	4770      	bx	lr
   1f3aa:	bf00      	nop
   1f3ac:	2000a94c 	.word	0x2000a94c

0001f3b0 <usb_dc_ep_configure>:
{
   1f3b0:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f3b2:	4b10      	ldr	r3, [pc, #64]	; (1f3f4 <usb_dc_ep_configure+0x44>)
{
   1f3b4:	4604      	mov	r4, r0
	if (!dev_attached()) {
   1f3b6:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1f3ba:	b1c3      	cbz	r3, 1f3ee <usb_dc_ep_configure+0x3e>
	ep_ctx = endpoint_ctx(ep_cfg->ep_addr);
   1f3bc:	7805      	ldrb	r5, [r0, #0]
   1f3be:	4628      	mov	r0, r5
   1f3c0:	f7ff fc38 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f3c4:	b910      	cbnz	r0, 1f3cc <usb_dc_ep_configure+0x1c>
		return -EINVAL;
   1f3c6:	f06f 0015 	mvn.w	r0, #21
}
   1f3ca:	bd38      	pop	{r3, r4, r5, pc}
	ep_ctx->cfg.addr = ep_cfg->ep_addr;
   1f3cc:	7245      	strb	r5, [r0, #9]
	ep_ctx->cfg.type = ep_cfg->ep_type;
   1f3ce:	7923      	ldrb	r3, [r4, #4]
   1f3d0:	7283      	strb	r3, [r0, #10]
	ep_ctx->cfg.max_sz = ep_cfg->ep_mps;
   1f3d2:	8863      	ldrh	r3, [r4, #2]
   1f3d4:	6043      	str	r3, [r0, #4]
	if (!NRF_USBD_EPISO_CHECK(ep_cfg->ep_addr)) {
   1f3d6:	7820      	ldrb	r0, [r4, #0]
   1f3d8:	8861      	ldrh	r1, [r4, #2]
   1f3da:	f010 0f08 	tst.w	r0, #8
   1f3de:	d102      	bne.n	1f3e6 <usb_dc_ep_configure+0x36>
		if ((ep_cfg->ep_mps & (ep_cfg->ep_mps - 1)) != 0U) {
   1f3e0:	1e4b      	subs	r3, r1, #1
   1f3e2:	420b      	tst	r3, r1
   1f3e4:	d1ef      	bne.n	1f3c6 <usb_dc_ep_configure+0x16>
	nrfx_usbd_ep_max_packet_size_set(ep_addr_to_nrfx(ep_cfg->ep_addr),
   1f3e6:	f006 fb41 	bl	25a6c <nrfx_usbd_ep_max_packet_size_set>
	return 0;
   1f3ea:	2000      	movs	r0, #0
   1f3ec:	e7ed      	b.n	1f3ca <usb_dc_ep_configure+0x1a>
		return -ENODEV;
   1f3ee:	f06f 0012 	mvn.w	r0, #18
   1f3f2:	e7ea      	b.n	1f3ca <usb_dc_ep_configure+0x1a>
   1f3f4:	2000a94c 	.word	0x2000a94c

0001f3f8 <usb_dc_ep_set_stall>:
{
   1f3f8:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f3fa:	4b12      	ldr	r3, [pc, #72]	; (1f444 <usb_dc_ep_set_stall+0x4c>)
{
   1f3fc:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   1f3fe:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   1f402:	b1ca      	cbz	r2, 1f438 <usb_dc_ep_set_stall+0x40>
   1f404:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f408:	b1b3      	cbz	r3, 1f438 <usb_dc_ep_set_stall+0x40>
	ep_ctx = endpoint_ctx(ep);
   1f40a:	f7ff fc13 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f40e:	4604      	mov	r4, r0
   1f410:	b1a8      	cbz	r0, 1f43e <usb_dc_ep_set_stall+0x46>
	switch (ep_ctx->cfg.type) {
   1f412:	7a83      	ldrb	r3, [r0, #10]
   1f414:	2b01      	cmp	r3, #1
   1f416:	d012      	beq.n	1f43e <usb_dc_ep_set_stall+0x46>
   1f418:	d907      	bls.n	1f42a <usb_dc_ep_set_stall+0x32>
   1f41a:	3b02      	subs	r3, #2
   1f41c:	2b01      	cmp	r3, #1
   1f41e:	d907      	bls.n	1f430 <usb_dc_ep_set_stall+0x38>
	ep_ctx->buf.len = 0U;
   1f420:	2000      	movs	r0, #0
	ep_ctx->buf.curr = ep_ctx->buf.data;
   1f422:	6963      	ldr	r3, [r4, #20]
	ep_ctx->buf.len = 0U;
   1f424:	60e0      	str	r0, [r4, #12]
	ep_ctx->buf.curr = ep_ctx->buf.data;
   1f426:	61a3      	str	r3, [r4, #24]
}
   1f428:	bd38      	pop	{r3, r4, r5, pc}
		nrfx_usbd_setup_stall();
   1f42a:	f003 fac7 	bl	229bc <nrfx_usbd_setup_stall>
		break;
   1f42e:	e7f7      	b.n	1f420 <usb_dc_ep_set_stall+0x28>
		nrfx_usbd_ep_stall(ep_addr_to_nrfx(ep));
   1f430:	4628      	mov	r0, r5
   1f432:	f003 fa33 	bl	2289c <nrfx_usbd_ep_stall>
		break;
   1f436:	e7f3      	b.n	1f420 <usb_dc_ep_set_stall+0x28>
		return -ENODEV;
   1f438:	f06f 0012 	mvn.w	r0, #18
   1f43c:	e7f4      	b.n	1f428 <usb_dc_ep_set_stall+0x30>
	switch (ep_ctx->cfg.type) {
   1f43e:	f06f 0015 	mvn.w	r0, #21
   1f442:	e7f1      	b.n	1f428 <usb_dc_ep_set_stall+0x30>
   1f444:	2000a94c 	.word	0x2000a94c

0001f448 <usb_dc_ep_clear_stall>:
{
   1f448:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f44a:	4b0e      	ldr	r3, [pc, #56]	; (1f484 <usb_dc_ep_clear_stall+0x3c>)
{
   1f44c:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   1f44e:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   1f452:	b182      	cbz	r2, 1f476 <usb_dc_ep_clear_stall+0x2e>
   1f454:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f458:	b16b      	cbz	r3, 1f476 <usb_dc_ep_clear_stall+0x2e>
	ep_ctx = endpoint_ctx(ep);
   1f45a:	f7ff fbeb 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f45e:	b168      	cbz	r0, 1f47c <usb_dc_ep_clear_stall+0x34>
	if (NRF_USBD_EPISO_CHECK(ep)) {
   1f460:	f015 0408 	ands.w	r4, r5, #8
   1f464:	d10a      	bne.n	1f47c <usb_dc_ep_clear_stall+0x34>
	nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
   1f466:	4628      	mov	r0, r5
   1f468:	f003 fa3a 	bl	228e0 <nrfx_usbd_ep_dtoggle_clear>
	nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
   1f46c:	4628      	mov	r0, r5
   1f46e:	f003 fc9f 	bl	22db0 <nrfx_usbd_ep_stall_clear>
	return 0;
   1f472:	4620      	mov	r0, r4
}
   1f474:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
   1f476:	f06f 0012 	mvn.w	r0, #18
   1f47a:	e7fb      	b.n	1f474 <usb_dc_ep_clear_stall+0x2c>
		return -EINVAL;
   1f47c:	f06f 0015 	mvn.w	r0, #21
   1f480:	e7f8      	b.n	1f474 <usb_dc_ep_clear_stall+0x2c>
   1f482:	bf00      	nop
   1f484:	2000a94c 	.word	0x2000a94c

0001f488 <usb_dc_ep_is_stalled>:
{
   1f488:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f48a:	4b0c      	ldr	r3, [pc, #48]	; (1f4bc <usb_dc_ep_is_stalled+0x34>)
{
   1f48c:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   1f48e:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   1f492:	460c      	mov	r4, r1
	if (!dev_attached() || !dev_ready()) {
   1f494:	b162      	cbz	r2, 1f4b0 <usb_dc_ep_is_stalled+0x28>
   1f496:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f49a:	b14b      	cbz	r3, 1f4b0 <usb_dc_ep_is_stalled+0x28>
	ep_ctx = endpoint_ctx(ep);
   1f49c:	f7ff fbca 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f4a0:	b148      	cbz	r0, 1f4b6 <usb_dc_ep_is_stalled+0x2e>
	if (!stalled) {
   1f4a2:	b144      	cbz	r4, 1f4b6 <usb_dc_ep_is_stalled+0x2e>
	*stalled = (uint8_t) nrfx_usbd_ep_stall_check(ep_addr_to_nrfx(ep));
   1f4a4:	4628      	mov	r0, r5
   1f4a6:	f003 fa01 	bl	228ac <nrfx_usbd_ep_stall_check>
   1f4aa:	7020      	strb	r0, [r4, #0]
	return 0;
   1f4ac:	2000      	movs	r0, #0
}
   1f4ae:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
   1f4b0:	f06f 0012 	mvn.w	r0, #18
   1f4b4:	e7fb      	b.n	1f4ae <usb_dc_ep_is_stalled+0x26>
		return -EINVAL;
   1f4b6:	f06f 0015 	mvn.w	r0, #21
   1f4ba:	e7f8      	b.n	1f4ae <usb_dc_ep_is_stalled+0x26>
   1f4bc:	2000a94c 	.word	0x2000a94c

0001f4c0 <usb_dc_ep_enable>:
{
   1f4c0:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
   1f4c2:	4e13      	ldr	r6, [pc, #76]	; (1f510 <usb_dc_ep_enable+0x50>)
{
   1f4c4:	4604      	mov	r4, r0
	if (!dev_attached()) {
   1f4c6:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
   1f4ca:	b1c3      	cbz	r3, 1f4fe <usb_dc_ep_enable+0x3e>
	ep_ctx = endpoint_ctx(ep);
   1f4cc:	f7ff fbb2 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f4d0:	4605      	mov	r5, r0
   1f4d2:	b1b8      	cbz	r0, 1f504 <usb_dc_ep_enable+0x44>
	if (!NRF_USBD_EPISO_CHECK(ep)) {
   1f4d4:	0723      	lsls	r3, r4, #28
   1f4d6:	d405      	bmi.n	1f4e4 <usb_dc_ep_enable+0x24>
		nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
   1f4d8:	4620      	mov	r0, r4
   1f4da:	f003 fa01 	bl	228e0 <nrfx_usbd_ep_dtoggle_clear>
		nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
   1f4de:	4620      	mov	r0, r4
   1f4e0:	f003 fc66 	bl	22db0 <nrfx_usbd_ep_stall_clear>
	if (ep_ctx->cfg.en) {
   1f4e4:	7a2b      	ldrb	r3, [r5, #8]
   1f4e6:	b983      	cbnz	r3, 1f50a <usb_dc_ep_enable+0x4a>
	ep_ctx->cfg.en = true;
   1f4e8:	2301      	movs	r3, #1
   1f4ea:	722b      	strb	r3, [r5, #8]
	if (dev_ready()) {
   1f4ec:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
   1f4f0:	b90b      	cbnz	r3, 1f4f6 <usb_dc_ep_enable+0x36>
	return 0;
   1f4f2:	2000      	movs	r0, #0
}
   1f4f4:	bd70      	pop	{r4, r5, r6, pc}
		nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep));
   1f4f6:	4620      	mov	r0, r4
   1f4f8:	f003 fc06 	bl	22d08 <nrfx_usbd_ep_enable>
   1f4fc:	e7f9      	b.n	1f4f2 <usb_dc_ep_enable+0x32>
		return -ENODEV;
   1f4fe:	f06f 0012 	mvn.w	r0, #18
   1f502:	e7f7      	b.n	1f4f4 <usb_dc_ep_enable+0x34>
		return -EINVAL;
   1f504:	f06f 0015 	mvn.w	r0, #21
   1f508:	e7f4      	b.n	1f4f4 <usb_dc_ep_enable+0x34>
		return -EALREADY;
   1f50a:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1f50e:	e7f1      	b.n	1f4f4 <usb_dc_ep_enable+0x34>
   1f510:	2000a94c 	.word	0x2000a94c

0001f514 <usb_dc_ep_write>:
{
   1f514:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return get_usbd_ctx()->attached;
   1f518:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 1f600 <usb_dc_ep_write+0xec>
{
   1f51c:	461e      	mov	r6, r3
	if (!dev_attached() || !dev_ready()) {
   1f51e:	f898 3024 	ldrb.w	r3, [r8, #36]	; 0x24
{
   1f522:	4607      	mov	r7, r0
   1f524:	4689      	mov	r9, r1
   1f526:	4615      	mov	r5, r2
   1f528:	b085      	sub	sp, #20
	if (!dev_attached() || !dev_ready()) {
   1f52a:	2b00      	cmp	r3, #0
   1f52c:	d061      	beq.n	1f5f2 <usb_dc_ep_write+0xde>
   1f52e:	f898 3025 	ldrb.w	r3, [r8, #37]	; 0x25
   1f532:	2b00      	cmp	r3, #0
   1f534:	d05d      	beq.n	1f5f2 <usb_dc_ep_write+0xde>
	if (NRF_USBD_EPOUT_CHECK(ep)) {
   1f536:	0603      	lsls	r3, r0, #24
   1f538:	d55e      	bpl.n	1f5f8 <usb_dc_ep_write+0xe4>
	ep_ctx = endpoint_ctx(ep);
   1f53a:	f7ff fb7b 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f53e:	4604      	mov	r4, r0
   1f540:	2800      	cmp	r0, #0
   1f542:	d059      	beq.n	1f5f8 <usb_dc_ep_write+0xe4>
	if (!ep_ctx->cfg.en) {
   1f544:	7a03      	ldrb	r3, [r0, #8]
   1f546:	2b00      	cmp	r3, #0
   1f548:	d056      	beq.n	1f5f8 <usb_dc_ep_write+0xe4>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f54a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f54e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f552:	f108 0038 	add.w	r0, r8, #56	; 0x38
   1f556:	f005 fd7d 	bl	25054 <k_mutex_lock.constprop.0.isra.0>
	if (ep_ctx->write_in_progress) {
   1f55a:	7fa3      	ldrb	r3, [r4, #30]
   1f55c:	b14b      	cbz	r3, 1f572 <usb_dc_ep_write+0x5e>
		k_mutex_unlock(&ctx->drv_lock);
   1f55e:	f108 0038 	add.w	r0, r8, #56	; 0x38
   1f562:	f005 fd79 	bl	25058 <k_mutex_unlock.isra.0>
		return -EAGAIN;
   1f566:	f06f 040a 	mvn.w	r4, #10
}
   1f56a:	4620      	mov	r0, r4
   1f56c:	b005      	add	sp, #20
   1f56e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   1f572:	7aa3      	ldrb	r3, [r4, #10]
	if (!data_len && ep_ctx->trans_zlp) {
   1f574:	b1c5      	cbz	r5, 1f5a8 <usb_dc_ep_write+0x94>
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   1f576:	b33b      	cbz	r3, 1f5c8 <usb_dc_ep_write+0xb4>
	ep_ctx->write_in_progress = true;
   1f578:	2301      	movs	r3, #1
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
   1f57a:	f04f 0800 	mov.w	r8, #0
	ep_ctx->write_in_progress = true;
   1f57e:	77a3      	strb	r3, [r4, #30]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
   1f580:	4638      	mov	r0, r7
   1f582:	a901      	add	r1, sp, #4
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
   1f584:	e9cd 9501 	strd	r9, r5, [sp, #4]
   1f588:	f8cd 800c 	str.w	r8, [sp, #12]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
   1f58c:	f002 ffe6 	bl	2255c <nrfx_usbd_ep_transfer>
	if (err != NRFX_SUCCESS) {
   1f590:	4b1c      	ldr	r3, [pc, #112]	; (1f604 <usb_dc_ep_write+0xf0>)
   1f592:	4298      	cmp	r0, r3
   1f594:	d029      	beq.n	1f5ea <usb_dc_ep_write+0xd6>
		ep_ctx->write_in_progress = false;
   1f596:	f884 801e 	strb.w	r8, [r4, #30]
		if (ret_bytes) {
   1f59a:	bb1e      	cbnz	r6, 1f5e4 <usb_dc_ep_write+0xd0>
		result = -EIO;
   1f59c:	f06f 0404 	mvn.w	r4, #4
	k_mutex_unlock(&ctx->drv_lock);
   1f5a0:	4819      	ldr	r0, [pc, #100]	; (1f608 <usb_dc_ep_write+0xf4>)
   1f5a2:	f005 fd59 	bl	25058 <k_mutex_unlock.isra.0>
	return result;
   1f5a6:	e7e0      	b.n	1f56a <usb_dc_ep_write+0x56>
	if (!data_len && ep_ctx->trans_zlp) {
   1f5a8:	7fe2      	ldrb	r2, [r4, #31]
   1f5aa:	b102      	cbz	r2, 1f5ae <usb_dc_ep_write+0x9a>
		ep_ctx->trans_zlp = false;
   1f5ac:	77e5      	strb	r5, [r4, #31]
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   1f5ae:	2b00      	cmp	r3, #0
   1f5b0:	d1e2      	bne.n	1f578 <usb_dc_ep_write+0x64>
	    && (nrfx_usbd_last_setup_dir_get() != ep)) {
   1f5b2:	f003 fa0b 	bl	229cc <nrfx_usbd_last_setup_dir_get>
   1f5b6:	42b8      	cmp	r0, r7
   1f5b8:	d0de      	beq.n	1f578 <usb_dc_ep_write+0x64>
		nrfx_usbd_setup_clear();
   1f5ba:	f003 f9f7 	bl	229ac <nrfx_usbd_setup_clear>
		k_mutex_unlock(&ctx->drv_lock);
   1f5be:	4812      	ldr	r0, [pc, #72]	; (1f608 <usb_dc_ep_write+0xf4>)
   1f5c0:	f005 fd4a 	bl	25058 <k_mutex_unlock.isra.0>
		return 0;
   1f5c4:	2400      	movs	r4, #0
   1f5c6:	e7d0      	b.n	1f56a <usb_dc_ep_write+0x56>
		if (data_len && usbd_ctx.setup.wLength > data_len &&
   1f5c8:	f8b8 300a 	ldrh.w	r3, [r8, #10]
   1f5cc:	42ab      	cmp	r3, r5
   1f5ce:	d9f0      	bls.n	1f5b2 <usb_dc_ep_write+0x9e>
		    !(data_len % ep_ctx->cfg.max_sz)) {
   1f5d0:	6862      	ldr	r2, [r4, #4]
   1f5d2:	fbb5 f3f2 	udiv	r3, r5, r2
   1f5d6:	fb02 5313 	mls	r3, r2, r3, r5
		if (data_len && usbd_ctx.setup.wLength > data_len &&
   1f5da:	2b00      	cmp	r3, #0
   1f5dc:	d1e9      	bne.n	1f5b2 <usb_dc_ep_write+0x9e>
			ep_ctx->trans_zlp = true;
   1f5de:	2301      	movs	r3, #1
   1f5e0:	77e3      	strb	r3, [r4, #31]
	if ((ep_ctx->cfg.type == USB_DC_EP_CONTROL)
   1f5e2:	e7e6      	b.n	1f5b2 <usb_dc_ep_write+0x9e>
			*ret_bytes = 0;
   1f5e4:	f8c6 8000 	str.w	r8, [r6]
   1f5e8:	e7d8      	b.n	1f59c <usb_dc_ep_write+0x88>
		if (ret_bytes) {
   1f5ea:	b106      	cbz	r6, 1f5ee <usb_dc_ep_write+0xda>
			*ret_bytes = data_len;
   1f5ec:	6035      	str	r5, [r6, #0]
	int result = 0;
   1f5ee:	2400      	movs	r4, #0
   1f5f0:	e7d6      	b.n	1f5a0 <usb_dc_ep_write+0x8c>
		return -ENODEV;
   1f5f2:	f06f 0412 	mvn.w	r4, #18
   1f5f6:	e7b8      	b.n	1f56a <usb_dc_ep_write+0x56>
		return -EINVAL;
   1f5f8:	f06f 0415 	mvn.w	r4, #21
   1f5fc:	e7b5      	b.n	1f56a <usb_dc_ep_write+0x56>
   1f5fe:	bf00      	nop
   1f600:	2000a94c 	.word	0x2000a94c
   1f604:	0bad0000 	.word	0x0bad0000
   1f608:	2000a984 	.word	0x2000a984

0001f60c <usb_dc_ep_read_wait>:
{
   1f60c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f610:	461d      	mov	r5, r3
	return get_usbd_ctx()->attached;
   1f612:	4b20      	ldr	r3, [pc, #128]	; (1f694 <usb_dc_ep_read_wait+0x88>)
{
   1f614:	4617      	mov	r7, r2
	if (!dev_attached() || !dev_ready()) {
   1f616:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   1f61a:	460e      	mov	r6, r1
	if (!dev_attached() || !dev_ready()) {
   1f61c:	2a00      	cmp	r2, #0
   1f61e:	d033      	beq.n	1f688 <usb_dc_ep_read_wait+0x7c>
   1f620:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f624:	b383      	cbz	r3, 1f688 <usb_dc_ep_read_wait+0x7c>
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1f626:	0603      	lsls	r3, r0, #24
   1f628:	d431      	bmi.n	1f68e <usb_dc_ep_read_wait+0x82>
	if (!data && max_data_len) {
   1f62a:	b901      	cbnz	r1, 1f62e <usb_dc_ep_read_wait+0x22>
   1f62c:	bb7f      	cbnz	r7, 1f68e <usb_dc_ep_read_wait+0x82>
	ep_ctx = endpoint_ctx(ep);
   1f62e:	f7ff fb01 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f632:	4604      	mov	r4, r0
   1f634:	b358      	cbz	r0, 1f68e <usb_dc_ep_read_wait+0x82>
	if (!ep_ctx->cfg.en) {
   1f636:	7a03      	ldrb	r3, [r0, #8]
   1f638:	b34b      	cbz	r3, 1f68e <usb_dc_ep_read_wait+0x82>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f63a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f63e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f642:	4815      	ldr	r0, [pc, #84]	; (1f698 <usb_dc_ep_read_wait+0x8c>)
   1f644:	f005 fd06 	bl	25054 <k_mutex_lock.constprop.0.isra.0>
	bytes_to_copy = MIN(max_data_len, ep_ctx->buf.len);
   1f648:	68e3      	ldr	r3, [r4, #12]
   1f64a:	46b8      	mov	r8, r7
   1f64c:	429f      	cmp	r7, r3
   1f64e:	bf28      	it	cs
   1f650:	4698      	movcs	r8, r3
	if (!data && !max_data_len) {
   1f652:	b946      	cbnz	r6, 1f666 <usb_dc_ep_read_wait+0x5a>
   1f654:	b93f      	cbnz	r7, 1f666 <usb_dc_ep_read_wait+0x5a>
		if (read_bytes) {
   1f656:	b105      	cbz	r5, 1f65a <usb_dc_ep_read_wait+0x4e>
			*read_bytes = ep_ctx->buf.len;
   1f658:	602b      	str	r3, [r5, #0]
		k_mutex_unlock(&ctx->drv_lock);
   1f65a:	480f      	ldr	r0, [pc, #60]	; (1f698 <usb_dc_ep_read_wait+0x8c>)
   1f65c:	f005 fcfc 	bl	25058 <k_mutex_unlock.isra.0>
		return 0;
   1f660:	2000      	movs	r0, #0
}
   1f662:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	memcpy(data, ep_ctx->buf.curr, bytes_to_copy);
   1f666:	4642      	mov	r2, r8
   1f668:	4630      	mov	r0, r6
   1f66a:	69a1      	ldr	r1, [r4, #24]
   1f66c:	f005 fcc5 	bl	24ffa <memcpy>
	ep_ctx->buf.curr += bytes_to_copy;
   1f670:	69a3      	ldr	r3, [r4, #24]
   1f672:	4443      	add	r3, r8
   1f674:	61a3      	str	r3, [r4, #24]
	ep_ctx->buf.len -= bytes_to_copy;
   1f676:	68e3      	ldr	r3, [r4, #12]
   1f678:	eba3 0308 	sub.w	r3, r3, r8
   1f67c:	60e3      	str	r3, [r4, #12]
	if (read_bytes) {
   1f67e:	2d00      	cmp	r5, #0
   1f680:	d0eb      	beq.n	1f65a <usb_dc_ep_read_wait+0x4e>
		*read_bytes = bytes_to_copy;
   1f682:	f8c5 8000 	str.w	r8, [r5]
   1f686:	e7e8      	b.n	1f65a <usb_dc_ep_read_wait+0x4e>
		return -ENODEV;
   1f688:	f06f 0012 	mvn.w	r0, #18
   1f68c:	e7e9      	b.n	1f662 <usb_dc_ep_read_wait+0x56>
		return -EINVAL;
   1f68e:	f06f 0015 	mvn.w	r0, #21
   1f692:	e7e6      	b.n	1f662 <usb_dc_ep_read_wait+0x56>
   1f694:	2000a94c 	.word	0x2000a94c
   1f698:	2000a984 	.word	0x2000a984

0001f69c <usb_dc_ep_read_continue>:
{
   1f69c:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
   1f69e:	4d1e      	ldr	r5, [pc, #120]	; (1f718 <usb_dc_ep_read_continue+0x7c>)
{
   1f6a0:	4603      	mov	r3, r0
	if (!dev_attached() || !dev_ready()) {
   1f6a2:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   1f6a6:	b382      	cbz	r2, 1f70a <usb_dc_ep_read_continue+0x6e>
   1f6a8:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   1f6ac:	b36a      	cbz	r2, 1f70a <usb_dc_ep_read_continue+0x6e>
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1f6ae:	061b      	lsls	r3, r3, #24
   1f6b0:	d42e      	bmi.n	1f710 <usb_dc_ep_read_continue+0x74>
	ep_ctx = endpoint_ctx(ep);
   1f6b2:	f7ff fabf 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f6b6:	4604      	mov	r4, r0
   1f6b8:	b350      	cbz	r0, 1f710 <usb_dc_ep_read_continue+0x74>
	if (!ep_ctx->cfg.en) {
   1f6ba:	7a03      	ldrb	r3, [r0, #8]
   1f6bc:	b343      	cbz	r3, 1f710 <usb_dc_ep_read_continue+0x74>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f6be:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f6c2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f6c6:	f105 0038 	add.w	r0, r5, #56	; 0x38
   1f6ca:	f005 fcc3 	bl	25054 <k_mutex_lock.constprop.0.isra.0>
	if (!ep_ctx->buf.len) {
   1f6ce:	68e3      	ldr	r3, [r4, #12]
   1f6d0:	b9b3      	cbnz	r3, 1f700 <usb_dc_ep_read_continue+0x64>
		ep_ctx->read_complete = true;
   1f6d2:	2601      	movs	r6, #1
		ep_ctx->buf.curr = ep_ctx->buf.data;
   1f6d4:	6963      	ldr	r3, [r4, #20]
		ep_ctx->read_complete = true;
   1f6d6:	7726      	strb	r6, [r4, #28]
		ep_ctx->buf.curr = ep_ctx->buf.data;
   1f6d8:	61a3      	str	r3, [r4, #24]
		if (ep_ctx->read_pending) {
   1f6da:	7f63      	ldrb	r3, [r4, #29]
   1f6dc:	b183      	cbz	r3, 1f700 <usb_dc_ep_read_continue+0x64>
			struct usbd_event *ev = usbd_evt_alloc();
   1f6de:	f7ff faef 	bl	1ecc0 <usbd_evt_alloc>
			if (!ev) {
   1f6e2:	b930      	cbnz	r0, 1f6f2 <usb_dc_ep_read_continue+0x56>
				k_mutex_unlock(&ctx->drv_lock);
   1f6e4:	f105 0038 	add.w	r0, r5, #56	; 0x38
   1f6e8:	f005 fcb6 	bl	25058 <k_mutex_unlock.isra.0>
				return -ENOMEM;
   1f6ec:	f06f 000b 	mvn.w	r0, #11
}
   1f6f0:	bd70      	pop	{r4, r5, r6, pc}
			ev->evt_type = USBD_EVT_EP;
   1f6f2:	7406      	strb	r6, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
   1f6f4:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1f6f6:	7306      	strb	r6, [r0, #12]
			usbd_evt_put(ev);
   1f6f8:	f7ff fa8e 	bl	1ec18 <usbd_evt_put>
			usbd_work_schedule();
   1f6fc:	f7ff fa92 	bl	1ec24 <usbd_work_schedule>
	k_mutex_unlock(&ctx->drv_lock);
   1f700:	4806      	ldr	r0, [pc, #24]	; (1f71c <usb_dc_ep_read_continue+0x80>)
   1f702:	f005 fca9 	bl	25058 <k_mutex_unlock.isra.0>
	return 0;
   1f706:	2000      	movs	r0, #0
   1f708:	e7f2      	b.n	1f6f0 <usb_dc_ep_read_continue+0x54>
		return -ENODEV;
   1f70a:	f06f 0012 	mvn.w	r0, #18
   1f70e:	e7ef      	b.n	1f6f0 <usb_dc_ep_read_continue+0x54>
		return -EINVAL;
   1f710:	f06f 0015 	mvn.w	r0, #21
   1f714:	e7ec      	b.n	1f6f0 <usb_dc_ep_read_continue+0x54>
   1f716:	bf00      	nop
   1f718:	2000a94c 	.word	0x2000a94c
   1f71c:	2000a984 	.word	0x2000a984

0001f720 <usb_dc_ep_set_callback>:
{
   1f720:	b510      	push	{r4, lr}
	return get_usbd_ctx()->attached;
   1f722:	4b08      	ldr	r3, [pc, #32]	; (1f744 <usb_dc_ep_set_callback+0x24>)
{
   1f724:	460c      	mov	r4, r1
	if (!dev_attached()) {
   1f726:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1f72a:	b12b      	cbz	r3, 1f738 <usb_dc_ep_set_callback+0x18>
	ep_ctx = endpoint_ctx(ep);
   1f72c:	f7ff fa82 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f730:	b128      	cbz	r0, 1f73e <usb_dc_ep_set_callback+0x1e>
	ep_ctx->cfg.cb = cb;
   1f732:	6004      	str	r4, [r0, #0]
	return 0;
   1f734:	2000      	movs	r0, #0
}
   1f736:	bd10      	pop	{r4, pc}
		return -ENODEV;
   1f738:	f06f 0012 	mvn.w	r0, #18
   1f73c:	e7fb      	b.n	1f736 <usb_dc_ep_set_callback+0x16>
		return -EINVAL;
   1f73e:	f06f 0015 	mvn.w	r0, #21
   1f742:	e7f8      	b.n	1f736 <usb_dc_ep_set_callback+0x16>
   1f744:	2000a94c 	.word	0x2000a94c

0001f748 <usb_dc_set_status_callback>:
	get_usbd_ctx()->status_cb = cb;
   1f748:	4b01      	ldr	r3, [pc, #4]	; (1f750 <usb_dc_set_status_callback+0x8>)
   1f74a:	6018      	str	r0, [r3, #0]
}
   1f74c:	4770      	bx	lr
   1f74e:	bf00      	nop
   1f750:	2000a94c 	.word	0x2000a94c

0001f754 <usb_dc_ep_mps>:
{
   1f754:	b508      	push	{r3, lr}
	return get_usbd_ctx()->attached;
   1f756:	4b07      	ldr	r3, [pc, #28]	; (1f774 <usb_dc_ep_mps+0x20>)
	if (!dev_attached()) {
   1f758:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1f75c:	b123      	cbz	r3, 1f768 <usb_dc_ep_mps+0x14>
	ep_ctx = endpoint_ctx(ep);
   1f75e:	f7ff fa69 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   1f762:	b120      	cbz	r0, 1f76e <usb_dc_ep_mps+0x1a>
	return ep_ctx->cfg.max_sz;
   1f764:	6840      	ldr	r0, [r0, #4]
}
   1f766:	bd08      	pop	{r3, pc}
		return -ENODEV;
   1f768:	f06f 0012 	mvn.w	r0, #18
   1f76c:	e7fb      	b.n	1f766 <usb_dc_ep_mps+0x12>
		return -EINVAL;
   1f76e:	f06f 0015 	mvn.w	r0, #21
   1f772:	e7f8      	b.n	1f766 <usb_dc_ep_mps+0x12>
   1f774:	2000a94c 	.word	0x2000a94c

0001f778 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
   1f778:	4b08      	ldr	r3, [pc, #32]	; (1f79c <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   1f77a:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   1f77c:	1ac3      	subs	r3, r0, r3
{
   1f77e:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f780:	4907      	ldr	r1, [pc, #28]	; (1f7a0 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
   1f782:	109b      	asrs	r3, r3, #2
{
   1f784:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f786:	4359      	muls	r1, r3
   1f788:	2240      	movs	r2, #64	; 0x40
   1f78a:	4806      	ldr	r0, [pc, #24]	; (1f7a4 <onoff_stop+0x2c>)
   1f78c:	f005 fcc2 	bl	25114 <stop>
	notify(mgr, res);
   1f790:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f792:	4601      	mov	r1, r0
	notify(mgr, res);
   1f794:	4620      	mov	r0, r4
}
   1f796:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   1f79a:	4718      	bx	r3
   1f79c:	2000b1f0 	.word	0x2000b1f0
   1f7a0:	b6db6db7 	.word	0xb6db6db7
   1f7a4:	00026228 	.word	0x00026228

0001f7a8 <onoff_start>:
static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f7a8:	2340      	movs	r3, #64	; 0x40
{
   1f7aa:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   1f7ac:	4c0b      	ldr	r4, [pc, #44]	; (1f7dc <onoff_start+0x34>)
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f7ae:	9300      	str	r3, [sp, #0]
	size_t offset = (size_t)(mgr - data->mgr);
   1f7b0:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f7b2:	460b      	mov	r3, r1
{
   1f7b4:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f7b6:	490a      	ldr	r1, [pc, #40]	; (1f7e0 <onoff_start+0x38>)
	size_t offset = (size_t)(mgr - data->mgr);
   1f7b8:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f7ba:	4361      	muls	r1, r4
{
   1f7bc:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f7be:	4a09      	ldr	r2, [pc, #36]	; (1f7e4 <onoff_start+0x3c>)
   1f7c0:	4809      	ldr	r0, [pc, #36]	; (1f7e8 <onoff_start+0x40>)
   1f7c2:	f005 fcd4 	bl	2516e <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
   1f7c6:	1e01      	subs	r1, r0, #0
   1f7c8:	da05      	bge.n	1f7d6 <onoff_start+0x2e>
		notify(mgr, err);
   1f7ca:	4630      	mov	r0, r6
   1f7cc:	462b      	mov	r3, r5
	}
}
   1f7ce:	b002      	add	sp, #8
   1f7d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
   1f7d4:	4718      	bx	r3
}
   1f7d6:	b002      	add	sp, #8
   1f7d8:	bd70      	pop	{r4, r5, r6, pc}
   1f7da:	bf00      	nop
   1f7dc:	2000b1f0 	.word	0x2000b1f0
   1f7e0:	b6db6db7 	.word	0xb6db6db7
   1f7e4:	000251db 	.word	0x000251db
   1f7e8:	00026228 	.word	0x00026228

0001f7ec <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   1f7ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f7f0:	2200      	movs	r2, #0
   1f7f2:	2101      	movs	r1, #1
{
   1f7f4:	4606      	mov	r6, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f7f6:	2005      	movs	r0, #5
   1f7f8:	f7fe fdae 	bl	1e358 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
   1f7fc:	4811      	ldr	r0, [pc, #68]	; (1f844 <clk_init+0x58>)
   1f7fe:	f001 fa17 	bl	20c30 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   1f802:	4b11      	ldr	r3, [pc, #68]	; (1f848 <clk_init+0x5c>)
   1f804:	4298      	cmp	r0, r3
   1f806:	d119      	bne.n	1f83c <clk_init+0x50>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   1f808:	f001 fa22 	bl	20c50 <nrfx_clock_enable>
   1f80c:	2400      	movs	r4, #0
	return &data->mgr[type];
   1f80e:	f04f 091c 	mov.w	r9, #28
					 &transitions);
		if (err < 0) {
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f812:	270c      	movs	r7, #12
		err = onoff_manager_init(get_onoff_manager(dev, i),
   1f814:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1f84c <clk_init+0x60>
	struct nrf_clock_control_data *data = dev->data;
   1f818:	6935      	ldr	r5, [r6, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   1f81a:	4641      	mov	r1, r8
   1f81c:	fb09 5004 	mla	r0, r9, r4, r5
   1f820:	f005 f87c 	bl	2491c <onoff_manager_init>
		if (err < 0) {
   1f824:	2800      	cmp	r0, #0
   1f826:	db07      	blt.n	1f838 <clk_init+0x4c>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f828:	2301      	movs	r3, #1
   1f82a:	fb07 5504 	mla	r5, r7, r4, r5
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
   1f82e:	441c      	add	r4, r3
   1f830:	2c04      	cmp	r4, #4
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f832:	67ab      	str	r3, [r5, #120]	; 0x78
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
   1f834:	d1f0      	bne.n	1f818 <clk_init+0x2c>
	}

	return 0;
   1f836:	2000      	movs	r0, #0
}
   1f838:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EIO;
   1f83c:	f06f 0004 	mvn.w	r0, #4
   1f840:	e7fa      	b.n	1f838 <clk_init+0x4c>
   1f842:	bf00      	nop
   1f844:	0001f885 	.word	0x0001f885
   1f848:	0bad0000 	.word	0x0bad0000
   1f84c:	000266f8 	.word	0x000266f8

0001f850 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   1f850:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   1f852:	230c      	movs	r3, #12
	sub_data->cb = NULL;
   1f854:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
   1f856:	434b      	muls	r3, r1
static void clkstarted_handle(const struct device *dev,
   1f858:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   1f85a:	4808      	ldr	r0, [pc, #32]	; (1f87c <clkstarted_handle.constprop.0+0x2c>)
   1f85c:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
   1f85e:	3378      	adds	r3, #120	; 0x78
   1f860:	4418      	add	r0, r3
	void *user_data = sub_data->user_data;
   1f862:	e9d4 561c 	ldrd	r5, r6, [r4, #112]	; 0x70
	sub_data->cb = NULL;
   1f866:	6722      	str	r2, [r4, #112]	; 0x70
	set_on_state(&sub_data->flags);
   1f868:	f005 fc41 	bl	250ee <set_on_state>
	if (callback) {
   1f86c:	b12d      	cbz	r5, 1f87a <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   1f86e:	4632      	mov	r2, r6
   1f870:	462b      	mov	r3, r5
}
   1f872:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   1f876:	4802      	ldr	r0, [pc, #8]	; (1f880 <clkstarted_handle.constprop.0+0x30>)
   1f878:	4718      	bx	r3
}
   1f87a:	bd70      	pop	{r4, r5, r6, pc}
   1f87c:	2000b1f0 	.word	0x2000b1f0
   1f880:	00026228 	.word	0x00026228

0001f884 <clock_event_handler>:
	switch (event) {
   1f884:	2805      	cmp	r0, #5
   1f886:	d811      	bhi.n	1f8ac <clock_event_handler+0x28>
   1f888:	e8df f000 	tbb	[pc, r0]
   1f88c:	10100e03 	.word	0x10100e03
   1f890:	0a0c      	.short	0x0a0c
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   1f892:	4b07      	ldr	r3, [pc, #28]	; (1f8b0 <clock_event_handler+0x2c>)
   1f894:	6f98      	ldr	r0, [r3, #120]	; 0x78
   1f896:	f010 0007 	ands.w	r0, r0, #7
   1f89a:	d107      	bne.n	1f8ac <clock_event_handler+0x28>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1f89c:	f7ff bfd8 	b.w	1f850 <clkstarted_handle.constprop.0>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK192M);
   1f8a0:	2002      	movs	r0, #2
   1f8a2:	e7fb      	b.n	1f89c <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLKAUDIO);
   1f8a4:	2003      	movs	r0, #3
   1f8a6:	e7f9      	b.n	1f89c <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1f8a8:	2001      	movs	r0, #1
   1f8aa:	e7f7      	b.n	1f89c <clock_event_handler+0x18>
}
   1f8ac:	4770      	bx	lr
   1f8ae:	bf00      	nop
   1f8b0:	2000b1f0 	.word	0x2000b1f0

0001f8b4 <generic_hfclk_start>:
{
   1f8b4:	b508      	push	{r3, lr}
	__asm__ volatile(
   1f8b6:	f04f 0320 	mov.w	r3, #32
   1f8ba:	f3ef 8111 	mrs	r1, BASEPRI
   1f8be:	f383 8812 	msr	BASEPRI_MAX, r3
   1f8c2:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   1f8c6:	4a11      	ldr	r2, [pc, #68]	; (1f90c <generic_hfclk_start+0x58>)
   1f8c8:	6813      	ldr	r3, [r2, #0]
   1f8ca:	f043 0002 	orr.w	r0, r3, #2
   1f8ce:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   1f8d0:	07da      	lsls	r2, r3, #31
   1f8d2:	d408      	bmi.n	1f8e6 <generic_hfclk_start+0x32>
	__asm__ volatile(
   1f8d4:	f381 8811 	msr	BASEPRI, r1
   1f8d8:	f3bf 8f6f 	isb	sy
}
   1f8dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   1f8e0:	2001      	movs	r0, #1
   1f8e2:	f001 b9cd 	b.w	20c80 <nrfx_clock_start>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   1f8e6:	4b0a      	ldr	r3, [pc, #40]	; (1f910 <generic_hfclk_start+0x5c>)
   1f8e8:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   1f8ec:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   1f8f0:	07d3      	lsls	r3, r2, #31
   1f8f2:	d5ef      	bpl.n	1f8d4 <generic_hfclk_start+0x20>
			set_on_state(get_hf_flags());
   1f8f4:	4807      	ldr	r0, [pc, #28]	; (1f914 <generic_hfclk_start+0x60>)
   1f8f6:	f005 fbfa 	bl	250ee <set_on_state>
   1f8fa:	f381 8811 	msr	BASEPRI, r1
   1f8fe:	f3bf 8f6f 	isb	sy
}
   1f902:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   1f906:	2000      	movs	r0, #0
   1f908:	f7ff bfa2 	b.w	1f850 <clkstarted_handle.constprop.0>
   1f90c:	2000b290 	.word	0x2000b290
   1f910:	40005000 	.word	0x40005000
   1f914:	2000b268 	.word	0x2000b268

0001f918 <api_blocking_start>:
{
   1f918:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   1f91a:	2200      	movs	r2, #0
   1f91c:	2301      	movs	r3, #1
   1f91e:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   1f922:	466b      	mov	r3, sp
   1f924:	4a08      	ldr	r2, [pc, #32]	; (1f948 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   1f926:	f8cd d000 	str.w	sp, [sp]
   1f92a:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   1f92e:	f005 fc4d 	bl	251cc <api_start>
	if (err < 0) {
   1f932:	2800      	cmp	r0, #0
   1f934:	db05      	blt.n	1f942 <api_blocking_start+0x2a>
	return z_impl_k_sem_take(sem, timeout);
   1f936:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1f93a:	2300      	movs	r3, #0
   1f93c:	4668      	mov	r0, sp
   1f93e:	f003 fe2b 	bl	23598 <z_impl_k_sem_take>
}
   1f942:	b005      	add	sp, #20
   1f944:	f85d fb04 	ldr.w	pc, [sp], #4
   1f948:	00025211 	.word	0x00025211

0001f94c <generic_hfclk_stop>:
{
   1f94c:	b510      	push	{r4, lr}
	__asm__ volatile(
   1f94e:	f04f 0320 	mov.w	r3, #32
   1f952:	f3ef 8411 	mrs	r4, BASEPRI
   1f956:	f383 8812 	msr	BASEPRI_MAX, r3
   1f95a:	f3bf 8f6f 	isb	sy
	hfclk_users &= ~HF_USER_GENERIC;
   1f95e:	4a07      	ldr	r2, [pc, #28]	; (1f97c <generic_hfclk_stop+0x30>)
   1f960:	6813      	ldr	r3, [r2, #0]
   1f962:	f023 0102 	bic.w	r1, r3, #2
	if (!(hfclk_users & HF_USER_BT)) {
   1f966:	07db      	lsls	r3, r3, #31
	hfclk_users &= ~HF_USER_GENERIC;
   1f968:	6011      	str	r1, [r2, #0]
	if (!(hfclk_users & HF_USER_BT)) {
   1f96a:	d402      	bmi.n	1f972 <generic_hfclk_stop+0x26>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   1f96c:	2001      	movs	r0, #1
   1f96e:	f005 ff62 	bl	25836 <nrfx_clock_stop>
	__asm__ volatile(
   1f972:	f384 8811 	msr	BASEPRI, r4
   1f976:	f3bf 8f6f 	isb	sy
}
   1f97a:	bd10      	pop	{r4, pc}
   1f97c:	2000b290 	.word	0x2000b290

0001f980 <z_nrf_clock_control_get_onoff>:
	return &data->mgr[type];
   1f980:	b2c3      	uxtb	r3, r0
}
   1f982:	201c      	movs	r0, #28
   1f984:	4a01      	ldr	r2, [pc, #4]	; (1f98c <z_nrf_clock_control_get_onoff+0xc>)
   1f986:	fb03 2000 	mla	r0, r3, r0, r2
   1f98a:	4770      	bx	lr
   1f98c:	2000b1f0 	.word	0x2000b1f0

0001f990 <z_nrf_clock_control_lf_on>:
{
   1f990:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1f994:	2201      	movs	r2, #1
   1f996:	4607      	mov	r7, r0
   1f998:	4935      	ldr	r1, [pc, #212]	; (1fa70 <z_nrf_clock_control_lf_on+0xe0>)
   1f99a:	e8d1 3fef 	ldaex	r3, [r1]
   1f99e:	e8c1 2fe0 	stlex	r0, r2, [r1]
   1f9a2:	2800      	cmp	r0, #0
   1f9a4:	d1f9      	bne.n	1f99a <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
   1f9a6:	b933      	cbnz	r3, 1f9b6 <z_nrf_clock_control_lf_on+0x26>
   1f9a8:	4932      	ldr	r1, [pc, #200]	; (1fa74 <z_nrf_clock_control_lf_on+0xe4>)
		err = onoff_request(mgr, &cli);
   1f9aa:	4833      	ldr	r0, [pc, #204]	; (1fa78 <z_nrf_clock_control_lf_on+0xe8>)
   1f9ac:	604b      	str	r3, [r1, #4]
   1f9ae:	60cb      	str	r3, [r1, #12]
   1f9b0:	608a      	str	r2, [r1, #8]
   1f9b2:	f004 ffc6 	bl	24942 <onoff_request>
	switch (start_mode) {
   1f9b6:	1e7b      	subs	r3, r7, #1
   1f9b8:	2b01      	cmp	r3, #1
   1f9ba:	d828      	bhi.n	1fa0e <z_nrf_clock_control_lf_on+0x7e>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   1f9bc:	2f01      	cmp	r7, #1
   1f9be:	d106      	bne.n	1f9ce <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   1f9c0:	4b2e      	ldr	r3, [pc, #184]	; (1fa7c <z_nrf_clock_control_lf_on+0xec>)
   1f9c2:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   1f9c6:	f003 0303 	and.w	r3, r3, #3
   1f9ca:	2b02      	cmp	r3, #2
   1f9cc:	d01f      	beq.n	1fa0e <z_nrf_clock_control_lf_on+0x7e>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   1f9ce:	f006 f8f6 	bl	25bbe <k_is_in_isr>
   1f9d2:	4605      	mov	r5, r0
   1f9d4:	b9e8      	cbnz	r0, 1fa12 <z_nrf_clock_control_lf_on+0x82>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   1f9d6:	4b2a      	ldr	r3, [pc, #168]	; (1fa80 <z_nrf_clock_control_lf_on+0xf0>)
   1f9d8:	781b      	ldrb	r3, [r3, #0]
   1f9da:	b1d3      	cbz	r3, 1fa12 <z_nrf_clock_control_lf_on+0x82>
    p_reg->INTENCLR = mask;
   1f9dc:	2202      	movs	r2, #2
	int key = isr_mode ? irq_lock() : 0;
   1f9de:	4606      	mov	r6, r0
   1f9e0:	4b26      	ldr	r3, [pc, #152]	; (1fa7c <z_nrf_clock_control_lf_on+0xec>)
   1f9e2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   1f9e6:	4c25      	ldr	r4, [pc, #148]	; (1fa7c <z_nrf_clock_control_lf_on+0xec>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1f9e8:	f8df 8098 	ldr.w	r8, [pc, #152]	; 1fa84 <z_nrf_clock_control_lf_on+0xf4>
   1f9ec:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   1f9f0:	f8d4 2418 	ldr.w	r2, [r4, #1048]	; 0x418
   1f9f4:	03d2      	lsls	r2, r2, #15
   1f9f6:	d516      	bpl.n	1fa26 <z_nrf_clock_control_lf_on+0x96>
	while (!(nrfx_clock_is_running(d, (void *)&type)
   1f9f8:	f003 0303 	and.w	r3, r3, #3
   1f9fc:	2b02      	cmp	r3, #2
   1f9fe:	d001      	beq.n	1fa04 <z_nrf_clock_control_lf_on+0x74>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   1fa00:	2f01      	cmp	r7, #1
   1fa02:	d110      	bne.n	1fa26 <z_nrf_clock_control_lf_on+0x96>
	if (isr_mode) {
   1fa04:	b375      	cbz	r5, 1fa64 <z_nrf_clock_control_lf_on+0xd4>
   1fa06:	f386 8811 	msr	BASEPRI, r6
   1fa0a:	f3bf 8f6f 	isb	sy
}
   1fa0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm__ volatile(
   1fa12:	f04f 0320 	mov.w	r3, #32
   1fa16:	f3ef 8611 	mrs	r6, BASEPRI
   1fa1a:	f383 8812 	msr	BASEPRI_MAX, r3
   1fa1e:	f3bf 8f6f 	isb	sy
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   1fa22:	2501      	movs	r5, #1
   1fa24:	e7df      	b.n	1f9e6 <z_nrf_clock_control_lf_on+0x56>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   1fa26:	b1c5      	cbz	r5, 1fa5a <z_nrf_clock_control_lf_on+0xca>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   1fa28:	4630      	mov	r0, r6
   1fa2a:	f7fe fc53 	bl	1e2d4 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   1fa2e:	f8d4 3518 	ldr.w	r3, [r4, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   1fa32:	b2db      	uxtb	r3, r3
   1fa34:	2b01      	cmp	r3, #1
   1fa36:	d1d9      	bne.n	1f9ec <z_nrf_clock_control_lf_on+0x5c>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1fa38:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
   1fa3c:	2a00      	cmp	r2, #0
   1fa3e:	d0d5      	beq.n	1f9ec <z_nrf_clock_control_lf_on+0x5c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1fa40:	2200      	movs	r2, #0
   1fa42:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
   1fa46:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
   1fa4a:	2202      	movs	r2, #2
   1fa4c:	f8c4 2518 	str.w	r2, [r4, #1304]	; 0x518
   1fa50:	2220      	movs	r2, #32
   1fa52:	f8c8 2180 	str.w	r2, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fa56:	60a3      	str	r3, [r4, #8]
}
   1fa58:	e7c8      	b.n	1f9ec <z_nrf_clock_control_lf_on+0x5c>
	return z_impl_k_sleep(timeout);
   1fa5a:	2100      	movs	r1, #0
   1fa5c:	2021      	movs	r0, #33	; 0x21
   1fa5e:	f004 f9fb 	bl	23e58 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   1fa62:	e7e4      	b.n	1fa2e <z_nrf_clock_control_lf_on+0x9e>
    p_reg->INTENSET = mask;
   1fa64:	2202      	movs	r2, #2
   1fa66:	4b05      	ldr	r3, [pc, #20]	; (1fa7c <z_nrf_clock_control_lf_on+0xec>)
   1fa68:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   1fa6c:	e7cf      	b.n	1fa0e <z_nrf_clock_control_lf_on+0x7e>
   1fa6e:	bf00      	nop
   1fa70:	2000b1ec 	.word	0x2000b1ec
   1fa74:	2000b1dc 	.word	0x2000b1dc
   1fa78:	2000b20c 	.word	0x2000b20c
   1fa7c:	40005000 	.word	0x40005000
   1fa80:	2000b62b 	.word	0x2000b62b
   1fa84:	e000e100 	.word	0xe000e100

0001fa88 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(void)
{
   1fa88:	b508      	push	{r3, lr}
   1fa8a:	4807      	ldr	r0, [pc, #28]	; (1faa8 <uart_console_init+0x20>)
   1fa8c:	f006 f82e 	bl	25aec <z_device_is_ready>
	if (!device_is_ready(uart_console_dev)) {
   1fa90:	b138      	cbz	r0, 1faa2 <uart_console_init+0x1a>
	__stdout_hook_install(console_out);
   1fa92:	4806      	ldr	r0, [pc, #24]	; (1faac <uart_console_init+0x24>)
   1fa94:	f7ff f8b2 	bl	1ebfc <__stdout_hook_install>
	__printk_hook_install(console_out);
   1fa98:	4804      	ldr	r0, [pc, #16]	; (1faac <uart_console_init+0x24>)
   1fa9a:	f7fc fd25 	bl	1c4e8 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   1fa9e:	2000      	movs	r0, #0
}
   1faa0:	bd08      	pop	{r3, pc}
		return -ENODEV;
   1faa2:	f06f 0012 	mvn.w	r0, #18
   1faa6:	e7fb      	b.n	1faa0 <uart_console_init+0x18>
   1faa8:	00026288 	.word	0x00026288
   1faac:	0001fab1 	.word	0x0001fab1

0001fab0 <console_out>:
	if ('\n' == c) {
   1fab0:	280a      	cmp	r0, #10
{
   1fab2:	b538      	push	{r3, r4, r5, lr}
   1fab4:	4604      	mov	r4, r0
   1fab6:	4d07      	ldr	r5, [pc, #28]	; (1fad4 <console_out+0x24>)
	if ('\n' == c) {
   1fab8:	d104      	bne.n	1fac4 <console_out+0x14>
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   1faba:	68ab      	ldr	r3, [r5, #8]
   1fabc:	210d      	movs	r1, #13
   1fabe:	4628      	mov	r0, r5
   1fac0:	685b      	ldr	r3, [r3, #4]
   1fac2:	4798      	blx	r3
   1fac4:	68ab      	ldr	r3, [r5, #8]
   1fac6:	4803      	ldr	r0, [pc, #12]	; (1fad4 <console_out+0x24>)
   1fac8:	685b      	ldr	r3, [r3, #4]
   1faca:	b2e1      	uxtb	r1, r4
   1facc:	4798      	blx	r3
}
   1face:	4620      	mov	r0, r4
   1fad0:	bd38      	pop	{r3, r4, r5, pc}
   1fad2:	bf00      	nop
   1fad4:	00026288 	.word	0x00026288

0001fad8 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   1fad8:	b530      	push	{r4, r5, lr}
	return port->config;
   1fada:	6840      	ldr	r0, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   1fadc:	f001 041f 	and.w	r4, r1, #31
   1fae0:	7b05      	ldrb	r5, [r0, #12]
	nrfx_err_t err;
	uint8_t ch;

	if (mode == GPIO_INT_MODE_DISABLED) {
   1fae2:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
{
   1fae6:	b085      	sub	sp, #20
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   1fae8:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
   1faec:	d105      	bne.n	1fafa <gpio_nrfx_pin_interrupt_configure+0x22>
		nrfx_gpiote_trigger_disable(abs_pin);
   1faee:	4620      	mov	r0, r4
   1faf0:	f001 fbba 	bl	21268 <nrfx_gpiote_trigger_disable>

		return 0;
   1faf4:	2000      	movs	r0, #0
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
}
   1faf6:	b005      	add	sp, #20
   1faf8:	bd30      	pop	{r4, r5, pc}
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fafa:	2500      	movs	r5, #0
	if (mode == GPIO_INT_MODE_LEVEL) {
   1fafc:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fb00:	e9cd 5502 	strd	r5, r5, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   1fb04:	d114      	bne.n	1fb30 <gpio_nrfx_pin_interrupt_configure+0x58>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   1fb06:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fb0a:	bf0c      	ite	eq
   1fb0c:	2304      	moveq	r3, #4
   1fb0e:	2305      	movne	r3, #5
   1fb10:	f88d 3008 	strb.w	r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fb14:	2300      	movs	r3, #0
   1fb16:	4620      	mov	r0, r4
   1fb18:	4619      	mov	r1, r3
   1fb1a:	aa02      	add	r2, sp, #8
   1fb1c:	f001 f9e2 	bl	20ee4 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   1fb20:	4b1f      	ldr	r3, [pc, #124]	; (1fba0 <gpio_nrfx_pin_interrupt_configure+0xc8>)
   1fb22:	4298      	cmp	r0, r3
   1fb24:	d138      	bne.n	1fb98 <gpio_nrfx_pin_interrupt_configure+0xc0>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   1fb26:	2101      	movs	r1, #1
   1fb28:	4620      	mov	r0, r4
   1fb2a:	f001 fb57 	bl	211dc <nrfx_gpiote_trigger_enable>
	return 0;
   1fb2e:	e7e1      	b.n	1faf4 <gpio_nrfx_pin_interrupt_configure+0x1c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   1fb30:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
   1fb34:	d025      	beq.n	1fb82 <gpio_nrfx_pin_interrupt_configure+0xaa>
   1fb36:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   1fb3a:	bf14      	ite	ne
   1fb3c:	2301      	movne	r3, #1
   1fb3e:	2302      	moveq	r3, #2
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fb40:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   1fb44:	6883      	ldr	r3, [r0, #8]
   1fb46:	40cb      	lsrs	r3, r1
   1fb48:	07d9      	lsls	r1, r3, #31
   1fb4a:	d4e3      	bmi.n	1fb14 <gpio_nrfx_pin_interrupt_configure+0x3c>
   1fb4c:	f1b2 7fa0 	cmp.w	r2, #20971520	; 0x1400000
   1fb50:	d1e0      	bne.n	1fb14 <gpio_nrfx_pin_interrupt_configure+0x3c>
        /* FALLTHROUGH */
        case 0: return NRF_P0;
#endif
#if defined(P1_FEATURE_PINS_PRESENT)
        /* FALLTHROUGH */
        case 1: return NRF_P1;
   1fb52:	4a14      	ldr	r2, [pc, #80]	; (1fba4 <gpio_nrfx_pin_interrupt_configure+0xcc>)
   1fb54:	4814      	ldr	r0, [pc, #80]	; (1fba8 <gpio_nrfx_pin_interrupt_configure+0xd0>)
NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;

    return pin_number >> 5;
   1fb56:	0961      	lsrs	r1, r4, #5
        case 1: return NRF_P1;
   1fb58:	2901      	cmp	r1, #1
   1fb5a:	bf08      	it	eq
   1fb5c:	4602      	moveq	r2, r0
    *p_pin = pin_number & 0x1F;
   1fb5e:	f004 031f 	and.w	r3, r4, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   1fb62:	3380      	adds	r3, #128	; 0x80
   1fb64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   1fb68:	07db      	lsls	r3, r3, #31
   1fb6a:	d4d3      	bmi.n	1fb14 <gpio_nrfx_pin_interrupt_configure+0x3c>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fb6c:	f10d 0507 	add.w	r5, sp, #7
   1fb70:	4629      	mov	r1, r5
   1fb72:	4620      	mov	r0, r4
   1fb74:	f001 fade 	bl	21134 <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   1fb78:	4b0c      	ldr	r3, [pc, #48]	; (1fbac <gpio_nrfx_pin_interrupt_configure+0xd4>)
   1fb7a:	4298      	cmp	r0, r3
   1fb7c:	d003      	beq.n	1fb86 <gpio_nrfx_pin_interrupt_configure+0xae>
		trigger_config.p_in_channel = &ch;
   1fb7e:	9503      	str	r5, [sp, #12]
   1fb80:	e7c8      	b.n	1fb14 <gpio_nrfx_pin_interrupt_configure+0x3c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   1fb82:	2303      	movs	r3, #3
   1fb84:	e7dc      	b.n	1fb40 <gpio_nrfx_pin_interrupt_configure+0x68>
			err = nrfx_gpiote_channel_alloc(&ch);
   1fb86:	4628      	mov	r0, r5
   1fb88:	f001 fb22 	bl	211d0 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   1fb8c:	4b04      	ldr	r3, [pc, #16]	; (1fba0 <gpio_nrfx_pin_interrupt_configure+0xc8>)
   1fb8e:	4298      	cmp	r0, r3
   1fb90:	d0f5      	beq.n	1fb7e <gpio_nrfx_pin_interrupt_configure+0xa6>
				return -ENOMEM;
   1fb92:	f06f 000b 	mvn.w	r0, #11
   1fb96:	e7ae      	b.n	1faf6 <gpio_nrfx_pin_interrupt_configure+0x1e>
		return -EINVAL;
   1fb98:	f06f 0015 	mvn.w	r0, #21
   1fb9c:	e7ab      	b.n	1faf6 <gpio_nrfx_pin_interrupt_configure+0x1e>
   1fb9e:	bf00      	nop
   1fba0:	0bad0000 	.word	0x0bad0000
   1fba4:	40842500 	.word	0x40842500
   1fba8:	40842800 	.word	0x40842800
   1fbac:	0bad0004 	.word	0x0bad0004

0001fbb0 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   1fbb0:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   1fbb2:	f001 fafd 	bl	211b0 <nrfx_gpiote_is_init>
   1fbb6:	4604      	mov	r4, r0
   1fbb8:	b968      	cbnz	r0, 1fbd6 <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   1fbba:	f001 fad1 	bl	21160 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   1fbbe:	4b08      	ldr	r3, [pc, #32]	; (1fbe0 <gpio_nrfx_init+0x30>)
   1fbc0:	4298      	cmp	r0, r3
   1fbc2:	d10a      	bne.n	1fbda <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   1fbc4:	4621      	mov	r1, r4
   1fbc6:	4807      	ldr	r0, [pc, #28]	; (1fbe4 <gpio_nrfx_init+0x34>)
   1fbc8:	f001 faae 	bl	21128 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   1fbcc:	4622      	mov	r2, r4
   1fbce:	2105      	movs	r1, #5
   1fbd0:	202f      	movs	r0, #47	; 0x2f
   1fbd2:	f7fe fbc1 	bl	1e358 <z_arm_irq_priority_set>
		return 0;
   1fbd6:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   1fbd8:	bd10      	pop	{r4, pc}
		return -EIO;
   1fbda:	f06f 0004 	mvn.w	r0, #4
   1fbde:	e7fb      	b.n	1fbd8 <gpio_nrfx_init+0x28>
   1fbe0:	0bad0000 	.word	0x0bad0000
   1fbe4:	0001fbe9 	.word	0x0001fbe9

0001fbe8 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbe8:	0942      	lsrs	r2, r0, #5
{
   1fbea:	4603      	mov	r3, r0
   1fbec:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbee:	d002      	beq.n	1fbf6 <nrfx_gpio_handler+0xe>
   1fbf0:	2a01      	cmp	r2, #1
   1fbf2:	d017      	beq.n	1fc24 <nrfx_gpio_handler+0x3c>
}
   1fbf4:	bd70      	pop	{r4, r5, r6, pc}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbf6:	4e0d      	ldr	r6, [pc, #52]	; (1fc2c <nrfx_gpio_handler+0x44>)
	gpio_fire_callbacks(list, port, BIT(pin));
   1fbf8:	6932      	ldr	r2, [r6, #16]
   1fbfa:	6851      	ldr	r1, [r2, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1fbfc:	2900      	cmp	r1, #0
   1fbfe:	d0f9      	beq.n	1fbf4 <nrfx_gpio_handler+0xc>
   1fc00:	2501      	movs	r5, #1
    *p_pin = pin_number & 0x1F;
   1fc02:	f003 031f 	and.w	r3, r3, #31
	return node->next;
   1fc06:	680c      	ldr	r4, [r1, #0]
   1fc08:	409d      	lsls	r5, r3
   1fc0a:	2900      	cmp	r1, #0
   1fc0c:	d0f2      	beq.n	1fbf4 <nrfx_gpio_handler+0xc>
		if (cb->pin_mask & pins) {
   1fc0e:	688a      	ldr	r2, [r1, #8]
   1fc10:	402a      	ands	r2, r5
   1fc12:	d002      	beq.n	1fc1a <nrfx_gpio_handler+0x32>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   1fc14:	4630      	mov	r0, r6
   1fc16:	684b      	ldr	r3, [r1, #4]
   1fc18:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1fc1a:	b12c      	cbz	r4, 1fc28 <nrfx_gpio_handler+0x40>
   1fc1c:	6823      	ldr	r3, [r4, #0]
   1fc1e:	4621      	mov	r1, r4
   1fc20:	461c      	mov	r4, r3
   1fc22:	e7f2      	b.n	1fc0a <nrfx_gpio_handler+0x22>
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fc24:	4e02      	ldr	r6, [pc, #8]	; (1fc30 <nrfx_gpio_handler+0x48>)
   1fc26:	e7e7      	b.n	1fbf8 <nrfx_gpio_handler+0x10>
   1fc28:	4623      	mov	r3, r4
   1fc2a:	e7f8      	b.n	1fc1e <nrfx_gpio_handler+0x36>
   1fc2c:	00026258 	.word	0x00026258
   1fc30:	00026240 	.word	0x00026240

0001fc34 <gpio_nrfx_pin_configure>:
{
   1fc34:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return port->config;
   1fc38:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1fc3a:	f001 051f 	and.w	r5, r1, #31
   1fc3e:	7b3b      	ldrb	r3, [r7, #12]
{
   1fc40:	4614      	mov	r4, r2
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1fc42:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
{
   1fc46:	460e      	mov	r6, r1
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fc48:	4628      	mov	r0, r5
   1fc4a:	f10d 0103 	add.w	r1, sp, #3
   1fc4e:	f001 fa71 	bl	21134 <nrfx_gpiote_channel_get>
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
   1fc52:	f414 3f40 	tst.w	r4, #196608	; 0x30000
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fc56:	4680      	mov	r8, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
   1fc58:	d10b      	bne.n	1fc72 <gpio_nrfx_pin_configure+0x3e>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
   1fc5a:	4628      	mov	r0, r5
   1fc5c:	f001 fb2c 	bl	212b8 <nrfx_gpiote_pin_uninit>
		if (free_ch) {
   1fc60:	4b3c      	ldr	r3, [pc, #240]	; (1fd54 <gpio_nrfx_pin_configure+0x120>)
   1fc62:	4598      	cmp	r8, r3
   1fc64:	d103      	bne.n	1fc6e <gpio_nrfx_pin_configure+0x3a>
			err = nrfx_gpiote_channel_free(ch);
   1fc66:	f89d 0003 	ldrb.w	r0, [sp, #3]
   1fc6a:	f001 faab 	bl	211c4 <nrfx_gpiote_channel_free>
		return 0;
   1fc6e:	2000      	movs	r0, #0
   1fc70:	e00c      	b.n	1fc8c <gpio_nrfx_pin_configure+0x58>
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fc72:	2300      	movs	r3, #0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fc74:	4628      	mov	r0, r5
   1fc76:	4619      	mov	r1, r3
   1fc78:	aa02      	add	r2, sp, #8
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fc7a:	e9cd 3302 	strd	r3, r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fc7e:	f001 f931 	bl	20ee4 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   1fc82:	4b34      	ldr	r3, [pc, #208]	; (1fd54 <gpio_nrfx_pin_configure+0x120>)
   1fc84:	4298      	cmp	r0, r3
   1fc86:	d004      	beq.n	1fc92 <gpio_nrfx_pin_configure+0x5e>
		return NRF_GPIO_PIN_PULLUP;
   1fc88:	f06f 0015 	mvn.w	r0, #21
}
   1fc8c:	b004      	add	sp, #16
   1fc8e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (free_ch) {
   1fc92:	4580      	cmp	r8, r0
   1fc94:	d103      	bne.n	1fc9e <gpio_nrfx_pin_configure+0x6a>
		err = nrfx_gpiote_channel_free(ch);
   1fc96:	f89d 0003 	ldrb.w	r0, [sp, #3]
   1fc9a:	f001 fa93 	bl	211c4 <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   1fc9e:	03a3      	lsls	r3, r4, #14
   1fca0:	d549      	bpl.n	1fd36 <gpio_nrfx_pin_configure+0x102>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fca2:	f240 3306 	movw	r3, #774	; 0x306
   1fca6:	4023      	ands	r3, r4
   1fca8:	f5b3 7f83 	cmp.w	r3, #262	; 0x106
   1fcac:	d019      	beq.n	1fce2 <gpio_nrfx_pin_configure+0xae>
   1fcae:	d80c      	bhi.n	1fcca <gpio_nrfx_pin_configure+0x96>
   1fcb0:	2b06      	cmp	r3, #6
   1fcb2:	d017      	beq.n	1fce4 <gpio_nrfx_pin_configure+0xb0>
   1fcb4:	d804      	bhi.n	1fcc0 <gpio_nrfx_pin_configure+0x8c>
   1fcb6:	b1ab      	cbz	r3, 1fce4 <gpio_nrfx_pin_configure+0xb0>
   1fcb8:	2b02      	cmp	r3, #2
   1fcba:	d1e5      	bne.n	1fc88 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0S1;
   1fcbc:	2304      	movs	r3, #4
   1fcbe:	e011      	b.n	1fce4 <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fcc0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   1fcc4:	d1e0      	bne.n	1fc88 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_H0S1;
   1fcc6:	2301      	movs	r3, #1
   1fcc8:	e00c      	b.n	1fce4 <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fcca:	f240 2202 	movw	r2, #514	; 0x202
   1fcce:	4293      	cmp	r3, r2
   1fcd0:	d026      	beq.n	1fd20 <gpio_nrfx_pin_configure+0xec>
   1fcd2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
   1fcd6:	d025      	beq.n	1fd24 <gpio_nrfx_pin_configure+0xf0>
   1fcd8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1fcdc:	d1d4      	bne.n	1fc88 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_S0H1;
   1fcde:	2302      	movs	r3, #2
   1fce0:	e000      	b.n	1fce4 <gpio_nrfx_pin_configure+0xb0>
		*drive = NRF_GPIO_PIN_H0D1;
   1fce2:	2307      	movs	r3, #7
		nrfx_gpiote_output_config_t output_config = {
   1fce4:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   1fce8:	f484 3380 	eor.w	r3, r4, #65536	; 0x10000
   1fcec:	f3c3 4300 	ubfx	r3, r3, #16, #1
	if (flags & GPIO_PULL_UP) {
   1fcf0:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   1fcf2:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
   1fcf6:	bf4c      	ite	mi
   1fcf8:	2303      	movmi	r3, #3
	} else if (flags & GPIO_PULL_DOWN) {
   1fcfa:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   1fcfe:	0321      	lsls	r1, r4, #12
		nrfx_gpiote_output_config_t output_config = {
   1fd00:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   1fd04:	d510      	bpl.n	1fd28 <gpio_nrfx_pin_configure+0xf4>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   1fd06:	2301      	movs	r3, #1
   1fd08:	687a      	ldr	r2, [r7, #4]
   1fd0a:	40b3      	lsls	r3, r6
    p_reg->OUTSET = set_mask;
   1fd0c:	6093      	str	r3, [r2, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   1fd0e:	2200      	movs	r2, #0
   1fd10:	4628      	mov	r0, r5
   1fd12:	a901      	add	r1, sp, #4
   1fd14:	f001 f994 	bl	21040 <nrfx_gpiote_output_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   1fd18:	4b0e      	ldr	r3, [pc, #56]	; (1fd54 <gpio_nrfx_pin_configure+0x120>)
   1fd1a:	4298      	cmp	r0, r3
   1fd1c:	d0a7      	beq.n	1fc6e <gpio_nrfx_pin_configure+0x3a>
   1fd1e:	e7b3      	b.n	1fc88 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0H1;
   1fd20:	2305      	movs	r3, #5
   1fd22:	e7df      	b.n	1fce4 <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fd24:	2303      	movs	r3, #3
   1fd26:	e7dd      	b.n	1fce4 <gpio_nrfx_pin_configure+0xb0>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   1fd28:	0362      	lsls	r2, r4, #13
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   1fd2a:	bf41      	itttt	mi
   1fd2c:	2301      	movmi	r3, #1
   1fd2e:	687a      	ldrmi	r2, [r7, #4]
   1fd30:	40b3      	lslmi	r3, r6
    p_reg->OUTCLR = clr_mask;
   1fd32:	60d3      	strmi	r3, [r2, #12]
}
   1fd34:	e7eb      	b.n	1fd0e <gpio_nrfx_pin_configure+0xda>
	if (flags & GPIO_PULL_UP) {
   1fd36:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1fd38:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   1fd3c:	bf4c      	ite	mi
   1fd3e:	2403      	movmi	r4, #3
	} else if (flags & GPIO_PULL_DOWN) {
   1fd40:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1fd44:	461a      	mov	r2, r3
   1fd46:	4628      	mov	r0, r5
   1fd48:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
   1fd4a:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1fd4e:	f001 f8c9 	bl	20ee4 <nrfx_gpiote_input_configure>
   1fd52:	e7e1      	b.n	1fd18 <gpio_nrfx_pin_configure+0xe4>
   1fd54:	0bad0000 	.word	0x0bad0000

0001fd58 <z_impl_hwinfo_get_device_id>:

static inline void soc_secure_read_deviceid(uint32_t deviceid[2])
{
	int err;

	err = soc_secure_mem_read(deviceid,
   1fd58:	2208      	movs	r2, #8
struct nrf_uid {
	uint32_t id[2];
};

ssize_t z_impl_hwinfo_get_device_id(uint8_t *buffer, size_t length)
{
   1fd5a:	b530      	push	{r4, r5, lr}
   1fd5c:	460c      	mov	r4, r1
   1fd5e:	b085      	sub	sp, #20
   1fd60:	4605      	mov	r5, r0
   1fd62:	490b      	ldr	r1, [pc, #44]	; (1fd90 <z_impl_hwinfo_get_device_id+0x38>)
   1fd64:	eb0d 0002 	add.w	r0, sp, r2
   1fd68:	f004 ffe6 	bl	24d38 <soc_secure_mem_read>
	soc_secure_read_deviceid(deviceid);

	dev_id.id[0] = sys_cpu_to_be32(deviceid[1]);
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);

	if (length > sizeof(dev_id.id)) {
   1fd6c:	2c08      	cmp	r4, #8
   1fd6e:	bf28      	it	cs
   1fd70:	2408      	movcs	r4, #8
   1fd72:	9b03      	ldr	r3, [sp, #12]
		length = sizeof(dev_id.id);
	}

	memcpy(buffer, dev_id.id, length);
   1fd74:	4622      	mov	r2, r4
   1fd76:	ba1b      	rev	r3, r3
	dev_id.id[0] = sys_cpu_to_be32(deviceid[1]);
   1fd78:	9300      	str	r3, [sp, #0]
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);
   1fd7a:	9b02      	ldr	r3, [sp, #8]
	memcpy(buffer, dev_id.id, length);
   1fd7c:	4669      	mov	r1, sp
   1fd7e:	ba1b      	rev	r3, r3
   1fd80:	4628      	mov	r0, r5
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);
   1fd82:	9301      	str	r3, [sp, #4]
	memcpy(buffer, dev_id.id, length);
   1fd84:	f005 f939 	bl	24ffa <memcpy>

	return length;
}
   1fd88:	4620      	mov	r0, r4
   1fd8a:	b005      	add	sp, #20
   1fd8c:	bd30      	pop	{r4, r5, pc}
   1fd8e:	bf00      	nop
   1fd90:	00ff0204 	.word	0x00ff0204

0001fd94 <i2c_nrfx_twim_init>:
	return ret;
}
#endif /* CONFIG_PM_DEVICE */

static int i2c_nrfx_twim_init(const struct device *dev)
{
   1fd94:	b538      	push	{r3, r4, r5, lr}
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   1fd96:	6844      	ldr	r4, [r0, #4]
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   1fd98:	6905      	ldr	r5, [r0, #16]

	dev_config->irq_connect();
   1fd9a:	69e3      	ldr	r3, [r4, #28]
   1fd9c:	4798      	blx	r3

	int err = pinctrl_apply_state(dev_config->pcfg,
   1fd9e:	6a20      	ldr	r0, [r4, #32]
   1fda0:	f005 faba 	bl	25318 <pinctrl_apply_state.constprop.0>
				      COND_CODE_1(CONFIG_PM_DEVICE_RUNTIME,
						  (PINCTRL_STATE_SLEEP),
						  (PINCTRL_STATE_DEFAULT)));
	if (err < 0) {
   1fda4:	2800      	cmp	r0, #0
   1fda6:	db0d      	blt.n	1fdc4 <i2c_nrfx_twim_init+0x30>
		return err;
	}

	if (nrfx_twim_init(&dev_config->twim, &dev_config->twim_config,
   1fda8:	462b      	mov	r3, r5
   1fdaa:	4620      	mov	r0, r4
   1fdac:	4a07      	ldr	r2, [pc, #28]	; (1fdcc <i2c_nrfx_twim_init+0x38>)
   1fdae:	f104 0108 	add.w	r1, r4, #8
   1fdb2:	f001 fe49 	bl	21a48 <nrfx_twim_init>
   1fdb6:	4b06      	ldr	r3, [pc, #24]	; (1fdd0 <i2c_nrfx_twim_init+0x3c>)
   1fdb8:	4298      	cmp	r0, r3
   1fdba:	d104      	bne.n	1fdc6 <i2c_nrfx_twim_init+0x32>

#ifdef CONFIG_PM_DEVICE_RUNTIME
	pm_device_init_suspended(dev);
	pm_device_runtime_enable(dev);
#else
	nrfx_twim_enable(&dev_config->twim);
   1fdbc:	4620      	mov	r0, r4
   1fdbe:	f001 fee1 	bl	21b84 <nrfx_twim_enable>
#endif

	return 0;
   1fdc2:	2000      	movs	r0, #0
}
   1fdc4:	bd38      	pop	{r3, r4, r5, pc}
		return -EIO;
   1fdc6:	f06f 0004 	mvn.w	r0, #4
   1fdca:	e7fb      	b.n	1fdc4 <i2c_nrfx_twim_init+0x30>
   1fdcc:	0001fe11 	.word	0x0001fe11
   1fdd0:	0bad0000 	.word	0x0bad0000

0001fdd4 <i2c_nrfx_twim_recover_bus>:
{
   1fdd4:	b570      	push	{r4, r5, r6, lr}
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   1fdd6:	6844      	ldr	r4, [r0, #4]
	scl_pin = nrf_twim_scl_pin_get(dev_config->twim.p_twim);
   1fdd8:	6823      	ldr	r3, [r4, #0]
		nrfx_twim_disable(&dev_config->twim);
   1fdda:	4620      	mov	r0, r4
    p_reg->PSEL.SDA = sda_pin;
}

NRF_STATIC_INLINE uint32_t nrf_twim_scl_pin_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->PSEL.SCL;
   1fddc:	f8d3 5508 	ldr.w	r5, [r3, #1288]	; 0x508
}

NRF_STATIC_INLINE uint32_t nrf_twim_sda_pin_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->PSEL.SDA;
   1fde0:	f8d3 650c 	ldr.w	r6, [r3, #1292]	; 0x50c
   1fde4:	f001 fede 	bl	21ba4 <nrfx_twim_disable>
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin);

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
    return nrfx_twi_twim_bus_recover(scl_pin, sda_pin);
   1fde8:	4631      	mov	r1, r6
   1fdea:	4628      	mov	r0, r5
   1fdec:	f003 f860 	bl	22eb0 <nrfx_twi_twim_bus_recover>
   1fdf0:	4605      	mov	r5, r0
		(void)pinctrl_apply_state(dev_config->pcfg,
   1fdf2:	6a20      	ldr	r0, [r4, #32]
   1fdf4:	f005 fa90 	bl	25318 <pinctrl_apply_state.constprop.0>
		nrfx_twim_enable(&dev_config->twim);
   1fdf8:	4620      	mov	r0, r4
   1fdfa:	f001 fec3 	bl	21b84 <nrfx_twim_enable>
	return (err == NRFX_SUCCESS ? 0 : -EBUSY);
   1fdfe:	4b03      	ldr	r3, [pc, #12]	; (1fe0c <i2c_nrfx_twim_recover_bus+0x38>)
   1fe00:	429d      	cmp	r5, r3
}
   1fe02:	bf14      	ite	ne
   1fe04:	f06f 000f 	mvnne.w	r0, #15
   1fe08:	2000      	moveq	r0, #0
   1fe0a:	bd70      	pop	{r4, r5, r6, pc}
   1fe0c:	0bad0000 	.word	0x0bad0000

0001fe10 <event_handler>:
	switch (p_event->type) {
   1fe10:	7803      	ldrb	r3, [r0, #0]
   1fe12:	2b01      	cmp	r3, #1
   1fe14:	d008      	beq.n	1fe28 <event_handler+0x18>
   1fe16:	2b02      	cmp	r3, #2
   1fe18:	d008      	beq.n	1fe2c <event_handler+0x1c>
   1fe1a:	b94b      	cbnz	r3, 1fe30 <event_handler+0x20>
		dev_data->res = NRFX_SUCCESS;
   1fe1c:	4b05      	ldr	r3, [pc, #20]	; (1fe34 <event_handler+0x24>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   1fe1e:	620b      	str	r3, [r1, #32]
	z_impl_k_sem_give(sem);
   1fe20:	f101 0010 	add.w	r0, r1, #16
   1fe24:	f003 bb98 	b.w	23558 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   1fe28:	4b03      	ldr	r3, [pc, #12]	; (1fe38 <event_handler+0x28>)
   1fe2a:	e7f8      	b.n	1fe1e <event_handler+0xe>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   1fe2c:	4b03      	ldr	r3, [pc, #12]	; (1fe3c <event_handler+0x2c>)
   1fe2e:	e7f6      	b.n	1fe1e <event_handler+0xe>
		dev_data->res = NRFX_ERROR_INTERNAL;
   1fe30:	4b03      	ldr	r3, [pc, #12]	; (1fe40 <event_handler+0x30>)
   1fe32:	e7f4      	b.n	1fe1e <event_handler+0xe>
   1fe34:	0bad0000 	.word	0x0bad0000
   1fe38:	0bae0001 	.word	0x0bae0001
   1fe3c:	0bae0002 	.word	0x0bae0002
   1fe40:	0bad0001 	.word	0x0bad0001

0001fe44 <i2c_nrfx_twim_transfer>:
{
   1fe44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1fe48:	4693      	mov	fp, r2
	nrfx_twim_xfer_desc_t cur_xfer = {
   1fe4a:	2214      	movs	r2, #20
{
   1fe4c:	461d      	mov	r5, r3
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   1fe4e:	f8d0 a004 	ldr.w	sl, [r0, #4]
{
   1fe52:	b08b      	sub	sp, #44	; 0x2c
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   1fe54:	6906      	ldr	r6, [r0, #16]
	uint16_t concat_buf_size = dev_config->concat_buf_size;
   1fe56:	f8ba 3018 	ldrh.w	r3, [sl, #24]
{
   1fe5a:	4681      	mov	r9, r0
   1fe5c:	460c      	mov	r4, r1
	nrfx_twim_xfer_desc_t cur_xfer = {
   1fe5e:	eb0d 0002 	add.w	r0, sp, r2
   1fe62:	2100      	movs	r1, #0
	uint8_t *msg_buf = dev_data->msg_buf;
   1fe64:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
	uint16_t concat_buf_size = dev_config->concat_buf_size;
   1fe68:	9302      	str	r3, [sp, #8]
	nrfx_twim_xfer_desc_t cur_xfer = {
   1fe6a:	f005 f8d1 	bl	25010 <memset>
   1fe6e:	f88d 5015 	strb.w	r5, [sp, #21]
	return z_impl_k_sem_take(sem, timeout);
   1fe72:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1fe76:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1fe7a:	4630      	mov	r0, r6
   1fe7c:	f003 fb8c 	bl	23598 <z_impl_k_sem_take>
	k_sem_take(&dev_data->completion_sync, K_NO_WAIT);
   1fe80:	f106 0310 	add.w	r3, r6, #16
   1fe84:	9301      	str	r3, [sp, #4]
	for (size_t i = 0; i < num_msgs; i++) {
   1fe86:	2700      	movs	r7, #0
   1fe88:	2200      	movs	r2, #0
   1fe8a:	2300      	movs	r3, #0
   1fe8c:	f106 0010 	add.w	r0, r6, #16
   1fe90:	f003 fb82 	bl	23598 <z_impl_k_sem_take>
	uint16_t msg_buf_used = 0;
   1fe94:	463d      	mov	r5, r7
	for (size_t i = 0; i < num_msgs; i++) {
   1fe96:	455f      	cmp	r7, fp
   1fe98:	d301      	bcc.n	1fe9e <i2c_nrfx_twim_transfer+0x5a>
   1fe9a:	2400      	movs	r4, #0
   1fe9c:	e068      	b.n	1ff70 <i2c_nrfx_twim_transfer+0x12c>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   1fe9e:	7a20      	ldrb	r0, [r4, #8]
   1fea0:	0702      	lsls	r2, r0, #28
   1fea2:	f100 8089 	bmi.w	1ffb8 <i2c_nrfx_twim_transfer+0x174>
		bool concat_next = ((i + 1) < num_msgs)
   1fea6:	3701      	adds	r7, #1
				&& ((msgs[i].flags & I2C_MSG_READ)
   1fea8:	455f      	cmp	r7, fp
   1feaa:	d20a      	bcs.n	1fec2 <i2c_nrfx_twim_transfer+0x7e>
				&& !(msgs[i].flags & I2C_MSG_STOP)
   1feac:	0783      	lsls	r3, r0, #30
   1feae:	d408      	bmi.n	1fec2 <i2c_nrfx_twim_transfer+0x7e>
				&& !(msgs[i + 1].flags & I2C_MSG_RESTART)
   1feb0:	7d23      	ldrb	r3, [r4, #20]
				    == (msgs[i + 1].flags & I2C_MSG_READ));
   1feb2:	ea80 0203 	eor.w	r2, r0, r3
				&& ((msgs[i].flags & I2C_MSG_READ)
   1feb6:	f002 0201 	and.w	r2, r2, #1
   1feba:	f003 0304 	and.w	r3, r3, #4
   1febe:	431a      	orrs	r2, r3
   1fec0:	d01a      	beq.n	1fef8 <i2c_nrfx_twim_transfer+0xb4>
		if (concat_next || (msg_buf_used != 0)) {
   1fec2:	b1dd      	cbz	r5, 1fefc <i2c_nrfx_twim_transfer+0xb8>
		bool concat_next = ((i + 1) < num_msgs)
   1fec4:	2300      	movs	r3, #0
			if ((msg_buf_used + msgs[i].len) > concat_buf_size) {
   1fec6:	6862      	ldr	r2, [r4, #4]
   1fec8:	f8dd c008 	ldr.w	ip, [sp, #8]
   1fecc:	18a9      	adds	r1, r5, r2
   1fece:	4561      	cmp	r1, ip
   1fed0:	d875      	bhi.n	1ffbe <i2c_nrfx_twim_transfer+0x17a>
			if (!(msgs[i].flags & I2C_MSG_READ)) {
   1fed2:	07c1      	lsls	r1, r0, #31
   1fed4:	d406      	bmi.n	1fee4 <i2c_nrfx_twim_transfer+0xa0>
				memcpy(msg_buf + msg_buf_used,
   1fed6:	6821      	ldr	r1, [r4, #0]
   1fed8:	eb08 0005 	add.w	r0, r8, r5
   1fedc:	9303      	str	r3, [sp, #12]
   1fede:	f005 f88c 	bl	24ffa <memcpy>
   1fee2:	9b03      	ldr	r3, [sp, #12]
			msg_buf_used += msgs[i].len;
   1fee4:	6862      	ldr	r2, [r4, #4]
   1fee6:	442a      	add	r2, r5
   1fee8:	b295      	uxth	r5, r2
		if (concat_next) {
   1feea:	2b00      	cmp	r3, #0
   1feec:	d14f      	bne.n	1ff8e <i2c_nrfx_twim_transfer+0x14a>
		if (msg_buf_used == 0) {
   1feee:	b14d      	cbz	r5, 1ff04 <i2c_nrfx_twim_transfer+0xc0>
			cur_xfer.primary_length = msg_buf_used;
   1fef0:	462b      	mov	r3, r5
			cur_xfer.p_primary_buf = msg_buf;
   1fef2:	f8cd 8020 	str.w	r8, [sp, #32]
			cur_xfer.primary_length = msg_buf_used;
   1fef6:	e009      	b.n	1ff0c <i2c_nrfx_twim_transfer+0xc8>
		bool concat_next = ((i + 1) < num_msgs)
   1fef8:	2301      	movs	r3, #1
   1fefa:	e7e4      	b.n	1fec6 <i2c_nrfx_twim_transfer+0x82>
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   1fefc:	07c0      	lsls	r0, r0, #31
			   !nrfx_is_in_ram(msgs[i].buf)) {
   1fefe:	e9d4 1200 	ldrd	r1, r2, [r4]
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   1ff02:	d51b      	bpl.n	1ff3c <i2c_nrfx_twim_transfer+0xf8>
			cur_xfer.p_primary_buf = msgs[i].buf;
   1ff04:	2500      	movs	r5, #0
   1ff06:	6823      	ldr	r3, [r4, #0]
   1ff08:	9308      	str	r3, [sp, #32]
			cur_xfer.primary_length = msgs[i].len;
   1ff0a:	6863      	ldr	r3, [r4, #4]
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   1ff0c:	7a22      	ldrb	r2, [r4, #8]
			cur_xfer.primary_length = msgs[i].len;
   1ff0e:	9306      	str	r3, [sp, #24]
			NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX;
   1ff10:	f002 0301 	and.w	r3, r2, #1
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   1ff14:	f082 0202 	eor.w	r2, r2, #2
   1ff18:	f3c2 0240 	ubfx	r2, r2, #1, #1
   1ff1c:	4650      	mov	r0, sl
   1ff1e:	0152      	lsls	r2, r2, #5
   1ff20:	a905      	add	r1, sp, #20
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   1ff22:	f88d 3014 	strb.w	r3, [sp, #20]
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   1ff26:	f001 fe5b 	bl	21be0 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
   1ff2a:	4b28      	ldr	r3, [pc, #160]	; (1ffcc <i2c_nrfx_twim_transfer+0x188>)
   1ff2c:	4298      	cmp	r0, r3
   1ff2e:	d013      	beq.n	1ff58 <i2c_nrfx_twim_transfer+0x114>
			if (res == NRFX_ERROR_BUSY) {
   1ff30:	330b      	adds	r3, #11
   1ff32:	4298      	cmp	r0, r3
   1ff34:	d11a      	bne.n	1ff6c <i2c_nrfx_twim_transfer+0x128>
				ret = -EBUSY;
   1ff36:	f06f 040f 	mvn.w	r4, #15
   1ff3a:	e019      	b.n	1ff70 <i2c_nrfx_twim_transfer+0x12c>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   1ff3c:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   1ff40:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   1ff44:	d0de      	beq.n	1ff04 <i2c_nrfx_twim_transfer+0xc0>
			if (msgs[i].len > dev_config->flash_buf_max_size) {
   1ff46:	f8ba 301a 	ldrh.w	r3, [sl, #26]
   1ff4a:	4293      	cmp	r3, r2
   1ff4c:	d33a      	bcc.n	1ffc4 <i2c_nrfx_twim_transfer+0x180>
			memcpy(msg_buf, msgs[i].buf, msgs[i].len);
   1ff4e:	4640      	mov	r0, r8
   1ff50:	f005 f853 	bl	24ffa <memcpy>
			msg_buf_used = msgs[i].len;
   1ff54:	88a5      	ldrh	r5, [r4, #4]
		if (concat_next) {
   1ff56:	e7ca      	b.n	1feee <i2c_nrfx_twim_transfer+0xaa>
   1ff58:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1ff5c:	2300      	movs	r3, #0
   1ff5e:	9801      	ldr	r0, [sp, #4]
   1ff60:	f003 fb1a 	bl	23598 <z_impl_k_sem_take>
		if (ret != 0) {
   1ff64:	b158      	cbz	r0, 1ff7e <i2c_nrfx_twim_transfer+0x13a>
			(void)i2c_nrfx_twim_recover_bus(dev);
   1ff66:	4648      	mov	r0, r9
   1ff68:	f7ff ff34 	bl	1fdd4 <i2c_nrfx_twim_recover_bus>
				ret = -EIO;
   1ff6c:	f06f 0404 	mvn.w	r4, #4
	z_impl_k_sem_give(sem);
   1ff70:	4630      	mov	r0, r6
   1ff72:	f003 faf1 	bl	23558 <z_impl_k_sem_give>
}
   1ff76:	4620      	mov	r0, r4
   1ff78:	b00b      	add	sp, #44	; 0x2c
   1ff7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		res = dev_data->res;
   1ff7e:	6a33      	ldr	r3, [r6, #32]
		if (res != NRFX_SUCCESS) {
   1ff80:	4a12      	ldr	r2, [pc, #72]	; (1ffcc <i2c_nrfx_twim_transfer+0x188>)
   1ff82:	4293      	cmp	r3, r2
   1ff84:	d1f2      	bne.n	1ff6c <i2c_nrfx_twim_transfer+0x128>
		if ((msgs[i].flags & I2C_MSG_READ)
   1ff86:	7a23      	ldrb	r3, [r4, #8]
   1ff88:	07db      	lsls	r3, r3, #31
   1ff8a:	d402      	bmi.n	1ff92 <i2c_nrfx_twim_transfer+0x14e>
		msg_buf_used = 0;
   1ff8c:	2500      	movs	r5, #0
   1ff8e:	340c      	adds	r4, #12
   1ff90:	e781      	b.n	1fe96 <i2c_nrfx_twim_transfer+0x52>
		    && cur_xfer.p_primary_buf == msg_buf) {
   1ff92:	9b08      	ldr	r3, [sp, #32]
   1ff94:	4598      	cmp	r8, r3
   1ff96:	d1f9      	bne.n	1ff8c <i2c_nrfx_twim_transfer+0x148>
   1ff98:	4623      	mov	r3, r4
   1ff9a:	e008      	b.n	1ffae <i2c_nrfx_twim_transfer+0x16a>
				msg_buf_used -= msgs[j].len;
   1ff9c:	1aa9      	subs	r1, r5, r2
				memcpy(msgs[j].buf,
   1ff9e:	68d8      	ldr	r0, [r3, #12]
				msg_buf_used -= msgs[j].len;
   1ffa0:	b28d      	uxth	r5, r1
				memcpy(msgs[j].buf,
   1ffa2:	fa18 f181 	uxtah	r1, r8, r1
   1ffa6:	9303      	str	r3, [sp, #12]
   1ffa8:	f005 f827 	bl	24ffa <memcpy>
				j--;
   1ffac:	9b03      	ldr	r3, [sp, #12]
			while (msg_buf_used >= msgs[j].len) {
   1ffae:	685a      	ldr	r2, [r3, #4]
   1ffb0:	3b0c      	subs	r3, #12
   1ffb2:	4295      	cmp	r5, r2
   1ffb4:	d2f2      	bcs.n	1ff9c <i2c_nrfx_twim_transfer+0x158>
   1ffb6:	e7e9      	b.n	1ff8c <i2c_nrfx_twim_transfer+0x148>
			ret = -ENOTSUP;
   1ffb8:	f06f 0485 	mvn.w	r4, #133	; 0x85
   1ffbc:	e7d8      	b.n	1ff70 <i2c_nrfx_twim_transfer+0x12c>
				ret = -ENOSPC;
   1ffbe:	f06f 041b 	mvn.w	r4, #27
   1ffc2:	e7d5      	b.n	1ff70 <i2c_nrfx_twim_transfer+0x12c>
				ret = -EINVAL;
   1ffc4:	f06f 0415 	mvn.w	r4, #21
   1ffc8:	e7d2      	b.n	1ff70 <i2c_nrfx_twim_transfer+0x12c>
   1ffca:	bf00      	nop
   1ffcc:	0bad0000 	.word	0x0bad0000

0001ffd0 <pinctrl_configure_pins>:
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1ffd0:	f04f 0c01 	mov.w	ip, #1
#define NRF_PSEL_QSPI(reg, line) ((NRF_QSPI_Type *)reg)->PSEL.line
#endif

int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
			   uintptr_t reg)
{
   1ffd4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        case 1: return NRF_P1;
   1ffd8:	4e56      	ldr	r6, [pc, #344]	; (20134 <pinctrl_configure_pins+0x164>)
   1ffda:	4f57      	ldr	r7, [pc, #348]	; (20138 <pinctrl_configure_pins+0x168>)
   1ffdc:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   1ffe0:	4281      	cmp	r1, r0
   1ffe2:	d102      	bne.n	1ffea <pinctrl_configure_pins+0x1a>
			nrf_gpio_cfg(pin, dir, input, NRF_GET_PULL(pins[i]),
				     drive, NRF_GPIO_PIN_NOSENSE);
		}
	}

	return 0;
   1ffe4:	2000      	movs	r0, #0
}
   1ffe6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
   1ffea:	6804      	ldr	r4, [r0, #0]
		uint32_t pin = NRF_GET_PIN(pins[i]);
   1ffec:	f004 037f 	and.w	r3, r4, #127	; 0x7f
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
   1fff0:	f3c4 2543 	ubfx	r5, r4, #9, #4
		switch (NRF_GET_FUN(pins[i])) {
   1fff4:	0c24      	lsrs	r4, r4, #16
			pin = 0xFFFFFFFFU;
   1fff6:	2b7f      	cmp	r3, #127	; 0x7f
		switch (NRF_GET_FUN(pins[i])) {
   1fff8:	f1a4 0404 	sub.w	r4, r4, #4
			pin = 0xFFFFFFFFU;
   1fffc:	bf08      	it	eq
   1fffe:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
		switch (NRF_GET_FUN(pins[i])) {
   20002:	2c1e      	cmp	r4, #30
   20004:	f200 8092 	bhi.w	2012c <pinctrl_configure_pins+0x15c>
   20008:	e8df f004 	tbb	[pc, r4]
   2000c:	90272310 	.word	0x90272310
   20010:	2b909090 	.word	0x2b909090
   20014:	90909058 	.word	0x90909058
   20018:	90909090 	.word	0x90909090
   2001c:	725b9090 	.word	0x725b9090
   20020:	90907875 	.word	0x90907875
   20024:	84817b90 	.word	0x84817b90
   20028:	8a87      	.short	0x8a87
   2002a:	8d          	.byte	0x8d
   2002b:	00          	.byte	0x00
			input = NRF_GPIO_PIN_INPUT_CONNECT;
   2002c:	2400      	movs	r4, #0
			NRF_PSEL_SPIM(reg, SCK) = pin;
   2002e:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    return pin_number >> 5;
   20032:	ea4f 1953 	mov.w	r9, r3, lsr #5
        case 1: return NRF_P1;
   20036:	f1b9 0f01 	cmp.w	r9, #1
   2003a:	bf14      	ite	ne
   2003c:	46b0      	movne	r8, r6
   2003e:	46b8      	moveq	r8, r7
    *p_pin = pin_number & 0x1F;
   20040:	f003 0e1f 	and.w	lr, r3, #31
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   20044:	fa0c fe0e 	lsl.w	lr, ip, lr
    p_reg->OUTCLR = clr_mask;
   20048:	f8c8 e00c 	str.w	lr, [r8, #12]
   2004c:	f04f 0e01 	mov.w	lr, #1
   20050:	e00e      	b.n	20070 <pinctrl_configure_pins+0xa0>
			NRF_PSEL_SPIM(reg, MOSI) = pin;
   20052:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
			pin = 0xFFFFFFFFU;
   20056:	2401      	movs	r4, #1
   20058:	e7eb      	b.n	20032 <pinctrl_configure_pins+0x62>
			NRF_PSEL_SPIM(reg, MISO) = pin;
   2005a:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
			input = NRF_GPIO_PIN_INPUT_CONNECT;
   2005e:	2400      	movs	r4, #0
   20060:	e044      	b.n	200ec <pinctrl_configure_pins+0x11c>
			NRF_PSEL_TWIM(reg, SCL) = pin;
   20062:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
			if (drive == NRF_DRIVE_S0S1) {
   20066:	2d00      	cmp	r5, #0
   20068:	d1f9      	bne.n	2005e <pinctrl_configure_pins+0x8e>
			input = NRF_GPIO_PIN_INPUT_CONNECT;
   2006a:	2400      	movs	r4, #0
				drive = NRF_DRIVE_S0D1;
   2006c:	2506      	movs	r5, #6
			dir = NRF_GPIO_PIN_DIR_INPUT;
   2006e:	46a6      	mov	lr, r4
			if (NRF_GET_LP(pins[i]) == NRF_LP_ENABLE) {
   20070:	f850 ab04 	ldr.w	sl, [r0], #4
    *p_pin = pin_number & 0x1F;
   20074:	f003 091f 	and.w	r9, r3, #31
   20078:	f40a 5800 	and.w	r8, sl, #8192	; 0x2000
				input = NRF_GPIO_PIN_INPUT_DISCONNECT;
   2007c:	f1b8 0f00 	cmp.w	r8, #0
    return pin_number >> 5;
   20080:	ea4f 1353 	mov.w	r3, r3, lsr #5
   20084:	bf1c      	itt	ne
   20086:	2401      	movne	r4, #1
   20088:	f04f 0e00 	movne.w	lr, #0
        case 0: return NRF_P0;
   2008c:	2b01      	cmp	r3, #1
   2008e:	bf0c      	ite	eq
   20090:	46b8      	moveq	r8, r7
   20092:	46b0      	movne	r8, r6
   20094:	eb08 0889 	add.w	r8, r8, r9, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   20098:	f8d8 3200 	ldr.w	r3, [r8, #512]	; 0x200
			nrf_gpio_cfg(pin, dir, input, NRF_GET_PULL(pins[i]),
   2009c:	f3ca 1ac1 	ubfx	sl, sl, #7, #2
   200a0:	f003 49e0 	and.w	r9, r3, #1879048192	; 0x70000000
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   200a4:	022b      	lsls	r3, r5, #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   200a6:	ea43 038a 	orr.w	r3, r3, sl, lsl #2
   200aa:	ea43 030e 	orr.w	r3, r3, lr
   200ae:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   200b2:	ea43 0309 	orr.w	r3, r3, r9
    reg->PIN_CNF[pin_number] = cnf;
   200b6:	f8c8 3200 	str.w	r3, [r8, #512]	; 0x200
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   200ba:	e791      	b.n	1ffe0 <pinctrl_configure_pins+0x10>
			NRF_PSEL_TWIM(reg, SDA) = pin;
   200bc:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
			if (drive == NRF_DRIVE_S0S1) {
   200c0:	e7d1      	b.n	20066 <pinctrl_configure_pins+0x96>
			NRF_PSEL_PWM(reg, OUT[0]) = pin;
   200c2:	f8c2 3560 	str.w	r3, [r2, #1376]	; 0x560
			write = NRF_GET_INVERT(pins[i]);
   200c6:	6804      	ldr	r4, [r0, #0]
   200c8:	f3c4 3480 	ubfx	r4, r4, #14, #1
    if (value == 0)
   200cc:	2c00      	cmp	r4, #0
   200ce:	d0c2      	beq.n	20056 <pinctrl_configure_pins+0x86>
    return pin_number >> 5;
   200d0:	ea4f 1853 	mov.w	r8, r3, lsr #5
        case 1: return NRF_P1;
   200d4:	f1b8 0f01 	cmp.w	r8, #1
   200d8:	bf14      	ite	ne
   200da:	46b6      	movne	lr, r6
   200dc:	46be      	moveq	lr, r7
    *p_pin = pin_number & 0x1F;
   200de:	f003 041f 	and.w	r4, r3, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   200e2:	fa0c f404 	lsl.w	r4, ip, r4
    p_reg->OUTSET = set_mask;
   200e6:	f8ce 4008 	str.w	r4, [lr, #8]
   200ea:	2401      	movs	r4, #1
			dir = NRF_GPIO_PIN_DIR_INPUT;
   200ec:	46a6      	mov	lr, r4
   200ee:	e7bf      	b.n	20070 <pinctrl_configure_pins+0xa0>
			NRF_PSEL_PWM(reg, OUT[1]) = pin;
   200f0:	f8c2 3564 	str.w	r3, [r2, #1380]	; 0x564
			write = NRF_GET_INVERT(pins[i]);
   200f4:	e7e7      	b.n	200c6 <pinctrl_configure_pins+0xf6>
			NRF_PSEL_PWM(reg, OUT[2]) = pin;
   200f6:	f8c2 3568 	str.w	r3, [r2, #1384]	; 0x568
			write = NRF_GET_INVERT(pins[i]);
   200fa:	e7e4      	b.n	200c6 <pinctrl_configure_pins+0xf6>
			NRF_PSEL_PWM(reg, OUT[3]) = pin;
   200fc:	f8c2 356c 	str.w	r3, [r2, #1388]	; 0x56c
   20100:	e7e1      	b.n	200c6 <pinctrl_configure_pins+0xf6>
			NRF_PSEL_QSPI(reg, SCK) = pin;
   20102:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
			input = NRF_GPIO_PIN_INPUT_DISCONNECT;
   20106:	2401      	movs	r4, #1
			dir = NRF_GPIO_PIN_DIR_INPUT;
   20108:	f04f 0e00 	mov.w	lr, #0
   2010c:	e7b0      	b.n	20070 <pinctrl_configure_pins+0xa0>
			NRF_PSEL_QSPI(reg, CSN) = pin;
   2010e:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
    if (value == 0)
   20112:	e7dd      	b.n	200d0 <pinctrl_configure_pins+0x100>
			NRF_PSEL_QSPI(reg, IO0) = pin;
   20114:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
			if (write != NO_WRITE) {
   20118:	e7f5      	b.n	20106 <pinctrl_configure_pins+0x136>
			NRF_PSEL_QSPI(reg, IO1) = pin;
   2011a:	f8c2 3534 	str.w	r3, [r2, #1332]	; 0x534
			if (write != NO_WRITE) {
   2011e:	e7f2      	b.n	20106 <pinctrl_configure_pins+0x136>
			NRF_PSEL_QSPI(reg, IO2) = pin;
   20120:	f8c2 3538 	str.w	r3, [r2, #1336]	; 0x538
			if (write != NO_WRITE) {
   20124:	e7ef      	b.n	20106 <pinctrl_configure_pins+0x136>
			NRF_PSEL_QSPI(reg, IO3) = pin;
   20126:	f8c2 353c 	str.w	r3, [r2, #1340]	; 0x53c
			if (write != NO_WRITE) {
   2012a:	e7ec      	b.n	20106 <pinctrl_configure_pins+0x136>
		switch (NRF_GET_FUN(pins[i])) {
   2012c:	f06f 0085 	mvn.w	r0, #133	; 0x85
   20130:	e759      	b.n	1ffe6 <pinctrl_configure_pins+0x16>
   20132:	bf00      	nop
   20134:	40842500 	.word	0x40842500
   20138:	40842800 	.word	0x40842800

0002013c <regulator_fixed_enable>:
struct regulator_fixed_data {
	struct regulator_common_data common;
};

static int regulator_fixed_enable(const struct device *dev)
{
   2013c:	b538      	push	{r3, r4, r5, lr}
	const struct regulator_fixed_config *cfg = dev->config;
   2013e:	6844      	ldr	r4, [r0, #4]
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
{
	return gpio_pin_set(spec->port, spec->pin, value);
   20140:	2201      	movs	r2, #1
   20142:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
   20146:	6a60      	ldr	r0, [r4, #36]	; 0x24
   20148:	f005 f9ae 	bl	254a8 <gpio_pin_set>
	int ret;

	ret = gpio_pin_set_dt(&cfg->enable, 1);
	if (ret < 0) {
   2014c:	2800      	cmp	r0, #0
   2014e:	db02      	blt.n	20156 <regulator_fixed_enable+0x1a>
		return ret;
	}

	if (cfg->off_on_delay_us > 0U) {
   20150:	6a24      	ldr	r4, [r4, #32]
   20152:	b90c      	cbnz	r4, 20158 <regulator_fixed_enable+0x1c>
		k_sleep(K_USEC(cfg->off_on_delay_us));
	}

	return 0;
   20154:	2000      	movs	r0, #0
}
   20156:	bd38      	pop	{r3, r4, r5, pc}
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
   20158:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   2015c:	2100      	movs	r1, #0
   2015e:	4805      	ldr	r0, [pc, #20]	; (20174 <regulator_fixed_enable+0x38>)
   20160:	2300      	movs	r3, #0
   20162:	fbe4 0105 	umlal	r0, r1, r4, r5
   20166:	4a04      	ldr	r2, [pc, #16]	; (20178 <regulator_fixed_enable+0x3c>)
   20168:	f7fb fff4 	bl	1c154 <__aeabi_uldivmod>
	return z_impl_k_sleep(timeout);
   2016c:	f003 fe74 	bl	23e58 <z_impl_k_sleep>
   20170:	e7f0      	b.n	20154 <regulator_fixed_enable+0x18>
   20172:	bf00      	nop
   20174:	000f423f 	.word	0x000f423f
   20178:	000f4240 	.word	0x000f4240

0002017c <transfer_next_chunk>:
	spi_context_complete(ctx, dev, error);
	dev_data->busy = false;
}

static void transfer_next_chunk(const struct device *dev)
{
   2017c:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct spi_nrfx_data *dev_data = dev->data;
   2017e:	6904      	ldr	r4, [r0, #16]
{
   20180:	4606      	mov	r6, r0
 * directions have a continuous buffer, i.e. the maximum SPI transfer that
 * can be done with DMA that handles only non-scattered buffers.
 */
static inline size_t spi_context_max_continuous_chunk(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
   20182:	6ca5      	ldr	r5, [r4, #72]	; 0x48
	const struct spi_nrfx_config *dev_config = dev->config;
   20184:	6847      	ldr	r7, [r0, #4]
		return ctx->rx_len;
   20186:	6d23      	ldr	r3, [r4, #80]	; 0x50
{
   20188:	b085      	sub	sp, #20
	if (!ctx->tx_len) {
   2018a:	b93d      	cbnz	r5, 2019c <transfer_next_chunk+0x20>
	struct spi_context *ctx = &dev_data->ctx;
	int error = 0;

	size_t chunk_len = spi_context_max_continuous_chunk(ctx);

	if (chunk_len > 0) {
   2018c:	bb6b      	cbnz	r3, 201ea <transfer_next_chunk+0x6e>
	int error = 0;
   2018e:	4619      	mov	r1, r3
			anomaly_58_workaround_clear(dev_data);
#endif
		}
	}

	finish_transaction(dev, error);
   20190:	6930      	ldr	r0, [r6, #16]
}
   20192:	b005      	add	sp, #20
   20194:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	finish_transaction(dev, error);
   20198:	f005 baa3 	b.w	256e2 <finish_transaction.isra.0>
		const uint8_t *tx_buf = ctx->tx_buf;
   2019c:	6c61      	ldr	r1, [r4, #68]	; 0x44
	} else if (!ctx->rx_len) {
   2019e:	bb03      	cbnz	r3, 201e2 <transfer_next_chunk+0x66>
	return !!(ctx->tx_buf && ctx->tx_len);
   201a0:	bb31      	cbnz	r1, 201f0 <transfer_next_chunk+0x74>
		if (chunk_len > dev_config->max_chunk_len) {
   201a2:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   201a4:	6c63      	ldr	r3, [r4, #68]	; 0x44
   201a6:	42aa      	cmp	r2, r5
   201a8:	bf28      	it	cs
   201aa:	462a      	movcs	r2, r5
		xfer.p_tx_buffer = tx_buf;
   201ac:	9100      	str	r1, [sp, #0]
		dev_data->chunk_len = chunk_len;
   201ae:	65a2      	str	r2, [r4, #88]	; 0x58
   201b0:	b11b      	cbz	r3, 201ba <transfer_next_chunk+0x3e>
   201b2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   201b4:	2b00      	cmp	r3, #0
   201b6:	bf18      	it	ne
   201b8:	4613      	movne	r3, r2
   201ba:	9301      	str	r3, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
   201bc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   201be:	9302      	str	r3, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
   201c0:	b11b      	cbz	r3, 201ca <transfer_next_chunk+0x4e>
   201c2:	6d23      	ldr	r3, [r4, #80]	; 0x50
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   201c4:	2b00      	cmp	r3, #0
   201c6:	bf18      	it	ne
   201c8:	4613      	movne	r3, r2
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   201ca:	2200      	movs	r2, #0
   201cc:	4669      	mov	r1, sp
   201ce:	4638      	mov	r0, r7
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   201d0:	9303      	str	r3, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   201d2:	f001 fb99 	bl	21908 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
   201d6:	4b0e      	ldr	r3, [pc, #56]	; (20210 <transfer_next_chunk+0x94>)
   201d8:	4298      	cmp	r0, r3
   201da:	d017      	beq.n	2020c <transfer_next_chunk+0x90>
			error = -EIO;
   201dc:	f06f 0104 	mvn.w	r1, #4
   201e0:	e7d6      	b.n	20190 <transfer_next_chunk+0x14>
		return ctx->tx_len;
	}

	return MIN(ctx->tx_len, ctx->rx_len);
   201e2:	429d      	cmp	r5, r3
   201e4:	bf28      	it	cs
   201e6:	461d      	movcs	r5, r3
   201e8:	e7da      	b.n	201a0 <transfer_next_chunk+0x24>
		const uint8_t *tx_buf = ctx->tx_buf;
   201ea:	461d      	mov	r5, r3
   201ec:	6c61      	ldr	r1, [r4, #68]	; 0x44
	return !!(ctx->tx_buf && ctx->tx_len);
   201ee:	e7d8      	b.n	201a2 <transfer_next_chunk+0x26>
   201f0:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		if (spi_context_tx_buf_on(ctx) && !nrfx_is_in_ram(tx_buf)) {
   201f4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   201f8:	d0d3      	beq.n	201a2 <transfer_next_chunk+0x26>
			if (chunk_len > CONFIG_SPI_NRFX_RAM_BUFFER_SIZE) {
   201fa:	2d08      	cmp	r5, #8
   201fc:	bf28      	it	cs
   201fe:	2508      	movcs	r5, #8
			memcpy(dev_data->buffer, tx_buf, chunk_len);
   20200:	6e20      	ldr	r0, [r4, #96]	; 0x60
   20202:	462a      	mov	r2, r5
   20204:	f004 fef9 	bl	24ffa <memcpy>
			tx_buf = dev_data->buffer;
   20208:	6e21      	ldr	r1, [r4, #96]	; 0x60
   2020a:	e7ca      	b.n	201a2 <transfer_next_chunk+0x26>
}
   2020c:	b005      	add	sp, #20
   2020e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   20210:	0bad0000 	.word	0x0bad0000

00020214 <spi_nrfx_transceive>:

static int spi_nrfx_transceive(const struct device *dev,
			       const struct spi_config *spi_cfg,
			       const struct spi_buf_set *tx_bufs,
			       const struct spi_buf_set *rx_bufs)
{
   20214:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20218:	469a      	mov	sl, r3
	const struct spi_nrfx_config *dev_config = dev->config;
   2021a:	6843      	ldr	r3, [r0, #4]
{
   2021c:	b08b      	sub	sp, #44	; 0x2c
	const struct spi_nrfx_config *dev_config = dev->config;
   2021e:	9303      	str	r3, [sp, #12]
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
   20220:	888b      	ldrh	r3, [r1, #4]
{
   20222:	4607      	mov	r7, r0
   20224:	049b      	lsls	r3, r3, #18
   20226:	460e      	mov	r6, r1
   20228:	4690      	mov	r8, r2
	struct spi_nrfx_data *dev_data = dev->data;
   2022a:	6904      	ldr	r4, [r0, #16]
   2022c:	f100 8106 	bmi.w	2043c <spi_nrfx_transceive+0x228>
	return z_impl_k_sem_take(sem, timeout);
   20230:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   20234:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   20238:	f104 0010 	add.w	r0, r4, #16
   2023c:	f003 f9ac 	bl	23598 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
   20240:	6066      	str	r6, [r4, #4]
	const struct spi_nrfx_config *dev_config = dev->config;
   20242:	687b      	ldr	r3, [r7, #4]
	struct spi_nrfx_data *dev_data = dev->data;
   20244:	f8d7 9010 	ldr.w	r9, [r7, #16]
	uint32_t max_freq = dev_config->max_freq;
   20248:	689d      	ldr	r5, [r3, #8]
	const struct spi_nrfx_config *dev_config = dev->config;
   2024a:	9300      	str	r3, [sp, #0]
	if (dev_data->initialized && spi_context_configured(ctx, spi_cfg)) {
   2024c:	f899 305d 	ldrb.w	r3, [r9, #93]	; 0x5d
   20250:	9301      	str	r3, [sp, #4]
   20252:	b11b      	cbz	r3, 2025c <spi_nrfx_transceive+0x48>
   20254:	f8d9 3000 	ldr.w	r3, [r9]
   20258:	429e      	cmp	r6, r3
   2025a:	d07c      	beq.n	20356 <spi_nrfx_transceive+0x142>
	if (spi_cfg->operation & SPI_HALF_DUPLEX) {
   2025c:	f8b6 c004 	ldrh.w	ip, [r6, #4]
   20260:	f41c 6f00 	tst.w	ip, #2048	; 0x800
   20264:	f040 811f 	bne.w	204a6 <spi_nrfx_transceive+0x292>
	if (spi_cfg->operation & SPI_MODE_LOOP) {
   20268:	f01c 0f09 	tst.w	ip, #9
   2026c:	f040 8118 	bne.w	204a0 <spi_nrfx_transceive+0x28c>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
   20270:	f3cc 1345 	ubfx	r3, ip, #5, #6
   20274:	2b08      	cmp	r3, #8
   20276:	f040 8113 	bne.w	204a0 <spi_nrfx_transceive+0x28c>
	if (spi_cfg->frequency < 125000) {
   2027a:	6833      	ldr	r3, [r6, #0]
   2027c:	9302      	str	r3, [sp, #8]
   2027e:	9a02      	ldr	r2, [sp, #8]
   20280:	4b9a      	ldr	r3, [pc, #616]	; (204ec <spi_nrfx_transceive+0x2d8>)
   20282:	429a      	cmp	r2, r3
   20284:	f240 810c 	bls.w	204a0 <spi_nrfx_transceive+0x28c>
	if (max_freq > 16000000 &&
   20288:	4b99      	ldr	r3, [pc, #612]	; (204f0 <spi_nrfx_transceive+0x2dc>)
   2028a:	429d      	cmp	r5, r3
   2028c:	d906      	bls.n	2029c <spi_nrfx_transceive+0x88>
                        CLOCK_HFCLKCTRL_HCLK_Msk);
}

NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk_div_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_hfclk_div_t)((p_reg->HFCLKCTRL & CLOCK_HFCLKCTRL_HCLK_Msk)
   2028e:	4a99      	ldr	r2, [pc, #612]	; (204f4 <spi_nrfx_transceive+0x2e0>)
   20290:	f8d2 2558 	ldr.w	r2, [r2, #1368]	; 0x558
		max_freq = 16000000;
   20294:	f012 0f03 	tst.w	r2, #3
   20298:	bf18      	it	ne
   2029a:	461d      	movne	r5, r3
	config = dev_config->def_config;
   2029c:	9b00      	ldr	r3, [sp, #0]
   2029e:	f10d 0e10 	add.w	lr, sp, #16
   202a2:	f103 0b0c 	add.w	fp, r3, #12
   202a6:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
   202aa:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
   202ae:	9b02      	ldr	r3, [sp, #8]
	config = dev_config->def_config;
   202b0:	e89b 0003 	ldmia.w	fp, {r0, r1}
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
   202b4:	42ab      	cmp	r3, r5
   202b6:	bf28      	it	cs
   202b8:	462b      	movcs	r3, r5
   202ba:	461d      	mov	r5, r3
	if (frequency < 250000) {
   202bc:	4b8e      	ldr	r3, [pc, #568]	; (204f8 <spi_nrfx_transceive+0x2e4>)
	config = dev_config->def_config;
   202be:	e88e 0003 	stmia.w	lr, {r0, r1}
	if (frequency < 250000) {
   202c2:	429d      	cmp	r5, r3
   202c4:	f240 80c3 	bls.w	2044e <spi_nrfx_transceive+0x23a>
	} else if (frequency < 500000) {
   202c8:	4b8c      	ldr	r3, [pc, #560]	; (204fc <spi_nrfx_transceive+0x2e8>)
   202ca:	429d      	cmp	r5, r3
   202cc:	f240 80c2 	bls.w	20454 <spi_nrfx_transceive+0x240>
	} else if (frequency < 1000000) {
   202d0:	4b8b      	ldr	r3, [pc, #556]	; (20500 <spi_nrfx_transceive+0x2ec>)
   202d2:	429d      	cmp	r5, r3
   202d4:	f240 80c1 	bls.w	2045a <spi_nrfx_transceive+0x246>
	} else if (frequency < 2000000) {
   202d8:	4b8a      	ldr	r3, [pc, #552]	; (20504 <spi_nrfx_transceive+0x2f0>)
   202da:	429d      	cmp	r5, r3
   202dc:	f240 80c0 	bls.w	20460 <spi_nrfx_transceive+0x24c>
	} else if (frequency < 4000000) {
   202e0:	4b89      	ldr	r3, [pc, #548]	; (20508 <spi_nrfx_transceive+0x2f4>)
   202e2:	429d      	cmp	r5, r3
   202e4:	f240 80bf 	bls.w	20466 <spi_nrfx_transceive+0x252>
	} else if (frequency < 8000000) {
   202e8:	4b88      	ldr	r3, [pc, #544]	; (2050c <spi_nrfx_transceive+0x2f8>)
   202ea:	429d      	cmp	r5, r3
   202ec:	f0c0 80be 	bcc.w	2046c <spi_nrfx_transceive+0x258>
	} else if (frequency < 16000000) {
   202f0:	4b7f      	ldr	r3, [pc, #508]	; (204f0 <spi_nrfx_transceive+0x2dc>)
   202f2:	429d      	cmp	r5, r3
   202f4:	f0c0 80bd 	bcc.w	20472 <spi_nrfx_transceive+0x25e>
		return NRF_SPIM_FREQ_16M;
   202f8:	4b85      	ldr	r3, [pc, #532]	; (20510 <spi_nrfx_transceive+0x2fc>)
   202fa:	429d      	cmp	r5, r3
   202fc:	bf2c      	ite	cs
   202fe:	f04f 55a0 	movcs.w	r5, #335544320	; 0x14000000
   20302:	f04f 6520 	movcc.w	r5, #167772160	; 0xa000000
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   20306:	f01c 0f02 	tst.w	ip, #2
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
   2030a:	9506      	str	r5, [sp, #24]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   2030c:	f00c 0304 	and.w	r3, ip, #4
   20310:	f000 80b2 	beq.w	20478 <spi_nrfx_transceive+0x264>
			return NRF_SPIM_MODE_2;
   20314:	2b00      	cmp	r3, #0
   20316:	bf14      	ite	ne
   20318:	2303      	movne	r3, #3
   2031a:	2302      	moveq	r3, #2
	config.mode      = get_nrf_spim_mode(spi_cfg->operation);
   2031c:	f88d 301c 	strb.w	r3, [sp, #28]
	if (dev_data->initialized) {
   20320:	9b01      	ldr	r3, [sp, #4]
	if (operation & SPI_TRANSFER_LSB) {
   20322:	f3cc 1c00 	ubfx	ip, ip, #4, #1
	config.bit_order = get_nrf_spim_bit_order(spi_cfg->operation);
   20326:	f88d c01d 	strb.w	ip, [sp, #29]
	if (dev_data->initialized) {
   2032a:	b12b      	cbz	r3, 20338 <spi_nrfx_transceive+0x124>
		nrfx_spim_uninit(&dev_config->spim);
   2032c:	9800      	ldr	r0, [sp, #0]
   2032e:	f001 fa97 	bl	21860 <nrfx_spim_uninit>
		dev_data->initialized = false;
   20332:	2300      	movs	r3, #0
   20334:	f889 305d 	strb.w	r3, [r9, #93]	; 0x5d
	result = nrfx_spim_init(&dev_config->spim, &config,
   20338:	464b      	mov	r3, r9
   2033a:	4a76      	ldr	r2, [pc, #472]	; (20514 <spi_nrfx_transceive+0x300>)
   2033c:	9800      	ldr	r0, [sp, #0]
   2033e:	a904      	add	r1, sp, #16
   20340:	f001 f956 	bl	215f0 <nrfx_spim_init>
	if (result != NRFX_SUCCESS) {
   20344:	4b74      	ldr	r3, [pc, #464]	; (20518 <spi_nrfx_transceive+0x304>)
   20346:	4298      	cmp	r0, r3
   20348:	f040 809a 	bne.w	20480 <spi_nrfx_transceive+0x26c>
	dev_data->initialized = true;
   2034c:	2301      	movs	r3, #1
	ctx->config = spi_cfg;
   2034e:	f8c9 6000 	str.w	r6, [r9]
	dev_data->initialized = true;
   20352:	f889 305d 	strb.w	r3, [r9, #93]	; 0x5d
		dev_data->busy = true;
   20356:	2301      	movs	r3, #1
   20358:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
   2035c:	f1b8 0f00 	cmp.w	r8, #0
   20360:	f040 80a4 	bne.w	204ac <spi_nrfx_transceive+0x298>
   20364:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
   20368:	2300      	movs	r3, #0
   2036a:	63a3      	str	r3, [r4, #56]	; 0x38
		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
   2036c:	f104 0248 	add.w	r2, r4, #72	; 0x48
   20370:	f104 0138 	add.w	r1, r4, #56	; 0x38
   20374:	f104 0034 	add.w	r0, r4, #52	; 0x34
   20378:	f005 f8f2 	bl	25560 <spi_context_get_next_buf.constprop.0>
	ctx->tx_buf = (const uint8_t *)
   2037c:	6460      	str	r0, [r4, #68]	; 0x44
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
   2037e:	f1ba 0f00 	cmp.w	sl, #0
   20382:	f040 809c 	bne.w	204be <spi_nrfx_transceive+0x2aa>
   20386:	f8c4 a03c 	str.w	sl, [r4, #60]	; 0x3c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
   2038a:	2300      	movs	r3, #0
   2038c:	6423      	str	r3, [r4, #64]	; 0x40
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
   2038e:	f104 0250 	add.w	r2, r4, #80	; 0x50
   20392:	f104 0140 	add.w	r1, r4, #64	; 0x40
   20396:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   2039a:	f005 f8e1 	bl	25560 <spi_context_get_next_buf.constprop.0>
	ctx->sync_status = 0;
   2039e:	2500      	movs	r5, #0
	_spi_context_cs_control(ctx, on, false);
   203a0:	2101      	movs	r1, #1
   203a2:	462a      	mov	r2, r5
	ctx->rx_buf = (uint8_t *)
   203a4:	64e0      	str	r0, [r4, #76]	; 0x4c
	ctx->sync_status = 0;
   203a6:	6325      	str	r5, [r4, #48]	; 0x30
	_spi_context_cs_control(ctx, on, false);
   203a8:	4620      	mov	r0, r4
   203aa:	f005 f900 	bl	255ae <_spi_context_cs_control>
		transfer_next_chunk(dev);
   203ae:	4638      	mov	r0, r7
   203b0:	f7ff fee4 	bl	2017c <transfer_next_chunk>
}

static inline size_t spi_context_total_tx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
   203b4:	462a      	mov	r2, r5

	for (n = 0; n < ctx->tx_count; ++n) {
   203b6:	462b      	mov	r3, r5
   203b8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   203ba:	4283      	cmp	r3, r0
   203bc:	f040 8088 	bne.w	204d0 <spi_nrfx_transceive+0x2bc>
}

static inline size_t spi_context_total_rx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
   203c0:	2300      	movs	r3, #0

	for (n = 0; n < ctx->rx_count; ++n) {
   203c2:	4619      	mov	r1, r3
   203c4:	6c25      	ldr	r5, [r4, #64]	; 0x40
   203c6:	42a9      	cmp	r1, r5
   203c8:	f040 8089 	bne.w	204de <spi_nrfx_transceive+0x2ca>
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
   203cc:	4293      	cmp	r3, r2
   203ce:	bf38      	it	cc
   203d0:	4613      	movcc	r3, r2
				     ctx->config->frequency;
   203d2:	4626      	mov	r6, r4
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
   203d4:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
   203d8:	f04f 0800 	mov.w	r8, #0
   203dc:	fb02 f503 	mul.w	r5, r2, r3
				     ctx->config->frequency;
   203e0:	f856 3b20 	ldr.w	r3, [r6], #32
   203e4:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
   203e8:	681b      	ldr	r3, [r3, #0]
   203ea:	4641      	mov	r1, r8
   203ec:	fbb5 f5f3 	udiv	r5, r5, r3
   203f0:	f240 30e7 	movw	r0, #999	; 0x3e7
			timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
   203f4:	35c8      	adds	r5, #200	; 0xc8
   203f6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   203fa:	2300      	movs	r3, #0
   203fc:	fbe5 010c 	umlal	r0, r1, r5, ip
   20400:	f7fb fea8 	bl	1c154 <__aeabi_uldivmod>
   20404:	4602      	mov	r2, r0
   20406:	460b      	mov	r3, r1
   20408:	4630      	mov	r0, r6
   2040a:	f003 f8c5 	bl	23598 <z_impl_k_sem_take>
		if (k_sem_take(&ctx->sync, timeout)) {
   2040e:	b918      	cbnz	r0, 20418 <spi_nrfx_transceive+0x204>
		status = ctx->sync_status;
   20410:	6b25      	ldr	r5, [r4, #48]	; 0x30
		if (error == -ETIMEDOUT) {
   20412:	f115 0f74 	cmn.w	r5, #116	; 0x74
   20416:	d135      	bne.n	20484 <spi_nrfx_transceive+0x270>
			nrfx_spim_uninit(&dev_config->spim);
   20418:	9803      	ldr	r0, [sp, #12]
			dev_data->chunk_len = 0;
   2041a:	f8c4 8058 	str.w	r8, [r4, #88]	; 0x58
			nrfx_spim_uninit(&dev_config->spim);
   2041e:	f001 fa1f 	bl	21860 <nrfx_spim_uninit>
			dev_data->initialized = false;
   20422:	f884 805d 	strb.w	r8, [r4, #93]	; 0x5d
			finish_transaction(dev, -ETIMEDOUT);
   20426:	f06f 0173 	mvn.w	r1, #115	; 0x73
   2042a:	6938      	ldr	r0, [r7, #16]
   2042c:	f005 f959 	bl	256e2 <finish_transaction.isra.0>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_RESET);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_reset(sem);
   20430:	4630      	mov	r0, r6
   20432:	f003 f8d9 	bl	235e8 <z_impl_k_sem_reset>
		error = spi_context_wait_for_completion(&dev_data->ctx);
   20436:	f06f 0573 	mvn.w	r5, #115	; 0x73
}
   2043a:	e023      	b.n	20484 <spi_nrfx_transceive+0x270>
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
   2043c:	69a3      	ldr	r3, [r4, #24]
   2043e:	2b00      	cmp	r3, #0
   20440:	f47f aef6 	bne.w	20230 <spi_nrfx_transceive+0x1c>
		(k_sem_count_get(&ctx->lock) == 0) &&
   20444:	6863      	ldr	r3, [r4, #4]
   20446:	4299      	cmp	r1, r3
   20448:	f47f aef2 	bne.w	20230 <spi_nrfx_transceive+0x1c>
   2044c:	e6f9      	b.n	20242 <spi_nrfx_transceive+0x2e>
		return NRF_SPIM_FREQ_125K;
   2044e:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
   20452:	e758      	b.n	20306 <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_250K;
   20454:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
   20458:	e755      	b.n	20306 <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_500K;
   2045a:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   2045e:	e752      	b.n	20306 <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_1M;
   20460:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   20464:	e74f      	b.n	20306 <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_2M;
   20466:	f04f 5500 	mov.w	r5, #536870912	; 0x20000000
   2046a:	e74c      	b.n	20306 <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_4M;
   2046c:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
   20470:	e749      	b.n	20306 <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_8M;
   20472:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
   20476:	e746      	b.n	20306 <spi_nrfx_transceive+0xf2>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
   20478:	3b00      	subs	r3, #0
   2047a:	bf18      	it	ne
   2047c:	2301      	movne	r3, #1
   2047e:	e74d      	b.n	2031c <spi_nrfx_transceive+0x108>
		return -EIO;
   20480:	f06f 0504 	mvn.w	r5, #4
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
   20484:	6823      	ldr	r3, [r4, #0]
   20486:	889b      	ldrh	r3, [r3, #4]
   20488:	f413 5300 	ands.w	r3, r3, #8192	; 0x2000
   2048c:	d104      	bne.n	20498 <spi_nrfx_transceive+0x284>
		ctx->owner = NULL;
   2048e:	6063      	str	r3, [r4, #4]
	z_impl_k_sem_give(sem);
   20490:	f104 0010 	add.w	r0, r4, #16
   20494:	f003 f860 	bl	23558 <z_impl_k_sem_give>
	return transceive(dev, spi_cfg, tx_bufs, rx_bufs, false, NULL, NULL);
}
   20498:	4628      	mov	r0, r5
   2049a:	b00b      	add	sp, #44	; 0x2c
   2049c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -EINVAL;
   204a0:	f06f 0515 	mvn.w	r5, #21
   204a4:	e7ee      	b.n	20484 <spi_nrfx_transceive+0x270>
		return -ENOTSUP;
   204a6:	f06f 0585 	mvn.w	r5, #133	; 0x85
   204aa:	e7eb      	b.n	20484 <spi_nrfx_transceive+0x270>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
   204ac:	f8d8 3000 	ldr.w	r3, [r8]
   204b0:	6363      	str	r3, [r4, #52]	; 0x34
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
   204b2:	2b00      	cmp	r3, #0
   204b4:	f43f af58 	beq.w	20368 <spi_nrfx_transceive+0x154>
   204b8:	f8d8 3004 	ldr.w	r3, [r8, #4]
   204bc:	e755      	b.n	2036a <spi_nrfx_transceive+0x156>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
   204be:	f8da 3000 	ldr.w	r3, [sl]
   204c2:	63e3      	str	r3, [r4, #60]	; 0x3c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
   204c4:	2b00      	cmp	r3, #0
   204c6:	f43f af60 	beq.w	2038a <spi_nrfx_transceive+0x176>
   204ca:	f8da 3004 	ldr.w	r3, [sl, #4]
   204ce:	e75d      	b.n	2038c <spi_nrfx_transceive+0x178>
		total_len += ctx->current_tx[n].len;
   204d0:	6b61      	ldr	r1, [r4, #52]	; 0x34
   204d2:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   204d6:	6849      	ldr	r1, [r1, #4]
	for (n = 0; n < ctx->tx_count; ++n) {
   204d8:	3301      	adds	r3, #1
		total_len += ctx->current_tx[n].len;
   204da:	440a      	add	r2, r1
	for (n = 0; n < ctx->tx_count; ++n) {
   204dc:	e76d      	b.n	203ba <spi_nrfx_transceive+0x1a6>
		total_len += ctx->current_rx[n].len;
   204de:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   204e0:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   204e4:	6840      	ldr	r0, [r0, #4]
	for (n = 0; n < ctx->rx_count; ++n) {
   204e6:	3101      	adds	r1, #1
		total_len += ctx->current_rx[n].len;
   204e8:	4403      	add	r3, r0
	for (n = 0; n < ctx->rx_count; ++n) {
   204ea:	e76c      	b.n	203c6 <spi_nrfx_transceive+0x1b2>
   204ec:	0001e847 	.word	0x0001e847
   204f0:	00f42400 	.word	0x00f42400
   204f4:	40005000 	.word	0x40005000
   204f8:	0003d08f 	.word	0x0003d08f
   204fc:	0007a11f 	.word	0x0007a11f
   20500:	000f423f 	.word	0x000f423f
   20504:	001e847f 	.word	0x001e847f
   20508:	003d08ff 	.word	0x003d08ff
   2050c:	007a1200 	.word	0x007a1200
   20510:	01e84800 	.word	0x01e84800
   20514:	00025703 	.word	0x00025703
   20518:	0bad0000 	.word	0x0bad0000

0002051c <compare_int_lock>:
#endif
}

static bool compare_int_lock(int32_t chan)
{
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   2051c:	2301      	movs	r3, #1
   2051e:	4083      	lsls	r3, r0
{
   20520:	b570      	push	{r4, r5, r6, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   20522:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   20524:	4a0b      	ldr	r2, [pc, #44]	; (20554 <compare_int_lock+0x38>)
   20526:	e8d2 1fef 	ldaex	r1, [r2]
   2052a:	ea01 0504 	and.w	r5, r1, r4
   2052e:	e8c2 5fe6 	stlex	r6, r5, [r2]
   20532:	2e00      	cmp	r6, #0
   20534:	d1f7      	bne.n	20526 <compare_int_lock+0xa>

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   20536:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   2053a:	4082      	lsls	r2, r0
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_int_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
   2053c:	4806      	ldr	r0, [pc, #24]	; (20558 <compare_int_lock+0x3c>)
   2053e:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
   20542:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   20546:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
   2054a:	420b      	tst	r3, r1
}
   2054c:	bf14      	ite	ne
   2054e:	2001      	movne	r0, #1
   20550:	2000      	moveq	r0, #0
   20552:	bd70      	pop	{r4, r5, r6, pc}
   20554:	2000b2e0 	.word	0x2000b2e0
   20558:	40015000 	.word	0x40015000

0002055c <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
   2055c:	b470      	push	{r4, r5, r6}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint32_t dticks = (uint32_t)(expire_time - last_count) / CYC_PER_TICK;
   2055e:	490e      	ldr	r1, [pc, #56]	; (20598 <sys_clock_timeout_handler+0x3c>)
	return absolute_time & COUNTER_MAX;
   20560:	f022 467f 	bic.w	r6, r2, #4278190080	; 0xff000000
	uint32_t dticks = (uint32_t)(expire_time - last_count) / CYC_PER_TICK;
   20564:	e9d1 3400 	ldrd	r3, r4, [r1]
   20568:	1ad0      	subs	r0, r2, r3

	last_count += dticks * CYC_PER_TICK;
   2056a:	18c3      	adds	r3, r0, r3
   2056c:	f144 0400 	adc.w	r4, r4, #0
   20570:	e9c1 3400 	strd	r3, r4, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   20574:	f5a6 1300 	sub.w	r3, r6, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   20578:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   2057c:	d209      	bcs.n	20592 <sys_clock_timeout_handler+0x36>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   2057e:	4b07      	ldr	r3, [pc, #28]	; (2059c <sys_clock_timeout_handler+0x40>)
   20580:	681b      	ldr	r3, [r3, #0]
   20582:	0a1a      	lsrs	r2, r3, #8
   20584:	061b      	lsls	r3, r3, #24
   20586:	199c      	adds	r4, r3, r6
   20588:	4b05      	ldr	r3, [pc, #20]	; (205a0 <sys_clock_timeout_handler+0x44>)
   2058a:	f142 0500 	adc.w	r5, r2, #0
   2058e:	e9c3 4500 	strd	r4, r5, [r3]
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(dticks);
}
   20592:	bc70      	pop	{r4, r5, r6}
	sys_clock_announce(dticks);
   20594:	f003 bde2 	b.w	2415c <sys_clock_announce>
   20598:	2000a560 	.word	0x2000a560
   2059c:	2000b2e4 	.word	0x2000b2e4
   205a0:	2000a568 	.word	0x2000a568

000205a4 <compare_int_unlock>:
	if (key) {
   205a4:	b1d9      	cbz	r1, 205de <compare_int_unlock+0x3a>
		atomic_or(&int_mask, BIT(chan));
   205a6:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   205a8:	4a0d      	ldr	r2, [pc, #52]	; (205e0 <compare_int_unlock+0x3c>)
   205aa:	4083      	lsls	r3, r0
   205ac:	e8d2 cfef 	ldaex	ip, [r2]
   205b0:	ea4c 0c03 	orr.w	ip, ip, r3
   205b4:	e8c2 cfe1 	stlex	r1, ip, [r2]
   205b8:	2900      	cmp	r1, #0
   205ba:	d1f7      	bne.n	205ac <compare_int_unlock+0x8>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   205bc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
   205c0:	4a08      	ldr	r2, [pc, #32]	; (205e4 <compare_int_unlock+0x40>)
   205c2:	4083      	lsls	r3, r0
   205c4:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   205c8:	4b07      	ldr	r3, [pc, #28]	; (205e8 <compare_int_unlock+0x44>)
   205ca:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   205ce:	40c3      	lsrs	r3, r0
   205d0:	07db      	lsls	r3, r3, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   205d2:	bf42      	ittt	mi
   205d4:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   205d8:	4b04      	ldrmi	r3, [pc, #16]	; (205ec <compare_int_unlock+0x48>)
   205da:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   205de:	4770      	bx	lr
   205e0:	2000b2e0 	.word	0x2000b2e0
   205e4:	40015000 	.word	0x40015000
   205e8:	2000b2dc 	.word	0x2000b2dc
   205ec:	e000e100 	.word	0xe000e100

000205f0 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   205f0:	4b0d      	ldr	r3, [pc, #52]	; (20628 <z_nrf_rtc_timer_read+0x38>)
   205f2:	6818      	ldr	r0, [r3, #0]
   205f4:	0a01      	lsrs	r1, r0, #8
   205f6:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
   205f8:	f3bf 8f5f 	dmb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
   205fc:	4b0b      	ldr	r3, [pc, #44]	; (2062c <z_nrf_rtc_timer_read+0x3c>)
   205fe:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   20602:	1818      	adds	r0, r3, r0
   20604:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   20608:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   2060c:	d20a      	bcs.n	20624 <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   2060e:	4b08      	ldr	r3, [pc, #32]	; (20630 <z_nrf_rtc_timer_read+0x40>)
   20610:	e9d3 2300 	ldrd	r2, r3, [r3]
   20614:	4290      	cmp	r0, r2
   20616:	eb71 0303 	sbcs.w	r3, r1, r3
   2061a:	d203      	bcs.n	20624 <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   2061c:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   20620:	f141 0100 	adc.w	r1, r1, #0
}
   20624:	4770      	bx	lr
   20626:	bf00      	nop
   20628:	2000b2e4 	.word	0x2000b2e4
   2062c:	40015000 	.word	0x40015000
   20630:	2000a568 	.word	0x2000a568

00020634 <compare_set>:
{
   20634:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20638:	4616      	mov	r6, r2
   2063a:	461f      	mov	r7, r3
   2063c:	4604      	mov	r4, r0
	key = compare_int_lock(chan);
   2063e:	f7ff ff6d 	bl	2051c <compare_int_lock>
   20642:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   20644:	f7ff ffd4 	bl	205f0 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   20648:	42b0      	cmp	r0, r6
   2064a:	eb71 0307 	sbcs.w	r3, r1, r7
   2064e:	d250      	bcs.n	206f2 <compare_set+0xbe>
		if (target_time - curr_time > COUNTER_HALF_SPAN) {
   20650:	4b38      	ldr	r3, [pc, #224]	; (20734 <compare_set+0x100>)
   20652:	1a30      	subs	r0, r6, r0
   20654:	eb67 0101 	sbc.w	r1, r7, r1
   20658:	4298      	cmp	r0, r3
   2065a:	f171 0100 	sbcs.w	r1, r1, #0
   2065e:	d265      	bcs.n	2072c <compare_set+0xf8>
		if (target_time != cc_data[chan].target_time) {
   20660:	4b35      	ldr	r3, [pc, #212]	; (20738 <compare_set+0x104>)
   20662:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   20666:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   2066a:	429f      	cmp	r7, r3
   2066c:	bf08      	it	eq
   2066e:	4296      	cmpeq	r6, r2
   20670:	d049      	beq.n	20706 <compare_set+0xd2>
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   20672:	f44f 3980 	mov.w	r9, #65536	; 0x10000
    p_reg->EVTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   20676:	4931      	ldr	r1, [pc, #196]	; (2073c <compare_set+0x108>)
   20678:	fa09 f904 	lsl.w	r9, r9, r4
	event_clear(chan);
   2067c:	4620      	mov	r0, r4
	return absolute_time & COUNTER_MAX;
   2067e:	f026 4b7f 	bic.w	fp, r6, #4278190080	; 0xff000000
   20682:	f8c1 9348 	str.w	r9, [r1, #840]	; 0x348
	event_clear(chan);
   20686:	f005 f889 	bl	2579c <event_clear>
	uint32_t cc_inc = MIN_CYCLES_FROM_NOW;
   2068a:	f04f 0a03 	mov.w	sl, #3
	uint32_t cc_val = req_cc;
   2068e:	4658      	mov	r0, fp
	return nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   20690:	f104 0550 	add.w	r5, r4, #80	; 0x50
   20694:	00ad      	lsls	r5, r5, #2
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   20696:	b2ad      	uxth	r5, r5
   20698:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
    p_reg->CC[ch] = cc_val;
   2069c:	f504 73a8 	add.w	r3, r4, #336	; 0x150
		if (counter_sub(cc_val, now + MIN_CYCLES_FROM_NOW) >
   206a0:	4a27      	ldr	r2, [pc, #156]	; (20740 <compare_set+0x10c>)
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   206a2:	f505 35a8 	add.w	r5, r5, #86016	; 0x15000
    p_reg->CC[ch] = cc_val;
   206a6:	9301      	str	r3, [sp, #4]
   206a8:	f8dd c004 	ldr.w	ip, [sp, #4]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   206ac:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
   206b0:	f841 302c 	str.w	r3, [r1, ip, lsl #2]
    p_reg->EVTENSET = mask;
   206b4:	f8c1 9344 	str.w	r9, [r1, #836]	; 0x344
     return p_reg->COUNTER;
   206b8:	f8d1 8504 	ldr.w	r8, [r1, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   206bc:	eba0 0008 	sub.w	r0, r0, r8
   206c0:	3803      	subs	r0, #3
   206c2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		if (counter_sub(cc_val, now + MIN_CYCLES_FROM_NOW) >
   206c6:	4290      	cmp	r0, r2
   206c8:	d91d      	bls.n	20706 <compare_set+0xd2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   206ca:	6828      	ldr	r0, [r5, #0]
			if (event_check(chan)) {
   206cc:	b160      	cbz	r0, 206e8 <compare_set+0xb4>
     return p_reg->COUNTER;
   206ce:	f8d1 8504 	ldr.w	r8, [r1, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   206d2:	eba8 000b 	sub.w	r0, r8, fp
   206d6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
				if (counter_sub(now, req_cc) > COUNTER_HALF_SPAN) {
   206da:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   206de:	d912      	bls.n	20706 <compare_set+0xd2>
					event_clear(chan);
   206e0:	4620      	mov	r0, r4
   206e2:	f005 f85b 	bl	2579c <event_clear>
   206e6:	4a16      	ldr	r2, [pc, #88]	; (20740 <compare_set+0x10c>)
			cc_val = now + cc_inc;
   206e8:	eb0a 0008 	add.w	r0, sl, r8
			cc_inc++;
   206ec:	f10a 0a01 	add.w	sl, sl, #1
	for (;;) {
   206f0:	e7da      	b.n	206a8 <compare_set+0x74>
		atomic_or(&force_isr_mask, BIT(chan));
   206f2:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   206f4:	4a13      	ldr	r2, [pc, #76]	; (20744 <compare_set+0x110>)
   206f6:	40a3      	lsls	r3, r4
   206f8:	e8d2 0fef 	ldaex	r0, [r2]
   206fc:	4318      	orrs	r0, r3
   206fe:	e8c2 0fe1 	stlex	r1, r0, [r2]
   20702:	2900      	cmp	r1, #0
   20704:	d1f8      	bne.n	206f8 <compare_set+0xc4>
	return ret;
   20706:	2500      	movs	r5, #0
	cc_data[chan].target_time = target_time;
   20708:	490b      	ldr	r1, [pc, #44]	; (20738 <compare_set+0x104>)
	cc_data[chan].callback = handler;
   2070a:	980c      	ldr	r0, [sp, #48]	; 0x30
	cc_data[chan].target_time = target_time;
   2070c:	0123      	lsls	r3, r4, #4
   2070e:	eb01 1204 	add.w	r2, r1, r4, lsl #4
	cc_data[chan].callback = handler;
   20712:	50c8      	str	r0, [r1, r3]
	cc_data[chan].target_time = target_time;
   20714:	e9c2 6702 	strd	r6, r7, [r2, #8]
	cc_data[chan].user_context = user_data;
   20718:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   2071a:	6053      	str	r3, [r2, #4]
	compare_int_unlock(chan, key);
   2071c:	4620      	mov	r0, r4
   2071e:	9900      	ldr	r1, [sp, #0]
   20720:	f7ff ff40 	bl	205a4 <compare_int_unlock>
}
   20724:	4628      	mov	r0, r5
   20726:	b003      	add	sp, #12
   20728:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return -EINVAL;
   2072c:	f06f 0515 	mvn.w	r5, #21
   20730:	e7f4      	b.n	2071c <compare_set+0xe8>
   20732:	bf00      	nop
   20734:	00800001 	.word	0x00800001
   20738:	2000a550 	.word	0x2000a550
   2073c:	40015000 	.word	0x40015000
   20740:	007ffffd 	.word	0x007ffffd
   20744:	2000b2dc 	.word	0x2000b2dc

00020748 <sys_clock_driver_init>:
	int_event_disable_rtc();
	NVIC_ClearPendingIRQ(RTC_IRQn);
}

static int sys_clock_driver_init(void)
{
   20748:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
   2074a:	2500      	movs	r5, #0
	int_event_disable_rtc();

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   2074c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   20750:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    p_reg->INTENCLR = mask;
   20754:	4c18      	ldr	r4, [pc, #96]	; (207b8 <sys_clock_driver_init+0x70>)
   20756:	4b19      	ldr	r3, [pc, #100]	; (207bc <sys_clock_driver_init+0x74>)
    p_reg->INTENSET = mask;
   20758:	2602      	movs	r6, #2
    p_reg->INTENCLR = mask;
   2075a:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    p_reg->EVTENCLR = mask;
   2075e:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
   20762:	4b17      	ldr	r3, [pc, #92]	; (207c0 <sys_clock_driver_init+0x78>)
    p_reg->PRESCALER = val;
   20764:	f8c4 5508 	str.w	r5, [r4, #1288]	; 0x508
   20768:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   2076c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20770:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   20774:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   20778:	4b12      	ldr	r3, [pc, #72]	; (207c4 <sys_clock_driver_init+0x7c>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   2077a:	2101      	movs	r1, #1
   2077c:	f8c4 6304 	str.w	r6, [r4, #772]	; 0x304
   20780:	2015      	movs	r0, #21
   20782:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   20786:	462a      	mov	r2, r5
   20788:	f7fd fde6 	bl	1e358 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   2078c:	2015      	movs	r0, #21
   2078e:	f7fd fdb3 	bl	1e2f8 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   20792:	2301      	movs	r3, #1

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
   20794:	4a0c      	ldr	r2, [pc, #48]	; (207c8 <sys_clock_driver_init+0x80>)
   20796:	60a3      	str	r3, [r4, #8]
   20798:	6023      	str	r3, [r4, #0]
   2079a:	6013      	str	r3, [r2, #0]
	}

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		MAX_CYCLES : CYC_PER_TICK;

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   2079c:	4b0b      	ldr	r3, [pc, #44]	; (207cc <sys_clock_driver_init+0x84>)
   2079e:	4a0c      	ldr	r2, [pc, #48]	; (207d0 <sys_clock_driver_init+0x88>)
   207a0:	9300      	str	r3, [sp, #0]
   207a2:	4628      	mov	r0, r5
   207a4:	2300      	movs	r3, #0
   207a6:	9501      	str	r5, [sp, #4]
   207a8:	f7ff ff44 	bl	20634 <compare_set>

	z_nrf_clock_control_lf_on(mode);
   207ac:	4630      	mov	r0, r6
   207ae:	f7ff f8ef 	bl	1f990 <z_nrf_clock_control_lf_on>

	return 0;
}
   207b2:	4628      	mov	r0, r5
   207b4:	b002      	add	sp, #8
   207b6:	bd70      	pop	{r4, r5, r6, pc}
   207b8:	40015000 	.word	0x40015000
   207bc:	000f0003 	.word	0x000f0003
   207c0:	2000a550 	.word	0x2000a550
   207c4:	e000e100 	.word	0xe000e100
   207c8:	2000b2e0 	.word	0x2000b2e0
   207cc:	0002055d 	.word	0x0002055d
   207d0:	007fffff 	.word	0x007fffff

000207d4 <rtc_nrf_isr>:
{
   207d4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    return p_reg->INTENSET & mask;
   207d8:	4b2e      	ldr	r3, [pc, #184]	; (20894 <rtc_nrf_isr+0xc0>)
   207da:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   207de:	0790      	lsls	r0, r2, #30
   207e0:	d50b      	bpl.n	207fa <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   207e2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   207e6:	b142      	cbz	r2, 207fa <rtc_nrf_isr+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   207e8:	2200      	movs	r2, #0
   207ea:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		overflow_cnt++;
   207ee:	4a2a      	ldr	r2, [pc, #168]	; (20898 <rtc_nrf_isr+0xc4>)
   207f0:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   207f4:	6813      	ldr	r3, [r2, #0]
   207f6:	3301      	adds	r3, #1
   207f8:	6013      	str	r3, [r2, #0]
    return p_reg->INTENSET & mask;
   207fa:	4a26      	ldr	r2, [pc, #152]	; (20894 <rtc_nrf_isr+0xc0>)
   207fc:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   20800:	03d9      	lsls	r1, r3, #15
   20802:	d527      	bpl.n	20854 <rtc_nrf_isr+0x80>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   20804:	4b25      	ldr	r3, [pc, #148]	; (2089c <rtc_nrf_isr+0xc8>)
   20806:	e8d3 1fef 	ldaex	r1, [r3]
   2080a:	f021 0001 	bic.w	r0, r1, #1
   2080e:	e8c3 0fe4 	stlex	r4, r0, [r3]
   20812:	2c00      	cmp	r4, #0
   20814:	d1f7      	bne.n	20806 <rtc_nrf_isr+0x32>
		if ((atomic_and(&force_isr_mask, ~BIT(chan)) & BIT(chan)) ||
   20816:	07cb      	lsls	r3, r1, #31
   20818:	d402      	bmi.n	20820 <rtc_nrf_isr+0x4c>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2081a:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
   2081e:	b1cb      	cbz	r3, 20854 <rtc_nrf_isr+0x80>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   20820:	2500      	movs	r5, #0
   20822:	4c1c      	ldr	r4, [pc, #112]	; (20894 <rtc_nrf_isr+0xc0>)
   20824:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
   20828:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		curr_time = z_nrf_rtc_timer_read();
   2082c:	f7ff fee0 	bl	205f0 <z_nrf_rtc_timer_read>
   20830:	f04f 0320 	mov.w	r3, #32
   20834:	f3ef 8211 	mrs	r2, BASEPRI
   20838:	f383 8812 	msr	BASEPRI_MAX, r3
   2083c:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   20840:	4b17      	ldr	r3, [pc, #92]	; (208a0 <rtc_nrf_isr+0xcc>)
   20842:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
		if (curr_time >= expire_time) {
   20846:	42b0      	cmp	r0, r6
   20848:	41b9      	sbcs	r1, r7
   2084a:	d206      	bcs.n	2085a <rtc_nrf_isr+0x86>
	__asm__ volatile(
   2084c:	f382 8811 	msr	BASEPRI, r2
   20850:	f3bf 8f6f 	isb	sy
}
   20854:	b003      	add	sp, #12
   20856:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   2085a:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
			user_context = cc_data[chan].user_context;
   2085e:	e9d3 1000 	ldrd	r1, r0, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   20862:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			cc_data[chan].callback = NULL;
   20866:	601d      	str	r5, [r3, #0]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   20868:	e9c3 8902 	strd	r8, r9, [r3, #8]
    p_reg->EVTENCLR = mask;
   2086c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   20870:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   20874:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
   20878:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
   2087c:	f382 8811 	msr	BASEPRI, r2
   20880:	f3bf 8f6f 	isb	sy
		if (handler) {
   20884:	2900      	cmp	r1, #0
   20886:	d0e5      	beq.n	20854 <rtc_nrf_isr+0x80>
			handler(chan, expire_time, user_context);
   20888:	9000      	str	r0, [sp, #0]
   2088a:	4632      	mov	r2, r6
   2088c:	463b      	mov	r3, r7
   2088e:	4628      	mov	r0, r5
   20890:	4788      	blx	r1
   20892:	e7df      	b.n	20854 <rtc_nrf_isr+0x80>
   20894:	40015000 	.word	0x40015000
   20898:	2000b2e4 	.word	0x2000b2e4
   2089c:	2000b2dc 	.word	0x2000b2dc
   208a0:	2000a550 	.word	0x2000a550

000208a4 <sys_clock_set_timeout>:
	if (ticks == K_TICKS_FOREVER) {
   208a4:	1c43      	adds	r3, r0, #1
{
   208a6:	b513      	push	{r0, r1, r4, lr}
	if (ticks == K_TICKS_FOREVER) {
   208a8:	d021      	beq.n	208ee <sys_clock_set_timeout+0x4a>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
   208aa:	2801      	cmp	r0, #1
   208ac:	dd21      	ble.n	208f2 <sys_clock_set_timeout+0x4e>
   208ae:	4a12      	ldr	r2, [pc, #72]	; (208f8 <sys_clock_set_timeout+0x54>)
   208b0:	4b12      	ldr	r3, [pc, #72]	; (208fc <sys_clock_set_timeout+0x58>)
   208b2:	4290      	cmp	r0, r2
   208b4:	bfd4      	ite	le
   208b6:	4604      	movle	r4, r0
   208b8:	461c      	movgt	r4, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   208ba:	f7ff fe99 	bl	205f0 <z_nrf_rtc_timer_read>
   208be:	4b10      	ldr	r3, [pc, #64]	; (20900 <sys_clock_set_timeout+0x5c>)
	if (cyc > MAX_CYCLES) {
   208c0:	490e      	ldr	r1, [pc, #56]	; (208fc <sys_clock_set_timeout+0x58>)
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   208c2:	e9d3 2300 	ldrd	r2, r3, [r3]
   208c6:	1a80      	subs	r0, r0, r2
		cyc = 0;
   208c8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   208cc:	bf28      	it	cs
   208ce:	2400      	movcs	r4, #0
	cyc += unannounced;
   208d0:	4404      	add	r4, r0
	if (cyc > MAX_CYCLES) {
   208d2:	428c      	cmp	r4, r1
   208d4:	bf28      	it	cs
   208d6:	460c      	movcs	r4, r1
	uint64_t target_time = cyc + last_count;
   208d8:	2000      	movs	r0, #0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   208da:	490a      	ldr	r1, [pc, #40]	; (20904 <sys_clock_set_timeout+0x60>)
	uint64_t target_time = cyc + last_count;
   208dc:	18a2      	adds	r2, r4, r2
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   208de:	9001      	str	r0, [sp, #4]
   208e0:	9100      	str	r1, [sp, #0]
   208e2:	f143 0300 	adc.w	r3, r3, #0
   208e6:	f7ff fea5 	bl	20634 <compare_set>
}
   208ea:	b002      	add	sp, #8
   208ec:	bd10      	pop	{r4, pc}
		cyc = MAX_TICKS * CYC_PER_TICK;
   208ee:	4c03      	ldr	r4, [pc, #12]	; (208fc <sys_clock_set_timeout+0x58>)
   208f0:	e7e3      	b.n	208ba <sys_clock_set_timeout+0x16>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
   208f2:	2401      	movs	r4, #1
   208f4:	e7e1      	b.n	208ba <sys_clock_set_timeout+0x16>
   208f6:	bf00      	nop
   208f8:	007ffffe 	.word	0x007ffffe
   208fc:	007fffff 	.word	0x007fffff
   20900:	2000a560 	.word	0x2000a560
   20904:	0002055d 	.word	0x0002055d

00020908 <sys_clock_elapsed>:
{
   20908:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   2090a:	f7ff fe71 	bl	205f0 <z_nrf_rtc_timer_read>
   2090e:	4b02      	ldr	r3, [pc, #8]	; (20918 <sys_clock_elapsed+0x10>)
   20910:	681b      	ldr	r3, [r3, #0]
}
   20912:	1ac0      	subs	r0, r0, r3
   20914:	bd08      	pop	{r3, pc}
   20916:	bf00      	nop
   20918:	2000a560 	.word	0x2000a560

0002091c <tfm_ns_interface_dispatch>:
K_MUTEX_DEFINE(tfm_mutex);

int32_t tfm_ns_interface_dispatch(veneer_fn fn,
				  uint32_t arg0, uint32_t arg1,
				  uint32_t arg2, uint32_t arg3)
{
   2091c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20920:	461f      	mov	r7, r3
	return !z_sys_post_kernel;
   20922:	4b15      	ldr	r3, [pc, #84]	; (20978 <tfm_ns_interface_dispatch+0x5c>)
   20924:	4604      	mov	r4, r0
   20926:	f893 8000 	ldrb.w	r8, [r3]
   2092a:	460d      	mov	r5, r1
   2092c:	4616      	mov	r6, r2
   2092e:	b0a2      	sub	sp, #136	; 0x88
	int32_t result;
	bool is_pre_kernel = k_is_pre_kernel();
	int tfm_ns_saved_prio;

	if (!is_pre_kernel) {
   20930:	f1b8 0f00 	cmp.w	r8, #0
   20934:	d115      	bne.n	20962 <tfm_ns_interface_dispatch+0x46>
#endif
	}

	struct fpu_ctx_full context_buffer;

	z_arm_save_fp_context(&context_buffer);
   20936:	4668      	mov	r0, sp
   20938:	f004 fb27 	bl	24f8a <z_arm_save_fp_context>

	result = fn(arg0, arg1, arg2, arg3);
   2093c:	463a      	mov	r2, r7
   2093e:	4631      	mov	r1, r6
   20940:	4628      	mov	r0, r5
   20942:	9b28      	ldr	r3, [sp, #160]	; 0xa0
   20944:	47a0      	blx	r4
   20946:	4604      	mov	r4, r0

	z_arm_restore_fp_context(&context_buffer);
   20948:	4668      	mov	r0, sp
   2094a:	f004 fb1f 	bl	24f8c <z_arm_restore_fp_context>

	if (!is_pre_kernel) {
   2094e:	f1b8 0f00 	cmp.w	r8, #0
   20952:	d002      	beq.n	2095a <tfm_ns_interface_dispatch+0x3e>
	return z_impl_k_mutex_unlock(mutex);
   20954:	4809      	ldr	r0, [pc, #36]	; (2097c <tfm_ns_interface_dispatch+0x60>)
   20956:	f002 fd8f 	bl	23478 <z_impl_k_mutex_unlock>

		k_mutex_unlock(&tfm_mutex);
	}

	return result;
}
   2095a:	4620      	mov	r0, r4
   2095c:	b022      	add	sp, #136	; 0x88
   2095e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return z_impl_k_mutex_lock(mutex, timeout);
   20962:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   20966:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2096a:	4804      	ldr	r0, [pc, #16]	; (2097c <tfm_ns_interface_dispatch+0x60>)
   2096c:	f002 fd0a 	bl	23384 <z_impl_k_mutex_lock>
		if (k_mutex_lock(&tfm_mutex, K_FOREVER) != 0) {
   20970:	2800      	cmp	r0, #0
   20972:	d0e0      	beq.n	20936 <tfm_ns_interface_dispatch+0x1a>
			return (int32_t)TFM_ERROR_GENERIC;
   20974:	241f      	movs	r4, #31
   20976:	e7f0      	b.n	2095a <tfm_ns_interface_dispatch+0x3e>
   20978:	2000b62b 	.word	0x2000b62b
   2097c:	2000a2f4 	.word	0x2000a2f4

00020980 <tfm_platform_ioctl>:
enum tfm_platform_err_t
tfm_platform_ioctl(tfm_platform_ioctl_req_t request,
                   psa_invec *input, psa_outvec *output)
{
    tfm_platform_ioctl_req_t req = request;
    struct psa_invec in_vec[2] = { {0} };
   20980:	2300      	movs	r3, #0
{
   20982:	b500      	push	{lr}
   20984:	b089      	sub	sp, #36	; 0x24
    struct psa_invec in_vec[2] = { {0} };
   20986:	e9cd 3306 	strd	r3, r3, [sp, #24]
    size_t inlen, outlen;
    psa_status_t status = PSA_ERROR_CONNECTION_REFUSED;

    in_vec[0].base = &req;
   2098a:	ab03      	add	r3, sp, #12
   2098c:	9304      	str	r3, [sp, #16]
    in_vec[0].len = sizeof(req);
   2098e:	2304      	movs	r3, #4
    tfm_platform_ioctl_req_t req = request;
   20990:	9003      	str	r0, [sp, #12]
    in_vec[0].len = sizeof(req);
   20992:	9305      	str	r3, [sp, #20]
    if (input != NULL) {
   20994:	b1a9      	cbz	r1, 209c2 <tfm_platform_ioctl+0x42>
        in_vec[1].base = input->base;
   20996:	680b      	ldr	r3, [r1, #0]
   20998:	9306      	str	r3, [sp, #24]
        in_vec[1].len = input->len;
   2099a:	684b      	ldr	r3, [r1, #4]
   2099c:	9307      	str	r3, [sp, #28]
        inlen = 2;
   2099e:	2302      	movs	r3, #2
    } else {
        inlen = 1;
    }

    if (output != NULL) {
   209a0:	1e11      	subs	r1, r2, #0
   209a2:	bf18      	it	ne
   209a4:	2101      	movne	r1, #1
        outlen = 1;
    } else {
        outlen = 0;
    }

    status = psa_call(TFM_PLATFORM_SERVICE_HANDLE,
   209a6:	4808      	ldr	r0, [pc, #32]	; (209c8 <tfm_platform_ioctl+0x48>)
   209a8:	e9cd 2100 	strd	r2, r1, [sp]
   209ac:	f240 31f5 	movw	r1, #1013	; 0x3f5
   209b0:	aa04      	add	r2, sp, #16
   209b2:	f000 f82b 	bl	20a0c <psa_call>
                      TFM_PLATFORM_API_ID_IOCTL,
                      in_vec, inlen,
                      output, outlen);

    if (status < PSA_SUCCESS) {
   209b6:	2800      	cmp	r0, #0
        return TFM_PLATFORM_ERR_SYSTEM_ERROR;
    } else {
        return (enum tfm_platform_err_t)status;
    }
}
   209b8:	bfb8      	it	lt
   209ba:	2001      	movlt	r0, #1
   209bc:	b009      	add	sp, #36	; 0x24
   209be:	f85d fb04 	ldr.w	pc, [sp], #4
        inlen = 1;
   209c2:	2301      	movs	r3, #1
   209c4:	e7ec      	b.n	209a0 <tfm_platform_ioctl+0x20>
   209c6:	bf00      	nop
   209c8:	40000105 	.word	0x40000105

000209cc <psa_generate_random>:
    return API_DISPATCH_NO_OUTVEC(in_vec);
}

psa_status_t psa_generate_random(uint8_t *output,
                                 size_t output_size)
{
   209cc:	b570      	push	{r4, r5, r6, lr}
    struct tfm_crypto_pack_iovec iov = {
   209ce:	2630      	movs	r6, #48	; 0x30
{
   209d0:	b092      	sub	sp, #72	; 0x48
    struct tfm_crypto_pack_iovec iov = {
   209d2:	ab06      	add	r3, sp, #24
{
   209d4:	4605      	mov	r5, r0
   209d6:	460c      	mov	r4, r1
    struct tfm_crypto_pack_iovec iov = {
   209d8:	4632      	mov	r2, r6
   209da:	2100      	movs	r1, #0
   209dc:	4618      	mov	r0, r3
   209de:	f004 fb17 	bl	25010 <memset>

    psa_invec in_vec[] = {
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    psa_outvec out_vec[] = {
   209e2:	e9cd 5404 	strd	r5, r4, [sp, #16]
    psa_invec in_vec[] = {
   209e6:	e9cd 0602 	strd	r0, r6, [sp, #8]
        {.base = output, .len = output_size},
    };

    if (output_size == 0) {
   209ea:	b154      	cbz	r4, 20a02 <psa_generate_random+0x36>
        return PSA_SUCCESS;
    }

    return API_DISPATCH(in_vec, out_vec);
   209ec:	2301      	movs	r3, #1
   209ee:	aa04      	add	r2, sp, #16
   209f0:	9200      	str	r2, [sp, #0]
   209f2:	2100      	movs	r1, #0
   209f4:	4804      	ldr	r0, [pc, #16]	; (20a08 <psa_generate_random+0x3c>)
   209f6:	9301      	str	r3, [sp, #4]
   209f8:	aa02      	add	r2, sp, #8
   209fa:	f000 f807 	bl	20a0c <psa_call>
}
   209fe:	b012      	add	sp, #72	; 0x48
   20a00:	bd70      	pop	{r4, r5, r6, pc}
        return PSA_SUCCESS;
   20a02:	4620      	mov	r0, r4
   20a04:	e7fb      	b.n	209fe <psa_generate_random+0x32>
   20a06:	bf00      	nop
   20a08:	40000100 	.word	0x40000100

00020a0c <psa_call>:
psa_status_t psa_call(psa_handle_t handle, int32_t type,
                      const psa_invec *in_vec,
                      size_t in_len,
                      psa_outvec *out_vec,
                      size_t out_len)
{
   20a0c:	b430      	push	{r4, r5}
    if ((type > INT16_MAX) ||
   20a0e:	f501 4500 	add.w	r5, r1, #32768	; 0x8000
   20a12:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
{
   20a16:	9c03      	ldr	r4, [sp, #12]
    if ((type > INT16_MAX) ||
   20a18:	d20d      	bcs.n	20a36 <psa_call+0x2a>
        (type < INT16_MIN) ||
   20a1a:	ea43 0504 	orr.w	r5, r3, r4
   20a1e:	2dff      	cmp	r5, #255	; 0xff
   20a20:	d809      	bhi.n	20a36 <psa_call+0x2a>
    }

    return tfm_ns_interface_dispatch(
                                (veneer_fn)tfm_psa_call_veneer,
                                (uint32_t)handle,
                                PARAM_PACK(type, in_len, out_len),
   20a22:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
    return tfm_ns_interface_dispatch(
   20a26:	4613      	mov	r3, r2
   20a28:	ea44 4201 	orr.w	r2, r4, r1, lsl #16
   20a2c:	4601      	mov	r1, r0
                                (uint32_t)in_vec,
                                (uint32_t)out_vec);
}
   20a2e:	bc30      	pop	{r4, r5}
    return tfm_ns_interface_dispatch(
   20a30:	4803      	ldr	r0, [pc, #12]	; (20a40 <psa_call+0x34>)
   20a32:	f7ff bf73 	b.w	2091c <tfm_ns_interface_dispatch>
}
   20a36:	f06f 0080 	mvn.w	r0, #128	; 0x80
   20a3a:	bc30      	pop	{r4, r5}
   20a3c:	4770      	bx	lr
   20a3e:	bf00      	nop
   20a40:	00017c11 	.word	0x00017c11

00020a44 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   20a44:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   20a46:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   20a48:	6802      	ldr	r2, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   20a4a:	fab2 f382 	clz	r3, r2
   20a4e:	f1c3 031f 	rsb	r3, r3, #31
   20a52:	b2db      	uxtb	r3, r3
        new_mask = prev_mask & ~NRFX_BIT(idx);
   20a54:	fa05 f403 	lsl.w	r4, r5, r3
   20a58:	ea22 0404 	bic.w	r4, r2, r4
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   20a5c:	e8d0 6fef 	ldaex	r6, [r0]
   20a60:	4296      	cmp	r6, r2
   20a62:	d104      	bne.n	20a6e <nrfx_flag32_alloc+0x2a>
   20a64:	e8c0 4fec 	stlex	ip, r4, [r0]
   20a68:	f1bc 0f00 	cmp.w	ip, #0
   20a6c:	d1f6      	bne.n	20a5c <nrfx_flag32_alloc+0x18>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   20a6e:	d1eb      	bne.n	20a48 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
}
   20a70:	4801      	ldr	r0, [pc, #4]	; (20a78 <nrfx_flag32_alloc+0x34>)
    *p_flag = idx;
   20a72:	700b      	strb	r3, [r1, #0]
}
   20a74:	bd70      	pop	{r4, r5, r6, pc}
   20a76:	bf00      	nop
   20a78:	0bad0000 	.word	0x0bad0000

00020a7c <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
   20a7c:	b510      	push	{r4, lr}
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   20a7e:	6803      	ldr	r3, [r0, #0]
   20a80:	40cb      	lsrs	r3, r1
   20a82:	07db      	lsls	r3, r3, #31
   20a84:	d410      	bmi.n	20aa8 <nrfx_flag32_free+0x2c>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   20a86:	2301      	movs	r3, #1
   20a88:	408b      	lsls	r3, r1
        prev_mask = *p_mask;
   20a8a:	6802      	ldr	r2, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   20a8c:	ea43 0102 	orr.w	r1, r3, r2
   20a90:	e8d0 4fef 	ldaex	r4, [r0]
   20a94:	4294      	cmp	r4, r2
   20a96:	d104      	bne.n	20aa2 <nrfx_flag32_free+0x26>
   20a98:	e8c0 1fec 	stlex	ip, r1, [r0]
   20a9c:	f1bc 0f00 	cmp.w	ip, #0
   20aa0:	d1f6      	bne.n	20a90 <nrfx_flag32_free+0x14>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   20aa2:	d1f2      	bne.n	20a8a <nrfx_flag32_free+0xe>

    return NRFX_SUCCESS;
   20aa4:	4801      	ldr	r0, [pc, #4]	; (20aac <nrfx_flag32_free+0x30>)
}
   20aa6:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   20aa8:	4801      	ldr	r0, [pc, #4]	; (20ab0 <nrfx_flag32_free+0x34>)
   20aaa:	e7fc      	b.n	20aa6 <nrfx_flag32_free+0x2a>
   20aac:	0bad0000 	.word	0x0bad0000
   20ab0:	0bad0004 	.word	0x0bad0004

00020ab4 <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
   20ab4:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch (domain)
   20ab6:	2803      	cmp	r0, #3
   20ab8:	f200 80a0 	bhi.w	20bfc <clock_stop+0x148>
   20abc:	e8df f000 	tbb	[pc, r0]
   20ac0:	32251802 	.word	0x32251802
    p_reg->INTENCLR = mask;
   20ac4:	2202      	movs	r2, #2
   20ac6:	4b59      	ldr	r3, [pc, #356]	; (20c2c <clock_stop+0x178>)
   20ac8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20acc:	2200      	movs	r2, #0
   20ace:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   20ad2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20ad6:	2201      	movs	r2, #1
   20ad8:	60da      	str	r2, [r3, #12]
            return;
    }

    bool stopped;
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   20ada:	2400      	movs	r4, #0
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
   20adc:	2301      	movs	r3, #1
   20ade:	f88d 3007 	strb.w	r3, [sp, #7]
    switch (domain)
   20ae2:	2803      	cmp	r0, #3
   20ae4:	f200 808a 	bhi.w	20bfc <clock_stop+0x148>
   20ae8:	e8df f000 	tbb	[pc, r0]
   20aec:	94736529 	.word	0x94736529
    p_reg->INTENCLR = mask;
   20af0:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20af2:	2100      	movs	r1, #0
    p_reg->INTENCLR = mask;
   20af4:	4b4d      	ldr	r3, [pc, #308]	; (20c2c <clock_stop+0x178>)
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   20af6:	f10d 0407 	add.w	r4, sp, #7
   20afa:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20afe:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
   20b02:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20b06:	605a      	str	r2, [r3, #4]
   20b08:	e7e8      	b.n	20adc <clock_stop+0x28>
    p_reg->INTENCLR = mask;
   20b0a:	f44f 7200 	mov.w	r2, #512	; 0x200
   20b0e:	4b47      	ldr	r3, [pc, #284]	; (20c2c <clock_stop+0x178>)
   20b10:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20b14:	2200      	movs	r2, #0
   20b16:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   20b1a:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20b1e:	2201      	movs	r2, #1
   20b20:	625a      	str	r2, [r3, #36]	; 0x24
   20b22:	e7da      	b.n	20ada <clock_stop+0x26>
    p_reg->INTENCLR = mask;
   20b24:	f44f 7280 	mov.w	r2, #256	; 0x100
   20b28:	4b40      	ldr	r3, [pc, #256]	; (20c2c <clock_stop+0x178>)
   20b2a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20b2e:	2200      	movs	r2, #0
   20b30:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   20b34:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20b38:	2201      	movs	r2, #1
   20b3a:	61da      	str	r2, [r3, #28]
   20b3c:	e7cd      	b.n	20ada <clock_stop+0x26>
    switch (domain)
   20b3e:	f242 7510 	movw	r5, #10000	; 0x2710
   20b42:	4e3a      	ldr	r6, [pc, #232]	; (20c2c <clock_stop+0x178>)
            if (p_clk_src != NULL)
   20b44:	b36c      	cbz	r4, 20ba2 <clock_stop+0xee>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20b46:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   20b4a:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
   20b4e:	7023      	strb	r3, [r4, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20b50:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   20b54:	03d9      	lsls	r1, r3, #15
   20b56:	d551      	bpl.n	20bfc <clock_stop+0x148>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   20b58:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20b5c:	2801      	cmp	r0, #1
   20b5e:	d14d      	bne.n	20bfc <clock_stop+0x148>
   20b60:	f004 fe67 	bl	25832 <nrfx_busy_wait>
   20b64:	3d01      	subs	r5, #1
   20b66:	d1ed      	bne.n	20b44 <clock_stop+0x90>
   20b68:	e048      	b.n	20bfc <clock_stop+0x148>
   20b6a:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20b6e:	2801      	cmp	r0, #1
   20b70:	d144      	bne.n	20bfc <clock_stop+0x148>
   20b72:	f004 fe5e 	bl	25832 <nrfx_busy_wait>
   20b76:	3d01      	subs	r5, #1
   20b78:	d14f      	bne.n	20c1a <clock_stop+0x166>
   20b7a:	e03f      	b.n	20bfc <clock_stop+0x148>
   20b7c:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20b80:	2801      	cmp	r0, #1
   20b82:	d13b      	bne.n	20bfc <clock_stop+0x148>
   20b84:	f004 fe55 	bl	25832 <nrfx_busy_wait>
   20b88:	3d01      	subs	r5, #1
   20b8a:	d037      	beq.n	20bfc <clock_stop+0x148>
            if (p_clk_src != NULL)
   20b8c:	b1bc      	cbz	r4, 20bbe <clock_stop+0x10a>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   20b8e:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   20b92:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
   20b96:	7023      	strb	r3, [r4, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   20b98:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   20b9c:	03db      	lsls	r3, r3, #15
   20b9e:	d52d      	bpl.n	20bfc <clock_stop+0x148>
   20ba0:	e7ec      	b.n	20b7c <clock_stop+0xc8>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20ba2:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   20ba6:	03da      	lsls	r2, r3, #15
   20ba8:	d528      	bpl.n	20bfc <clock_stop+0x148>
   20baa:	2001      	movs	r0, #1
   20bac:	f004 fe41 	bl	25832 <nrfx_busy_wait>
   20bb0:	3d01      	subs	r5, #1
   20bb2:	d1f6      	bne.n	20ba2 <clock_stop+0xee>
   20bb4:	e022      	b.n	20bfc <clock_stop+0x148>
    switch (domain)
   20bb6:	f242 7510 	movw	r5, #10000	; 0x2710
   20bba:	4e1c      	ldr	r6, [pc, #112]	; (20c2c <clock_stop+0x178>)
   20bbc:	e7e6      	b.n	20b8c <clock_stop+0xd8>
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   20bbe:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   20bc2:	03d8      	lsls	r0, r3, #15
   20bc4:	d51a      	bpl.n	20bfc <clock_stop+0x148>
   20bc6:	2001      	movs	r0, #1
   20bc8:	f004 fe33 	bl	25832 <nrfx_busy_wait>
   20bcc:	3d01      	subs	r5, #1
   20bce:	d1f6      	bne.n	20bbe <clock_stop+0x10a>
   20bd0:	e014      	b.n	20bfc <clock_stop+0x148>
    switch (domain)
   20bd2:	f242 7510 	movw	r5, #10000	; 0x2710
   20bd6:	4e15      	ldr	r6, [pc, #84]	; (20c2c <clock_stop+0x178>)
            if (p_clk_src != NULL)
   20bd8:	b194      	cbz	r4, 20c00 <clock_stop+0x14c>
                    (nrf_clock_hfclk_t)((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_SRC_Msk)
   20bda:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
   20bde:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
   20be2:	7023      	strb	r3, [r4, #0]
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
   20be4:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
   20be8:	03d9      	lsls	r1, r3, #15
   20bea:	d507      	bpl.n	20bfc <clock_stop+0x148>
   20bec:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20bf0:	2801      	cmp	r0, #1
   20bf2:	d103      	bne.n	20bfc <clock_stop+0x148>
   20bf4:	f004 fe1d 	bl	25832 <nrfx_busy_wait>
   20bf8:	3d01      	subs	r5, #1
   20bfa:	d1ed      	bne.n	20bd8 <clock_stop+0x124>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   20bfc:	b002      	add	sp, #8
   20bfe:	bd70      	pop	{r4, r5, r6, pc}
   20c00:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
   20c04:	03da      	lsls	r2, r3, #15
   20c06:	d5f9      	bpl.n	20bfc <clock_stop+0x148>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   20c08:	2001      	movs	r0, #1
   20c0a:	f004 fe12 	bl	25832 <nrfx_busy_wait>
   20c0e:	3d01      	subs	r5, #1
   20c10:	d1f6      	bne.n	20c00 <clock_stop+0x14c>
   20c12:	e7f3      	b.n	20bfc <clock_stop+0x148>
    switch (domain)
   20c14:	f242 7510 	movw	r5, #10000	; 0x2710
            return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
   20c18:	4e04      	ldr	r6, [pc, #16]	; (20c2c <clock_stop+0x178>)
   20c1a:	f8d6 3454 	ldr.w	r3, [r6, #1108]	; 0x454
   20c1e:	03db      	lsls	r3, r3, #15
   20c20:	d5ec      	bpl.n	20bfc <clock_stop+0x148>
   20c22:	2c00      	cmp	r4, #0
   20c24:	d1a1      	bne.n	20b6a <clock_stop+0xb6>
   20c26:	2001      	movs	r0, #1
   20c28:	e7a3      	b.n	20b72 <clock_stop+0xbe>
   20c2a:	bf00      	nop
   20c2c:	40005000 	.word	0x40005000

00020c30 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   20c30:	4b04      	ldr	r3, [pc, #16]	; (20c44 <nrfx_clock_init+0x14>)
   20c32:	791a      	ldrb	r2, [r3, #4]
   20c34:	b922      	cbnz	r2, 20c40 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   20c36:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   20c38:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   20c3a:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   20c3c:	4802      	ldr	r0, [pc, #8]	; (20c48 <nrfx_clock_init+0x18>)
   20c3e:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   20c40:	4802      	ldr	r0, [pc, #8]	; (20c4c <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   20c42:	4770      	bx	lr
   20c44:	2000b2e8 	.word	0x2000b2e8
   20c48:	0bad0000 	.word	0x0bad0000
   20c4c:	0bad000c 	.word	0x0bad000c

00020c50 <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
   20c50:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   20c52:	2005      	movs	r0, #5
   20c54:	f7fd fb72 	bl	1e33c <arch_irq_is_enabled>
   20c58:	b910      	cbnz	r0, 20c60 <nrfx_clock_enable+0x10>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   20c5a:	2005      	movs	r0, #5
   20c5c:	f7fd fb4c 	bl	1e2f8 <arch_irq_enable>
    p_reg->LFCLKSRC = (uint32_t)(source);
   20c60:	2301      	movs	r3, #1
   20c62:	4a05      	ldr	r2, [pc, #20]	; (20c78 <nrfx_clock_enable+0x28>)
   20c64:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    p_reg->HFCLKSRC = (uint32_t)(source);
   20c68:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
                                   >> CLOCK_HFCLK192MCTRL_HCLK192M_Pos);
}

NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLK192MSRC = (uint32_t)(source);
   20c6c:	f8c2 3580 	str.w	r3, [r2, #1408]	; 0x580
#endif
#if NRF_CLOCK_HAS_HFCLK192M
    nrf_clock_hfclk192m_src_set(NRF_CLOCK, (nrf_clock_hfclk_t)NRFX_CLOCK_CONFIG_HFCLK192M_SRC);
#endif
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
   20c70:	4a02      	ldr	r2, [pc, #8]	; (20c7c <nrfx_clock_enable+0x2c>)
   20c72:	7013      	strb	r3, [r2, #0]
#endif

    NRFX_LOG_INFO("Module enabled.");
}
   20c74:	bd08      	pop	{r3, pc}
   20c76:	bf00      	nop
   20c78:	40005000 	.word	0x40005000
   20c7c:	2000b625 	.word	0x2000b625

00020c80 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
   20c80:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   20c82:	2803      	cmp	r0, #3
   20c84:	d818      	bhi.n	20cb8 <nrfx_clock_start+0x38>
   20c86:	e8df f000 	tbb	[pc, r0]
   20c8a:	3002      	.short	0x3002
   20c8c:	483b      	.short	0x483b
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20c8e:	4a29      	ldr	r2, [pc, #164]	; (20d34 <nrfx_clock_start+0xb4>)
   20c90:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20c94:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   20c98:	03c9      	lsls	r1, r1, #15
   20c9a:	d40e      	bmi.n	20cba <nrfx_clock_start+0x3a>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
   20c9c:	f8d2 3414 	ldr.w	r3, [r2, #1044]	; 0x414
                    // LF clock is already running. Inspect its source.
                    // If LF clock source is inappropriate then it will be stopped and modified.
                    // Ignore return value as LF clock will be started again regardless of the result.
                    (void)clock_lfclksrc_tweak(&lfclksrc);
                }
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
   20ca0:	07db      	lsls	r3, r3, #31
   20ca2:	d513      	bpl.n	20ccc <nrfx_clock_start+0x4c>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   20ca4:	f8d2 341c 	ldr.w	r3, [r2, #1052]	; 0x41c
   20ca8:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   20cac:	3b01      	subs	r3, #1
   20cae:	2b01      	cmp	r3, #1
   20cb0:	d809      	bhi.n	20cc6 <nrfx_clock_start+0x46>
    p_reg->INTENSET = mask;
   20cb2:	2302      	movs	r3, #2
   20cb4:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   20cb8:	bd08      	pop	{r3, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20cba:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   20cbe:	2b02      	cmp	r3, #2
   20cc0:	d005      	beq.n	20cce <nrfx_clock_start+0x4e>
   20cc2:	2b01      	cmp	r3, #1
   20cc4:	d002      	beq.n	20ccc <nrfx_clock_start+0x4c>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   20cc6:	2000      	movs	r0, #0
   20cc8:	f7ff fef4 	bl	20ab4 <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
   20ccc:	2301      	movs	r3, #1
    p_reg->LFCLKSRC = (uint32_t)(source);
   20cce:	4a19      	ldr	r2, [pc, #100]	; (20d34 <nrfx_clock_start+0xb4>)
   20cd0:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20cd4:	2300      	movs	r3, #0
   20cd6:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
   20cda:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    p_reg->INTENSET = mask;
   20cde:	2302      	movs	r3, #2
   20ce0:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20ce4:	2301      	movs	r3, #1
   20ce6:	6093      	str	r3, [r2, #8]
}
   20ce8:	e7e6      	b.n	20cb8 <nrfx_clock_start+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20cea:	2200      	movs	r2, #0
   20cec:	4b11      	ldr	r3, [pc, #68]	; (20d34 <nrfx_clock_start+0xb4>)
   20cee:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   20cf2:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   20cf6:	2201      	movs	r2, #1
   20cf8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20cfc:	601a      	str	r2, [r3, #0]
}
   20cfe:	e7db      	b.n	20cb8 <nrfx_clock_start+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d00:	2200      	movs	r2, #0
   20d02:	4b0c      	ldr	r3, [pc, #48]	; (20d34 <nrfx_clock_start+0xb4>)
   20d04:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   20d08:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENSET = mask;
   20d0c:	f44f 7200 	mov.w	r2, #512	; 0x200
   20d10:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20d14:	2201      	movs	r2, #1
   20d16:	621a      	str	r2, [r3, #32]
}
   20d18:	e7ce      	b.n	20cb8 <nrfx_clock_start+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d1a:	2200      	movs	r2, #0
   20d1c:	4b05      	ldr	r3, [pc, #20]	; (20d34 <nrfx_clock_start+0xb4>)
   20d1e:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   20d22:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENSET = mask;
   20d26:	f44f 7280 	mov.w	r2, #256	; 0x100
   20d2a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20d2e:	2201      	movs	r2, #1
   20d30:	619a      	str	r2, [r3, #24]
}
   20d32:	e7c1      	b.n	20cb8 <nrfx_clock_start+0x38>
   20d34:	40005000 	.word	0x40005000

00020d38 <nrfx_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   20d38:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d3a:	4b28      	ldr	r3, [pc, #160]	; (20ddc <nrfx_clock_irq_handler+0xa4>)
   20d3c:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   20d40:	b152      	cbz	r2, 20d58 <nrfx_clock_irq_handler+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d42:	2000      	movs	r0, #0
   20d44:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
   20d48:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
   20d4c:	2201      	movs	r2, #1
   20d4e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   20d52:	4b23      	ldr	r3, [pc, #140]	; (20de0 <nrfx_clock_irq_handler+0xa8>)
   20d54:	681b      	ldr	r3, [r3, #0]
   20d56:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d58:	4b20      	ldr	r3, [pc, #128]	; (20ddc <nrfx_clock_irq_handler+0xa4>)
   20d5a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   20d5e:	b18a      	cbz	r2, 20d84 <nrfx_clock_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d60:	2200      	movs	r2, #0
   20d62:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   20d66:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20d6a:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20d6e:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   20d72:	f002 0203 	and.w	r2, r2, #3
   20d76:	2a01      	cmp	r2, #1
   20d78:	f04f 0102 	mov.w	r1, #2
   20d7c:	d126      	bne.n	20dcc <nrfx_clock_irq_handler+0x94>
    p_reg->LFCLKSRC = (uint32_t)(source);
   20d7e:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20d82:	609a      	str	r2, [r3, #8]
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d84:	4b15      	ldr	r3, [pc, #84]	; (20ddc <nrfx_clock_irq_handler+0xa4>)
   20d86:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_CAL_DONE);
    }
#endif // NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)

#if NRF_CLOCK_HAS_HFCLKAUDIO
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED))
   20d8a:	b162      	cbz	r2, 20da6 <nrfx_clock_irq_handler+0x6e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d8c:	2200      	movs	r2, #0
   20d8e:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   20d92:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENCLR = mask;
   20d96:	f44f 7280 	mov.w	r2, #256	; 0x100
   20d9a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLKAUDIO_STARTED);
   20d9e:	4b10      	ldr	r3, [pc, #64]	; (20de0 <nrfx_clock_irq_handler+0xa8>)
   20da0:	2004      	movs	r0, #4
   20da2:	681b      	ldr	r3, [r3, #0]
   20da4:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20da6:	4b0d      	ldr	r3, [pc, #52]	; (20ddc <nrfx_clock_irq_handler+0xa4>)
   20da8:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    }
#endif

#if NRF_CLOCK_HAS_HFCLK192M
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED))
   20dac:	b1aa      	cbz	r2, 20dda <nrfx_clock_irq_handler+0xa2>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20dae:	2200      	movs	r2, #0
   20db0:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   20db4:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENCLR = mask;
   20db8:	f44f 7200 	mov.w	r2, #512	; 0x200
   20dbc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLK192MSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
   20dc0:	4b07      	ldr	r3, [pc, #28]	; (20de0 <nrfx_clock_irq_handler+0xa8>)
   20dc2:	2005      	movs	r0, #5
    }
#endif
}
   20dc4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
   20dc8:	681b      	ldr	r3, [r3, #0]
   20dca:	4718      	bx	r3
   20dcc:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   20dd0:	4b03      	ldr	r3, [pc, #12]	; (20de0 <nrfx_clock_irq_handler+0xa8>)
   20dd2:	2001      	movs	r0, #1
   20dd4:	681b      	ldr	r3, [r3, #0]
   20dd6:	4798      	blx	r3
   20dd8:	e7d4      	b.n	20d84 <nrfx_clock_irq_handler+0x4c>
}
   20dda:	bd10      	pop	{r4, pc}
   20ddc:	40005000 	.word	0x40005000
   20de0:	2000b2e8 	.word	0x2000b2e8

00020de4 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
   20de4:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
   20de6:	f003 021f 	and.w	r2, r3, #31
   20dea:	6002      	str	r2, [r0, #0]
}
   20dec:	4a03      	ldr	r2, [pc, #12]	; (20dfc <nrf_gpio_pin_port_decode+0x18>)
   20dee:	4804      	ldr	r0, [pc, #16]	; (20e00 <nrf_gpio_pin_port_decode+0x1c>)
    return pin_number >> 5;
   20df0:	095b      	lsrs	r3, r3, #5
}
   20df2:	2b01      	cmp	r3, #1
   20df4:	bf18      	it	ne
   20df6:	4610      	movne	r0, r2
   20df8:	4770      	bx	lr
   20dfa:	bf00      	nop
   20dfc:	40842500 	.word	0x40842500
   20e00:	40842800 	.word	0x40842800

00020e04 <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   20e04:	4b03      	ldr	r3, [pc, #12]	; (20e14 <pin_in_use_by_te+0x10>)
   20e06:	3008      	adds	r0, #8
   20e08:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   20e0c:	f3c0 1040 	ubfx	r0, r0, #5, #1
   20e10:	4770      	bx	lr
   20e12:	bf00      	nop
   20e14:	2000a208 	.word	0x2000a208

00020e18 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   20e18:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e1a:	4c0d      	ldr	r4, [pc, #52]	; (20e50 <call_handler+0x38>)
   20e1c:	f100 0308 	add.w	r3, r0, #8
   20e20:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
   20e24:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e26:	05da      	lsls	r2, r3, #23
{
   20e28:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e2a:	d507      	bpl.n	20e3c <call_handler+0x24>
   20e2c:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   20e30:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   20e34:	6852      	ldr	r2, [r2, #4]
   20e36:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   20e3a:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   20e3c:	68a3      	ldr	r3, [r4, #8]
   20e3e:	b12b      	cbz	r3, 20e4c <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   20e40:	4631      	mov	r1, r6
   20e42:	4628      	mov	r0, r5
   20e44:	68e2      	ldr	r2, [r4, #12]
    }
}
   20e46:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   20e4a:	4718      	bx	r3
}
   20e4c:	bd70      	pop	{r4, r5, r6, pc}
   20e4e:	bf00      	nop
   20e50:	2000a208 	.word	0x2000a208

00020e54 <release_handler>:
{
   20e54:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e56:	4a12      	ldr	r2, [pc, #72]	; (20ea0 <release_handler+0x4c>)
   20e58:	3008      	adds	r0, #8
   20e5a:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
   20e5e:	05d9      	lsls	r1, r3, #23
   20e60:	d51b      	bpl.n	20e9a <release_handler+0x46>
   20e62:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   20e66:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   20e6a:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   20e6e:	2000      	movs	r0, #0
   20e70:	f102 040e 	add.w	r4, r2, #14
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   20e74:	f834 3f02 	ldrh.w	r3, [r4, #2]!
   20e78:	f413 7f80 	tst.w	r3, #256	; 0x100
   20e7c:	d003      	beq.n	20e86 <release_handler+0x32>
   20e7e:	f3c3 2343 	ubfx	r3, r3, #9, #4
   20e82:	4299      	cmp	r1, r3
   20e84:	d009      	beq.n	20e9a <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   20e86:	3001      	adds	r0, #1
   20e88:	2830      	cmp	r0, #48	; 0x30
   20e8a:	d1f3      	bne.n	20e74 <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   20e8c:	2300      	movs	r3, #0
   20e8e:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   20e92:	4804      	ldr	r0, [pc, #16]	; (20ea4 <release_handler+0x50>)
}
   20e94:	bc10      	pop	{r4}
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   20e96:	f7ff bdf1 	b.w	20a7c <nrfx_flag32_free>
}
   20e9a:	bc10      	pop	{r4}
   20e9c:	4770      	bx	lr
   20e9e:	bf00      	nop
   20ea0:	2000a208 	.word	0x2000a208
   20ea4:	2000a27c 	.word	0x2000a27c

00020ea8 <pin_handler_trigger_uninit>:
{
   20ea8:	b538      	push	{r3, r4, r5, lr}
   20eaa:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   20eac:	f7ff ffaa 	bl	20e04 <pin_in_use_by_te>
   20eb0:	4c0b      	ldr	r4, [pc, #44]	; (20ee0 <pin_handler_trigger_uninit+0x38>)
   20eb2:	f102 0508 	add.w	r5, r2, #8
   20eb6:	b160      	cbz	r0, 20ed2 <pin_handler_trigger_uninit+0x2a>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   20eb8:	2100      	movs	r1, #0
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   20eba:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   20ebe:	0b5b      	lsrs	r3, r3, #13
   20ec0:	009b      	lsls	r3, r3, #2
   20ec2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   20ec6:	f503 333c 	add.w	r3, r3, #192512	; 0x2f000
   20eca:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
#if defined(NRF53_SERIES) || defined(NRF91_SERIES)
    p_reg->CONFIG[idx] = 0;
   20ece:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
    release_handler(pin);
   20ed2:	4610      	mov	r0, r2
   20ed4:	f7ff ffbe 	bl	20e54 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   20ed8:	2300      	movs	r3, #0
   20eda:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   20ede:	bd38      	pop	{r3, r4, r5, pc}
   20ee0:	2000a208 	.word	0x2000a208

00020ee4 <nrfx_gpiote_input_configure>:
{
   20ee4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   20ee8:	4604      	mov	r4, r0
   20eea:	4690      	mov	r8, r2
   20eec:	461d      	mov	r5, r3
    if (p_input_config)
   20eee:	b301      	cbz	r1, 20f32 <nrfx_gpiote_input_configure+0x4e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   20ef0:	4e4f      	ldr	r6, [pc, #316]	; (21030 <nrfx_gpiote_input_configure+0x14c>)
   20ef2:	f100 0708 	add.w	r7, r0, #8
    return pin_is_output(pin) && pin_in_use_by_te(pin);
   20ef6:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   20efa:	079b      	lsls	r3, r3, #30
   20efc:	d502      	bpl.n	20f04 <nrfx_gpiote_input_configure+0x20>
   20efe:	f7ff ff81 	bl	20e04 <pin_in_use_by_te>
   20f02:	bb28      	cbnz	r0, 20f50 <nrfx_gpiote_input_configure+0x6c>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
   20f04:	2300      	movs	r3, #0
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
   20f06:	4620      	mov	r0, r4
   20f08:	e9cd 3300 	strd	r3, r3, [sp]
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
   20f0c:	f88d 300e 	strb.w	r3, [sp, #14]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
   20f10:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
   20f14:	f10d 020f 	add.w	r2, sp, #15
   20f18:	460b      	mov	r3, r1
   20f1a:	f10d 010e 	add.w	r1, sp, #14
   20f1e:	f004 fc8c 	bl	2583a <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   20f22:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   20f26:	f023 0302 	bic.w	r3, r3, #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   20f2a:	f043 0301 	orr.w	r3, r3, #1
   20f2e:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_trigger_config)
   20f32:	f1b8 0f00 	cmp.w	r8, #0
   20f36:	d02d      	beq.n	20f94 <nrfx_gpiote_input_configure+0xb0>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   20f38:	4e3d      	ldr	r6, [pc, #244]	; (21030 <nrfx_gpiote_input_configure+0x14c>)
   20f3a:	f104 0708 	add.w	r7, r4, #8
   20f3e:	f836 1017 	ldrh.w	r1, [r6, r7, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   20f42:	f898 0000 	ldrb.w	r0, [r8]
        if (pin_is_output(pin))
   20f46:	078a      	lsls	r2, r1, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   20f48:	f8d8 3004 	ldr.w	r3, [r8, #4]
        if (pin_is_output(pin))
   20f4c:	d502      	bpl.n	20f54 <nrfx_gpiote_input_configure+0x70>
            if (use_evt)
   20f4e:	b1cb      	cbz	r3, 20f84 <nrfx_gpiote_input_configure+0xa0>
            return NRFX_ERROR_INVALID_PARAM;
   20f50:	4838      	ldr	r0, [pc, #224]	; (21034 <nrfx_gpiote_input_configure+0x150>)
   20f52:	e021      	b.n	20f98 <nrfx_gpiote_input_configure+0xb4>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   20f54:	f021 0120 	bic.w	r1, r1, #32
   20f58:	04c9      	lsls	r1, r1, #19
   20f5a:	0cc9      	lsrs	r1, r1, #19
   20f5c:	f826 1017 	strh.w	r1, [r6, r7, lsl #1]
            if (use_evt)
   20f60:	b183      	cbz	r3, 20f84 <nrfx_gpiote_input_configure+0xa0>
                if (!edge)
   20f62:	2803      	cmp	r0, #3
   20f64:	d8f4      	bhi.n	20f50 <nrfx_gpiote_input_configure+0x6c>
                uint8_t ch = *p_trigger_config->p_in_channel;
   20f66:	f8d8 3004 	ldr.w	r3, [r8, #4]
   20f6a:	f893 c000 	ldrb.w	ip, [r3]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   20f6e:	4662      	mov	r2, ip
   20f70:	0092      	lsls	r2, r2, #2
   20f72:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   20f76:	f502 323c 	add.w	r2, r2, #192512	; 0x2f000
   20f7a:	b980      	cbnz	r0, 20f9e <nrfx_gpiote_input_configure+0xba>
    p_reg->CONFIG[idx] = 0;
   20f7c:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
   20f80:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   20f84:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   20f88:	f023 031c 	bic.w	r3, r3, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   20f8c:	ea43 0380 	orr.w	r3, r3, r0, lsl #2
   20f90:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_handler_config)
   20f94:	bb1d      	cbnz	r5, 20fde <nrfx_gpiote_input_configure+0xfa>
        err = NRFX_SUCCESS;
   20f96:	4828      	ldr	r0, [pc, #160]	; (21038 <nrfx_gpiote_input_configure+0x154>)
}
   20f98:	b004      	add	sp, #16
   20f9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   20f9e:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   20fa2:	ea41 314c 	orr.w	r1, r1, ip, lsl #13
   20fa6:	f023 0303 	bic.w	r3, r3, #3
   20faa:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   20fae:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
   20fb2:	f041 0120 	orr.w	r1, r1, #32
   20fb6:	f423 334f 	bic.w	r3, r3, #211968	; 0x33c00
   20fba:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   20fbe:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   20fc2:	0223      	lsls	r3, r4, #8
   20fc4:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
   20fc8:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
   20fcc:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   20fd0:	ea43 030e 	orr.w	r3, r3, lr
   20fd4:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
   20fd8:	f826 1017 	strh.w	r1, [r6, r7, lsl #1]
   20fdc:	e7d2      	b.n	20f84 <nrfx_gpiote_input_configure+0xa0>
    release_handler(pin);
   20fde:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   20fe0:	e9d5 6700 	ldrd	r6, r7, [r5]
    release_handler(pin);
   20fe4:	f7ff ff36 	bl	20e54 <release_handler>
    if (!handler)
   20fe8:	2e00      	cmp	r6, #0
   20fea:	d0d4      	beq.n	20f96 <nrfx_gpiote_input_configure+0xb2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   20fec:	4d10      	ldr	r5, [pc, #64]	; (21030 <nrfx_gpiote_input_configure+0x14c>)
   20fee:	e9d5 2300 	ldrd	r2, r3, [r5]
   20ff2:	4296      	cmp	r6, r2
   20ff4:	d101      	bne.n	20ffa <nrfx_gpiote_input_configure+0x116>
   20ff6:	429f      	cmp	r7, r3
   20ff8:	d018      	beq.n	2102c <nrfx_gpiote_input_configure+0x148>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   20ffa:	4810      	ldr	r0, [pc, #64]	; (2103c <nrfx_gpiote_input_configure+0x158>)
   20ffc:	f10d 010f 	add.w	r1, sp, #15
   21000:	f7ff fd20 	bl	20a44 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   21004:	4b0c      	ldr	r3, [pc, #48]	; (21038 <nrfx_gpiote_input_configure+0x154>)
   21006:	4298      	cmp	r0, r3
   21008:	d1c6      	bne.n	20f98 <nrfx_gpiote_input_configure+0xb4>
        handler_id = (int32_t)id;
   2100a:	f89d 200f 	ldrb.w	r2, [sp, #15]
    m_cb.handlers[handler_id].p_context = p_context;
   2100e:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   21012:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   21014:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   21016:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
   2101a:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   2101e:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   21022:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   21026:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
    return NRFX_SUCCESS;
   2102a:	e7b4      	b.n	20f96 <nrfx_gpiote_input_configure+0xb2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   2102c:	2200      	movs	r2, #0
   2102e:	e7ee      	b.n	2100e <nrfx_gpiote_input_configure+0x12a>
   21030:	2000a208 	.word	0x2000a208
   21034:	0bad0004 	.word	0x0bad0004
   21038:	0bad0000 	.word	0x0bad0000
   2103c:	2000a27c 	.word	0x2000a27c

00021040 <nrfx_gpiote_output_configure>:
{
   21040:	b5f0      	push	{r4, r5, r6, r7, lr}
   21042:	4604      	mov	r4, r0
   21044:	4615      	mov	r5, r2
   21046:	b085      	sub	sp, #20
    if (p_config)
   21048:	b319      	cbz	r1, 21092 <nrfx_gpiote_output_configure+0x52>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   2104a:	4e34      	ldr	r6, [pc, #208]	; (2111c <nrfx_gpiote_output_configure+0xdc>)
   2104c:	f100 0708 	add.w	r7, r0, #8
   21050:	f836 2017 	ldrh.w	r2, [r6, r7, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   21054:	0793      	lsls	r3, r2, #30
   21056:	d403      	bmi.n	21060 <nrfx_gpiote_output_configure+0x20>
   21058:	f7ff fed4 	bl	20e04 <pin_in_use_by_te>
   2105c:	2800      	cmp	r0, #0
   2105e:	d15a      	bne.n	21116 <nrfx_gpiote_output_configure+0xd6>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   21060:	f012 0f1c 	tst.w	r2, #28
   21064:	d002      	beq.n	2106c <nrfx_gpiote_output_configure+0x2c>
   21066:	784b      	ldrb	r3, [r1, #1]
   21068:	2b01      	cmp	r3, #1
   2106a:	d054      	beq.n	21116 <nrfx_gpiote_output_configure+0xd6>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
   2106c:	2301      	movs	r3, #1
   2106e:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
   21072:	2300      	movs	r3, #0
   21074:	1c4a      	adds	r2, r1, #1
   21076:	e9cd 1300 	strd	r1, r3, [sp]
   2107a:	4620      	mov	r0, r4
   2107c:	1c8b      	adds	r3, r1, #2
   2107e:	f10d 010f 	add.w	r1, sp, #15
   21082:	f004 fbda 	bl	2583a <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   21086:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   2108a:	f043 0303 	orr.w	r3, r3, #3
   2108e:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_task_config)
   21092:	b915      	cbnz	r5, 2109a <nrfx_gpiote_output_configure+0x5a>
    return NRFX_SUCCESS;
   21094:	4822      	ldr	r0, [pc, #136]	; (21120 <nrfx_gpiote_output_configure+0xe0>)
}
   21096:	b005      	add	sp, #20
   21098:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   2109a:	4e20      	ldr	r6, [pc, #128]	; (2111c <nrfx_gpiote_output_configure+0xdc>)
   2109c:	f104 0708 	add.w	r7, r4, #8
   210a0:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
        if (pin_is_input(pin))
   210a4:	0783      	lsls	r3, r0, #30
   210a6:	d536      	bpl.n	21116 <nrfx_gpiote_output_configure+0xd6>
        uint32_t ch = p_task_config->task_ch;
   210a8:	f895 c000 	ldrb.w	ip, [r5]
    p_reg->CONFIG[idx] = 0;
   210ac:	2300      	movs	r3, #0
   210ae:	4661      	mov	r1, ip
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   210b0:	f020 0020 	bic.w	r0, r0, #32
   210b4:	0089      	lsls	r1, r1, #2
   210b6:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   210ba:	04c0      	lsls	r0, r0, #19
   210bc:	f501 313c 	add.w	r1, r1, #192512	; 0x2f000
   210c0:	0cc0      	lsrs	r0, r0, #19
   210c2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   210c6:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
    p_reg->CONFIG[idx] = 0;
   210ca:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   210ce:	786a      	ldrb	r2, [r5, #1]
   210d0:	2a00      	cmp	r2, #0
   210d2:	d0df      	beq.n	21094 <nrfx_gpiote_output_configure+0x54>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   210d4:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
                                      p_task_config->init_val);
   210d8:	78ad      	ldrb	r5, [r5, #2]
   210da:	f423 1399 	bic.w	r3, r3, #1253376	; 0x132000
   210de:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   210e2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   210e6:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   210ea:	0223      	lsls	r3, r4, #8
   210ec:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   210f0:	0412      	lsls	r2, r2, #16
   210f2:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   210f6:	ea43 030e 	orr.w	r3, r3, lr
   210fa:	4313      	orrs	r3, r2
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   210fc:	052a      	lsls	r2, r5, #20
   210fe:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   21102:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   21106:	4313      	orrs	r3, r2
   21108:	f040 0020 	orr.w	r0, r0, #32
   2110c:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   21110:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
   21114:	e7be      	b.n	21094 <nrfx_gpiote_output_configure+0x54>
{
   21116:	4803      	ldr	r0, [pc, #12]	; (21124 <nrfx_gpiote_output_configure+0xe4>)
   21118:	e7bd      	b.n	21096 <nrfx_gpiote_output_configure+0x56>
   2111a:	bf00      	nop
   2111c:	2000a208 	.word	0x2000a208
   21120:	0bad0000 	.word	0x0bad0000
   21124:	0bad0004 	.word	0x0bad0004

00021128 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   21128:	4b01      	ldr	r3, [pc, #4]	; (21130 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   2112a:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   2112e:	4770      	bx	lr
   21130:	2000a208 	.word	0x2000a208

00021134 <nrfx_gpiote_channel_get>:
{
   21134:	b508      	push	{r3, lr}
   21136:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   21138:	f7ff fe64 	bl	20e04 <pin_in_use_by_te>
   2113c:	b138      	cbz	r0, 2114e <nrfx_gpiote_channel_get+0x1a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   2113e:	4b05      	ldr	r3, [pc, #20]	; (21154 <nrfx_gpiote_channel_get+0x20>)
   21140:	3208      	adds	r2, #8
   21142:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
        return NRFX_SUCCESS;
   21146:	4804      	ldr	r0, [pc, #16]	; (21158 <nrfx_gpiote_channel_get+0x24>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   21148:	0b5b      	lsrs	r3, r3, #13
   2114a:	700b      	strb	r3, [r1, #0]
}
   2114c:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
   2114e:	4803      	ldr	r0, [pc, #12]	; (2115c <nrfx_gpiote_channel_get+0x28>)
   21150:	e7fc      	b.n	2114c <nrfx_gpiote_channel_get+0x18>
   21152:	bf00      	nop
   21154:	2000a208 	.word	0x2000a208
   21158:	0bad0000 	.word	0x0bad0000
   2115c:	0bad0004 	.word	0x0bad0004

00021160 <nrfx_gpiote_init>:
{
   21160:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   21162:	4c0f      	ldr	r4, [pc, #60]	; (211a0 <nrfx_gpiote_init+0x40>)
   21164:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
   21168:	b9bd      	cbnz	r5, 2119a <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   2116a:	2260      	movs	r2, #96	; 0x60
   2116c:	4629      	mov	r1, r5
   2116e:	f104 0010 	add.w	r0, r4, #16
   21172:	f003 ff4d 	bl	25010 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   21176:	202f      	movs	r0, #47	; 0x2f
   21178:	f7fd f8be 	bl	1e2f8 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   2117c:	4b09      	ldr	r3, [pc, #36]	; (211a4 <nrfx_gpiote_init+0x44>)
    return err_code;
   2117e:	480a      	ldr	r0, [pc, #40]	; (211a8 <nrfx_gpiote_init+0x48>)
   21180:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
   21184:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
   21188:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   2118c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   21190:	2301      	movs	r3, #1
   21192:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   21196:	6763      	str	r3, [r4, #116]	; 0x74
}
   21198:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   2119a:	4804      	ldr	r0, [pc, #16]	; (211ac <nrfx_gpiote_init+0x4c>)
   2119c:	e7fc      	b.n	21198 <nrfx_gpiote_init+0x38>
   2119e:	bf00      	nop
   211a0:	2000a208 	.word	0x2000a208
   211a4:	4002f000 	.word	0x4002f000
   211a8:	0bad0000 	.word	0x0bad0000
   211ac:	0bad0005 	.word	0x0bad0005

000211b0 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   211b0:	4b03      	ldr	r3, [pc, #12]	; (211c0 <nrfx_gpiote_is_init+0x10>)
   211b2:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
   211b6:	3800      	subs	r0, #0
   211b8:	bf18      	it	ne
   211ba:	2001      	movne	r0, #1
   211bc:	4770      	bx	lr
   211be:	bf00      	nop
   211c0:	2000a208 	.word	0x2000a208

000211c4 <nrfx_gpiote_channel_free>:
{
   211c4:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   211c6:	4801      	ldr	r0, [pc, #4]	; (211cc <nrfx_gpiote_channel_free+0x8>)
   211c8:	f7ff bc58 	b.w	20a7c <nrfx_flag32_free>
   211cc:	2000a278 	.word	0x2000a278

000211d0 <nrfx_gpiote_channel_alloc>:
{
   211d0:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   211d2:	4801      	ldr	r0, [pc, #4]	; (211d8 <nrfx_gpiote_channel_alloc+0x8>)
   211d4:	f7ff bc36 	b.w	20a44 <nrfx_flag32_alloc>
   211d8:	2000a278 	.word	0x2000a278

000211dc <nrfx_gpiote_trigger_enable>:
{
   211dc:	b537      	push	{r0, r1, r2, r4, r5, lr}
   211de:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   211e0:	f7ff fe10 	bl	20e04 <pin_in_use_by_te>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   211e4:	4b1d      	ldr	r3, [pc, #116]	; (2125c <nrfx_gpiote_trigger_enable+0x80>)
   211e6:	f104 0208 	add.w	r2, r4, #8
   211ea:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   211ee:	b1d0      	cbz	r0, 21226 <nrfx_gpiote_trigger_enable+0x4a>
   211f0:	f013 0502 	ands.w	r5, r3, #2
   211f4:	d117      	bne.n	21226 <nrfx_gpiote_trigger_enable+0x4a>
    return ((uint32_t)p_reg + event);
   211f6:	481a      	ldr	r0, [pc, #104]	; (21260 <nrfx_gpiote_trigger_enable+0x84>)
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   211f8:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   211fa:	009a      	lsls	r2, r3, #2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   211fc:	5085      	str	r5, [r0, r2]
   211fe:	5880      	ldr	r0, [r0, r2]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   21200:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   21204:	f502 323c 	add.w	r2, r2, #192512	; 0x2f000
   21208:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   2120c:	f040 0001 	orr.w	r0, r0, #1
   21210:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   21214:	b129      	cbz	r1, 21222 <nrfx_gpiote_trigger_enable+0x46>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   21216:	2201      	movs	r2, #1
   21218:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   2121c:	4a11      	ldr	r2, [pc, #68]	; (21264 <nrfx_gpiote_trigger_enable+0x88>)
   2121e:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   21222:	b003      	add	sp, #12
   21224:	bd30      	pop	{r4, r5, pc}
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   21226:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   2122a:	2b04      	cmp	r3, #4
   2122c:	d011      	beq.n	21252 <nrfx_gpiote_trigger_enable+0x76>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   2122e:	2b05      	cmp	r3, #5
   21230:	d011      	beq.n	21256 <nrfx_gpiote_trigger_enable+0x7a>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   21232:	a801      	add	r0, sp, #4
   21234:	9401      	str	r4, [sp, #4]
   21236:	f7ff fdd5 	bl	20de4 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   2123a:	9b01      	ldr	r3, [sp, #4]
    return p_reg->IN;
   2123c:	6901      	ldr	r1, [r0, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   2123e:	40d9      	lsrs	r1, r3
   21240:	f001 0101 	and.w	r1, r1, #1
   21244:	3102      	adds	r1, #2
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   21246:	4620      	mov	r0, r4
}
   21248:	b003      	add	sp, #12
   2124a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   2124e:	f004 bb3d 	b.w	258cc <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   21252:	2103      	movs	r1, #3
   21254:	e7f7      	b.n	21246 <nrfx_gpiote_trigger_enable+0x6a>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   21256:	2102      	movs	r1, #2
   21258:	e7f5      	b.n	21246 <nrfx_gpiote_trigger_enable+0x6a>
   2125a:	bf00      	nop
   2125c:	2000a208 	.word	0x2000a208
   21260:	4002f100 	.word	0x4002f100
   21264:	4002f000 	.word	0x4002f000

00021268 <nrfx_gpiote_trigger_disable>:
{
   21268:	b508      	push	{r3, lr}
   2126a:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   2126c:	f7ff fdca 	bl	20e04 <pin_in_use_by_te>
   21270:	b1c0      	cbz	r0, 212a4 <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   21272:	4b0f      	ldr	r3, [pc, #60]	; (212b0 <nrfx_gpiote_trigger_disable+0x48>)
   21274:	f102 0108 	add.w	r1, r2, #8
   21278:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   2127c:	0799      	lsls	r1, r3, #30
   2127e:	d411      	bmi.n	212a4 <nrfx_gpiote_trigger_disable+0x3c>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   21280:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   21282:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   21284:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   21286:	490b      	ldr	r1, [pc, #44]	; (212b4 <nrfx_gpiote_trigger_disable+0x4c>)
   21288:	009b      	lsls	r3, r3, #2
   2128a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2128e:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   21292:	f503 333c 	add.w	r3, r3, #192512	; 0x2f000
   21296:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   2129a:	f022 0203 	bic.w	r2, r2, #3
   2129e:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   212a2:	bd08      	pop	{r3, pc}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   212a4:	2100      	movs	r1, #0
}
   212a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   212aa:	4610      	mov	r0, r2
   212ac:	f004 bb0e 	b.w	258cc <nrf_gpio_cfg_sense_set>
   212b0:	2000a208 	.word	0x2000a208
   212b4:	4002f000 	.word	0x4002f000

000212b8 <nrfx_gpiote_pin_uninit>:
{
   212b8:	b513      	push	{r0, r1, r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   212ba:	4b10      	ldr	r3, [pc, #64]	; (212fc <nrfx_gpiote_pin_uninit+0x44>)
   212bc:	f100 0208 	add.w	r2, r0, #8
   212c0:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
   212c4:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   212c6:	07db      	lsls	r3, r3, #31
   212c8:	d516      	bpl.n	212f8 <nrfx_gpiote_pin_uninit+0x40>
    nrfx_gpiote_trigger_disable(pin);
   212ca:	f7ff ffcd 	bl	21268 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   212ce:	4620      	mov	r0, r4
   212d0:	f7ff fdea 	bl	20ea8 <pin_handler_trigger_uninit>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   212d4:	a801      	add	r0, sp, #4
   212d6:	9401      	str	r4, [sp, #4]
   212d8:	f7ff fd84 	bl	20de4 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   212dc:	9b01      	ldr	r3, [sp, #4]
   212de:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   212e2:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   212e6:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   212ea:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
   212ee:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    nrf_gpio_cfg(
   212f2:	4803      	ldr	r0, [pc, #12]	; (21300 <nrfx_gpiote_pin_uninit+0x48>)
}
   212f4:	b002      	add	sp, #8
   212f6:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   212f8:	4802      	ldr	r0, [pc, #8]	; (21304 <nrfx_gpiote_pin_uninit+0x4c>)
   212fa:	e7fb      	b.n	212f4 <nrfx_gpiote_pin_uninit+0x3c>
   212fc:	2000a208 	.word	0x2000a208
   21300:	0bad0000 	.word	0x0bad0000
   21304:	0bad0004 	.word	0x0bad0004

00021308 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   21308:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
   2130c:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   2130e:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   21310:	4634      	mov	r4, r6
{
   21312:	4b63      	ldr	r3, [pc, #396]	; (214a0 <nrfx_gpiote_irq_handler+0x198>)
    return p_reg->INTENSET & mask;
   21314:	4863      	ldr	r0, [pc, #396]	; (214a4 <nrfx_gpiote_irq_handler+0x19c>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   21316:	4964      	ldr	r1, [pc, #400]	; (214a8 <nrfx_gpiote_irq_handler+0x1a0>)
{
   21318:	b087      	sub	sp, #28
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2131a:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   2131c:	b135      	cbz	r5, 2132c <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   2131e:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   21322:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   21324:	bf1e      	ittt	ne
   21326:	601c      	strne	r4, [r3, #0]
   21328:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   2132a:	4316      	orrne	r6, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   2132c:	3304      	adds	r3, #4
   2132e:	428b      	cmp	r3, r1
        }
        mask <<= 1;
   21330:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   21334:	d1f1      	bne.n	2131a <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21336:	f8df a16c 	ldr.w	sl, [pc, #364]	; 214a4 <nrfx_gpiote_irq_handler+0x19c>
   2133a:	f8da 317c 	ldr.w	r3, [sl, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   2133e:	2b00      	cmp	r3, #0
   21340:	f000 8091 	beq.w	21466 <nrfx_gpiote_irq_handler+0x15e>
        *p_masks = gpio_regs[i]->LATCH;
   21344:	f8df 8164 	ldr.w	r8, [pc, #356]	; 214ac <nrfx_gpiote_irq_handler+0x1a4>
   21348:	f8d8 3020 	ldr.w	r3, [r8, #32]
   2134c:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
   2134e:	f8c8 3020 	str.w	r3, [r8, #32]
        *p_masks = gpio_regs[i]->LATCH;
   21352:	4b57      	ldr	r3, [pc, #348]	; (214b0 <nrfx_gpiote_irq_handler+0x1a8>)
   21354:	6a1a      	ldr	r2, [r3, #32]
   21356:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
   21358:	621a      	str	r2, [r3, #32]
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   2135a:	f04f 0900 	mov.w	r9, #0
            while (latch[i])
   2135e:	f10d 0b10 	add.w	fp, sp, #16
   21362:	ea4f 1349 	mov.w	r3, r9, lsl #5
   21366:	9300      	str	r3, [sp, #0]
   21368:	e048      	b.n	213fc <nrfx_gpiote_irq_handler+0xf4>
                uint32_t pin = NRF_CTZ(latch[i]);
   2136a:	fa94 f4a4 	rbit	r4, r4
   2136e:	fab4 f484 	clz	r4, r4
                pin += 32 * i;
   21372:	9b00      	ldr	r3, [sp, #0]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   21374:	4a4f      	ldr	r2, [pc, #316]	; (214b4 <nrfx_gpiote_irq_handler+0x1ac>)
                pin += 32 * i;
   21376:	441c      	add	r4, r3
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   21378:	f104 0308 	add.w	r3, r4, #8
   2137c:	f832 7013 	ldrh.w	r7, [r2, r3, lsl #1]
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   21380:	2301      	movs	r3, #1
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   21382:	08e0      	lsrs	r0, r4, #3
    bit = BITMASK_RELBIT_GET(bit);
   21384:	f004 0207 	and.w	r2, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   21388:	fa03 f202 	lsl.w	r2, r3, r2
   2138c:	f81b 3000 	ldrb.w	r3, [fp, r0]
   21390:	9403      	str	r4, [sp, #12]
   21392:	ea23 0302 	bic.w	r3, r3, r2
   21396:	f80b 3000 	strb.w	r3, [fp, r0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2139a:	a803      	add	r0, sp, #12
   2139c:	f7ff fd22 	bl	20de4 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   213a0:	9b03      	ldr	r3, [sp, #12]
   213a2:	08b9      	lsrs	r1, r7, #2
   213a4:	3380      	adds	r3, #128	; 0x80
   213a6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   213aa:	f3c7 0582 	ubfx	r5, r7, #2, #3
    if (is_level(trigger))
   213ae:	074a      	lsls	r2, r1, #29
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   213b0:	462f      	mov	r7, r5
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   213b2:	f3c3 4301 	ubfx	r3, r3, #16, #2
    if (is_level(trigger))
   213b6:	d52b      	bpl.n	21410 <nrfx_gpiote_irq_handler+0x108>
        call_handler(pin, trigger);
   213b8:	4620      	mov	r0, r4
   213ba:	4639      	mov	r1, r7
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   213bc:	b2dd      	uxtb	r5, r3
   213be:	f7ff fd2b 	bl	20e18 <call_handler>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   213c2:	a803      	add	r0, sp, #12
   213c4:	9403      	str	r4, [sp, #12]
   213c6:	f7ff fd0d 	bl	20de4 <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   213ca:	9b03      	ldr	r3, [sp, #12]
   213cc:	3380      	adds	r3, #128	; 0x80
   213ce:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
        if (nrf_gpio_pin_sense_get(pin) == sense)
   213d2:	f3c3 4301 	ubfx	r3, r3, #16, #2
   213d6:	429d      	cmp	r5, r3
   213d8:	d107      	bne.n	213ea <nrfx_gpiote_irq_handler+0xe2>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   213da:	2100      	movs	r1, #0
   213dc:	4620      	mov	r0, r4
   213de:	f004 fa75 	bl	258cc <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   213e2:	4629      	mov	r1, r5
   213e4:	4620      	mov	r0, r4
   213e6:	f004 fa71 	bl	258cc <nrf_gpio_cfg_sense_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   213ea:	a803      	add	r0, sp, #12
   213ec:	9403      	str	r4, [sp, #12]
   213ee:	f7ff fcf9 	bl	20de4 <nrf_gpio_pin_port_decode>
    reg->LATCH = (1 << pin_number);
   213f2:	2201      	movs	r2, #1
   213f4:	9b03      	ldr	r3, [sp, #12]
   213f6:	fa02 f303 	lsl.w	r3, r2, r3
   213fa:	6203      	str	r3, [r0, #32]
            while (latch[i])
   213fc:	f85b 4029 	ldr.w	r4, [fp, r9, lsl #2]
   21400:	2c00      	cmp	r4, #0
   21402:	d1b2      	bne.n	2136a <nrfx_gpiote_irq_handler+0x62>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   21404:	f1b9 0f00 	cmp.w	r9, #0
   21408:	d11d      	bne.n	21446 <nrfx_gpiote_irq_handler+0x13e>
   2140a:	f04f 0901 	mov.w	r9, #1
   2140e:	e7a8      	b.n	21362 <nrfx_gpiote_irq_handler+0x5a>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   21410:	2b02      	cmp	r3, #2
   21412:	d10c      	bne.n	2142e <nrfx_gpiote_irq_handler+0x126>
        nrf_gpio_cfg_sense_set(pin, next_sense);
   21414:	2103      	movs	r1, #3
   21416:	4620      	mov	r0, r4
   21418:	f004 fa58 	bl	258cc <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   2141c:	f005 0305 	and.w	r3, r5, #5
   21420:	2b01      	cmp	r3, #1
   21422:	d1e2      	bne.n	213ea <nrfx_gpiote_irq_handler+0xe2>
            call_handler(pin, trigger);
   21424:	4639      	mov	r1, r7
   21426:	4620      	mov	r0, r4
   21428:	f7ff fcf6 	bl	20e18 <call_handler>
   2142c:	e7dd      	b.n	213ea <nrfx_gpiote_irq_handler+0xe2>
        nrf_gpio_cfg_sense_set(pin, next_sense);
   2142e:	2102      	movs	r1, #2
   21430:	4620      	mov	r0, r4
   21432:	9301      	str	r3, [sp, #4]
   21434:	f004 fa4a 	bl	258cc <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   21438:	2d03      	cmp	r5, #3
   2143a:	d0f3      	beq.n	21424 <nrfx_gpiote_irq_handler+0x11c>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   2143c:	9b01      	ldr	r3, [sp, #4]
   2143e:	2b03      	cmp	r3, #3
   21440:	d1d3      	bne.n	213ea <nrfx_gpiote_irq_handler+0xe2>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   21442:	2d02      	cmp	r5, #2
   21444:	e7ed      	b.n	21422 <nrfx_gpiote_irq_handler+0x11a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   21446:	f8ca 417c 	str.w	r4, [sl, #380]	; 0x17c
   2144a:	f8da 317c 	ldr.w	r3, [sl, #380]	; 0x17c
        *p_masks = gpio_regs[i]->LATCH;
   2144e:	f8d8 3020 	ldr.w	r3, [r8, #32]
   21452:	4917      	ldr	r1, [pc, #92]	; (214b0 <nrfx_gpiote_irq_handler+0x1a8>)
   21454:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
   21456:	f8c8 3020 	str.w	r3, [r8, #32]
        *p_masks = gpio_regs[i]->LATCH;
   2145a:	6a0a      	ldr	r2, [r1, #32]
        if (latch[port_idx])
   2145c:	4313      	orrs	r3, r2
   2145e:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
   21460:	620a      	str	r2, [r1, #32]
   21462:	f47f af7a 	bne.w	2135a <nrfx_gpiote_irq_handler+0x52>
        mask &= ~NRFX_BIT(ch);
   21466:	2401      	movs	r4, #1
    while (mask)
   21468:	b916      	cbnz	r6, 21470 <nrfx_gpiote_irq_handler+0x168>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   2146a:	b007      	add	sp, #28
   2146c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        uint32_t ch = NRF_CTZ(mask);
   21470:	fa96 f3a6 	rbit	r3, r6
   21474:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   21478:	fa04 f203 	lsl.w	r2, r4, r3
   2147c:	009b      	lsls	r3, r3, #2
   2147e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   21482:	f503 333c 	add.w	r3, r3, #192512	; 0x2f000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   21486:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   2148a:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   2148e:	f3c0 2005 	ubfx	r0, r0, #8, #6
   21492:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
   21496:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   2149a:	f7ff fcbd 	bl	20e18 <call_handler>
   2149e:	e7e3      	b.n	21468 <nrfx_gpiote_irq_handler+0x160>
   214a0:	4002f100 	.word	0x4002f100
   214a4:	4002f000 	.word	0x4002f000
   214a8:	4002f120 	.word	0x4002f120
   214ac:	40842500 	.word	0x40842500
   214b0:	40842800 	.word	0x40842800
   214b4:	2000a208 	.word	0x2000a208

000214b8 <nrfx_power_init>:
    return m_usbevt_handler;
}
#endif

nrfx_err_t nrfx_power_init(nrfx_power_config_t const * p_config)
{
   214b8:	b510      	push	{r4, lr}
    NRFX_ASSERT(p_config);
    if (m_initialized)
   214ba:	4c0e      	ldr	r4, [pc, #56]	; (214f4 <nrfx_power_init+0x3c>)
   214bc:	7823      	ldrb	r3, [r4, #0]
   214be:	b9b3      	cbnz	r3, 214ee <nrfx_power_init+0x36>
#endif // NRF_REGULATORS_HAS_POFCON_VDDH

#if NRF_REGULATORS_HAS_DCDCEN_VDDH
NRF_STATIC_INLINE void nrf_regulators_dcdcen_vddh_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
    p_reg->VREGH.DCDCEN = (enable) ? REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled :
   214c0:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    }

#if NRF_POWER_HAS_DCDCEN_VDDH
    nrf_power_dcdcen_vddh_set(NRF_POWER, p_config->dcdcenhv);
#elif NRF_REGULATORS_HAS_DCDCEN_VDDH
    nrf_regulators_dcdcen_vddh_set(NRF_REGULATORS, p_config->dcdcenhv);
   214c4:	7803      	ldrb	r3, [r0, #0]
   214c6:	f3c3 0340 	ubfx	r3, r3, #1, #1
   214ca:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
#endif

#if NRF_POWER_HAS_DCDCEN
    nrf_power_dcdcen_set(NRF_POWER, p_config->dcdcen);
#elif defined(REGULATORS_PRESENT)
    nrf_regulators_dcdcen_set(NRF_REGULATORS, p_config->dcdcen);
   214ce:	7803      	ldrb	r3, [r0, #0]
    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   214d0:	2005      	movs	r0, #5
    p_reg->VREGMAIN.DCDCEN = (enable ? REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Msk : 0);
   214d2:	f003 0301 	and.w	r3, r3, #1
   214d6:	f8c2 3704 	str.w	r3, [r2, #1796]	; 0x704
   214da:	f7fc ff2f 	bl	1e33c <arch_irq_is_enabled>
   214de:	b910      	cbnz	r0, 214e6 <nrfx_power_init+0x2e>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   214e0:	2005      	movs	r0, #5
   214e2:	f7fc ff09 	bl	1e2f8 <arch_irq_enable>
#endif
#endif // defined(REGULATORS_PRESENT)

    nrfx_power_clock_irq_init();

    m_initialized = true;
   214e6:	2301      	movs	r3, #1
    return NRFX_SUCCESS;
   214e8:	4803      	ldr	r0, [pc, #12]	; (214f8 <nrfx_power_init+0x40>)
    m_initialized = true;
   214ea:	7023      	strb	r3, [r4, #0]
}
   214ec:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   214ee:	4803      	ldr	r0, [pc, #12]	; (214fc <nrfx_power_init+0x44>)
   214f0:	e7fc      	b.n	214ec <nrfx_power_init+0x34>
   214f2:	bf00      	nop
   214f4:	2000b626 	.word	0x2000b626
   214f8:	0bad0000 	.word	0x0bad0000
   214fc:	0bad000c 	.word	0x0bad000c

00021500 <nrfx_power_irq_handler>:

#endif /* NRF_POWER_HAS_USBREG */


void nrfx_power_irq_handler(void)
{
   21500:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
}

NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg)
{
    return p_reg->INTENSET;
   21502:	4b18      	ldr	r3, [pc, #96]	; (21564 <nrfx_power_irq_handler+0x64>)
   21504:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
    uint32_t enabled = nrf_power_int_enable_get(NRF_POWER);
    /* Prevent "unused variable" warning when all below blocks are disabled. */
    (void)enabled;

#if NRFX_POWER_SUPPORTS_POFCON
    if ((0 != (enabled & NRF_POWER_INT_POFWARN_MASK)) &&
   21508:	0761      	lsls	r1, r4, #29
   2150a:	d50a      	bpl.n	21522 <nrfx_power_irq_handler+0x22>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2150c:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    if (ret)
   21510:	b13a      	cbz	r2, 21522 <nrfx_power_irq_handler+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21512:	2200      	movs	r2, #0
   21514:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   21518:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_POFWARN))
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_pofwarn_handler != NULL);
        m_pofwarn_handler();
   2151c:	4b12      	ldr	r3, [pc, #72]	; (21568 <nrfx_power_irq_handler+0x68>)
   2151e:	681b      	ldr	r3, [r3, #0]
   21520:	4798      	blx	r3
    }
#endif
#if NRF_POWER_HAS_SLEEPEVT
    if ((0 != (enabled & NRF_POWER_INT_SLEEPENTER_MASK)) &&
   21522:	06a2      	lsls	r2, r4, #26
   21524:	d50b      	bpl.n	2153e <nrfx_power_irq_handler+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21526:	4b0f      	ldr	r3, [pc, #60]	; (21564 <nrfx_power_irq_handler+0x64>)
   21528:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
    if (ret)
   2152c:	b13a      	cbz	r2, 2153e <nrfx_power_irq_handler+0x3e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2152e:	2000      	movs	r0, #0
   21530:	f8c3 0114 	str.w	r0, [r3, #276]	; 0x114
   21534:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPENTER))
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_ENTER);
   21538:	4b0c      	ldr	r3, [pc, #48]	; (2156c <nrfx_power_irq_handler+0x6c>)
   2153a:	681b      	ldr	r3, [r3, #0]
   2153c:	4798      	blx	r3
    }
    if ((0 != (enabled & NRF_POWER_INT_SLEEPEXIT_MASK)) &&
   2153e:	0663      	lsls	r3, r4, #25
   21540:	d50e      	bpl.n	21560 <nrfx_power_irq_handler+0x60>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21542:	4b08      	ldr	r3, [pc, #32]	; (21564 <nrfx_power_irq_handler+0x64>)
   21544:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (ret)
   21548:	b152      	cbz	r2, 21560 <nrfx_power_irq_handler+0x60>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2154a:	2200      	movs	r2, #0
   2154c:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   21550:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPEXIT))
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_EXIT);
   21554:	4b05      	ldr	r3, [pc, #20]	; (2156c <nrfx_power_irq_handler+0x6c>)
   21556:	2001      	movs	r0, #1
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_usbevt_handler != NULL);
        m_usbevt_handler(NRFX_POWER_USB_EVT_READY);
    }
#endif
}
   21558:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_EXIT);
   2155c:	681b      	ldr	r3, [r3, #0]
   2155e:	4718      	bx	r3
}
   21560:	bd10      	pop	{r4, pc}
   21562:	bf00      	nop
   21564:	40005000 	.word	0x40005000
   21568:	2000b2f4 	.word	0x2000b2f4
   2156c:	2000b2f0 	.word	0x2000b2f0

00021570 <nrf_gpio_pin_clear>:
        case 0: return NRF_P0;
   21570:	4a05      	ldr	r2, [pc, #20]	; (21588 <nrf_gpio_pin_clear+0x18>)
   21572:	4b06      	ldr	r3, [pc, #24]	; (2158c <nrf_gpio_pin_clear+0x1c>)
    *p_pin = pin_number & 0x1F;
   21574:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
   21578:	0940      	lsrs	r0, r0, #5
        case 0: return NRF_P0;
   2157a:	2801      	cmp	r0, #1
   2157c:	bf18      	it	ne
   2157e:	4613      	movne	r3, r2
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   21580:	2201      	movs	r2, #1
   21582:	408a      	lsls	r2, r1
    p_reg->OUTCLR = clr_mask;
   21584:	60da      	str	r2, [r3, #12]
}
   21586:	4770      	bx	lr
   21588:	40842500 	.word	0x40842500
   2158c:	40842800 	.word	0x40842800

00021590 <nrf_gpio_cfg.constprop.0>:
NRF_STATIC_INLINE void nrf_gpio_cfg(
   21590:	b570      	push	{r4, r5, r6, lr}
        case 0: return NRF_P0;
   21592:	4c0d      	ldr	r4, [pc, #52]	; (215c8 <nrf_gpio_cfg.constprop.0+0x38>)
   21594:	4e0d      	ldr	r6, [pc, #52]	; (215cc <nrf_gpio_cfg.constprop.0+0x3c>)
    *p_pin = pin_number & 0x1F;
   21596:	f000 051f 	and.w	r5, r0, #31
    return pin_number >> 5;
   2159a:	0940      	lsrs	r0, r0, #5
        case 0: return NRF_P0;
   2159c:	2801      	cmp	r0, #1
   2159e:	bf18      	it	ne
   215a0:	4634      	movne	r4, r6
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   215a2:	f89d 0010 	ldrb.w	r0, [sp, #16]
   215a6:	eb04 0485 	add.w	r4, r4, r5, lsl #2
   215aa:	0200      	lsls	r0, r0, #8
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   215ac:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   215b0:	ea40 0083 	orr.w	r0, r0, r3, lsl #2
   215b4:	4308      	orrs	r0, r1
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   215b6:	f005 45e0 	and.w	r5, r5, #1879048192	; 0x70000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   215ba:	ea40 0042 	orr.w	r0, r0, r2, lsl #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   215be:	4328      	orrs	r0, r5
    reg->PIN_CNF[pin_number] = cnf;
   215c0:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
}
   215c4:	bd70      	pop	{r4, r5, r6, pc}
   215c6:	bf00      	nop
   215c8:	40842800 	.word	0x40842800
   215cc:	40842500 	.word	0x40842500

000215d0 <nrf_gpio_pin_set>:
        case 0: return NRF_P0;
   215d0:	4a05      	ldr	r2, [pc, #20]	; (215e8 <nrf_gpio_pin_set+0x18>)
   215d2:	4b06      	ldr	r3, [pc, #24]	; (215ec <nrf_gpio_pin_set+0x1c>)
    *p_pin = pin_number & 0x1F;
   215d4:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
   215d8:	0940      	lsrs	r0, r0, #5
        case 0: return NRF_P0;
   215da:	2801      	cmp	r0, #1
   215dc:	bf18      	it	ne
   215de:	4613      	movne	r3, r2
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   215e0:	2201      	movs	r2, #1
   215e2:	408a      	lsls	r2, r1
    p_reg->OUTSET = set_mask;
   215e4:	609a      	str	r2, [r3, #8]
}
   215e6:	4770      	bx	lr
   215e8:	40842500 	.word	0x40842500
   215ec:	40842800 	.word	0x40842800

000215f0 <nrfx_spim_init>:

nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
                          nrfx_spim_config_t const * p_config,
                          nrfx_spim_evt_handler_t    handler,
                          void *                     p_context)
{
   215f0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   215f4:	4607      	mov	r7, r0
   215f6:	460c      	mov	r4, r1
    NRFX_ASSERT(p_config);
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   215f8:	4e93      	ldr	r6, [pc, #588]	; (21848 <nrfx_spim_init+0x258>)
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   215fa:	7939      	ldrb	r1, [r7, #4]
{
   215fc:	4610      	mov	r0, r2
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   215fe:	eb06 1241 	add.w	r2, r6, r1, lsl #5
   21602:	f892 a01c 	ldrb.w	sl, [r2, #28]
   21606:	ea4f 1941 	mov.w	r9, r1, lsl #5
   2160a:	f1ba 0f00 	cmp.w	sl, #0
   2160e:	f040 8116 	bne.w	2183e <nrfx_spim_init+0x24e>
        return err_code;
    }

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // Check if SPIM instance supports the extended features.
    if (
   21612:	b949      	cbnz	r1, 21628 <nrfx_spim_init+0x38>
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   21614:	68a2      	ldr	r2, [r4, #8]
   21616:	f1b2 6f20 	cmp.w	r2, #167772160	; 0xa000000
   2161a:	d003      	beq.n	21624 <nrfx_spim_init+0x34>
   2161c:	f1b2 5fa0 	cmp.w	r2, #335544320	; 0x14000000
   21620:	f040 80ee 	bne.w	21800 <nrfx_spim_init+0x210>
    {
        err_code = NRFX_ERROR_NOT_SUPPORTED;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
   21624:	4889      	ldr	r0, [pc, #548]	; (2184c <nrfx_spim_init+0x25c>)
   21626:	e0e8      	b.n	217fa <nrfx_spim_init+0x20a>
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   21628:	2901      	cmp	r1, #1
   2162a:	d1fb      	bne.n	21624 <nrfx_spim_init+0x34>
        ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
   2162c:	7be1      	ldrb	r1, [r4, #15]

#if NRF_SPIM_HAS_32_MHZ_FREQ && defined(NRF5340_XXAA_APPLICATION)
    // Check if dedicated SPIM pins are used, unless both GPIO configuration
    // and pin selection are to be skipped (pin numbers may be not specified
    // in such case).
    if (!(p_config->skip_gpio_cfg && p_config->skip_psel_cfg) &&
   2162e:	7ce2      	ldrb	r2, [r4, #19]
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   21630:	f8d7 8000 	ldr.w	r8, [r7]
    if (!(p_config->skip_gpio_cfg && p_config->skip_psel_cfg) &&
   21634:	b10a      	cbz	r2, 2163a <nrfx_spim_init+0x4a>
   21636:	7d22      	ldrb	r2, [r4, #20]
   21638:	bb1a      	cbnz	r2, 21682 <nrfx_spim_init+0x92>
   2163a:	4a85      	ldr	r2, [pc, #532]	; (21850 <nrfx_spim_init+0x260>)
   2163c:	4590      	cmp	r8, r2
   2163e:	d120      	bne.n	21682 <nrfx_spim_init+0x92>
        (p_spim == NRF_SPIM4) && (p_config->frequency == NRF_SPIM_FREQ_32M))
   21640:	68a2      	ldr	r2, [r4, #8]
   21642:	f1b2 5fa0 	cmp.w	r2, #335544320	; 0x14000000
   21646:	d11c      	bne.n	21682 <nrfx_spim_init+0x92>
            SPIM_MISO_DEDICATED = NRF_GPIO_PIN_MAP(0, 10),
            SPIM_CSN_DEDICATED  = NRF_GPIO_PIN_MAP(0, 11),
            SPIM_DCX_DEDICATED  = NRF_GPIO_PIN_MAP(0, 12),
        };

        if (!SPIM_DEDICATED_PIN_VALIDATE(p_config->sck_pin, SPIM_SCK_DEDICATED) ||
   21648:	7822      	ldrb	r2, [r4, #0]
   2164a:	2aff      	cmp	r2, #255	; 0xff
   2164c:	d002      	beq.n	21654 <nrfx_spim_init+0x64>
   2164e:	2a08      	cmp	r2, #8
   21650:	f040 80f7 	bne.w	21842 <nrfx_spim_init+0x252>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->ss_pin,  SPIM_CSN_DEDICATED) ||
   21654:	78e2      	ldrb	r2, [r4, #3]
        if (!SPIM_DEDICATED_PIN_VALIDATE(p_config->sck_pin, SPIM_SCK_DEDICATED) ||
   21656:	2aff      	cmp	r2, #255	; 0xff
   21658:	d002      	beq.n	21660 <nrfx_spim_init+0x70>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->ss_pin,  SPIM_CSN_DEDICATED) ||
   2165a:	2a0b      	cmp	r2, #11
   2165c:	f040 80f1 	bne.w	21842 <nrfx_spim_init+0x252>
   21660:	29ff      	cmp	r1, #255	; 0xff
   21662:	d002      	beq.n	2166a <nrfx_spim_init+0x7a>
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->dcx_pin, SPIM_DCX_DEDICATED) ||
   21664:	290c      	cmp	r1, #12
   21666:	f040 80ec 	bne.w	21842 <nrfx_spim_init+0x252>
#endif
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
   2166a:	7862      	ldrb	r2, [r4, #1]
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->dcx_pin, SPIM_DCX_DEDICATED) ||
   2166c:	2aff      	cmp	r2, #255	; 0xff
   2166e:	d002      	beq.n	21676 <nrfx_spim_init+0x86>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
   21670:	2a09      	cmp	r2, #9
   21672:	f040 80e6 	bne.w	21842 <nrfx_spim_init+0x252>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->miso_pin, SPIM_MISO_DEDICATED))
   21676:	78a2      	ldrb	r2, [r4, #2]
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
   21678:	2aff      	cmp	r2, #255	; 0xff
   2167a:	d002      	beq.n	21682 <nrfx_spim_init+0x92>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->miso_pin, SPIM_MISO_DEDICATED))
   2167c:	2a0a      	cmp	r2, #10
   2167e:	f040 80e0 	bne.w	21842 <nrfx_spim_init+0x252>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
   21682:	eb06 0209 	add.w	r2, r6, r9
   21686:	f846 0009 	str.w	r0, [r6, r9]
    p_cb->p_context = p_context;
   2168a:	6053      	str	r3, [r2, #4]

    p_cb->skip_gpio_cfg = p_config->skip_gpio_cfg;
   2168c:	7ce0      	ldrb	r0, [r4, #19]
   2168e:	7f91      	ldrb	r1, [r2, #30]
   21690:	f360 0100 	bfi	r1, r0, #0, #1
   21694:	7791      	strb	r1, [r2, #30]
    p_cb->ss_active_high = p_config->ss_active_high;
   21696:	7920      	ldrb	r0, [r4, #4]
   21698:	b2c9      	uxtb	r1, r1
   2169a:	f360 0141 	bfi	r1, r0, #1, #1
   2169e:	7791      	strb	r1, [r2, #30]
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    p_cb->use_hw_ss = p_config->use_hw_ss;
   216a0:	7c60      	ldrb	r0, [r4, #17]
   216a2:	b2c9      	uxtb	r1, r1
   216a4:	f360 0182 	bfi	r1, r0, #2, #1
   216a8:	7791      	strb	r1, [r2, #30]
#endif
    p_cb->ss_pin = p_config->ss_pin;
   216aa:	78e3      	ldrb	r3, [r4, #3]
   216ac:	77d3      	strb	r3, [r2, #31]
    if (!p_config->skip_gpio_cfg)
   216ae:	7ce3      	ldrb	r3, [r4, #19]
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   216b0:	683d      	ldr	r5, [r7, #0]
    if (!p_config->skip_gpio_cfg)
   216b2:	2b00      	cmp	r3, #0
   216b4:	d148      	bne.n	21748 <nrfx_spim_init+0x158>
                    : NRF_GPIO_PIN_S0S1;
   216b6:	68a3      	ldr	r3, [r4, #8]
        nrf_gpio_pin_write(p_config->sck_pin,
   216b8:	7820      	ldrb	r0, [r4, #0]
                    : NRF_GPIO_PIN_S0S1;
   216ba:	f1b3 5fa0 	cmp.w	r3, #335544320	; 0x14000000
    if (value == 0)
   216be:	7b23      	ldrb	r3, [r4, #12]
   216c0:	bf08      	it	eq
   216c2:	f04f 0a03 	moveq.w	sl, #3
   216c6:	2b01      	cmp	r3, #1
   216c8:	f200 80a3 	bhi.w	21812 <nrfx_spim_init+0x222>
        nrf_gpio_pin_clear(pin_number);
   216cc:	f7ff ff50 	bl	21570 <nrf_gpio_pin_clear>
        nrf_gpio_cfg(p_config->sck_pin,
   216d0:	2300      	movs	r3, #0
   216d2:	f8cd a000 	str.w	sl, [sp]
   216d6:	7820      	ldrb	r0, [r4, #0]
   216d8:	461a      	mov	r2, r3
   216da:	2101      	movs	r1, #1
   216dc:	f7ff ff58 	bl	21590 <nrf_gpio_cfg.constprop.0>
        if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   216e0:	7860      	ldrb	r0, [r4, #1]
   216e2:	28ff      	cmp	r0, #255	; 0xff
   216e4:	d009      	beq.n	216fa <nrfx_spim_init+0x10a>
   216e6:	f7ff ff43 	bl	21570 <nrf_gpio_pin_clear>
            nrf_gpio_cfg(p_config->mosi_pin,
   216ea:	2201      	movs	r2, #1
   216ec:	f8cd a000 	str.w	sl, [sp]
   216f0:	2300      	movs	r3, #0
   216f2:	4611      	mov	r1, r2
   216f4:	7860      	ldrb	r0, [r4, #1]
   216f6:	f7ff ff4b 	bl	21590 <nrf_gpio_cfg.constprop.0>
        if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   216fa:	78a0      	ldrb	r0, [r4, #2]
   216fc:	28ff      	cmp	r0, #255	; 0xff
   216fe:	d006      	beq.n	2170e <nrfx_spim_init+0x11e>
            nrf_gpio_cfg(p_config->miso_pin,
   21700:	2200      	movs	r2, #0
   21702:	f8cd a000 	str.w	sl, [sp]
   21706:	4611      	mov	r1, r2
   21708:	7ba3      	ldrb	r3, [r4, #14]
   2170a:	f7ff ff41 	bl	21590 <nrf_gpio_cfg.constprop.0>
        if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   2170e:	78e0      	ldrb	r0, [r4, #3]
   21710:	28ff      	cmp	r0, #255	; 0xff
   21712:	d00c      	beq.n	2172e <nrfx_spim_init+0x13e>
    if (value == 0)
   21714:	7923      	ldrb	r3, [r4, #4]
   21716:	2b00      	cmp	r3, #0
   21718:	d07e      	beq.n	21818 <nrfx_spim_init+0x228>
        nrf_gpio_pin_clear(pin_number);
   2171a:	f7ff ff29 	bl	21570 <nrf_gpio_pin_clear>
            nrf_gpio_cfg(p_config->ss_pin,
   2171e:	2201      	movs	r2, #1
   21720:	f8cd a000 	str.w	sl, [sp]
   21724:	2300      	movs	r3, #0
   21726:	4611      	mov	r1, r2
   21728:	78e0      	ldrb	r0, [r4, #3]
   2172a:	f7ff ff31 	bl	21590 <nrf_gpio_cfg.constprop.0>
        if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
   2172e:	7be0      	ldrb	r0, [r4, #15]
   21730:	28ff      	cmp	r0, #255	; 0xff
   21732:	d009      	beq.n	21748 <nrfx_spim_init+0x158>
        nrf_gpio_pin_set(pin_number);
   21734:	f7ff ff4c 	bl	215d0 <nrf_gpio_pin_set>
            nrf_gpio_cfg(p_config->dcx_pin,
   21738:	2201      	movs	r2, #1
   2173a:	f8cd a000 	str.w	sl, [sp]
   2173e:	2300      	movs	r3, #0
   21740:	4611      	mov	r1, r2
   21742:	7be0      	ldrb	r0, [r4, #15]
   21744:	f7ff ff24 	bl	21590 <nrf_gpio_cfg.constprop.0>
    if (!p_config->skip_psel_cfg)
   21748:	7d23      	ldrb	r3, [r4, #20]
   2174a:	bb6b      	cbnz	r3, 217a8 <nrfx_spim_init+0x1b8>
        uint32_t mosi_pin = (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   2174c:	7863      	ldrb	r3, [r4, #1]
        nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
   2174e:	7821      	ldrb	r1, [r4, #0]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   21750:	2bff      	cmp	r3, #255	; 0xff
   21752:	bf18      	it	ne
   21754:	461a      	movne	r2, r3
        uint32_t miso_pin = (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   21756:	78a3      	ldrb	r3, [r4, #2]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   21758:	bf08      	it	eq
   2175a:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   2175e:	2bff      	cmp	r3, #255	; 0xff
   21760:	bf08      	it	eq
   21762:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
NRF_STATIC_INLINE void nrf_spim_pins_set(NRF_SPIM_Type * p_reg,
                                         uint32_t        sck_pin,
                                         uint32_t        mosi_pin,
                                         uint32_t        miso_pin)
{
    p_reg->PSEL.SCK  = sck_pin;
   21766:	f8c5 1508 	str.w	r1, [r5, #1288]	; 0x508
    p_reg->PSEL.MOSI = mosi_pin;
   2176a:	f8c5 250c 	str.w	r2, [r5, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   2176e:	f8c5 3510 	str.w	r3, [r5, #1296]	; 0x510
        if (SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx))
   21772:	793b      	ldrb	r3, [r7, #4]
   21774:	2b01      	cmp	r3, #1
   21776:	d117      	bne.n	217a8 <nrfx_spim_init+0x1b8>
            if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED &&
   21778:	78e3      	ldrb	r3, [r4, #3]
   2177a:	2bff      	cmp	r3, #255	; 0xff
   2177c:	d04f      	beq.n	2181e <nrfx_spim_init+0x22e>
   2177e:	7c62      	ldrb	r2, [r4, #17]
   21780:	2a00      	cmp	r2, #0
   21782:	d04c      	beq.n	2181e <nrfx_spim_init+0x22e>
                                    (p_config->ss_active_high == true
   21784:	7921      	ldrb	r1, [r4, #4]
                nrf_spim_csn_configure(p_spim,
   21786:	7ca2      	ldrb	r2, [r4, #18]
NRF_STATIC_INLINE void nrf_spim_csn_configure(NRF_SPIM_Type *    p_reg,
                                              uint32_t           pin,
                                              nrf_spim_csn_pol_t polarity,
                                              uint32_t           duration)
{
    p_reg->PSEL.CSN = pin;
   21788:	f8c5 3514 	str.w	r3, [r5, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
   2178c:	f8c5 1568 	str.w	r1, [r5, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
   21790:	f8c5 2564 	str.w	r2, [r5, #1380]	; 0x564
        if (SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
   21794:	793b      	ldrb	r3, [r7, #4]
   21796:	2b01      	cmp	r3, #1
   21798:	d106      	bne.n	217a8 <nrfx_spim_init+0x1b8>
            uint32_t dcx_pin = (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
   2179a:	7be3      	ldrb	r3, [r4, #15]
                               : NRF_SPIM_PIN_NOT_CONNECTED;
   2179c:	2bff      	cmp	r3, #255	; 0xff
   2179e:	bf08      	it	eq
   217a0:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff

#if NRF_SPIM_DCX_PRESENT
NRF_STATIC_INLINE void nrf_spim_dcx_pin_set(NRF_SPIM_Type * p_reg,
                                            uint32_t        dcx_pin)
{
    p_reg->PSELDCX = dcx_pin;
   217a4:	f8c5 356c 	str.w	r3, [r5, #1388]	; 0x56c

    configure_pins(p_instance, p_config);

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // Change rx delay
    nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
   217a8:	7c23      	ldrb	r3, [r4, #16]

#if NRF_SPIM_RXDELAY_PRESENT
NRF_STATIC_INLINE void nrf_spim_iftiming_set(NRF_SPIM_Type * p_reg,
                                             uint32_t        rxdelay)
{
    p_reg->IFTIMING.RXDELAY = rxdelay;
   217aa:	f8c8 3560 	str.w	r3, [r8, #1376]	; 0x560
#endif // defined(SPIM_STALLSTAT_TX_Msk)

NRF_STATIC_INLINE void nrf_spim_frequency_set(NRF_SPIM_Type *      p_reg,
                                              nrf_spim_frequency_t frequency)
{
    p_reg->FREQUENCY = (uint32_t)frequency;
   217ae:	68a3      	ldr	r3, [r4, #8]
   217b0:	f8c8 3524 	str.w	r3, [r8, #1316]	; 0x524
NRF_STATIC_INLINE void nrf_spim_configure(NRF_SPIM_Type *      p_reg,
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
   217b4:	7b63      	ldrb	r3, [r4, #13]
#endif

    nrf_spim_frequency_set(p_spim, p_config->frequency);
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
   217b6:	7b22      	ldrb	r2, [r4, #12]
   217b8:	3b00      	subs	r3, #0
   217ba:	bf18      	it	ne
   217bc:	2301      	movne	r3, #1
    switch (spi_mode)
   217be:	2a02      	cmp	r2, #2
   217c0:	d037      	beq.n	21832 <nrfx_spim_init+0x242>
   217c2:	2a03      	cmp	r2, #3
   217c4:	d038      	beq.n	21838 <nrfx_spim_init+0x248>
   217c6:	2a01      	cmp	r2, #1
   217c8:	d101      	bne.n	217ce <nrfx_spim_init+0x1de>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   217ca:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   217ce:	f8c8 3554 	str.w	r3, [r8, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
   217d2:	79a3      	ldrb	r3, [r4, #6]
   217d4:	f8c8 35c0 	str.w	r3, [r8, #1472]	; 0x5c0
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
   217d8:	2307      	movs	r3, #7
   217da:	f8c8 3500 	str.w	r3, [r8, #1280]	; 0x500

    nrf_spim_orc_set(p_spim, p_config->orc);

    nrf_spim_enable(p_spim);

    if (p_cb->handler)
   217de:	f856 3009 	ldr.w	r3, [r6, r9]
   217e2:	b123      	cbz	r3, 217ee <nrfx_spim_init+0x1fe>
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   217e4:	6838      	ldr	r0, [r7, #0]
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   217e6:	f340 3007 	sbfx	r0, r0, #12, #8
   217ea:	f7fc fd85 	bl	1e2f8 <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
   217ee:	2300      	movs	r3, #0
   217f0:	444e      	add	r6, r9
   217f2:	7773      	strb	r3, [r6, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   217f4:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   217f6:	4817      	ldr	r0, [pc, #92]	; (21854 <nrfx_spim_init+0x264>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   217f8:	7733      	strb	r3, [r6, #28]
}
   217fa:	b002      	add	sp, #8
   217fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   21800:	7c62      	ldrb	r2, [r4, #17]
   21802:	2a00      	cmp	r2, #0
   21804:	f47f af0e 	bne.w	21624 <nrfx_spim_init+0x34>
        ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
   21808:	7be1      	ldrb	r1, [r4, #15]
         !SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx)) ||
   2180a:	29ff      	cmp	r1, #255	; 0xff
   2180c:	f47f af0a 	bne.w	21624 <nrfx_spim_init+0x34>
   21810:	e70d      	b.n	2162e <nrfx_spim_init+0x3e>
   21812:	f7ff fedd 	bl	215d0 <nrf_gpio_pin_set>
   21816:	e75b      	b.n	216d0 <nrfx_spim_init+0xe0>
   21818:	f7ff feda 	bl	215d0 <nrf_gpio_pin_set>
   2181c:	e77f      	b.n	2171e <nrfx_spim_init+0x12e>
    p_reg->PSEL.CSN = pin;
   2181e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   21822:	f8c5 3514 	str.w	r3, [r5, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
   21826:	2300      	movs	r3, #0
   21828:	f8c5 3568 	str.w	r3, [r5, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
   2182c:	f8c5 3564 	str.w	r3, [r5, #1380]	; 0x564
}
   21830:	e7b0      	b.n	21794 <nrfx_spim_init+0x1a4>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   21832:	f043 0304 	orr.w	r3, r3, #4
        break;
   21836:	e7ca      	b.n	217ce <nrfx_spim_init+0x1de>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   21838:	f043 0306 	orr.w	r3, r3, #6
        break;
   2183c:	e7c7      	b.n	217ce <nrfx_spim_init+0x1de>
        return err_code;
   2183e:	4806      	ldr	r0, [pc, #24]	; (21858 <nrfx_spim_init+0x268>)
   21840:	e7db      	b.n	217fa <nrfx_spim_init+0x20a>
            return err_code;
   21842:	4806      	ldr	r0, [pc, #24]	; (2185c <nrfx_spim_init+0x26c>)
   21844:	e7d9      	b.n	217fa <nrfx_spim_init+0x20a>
   21846:	bf00      	nop
   21848:	2000b2f8 	.word	0x2000b2f8
   2184c:	0bad0003 	.word	0x0bad0003
   21850:	4000a000 	.word	0x4000a000
   21854:	0bad0000 	.word	0x0bad0000
   21858:	0bad0005 	.word	0x0bad0005
   2185c:	0bad0004 	.word	0x0bad0004

00021860 <nrfx_spim_uninit>:

    nrf_gpio_cfg_default(pin);
}

void nrfx_spim_uninit(nrfx_spim_t const * p_instance)
{
   21860:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21864:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
    NRF_SPIM_Type * p_spim = p_instance->p_reg;

    if (p_cb->handler)
   21866:	4d26      	ldr	r5, [pc, #152]	; (21900 <nrfx_spim_uninit+0xa0>)
   21868:	015e      	lsls	r6, r3, #5
   2186a:	eb05 1843 	add.w	r8, r5, r3, lsl #5
   2186e:	59ab      	ldr	r3, [r5, r6]
{
   21870:	4607      	mov	r7, r0
    NRF_SPIM_Type * p_spim = p_instance->p_reg;
   21872:	6804      	ldr	r4, [r0, #0]
    if (p_cb->handler)
   21874:	b1cb      	cbz	r3, 218aa <nrfx_spim_uninit+0x4a>
    {
        NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
   21876:	f344 3007 	sbfx	r0, r4, #12, #8
   2187a:	f7fc fd4b 	bl	1e314 <arch_irq_disable>
    p_reg->INTENCLR = mask;
   2187e:	4b21      	ldr	r3, [pc, #132]	; (21904 <nrfx_spim_uninit+0xa4>)
   21880:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
        nrf_spim_int_disable(p_spim, NRF_SPIM_ALL_INTS_MASK);
        if (p_cb->transfer_in_progress)
   21884:	f898 301d 	ldrb.w	r3, [r8, #29]
   21888:	b17b      	cbz	r3, 218aa <nrfx_spim_uninit+0x4a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2188a:	2301      	movs	r3, #1
   2188c:	f04f 0864 	mov.w	r8, #100	; 0x64
   21890:	6163      	str	r3, [r4, #20]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21892:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    NRFX_WAIT_FOR(nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STOPPED), 100, 1, stopped);
   21896:	b92b      	cbnz	r3, 218a4 <nrfx_spim_uninit+0x44>
   21898:	2001      	movs	r0, #1
   2189a:	f003 ffca 	bl	25832 <nrfx_busy_wait>
   2189e:	f1b8 0801 	subs.w	r8, r8, #1
   218a2:	d1f6      	bne.n	21892 <nrfx_spim_uninit+0x32>
    p_cb->transfer_in_progress = false;
   218a4:	2200      	movs	r2, #0
   218a6:	19ab      	adds	r3, r5, r6
   218a8:	775a      	strb	r2, [r3, #29]
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Disabled << SPIM_ENABLE_ENABLE_Pos);
   218aa:	2300      	movs	r3, #0
   218ac:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
        }
    }

    nrf_spim_disable(p_spim);

    if (!p_cb->skip_gpio_cfg)
   218b0:	19ab      	adds	r3, r5, r6
   218b2:	7f9b      	ldrb	r3, [r3, #30]
   218b4:	07db      	lsls	r3, r3, #31
   218b6:	d41c      	bmi.n	218f2 <nrfx_spim_uninit+0x92>
    return p_reg->PSEL.SCK;
   218b8:	f8d4 0508 	ldr.w	r0, [r4, #1288]	; 0x508
    {
        spim_pin_uninit(nrf_spim_sck_pin_get(p_spim));
   218bc:	f004 f81c 	bl	258f8 <spim_pin_uninit>
    return p_reg->PSEL.MISO;
   218c0:	f8d4 0510 	ldr.w	r0, [r4, #1296]	; 0x510
        spim_pin_uninit(nrf_spim_miso_pin_get(p_spim));
   218c4:	f004 f818 	bl	258f8 <spim_pin_uninit>
    return p_reg->PSEL.MOSI;
   218c8:	f8d4 050c 	ldr.w	r0, [r4, #1292]	; 0x50c
        spim_pin_uninit(nrf_spim_mosi_pin_get(p_spim));
   218cc:	f004 f814 	bl	258f8 <spim_pin_uninit>
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
   218d0:	793b      	ldrb	r3, [r7, #4]
   218d2:	2b01      	cmp	r3, #1
   218d4:	d103      	bne.n	218de <nrfx_spim_uninit+0x7e>
    return p_reg->PSELDCX;
   218d6:	f8d4 056c 	ldr.w	r0, [r4, #1388]	; 0x56c
        {
            spim_pin_uninit(nrf_spim_dcx_pin_get(p_spim));
   218da:	f004 f80d 	bl	258f8 <spim_pin_uninit>
        }
#endif
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   218de:	19ab      	adds	r3, r5, r6
   218e0:	7fd8      	ldrb	r0, [r3, #31]
   218e2:	28ff      	cmp	r0, #255	; 0xff
   218e4:	d005      	beq.n	218f2 <nrfx_spim_uninit+0x92>
    nrf_gpio_cfg(
   218e6:	2300      	movs	r3, #0
   218e8:	2201      	movs	r2, #1
   218ea:	4619      	mov	r1, r3
   218ec:	9300      	str	r3, [sp, #0]
   218ee:	f7ff fe4f 	bl	21590 <nrf_gpio_cfg.constprop.0>

#if NRFX_CHECK(NRFX_PRS_ENABLED)
    nrfx_prs_release(p_instance->p_reg);
#endif

    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
   218f2:	2300      	movs	r3, #0
   218f4:	4435      	add	r5, r6
   218f6:	772b      	strb	r3, [r5, #28]
}
   218f8:	b002      	add	sp, #8
   218fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   218fe:	bf00      	nop
   21900:	2000b2f8 	.word	0x2000b2f8
   21904:	00080152 	.word	0x00080152

00021908 <nrfx_spim_xfer>:
}

nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
                          nrfx_spim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   21908:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2190c:	4f38      	ldr	r7, [pc, #224]	; (219f0 <nrfx_spim_xfer+0xe8>)
   2190e:	7903      	ldrb	r3, [r0, #4]
{
   21910:	4615      	mov	r5, r2
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21912:	eb07 1843 	add.w	r8, r7, r3, lsl #5
#endif
                (p_cb->ss_pin == NRFX_SPIM_PIN_NOT_USED));

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
   21916:	f898 201d 	ldrb.w	r2, [r8, #29]
{
   2191a:	4681      	mov	r9, r0
   2191c:	460c      	mov	r4, r1
    if (p_cb->transfer_in_progress)
   2191e:	015e      	lsls	r6, r3, #5
   21920:	2a00      	cmp	r2, #0
   21922:	d163      	bne.n	219ec <nrfx_spim_xfer+0xe4>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
   21924:	59ba      	ldr	r2, [r7, r6]
   21926:	b12a      	cbz	r2, 21934 <nrfx_spim_xfer+0x2c>
   21928:	f015 0f14 	tst.w	r5, #20
                                        NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
        {
            p_cb->transfer_in_progress = true;
   2192c:	bf04      	itt	eq
   2192e:	2201      	moveq	r2, #1
   21930:	f888 201d 	strbeq.w	r2, [r8, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
   21934:	eb07 0c06 	add.w	ip, r7, r6
   21938:	f10c 0c0c 	add.w	ip, ip, #12
   2193c:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   21940:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    set_ss_pin_state(p_cb, true);
   21944:	2101      	movs	r1, #1
   21946:	4640      	mov	r0, r8
   21948:	f003 ffe2 	bl	25910 <set_ss_pin_state>
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   2194c:	6821      	ldr	r1, [r4, #0]

    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   2194e:	f8d9 3000 	ldr.w	r3, [r9]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   21952:	b121      	cbz	r1, 2195e <nrfx_spim_xfer+0x56>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   21954:	f001 4260 	and.w	r2, r1, #3758096384	; 0xe0000000
   21958:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   2195c:	d106      	bne.n	2196c <nrfx_spim_xfer+0x64>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   2195e:	68a2      	ldr	r2, [r4, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   21960:	b152      	cbz	r2, 21978 <nrfx_spim_xfer+0x70>
   21962:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   21966:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   2196a:	d005      	beq.n	21978 <nrfx_spim_xfer+0x70>
        p_cb->transfer_in_progress = false;
   2196c:	2300      	movs	r3, #0
   2196e:	443e      	add	r6, r7
        return err_code;
   21970:	4820      	ldr	r0, [pc, #128]	; (219f4 <nrfx_spim_xfer+0xec>)
        p_cb->transfer_in_progress = false;
   21972:	7773      	strb	r3, [r6, #29]
}
   21974:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   21978:	6862      	ldr	r2, [r4, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2197a:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2197e:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   21982:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
   21986:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   2198a:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2198e:	2200      	movs	r2, #0
   21990:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   21994:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   21998:	f015 0201 	ands.w	r2, r5, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   2199c:	bf18      	it	ne
   2199e:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   219a0:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   219a4:	f015 0202 	ands.w	r2, r5, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   219a8:	bf18      	it	ne
   219aa:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   219ac:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   219b0:	072a      	lsls	r2, r5, #28
   219b2:	d507      	bpl.n	219c4 <nrfx_spim_xfer+0xbc>
    if (!p_cb->handler)
   219b4:	59ba      	ldr	r2, [r7, r6]
   219b6:	b972      	cbnz	r2, 219d6 <nrfx_spim_xfer+0xce>
        set_ss_pin_state(p_cb, false);
   219b8:	2100      	movs	r1, #0
   219ba:	4640      	mov	r0, r8
   219bc:	f003 ffa8 	bl	25910 <set_ss_pin_state>
    return err_code;
   219c0:	480d      	ldr	r0, [pc, #52]	; (219f8 <nrfx_spim_xfer+0xf0>)
   219c2:	e7d7      	b.n	21974 <nrfx_spim_xfer+0x6c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   219c4:	2201      	movs	r2, #1
   219c6:	611a      	str	r2, [r3, #16]
    if (!p_cb->handler)
   219c8:	59ba      	ldr	r2, [r7, r6]
   219ca:	b922      	cbnz	r2, 219d6 <nrfx_spim_xfer+0xce>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   219cc:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
            while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   219d0:	2a00      	cmp	r2, #0
   219d2:	d0fb      	beq.n	219cc <nrfx_spim_xfer+0xc4>
   219d4:	e7f0      	b.n	219b8 <nrfx_spim_xfer+0xb0>
    if (!enable)
   219d6:	f015 0f04 	tst.w	r5, #4
   219da:	f04f 0240 	mov.w	r2, #64	; 0x40
   219de:	d002      	beq.n	219e6 <nrfx_spim_xfer+0xde>
    p_reg->INTENCLR = mask;
   219e0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   219e4:	e7ec      	b.n	219c0 <nrfx_spim_xfer+0xb8>
    p_reg->INTENSET = mask;
   219e6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   219ea:	e7e9      	b.n	219c0 <nrfx_spim_xfer+0xb8>
        return err_code;
   219ec:	4803      	ldr	r0, [pc, #12]	; (219fc <nrfx_spim_xfer+0xf4>)
   219ee:	e7c1      	b.n	21974 <nrfx_spim_xfer+0x6c>
   219f0:	2000b2f8 	.word	0x2000b2f8
   219f4:	0bad000a 	.word	0x0bad000a
   219f8:	0bad0000 	.word	0x0bad0000
   219fc:	0bad000b 	.word	0x0bad000b

00021a00 <nrfx_spim_3_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21a00:	4b06      	ldr	r3, [pc, #24]	; (21a1c <nrfx_spim_3_irq_handler+0x1c>)
   21a02:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
        nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
        return;
    }
#endif

    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   21a06:	b13a      	cbz	r2, 21a18 <nrfx_spim_3_irq_handler+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21a08:	2200      	movs	r2, #0
   21a0a:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   21a0e:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        }
#endif
        nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
        NRFX_ASSERT(p_cb->handler);
        NRFX_LOG_DEBUG("Event: NRF_SPIM_EVENT_END.");
        finish_transfer(p_cb);
   21a12:	4803      	ldr	r0, [pc, #12]	; (21a20 <nrfx_spim_3_irq_handler+0x20>)
   21a14:	f003 bf8c 	b.w	25930 <finish_transfer>

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
}
   21a18:	4770      	bx	lr
   21a1a:	bf00      	nop
   21a1c:	4000c000 	.word	0x4000c000
   21a20:	2000b2f8 	.word	0x2000b2f8

00021a24 <nrfx_spim_4_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21a24:	4b06      	ldr	r3, [pc, #24]	; (21a40 <nrfx_spim_4_irq_handler+0x1c>)
   21a26:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   21a2a:	b13a      	cbz	r2, 21a3c <nrfx_spim_4_irq_handler+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21a2c:	2200      	movs	r2, #0
   21a2e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   21a32:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        finish_transfer(p_cb);
   21a36:	4803      	ldr	r0, [pc, #12]	; (21a44 <nrfx_spim_4_irq_handler+0x20>)
   21a38:	f003 bf7a 	b.w	25930 <finish_transfer>

#if NRFX_CHECK(NRFX_SPIM4_ENABLED)
void nrfx_spim_4_irq_handler(void)
{
    irq_handler(NRF_SPIM4, &m_cb[NRFX_SPIM4_INST_IDX]);
}
   21a3c:	4770      	bx	lr
   21a3e:	bf00      	nop
   21a40:	4000a000 	.word	0x4000a000
   21a44:	2000b318 	.word	0x2000b318

00021a48 <nrfx_twim_init>:
    NRFX_ASSERT(p_config);
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   21a48:	f04f 0c34 	mov.w	ip, #52	; 0x34
{
   21a4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   21a50:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   21a52:	4d46      	ldr	r5, [pc, #280]	; (21b6c <nrfx_twim_init+0x124>)
   21a54:	fb0c fc06 	mul.w	ip, ip, r6
   21a58:	eb05 040c 	add.w	r4, r5, ip
{
   21a5c:	469e      	mov	lr, r3
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   21a5e:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   21a62:	2b00      	cmp	r3, #0
   21a64:	d17d      	bne.n	21b62 <nrfx_twim_init+0x11a>
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   21a66:	6807      	ldr	r7, [r0, #0]
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler         = event_handler;
    p_cb->p_context       = p_context;
    p_cb->int_mask        = 0;
   21a68:	60a3      	str	r3, [r4, #8]
    p_cb->handler         = event_handler;
   21a6a:	f845 200c 	str.w	r2, [r5, ip]
    p_cb->p_context       = p_context;
   21a6e:	f8c4 e004 	str.w	lr, [r4, #4]
    p_cb->repeated        = false;
   21a72:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    p_cb->busy            = false;
   21a76:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   21a7a:	7b4b      	ldrb	r3, [r1, #13]
   21a7c:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
    p_cb->skip_gpio_cfg   = p_config->skip_gpio_cfg;
   21a80:	f891 c00e 	ldrb.w	ip, [r1, #14]
   21a84:	f884 c033 	strb.w	ip, [r4, #51]	; 0x33
    if (p_config->skip_gpio_cfg && p_config->skip_psel_cfg)
   21a88:	688b      	ldr	r3, [r1, #8]
   21a8a:	f1bc 0f00 	cmp.w	ip, #0
   21a8e:	d01c      	beq.n	21aca <nrfx_twim_init+0x82>
   21a90:	7bcc      	ldrb	r4, [r1, #15]
   21a92:	b944      	cbnz	r4, 21aa6 <nrfx_twim_init+0x5e>
    if (p_config->frequency >= NRF_TWIM_FREQ_1000K)
   21a94:	f1b3 6f7f 	cmp.w	r3, #267386880	; 0xff00000
   21a98:	d24d      	bcs.n	21b36 <nrfx_twim_init+0xee>
        nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
   21a9a:	e9d1 4300 	ldrd	r4, r3, [r1]
    p_reg->PSEL.SCL = scl_pin;
   21a9e:	f8c7 4508 	str.w	r4, [r7, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   21aa2:	f8c7 350c 	str.w	r3, [r7, #1292]	; 0x50c
    if (!twim_pins_configure(p_twim, p_config))
    {
        return NRFX_ERROR_INVALID_PARAM;
    }

    nrf_twim_frequency_set(p_twim, (nrf_twim_frequency_t)p_config->frequency);
   21aa6:	688b      	ldr	r3, [r1, #8]
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   21aa8:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524

    if (p_cb->handler)
   21aac:	b122      	cbz	r2, 21ab8 <nrfx_twim_init+0x70>
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   21aae:	6800      	ldr	r0, [r0, #0]
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_twim),
            p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   21ab0:	f340 3007 	sbfx	r0, r0, #12, #8
   21ab4:	f7fc fc20 	bl	1e2f8 <arch_irq_enable>
    }

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21ab8:	2334      	movs	r3, #52	; 0x34
   21aba:	fb03 5506 	mla	r5, r3, r6, r5
   21abe:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   21ac0:	482b      	ldr	r0, [pc, #172]	; (21b70 <nrfx_twim_init+0x128>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21ac2:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
}
   21ac6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (p_config->frequency >= NRF_TWIM_FREQ_1000K)
   21aca:	f1b3 6f7f 	cmp.w	r3, #267386880	; 0xff00000
   21ace:	d345      	bcc.n	21b5c <nrfx_twim_init+0x114>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   21ad0:	680b      	ldr	r3, [r1, #0]
   21ad2:	2b22      	cmp	r3, #34	; 0x22
   21ad4:	d139      	bne.n	21b4a <nrfx_twim_init+0x102>
   21ad6:	684b      	ldr	r3, [r1, #4]
   21ad8:	2b23      	cmp	r3, #35	; 0x23
   21ada:	d144      	bne.n	21b66 <nrfx_twim_init+0x11e>
   21adc:	f04f 0c0b 	mov.w	ip, #11
        TWIM_PIN_INIT(p_config->scl, drive);
   21ae0:	680c      	ldr	r4, [r1, #0]
        case 0: return NRF_P0;
   21ae2:	4b24      	ldr	r3, [pc, #144]	; (21b74 <nrfx_twim_init+0x12c>)
   21ae4:	f8df 8090 	ldr.w	r8, [pc, #144]	; 21b78 <nrfx_twim_init+0x130>
    *p_pin = pin_number & 0x1F;
   21ae8:	f004 091f 	and.w	r9, r4, #31
    return pin_number >> 5;
   21aec:	0964      	lsrs	r4, r4, #5
        case 0: return NRF_P0;
   21aee:	2c01      	cmp	r4, #1
   21af0:	bf0c      	ite	eq
   21af2:	469e      	moveq	lr, r3
   21af4:	46c6      	movne	lr, r8
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21af6:	eb0e 0e89 	add.w	lr, lr, r9, lsl #2
   21afa:	f8de 4200 	ldr.w	r4, [lr, #512]	; 0x200
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   21afe:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   21b02:	f04c 0c0c 	orr.w	ip, ip, #12
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21b06:	f004 44e0 	and.w	r4, r4, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   21b0a:	ea44 040c 	orr.w	r4, r4, ip
    reg->PIN_CNF[pin_number] = cnf;
   21b0e:	f8ce 4200 	str.w	r4, [lr, #512]	; 0x200
        TWIM_PIN_INIT(p_config->sda, drive);
   21b12:	684c      	ldr	r4, [r1, #4]
    *p_pin = pin_number & 0x1F;
   21b14:	f004 0e1f 	and.w	lr, r4, #31
    return pin_number >> 5;
   21b18:	0964      	lsrs	r4, r4, #5
        case 0: return NRF_P0;
   21b1a:	2c01      	cmp	r4, #1
   21b1c:	bf18      	it	ne
   21b1e:	4643      	movne	r3, r8
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21b20:	eb03 038e 	add.w	r3, r3, lr, lsl #2
   21b24:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
   21b28:	f004 44e0 	and.w	r4, r4, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   21b2c:	ea44 040c 	orr.w	r4, r4, ip
    reg->PIN_CNF[pin_number] = cnf;
   21b30:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
   21b34:	e005      	b.n	21b42 <nrfx_twim_init+0xfa>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   21b36:	680b      	ldr	r3, [r1, #0]
   21b38:	2b22      	cmp	r3, #34	; 0x22
   21b3a:	d106      	bne.n	21b4a <nrfx_twim_init+0x102>
   21b3c:	684b      	ldr	r3, [r1, #4]
   21b3e:	2b23      	cmp	r3, #35	; 0x23
   21b40:	d111      	bne.n	21b66 <nrfx_twim_init+0x11e>
    if (!p_config->skip_psel_cfg)
   21b42:	7bcb      	ldrb	r3, [r1, #15]
   21b44:	2b00      	cmp	r3, #0
   21b46:	d1ae      	bne.n	21aa6 <nrfx_twim_init+0x5e>
   21b48:	e7a7      	b.n	21a9a <nrfx_twim_init+0x52>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   21b4a:	2b23      	cmp	r3, #35	; 0x23
   21b4c:	d10b      	bne.n	21b66 <nrfx_twim_init+0x11e>
            ((p_config->scl != e0e1_pin_2) || (p_config->sda != e0e1_pin_1)))
   21b4e:	684b      	ldr	r3, [r1, #4]
   21b50:	2b22      	cmp	r3, #34	; 0x22
   21b52:	d108      	bne.n	21b66 <nrfx_twim_init+0x11e>
    if (!p_config->skip_gpio_cfg)
   21b54:	f1bc 0f00 	cmp.w	ip, #0
   21b58:	d1f3      	bne.n	21b42 <nrfx_twim_init+0xfa>
   21b5a:	e7bf      	b.n	21adc <nrfx_twim_init+0x94>
        drive = NRF_GPIO_PIN_S0D1;
   21b5c:	f04f 0c06 	mov.w	ip, #6
   21b60:	e7be      	b.n	21ae0 <nrfx_twim_init+0x98>
        return err_code;
   21b62:	4806      	ldr	r0, [pc, #24]	; (21b7c <nrfx_twim_init+0x134>)
   21b64:	e7af      	b.n	21ac6 <nrfx_twim_init+0x7e>
        return NRFX_ERROR_INVALID_PARAM;
   21b66:	4806      	ldr	r0, [pc, #24]	; (21b80 <nrfx_twim_init+0x138>)
   21b68:	e7ad      	b.n	21ac6 <nrfx_twim_init+0x7e>
   21b6a:	bf00      	nop
   21b6c:	2000b338 	.word	0x2000b338
   21b70:	0bad0000 	.word	0x0bad0000
   21b74:	40842800 	.word	0x40842800
   21b78:	40842500 	.word	0x40842500
   21b7c:	0bad0005 	.word	0x0bad0005
   21b80:	0bad0004 	.word	0x0bad0004

00021b84 <nrfx_twim_enable>:
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   21b84:	2106      	movs	r1, #6
void nrfx_twim_enable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);

    nrf_twim_enable(p_instance->p_twim);
   21b86:	6803      	ldr	r3, [r0, #0]
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21b88:	7902      	ldrb	r2, [r0, #4]
   21b8a:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500

    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   21b8e:	2134      	movs	r1, #52	; 0x34
   21b90:	4b03      	ldr	r3, [pc, #12]	; (21ba0 <nrfx_twim_enable+0x1c>)
   21b92:	fb01 3302 	mla	r3, r1, r2, r3
   21b96:	2202      	movs	r2, #2
   21b98:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance enabled: %d.", p_instance->drv_inst_idx);
}
   21b9c:	4770      	bx	lr
   21b9e:	bf00      	nop
   21ba0:	2000b338 	.word	0x2000b338

00021ba4 <nrfx_twim_disable>:

void nrfx_twim_disable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21ba4:	7901      	ldrb	r1, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   21ba6:	6802      	ldr	r2, [r0, #0]
    p_cb->int_mask = 0;
   21ba8:	2034      	movs	r0, #52	; 0x34
   21baa:	4b0b      	ldr	r3, [pc, #44]	; (21bd8 <nrfx_twim_disable+0x34>)
   21bac:	fb00 3301 	mla	r3, r0, r1, r3
   21bb0:	2100      	movs	r1, #0
    p_reg->INTENCLR = mask;
   21bb2:	480a      	ldr	r0, [pc, #40]	; (21bdc <nrfx_twim_disable+0x38>)
   21bb4:	6099      	str	r1, [r3, #8]
   21bb6:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   21bba:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
   21bbe:	f420 50bc 	bic.w	r0, r0, #6016	; 0x1780
   21bc2:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   21bc6:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    nrf_twim_shorts_disable(p_twim, NRF_TWIM_ALL_SHORTS_MASK);
    nrf_twim_disable(p_twim);

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21bca:	2201      	movs	r2, #1
    p_cb->busy = false;
   21bcc:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21bd0:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance disabled: %d.", p_instance->drv_inst_idx);
}
   21bd4:	4770      	bx	lr
   21bd6:	bf00      	nop
   21bd8:	2000b338 	.word	0x2000b338
   21bdc:	019c0202 	.word	0x019c0202

00021be0 <nrfx_twim_xfer>:
                            nrfx_twim_xfer_desc_t const * p_xfer_desc,
                            uint32_t                      flags)
{
    nrfx_err_t err_code = NRFX_SUCCESS;
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
    p_cb->error = false;
   21be0:	2334      	movs	r3, #52	; 0x34


nrfx_err_t nrfx_twim_xfer(nrfx_twim_t           const * p_instance,
                          nrfx_twim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   21be2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21be6:	4617      	mov	r7, r2
    p_cb->error = false;
   21be8:	2200      	movs	r2, #0
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
                                     p_xfer_desc->primary_length,
                                     p_xfer_desc->secondary_length));

    nrfx_err_t err_code = NRFX_SUCCESS;
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21bea:	f890 e004 	ldrb.w	lr, [r0, #4]
    p_cb->error = false;
   21bee:	f8df c2e4 	ldr.w	ip, [pc, #740]	; 21ed4 <nrfx_twim_xfer+0x2f4>
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   21bf2:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
   21bf4:	fb03 c30e 	mla	r3, r3, lr, ip
   21bf8:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   21bfc:	684b      	ldr	r3, [r1, #4]
{
   21bfe:	460d      	mov	r5, r1
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   21c00:	b14b      	cbz	r3, 21c16 <nrfx_twim_xfer+0x36>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   21c02:	68cb      	ldr	r3, [r1, #12]
   21c04:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   21c08:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   21c0c:	d003      	beq.n	21c16 <nrfx_twim_xfer+0x36>
        return err_code;
   21c0e:	4eb2      	ldr	r6, [pc, #712]	; (21ed8 <nrfx_twim_xfer+0x2f8>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   21c10:	4630      	mov	r0, r6
   21c12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (p_cb->busy)
   21c16:	2634      	movs	r6, #52	; 0x34
   21c18:	fb06 c60e 	mla	r6, r6, lr, ip
    p_reg->INTENCLR = mask;
   21c1c:	4baf      	ldr	r3, [pc, #700]	; (21edc <nrfx_twim_xfer+0x2fc>)
   21c1e:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
   21c22:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
   21c26:	f003 0aff 	and.w	sl, r3, #255	; 0xff
   21c2a:	b123      	cbz	r3, 21c36 <nrfx_twim_xfer+0x56>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   21c2c:	68b3      	ldr	r3, [r6, #8]
        return err_code;
   21c2e:	4eac      	ldr	r6, [pc, #688]	; (21ee0 <nrfx_twim_xfer+0x300>)
    p_reg->INTENSET = mask;
   21c30:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   21c34:	e7ec      	b.n	21c10 <nrfx_twim_xfer+0x30>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   21c36:	f017 0f14 	tst.w	r7, #20
   21c3a:	bf0c      	ite	eq
   21c3c:	2301      	moveq	r3, #1
   21c3e:	2300      	movne	r3, #0
    p_cb->xfer_desc = *p_xfer_desc;
   21c40:	46a9      	mov	r9, r5
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   21c42:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
   21c46:	f106 080c 	add.w	r8, r6, #12
   21c4a:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
   21c4e:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
   21c52:	f8d9 3000 	ldr.w	r3, [r9]
    p_cb->flags = flags;
   21c56:	6237      	str	r7, [r6, #32]
    p_cb->xfer_desc = *p_xfer_desc;
   21c58:	f8c8 3000 	str.w	r3, [r8]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   21c5c:	f3c7 1300 	ubfx	r3, r7, #4, #1
   21c60:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   21c64:	786b      	ldrb	r3, [r5, #1]
   21c66:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21c6a:	f8c4 a104 	str.w	sl, [r4, #260]	; 0x104
   21c6e:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   21c72:	f8c4 a124 	str.w	sl, [r4, #292]	; 0x124
   21c76:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
   21c7a:	f8c4 a160 	str.w	sl, [r4, #352]	; 0x160
   21c7e:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
   21c82:	f8c4 a148 	str.w	sl, [r4, #328]	; 0x148
   21c86:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   21c8a:	f017 0301 	ands.w	r3, r7, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   21c8e:	bf18      	it	ne
   21c90:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   21c92:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   21c96:	f017 0302 	ands.w	r3, r7, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   21c9a:	bf18      	it	ne
   21c9c:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   21c9e:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
   21ca2:	782b      	ldrb	r3, [r5, #0]
   21ca4:	2b03      	cmp	r3, #3
   21ca6:	f200 80b9 	bhi.w	21e1c <nrfx_twim_xfer+0x23c>
   21caa:	e8df f003 	tbb	[pc, r3]
   21cae:	a48b      	.short	0xa48b
   21cb0:	026d      	.short	0x026d
   21cb2:	692b      	ldr	r3, [r5, #16]
   21cb4:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   21cb8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   21cbc:	d1a7      	bne.n	21c0e <nrfx_twim_xfer+0x2e>
    p_reg->SHORTS = mask;
   21cbe:	f44f 7380 	mov.w	r3, #256	; 0x100
   21cc2:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21cc6:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21cc8:	68ea      	ldr	r2, [r5, #12]
   21cca:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21cce:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21cd2:	2300      	movs	r3, #0
   21cd4:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   21cd8:	f8d4 2150 	ldr.w	r2, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21cdc:	2201      	movs	r2, #1
   21cde:	6222      	str	r2, [r4, #32]
   21ce0:	60a2      	str	r2, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21ce2:	f8d4 2150 	ldr.w	r2, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   21ce6:	2a00      	cmp	r2, #0
   21ce8:	d0fb      	beq.n	21ce2 <nrfx_twim_xfer+0x102>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21cea:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   21cee:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21cf2:	692a      	ldr	r2, [r5, #16]
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   21cf4:	68ab      	ldr	r3, [r5, #8]
   21cf6:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21cfa:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   21cfe:	2334      	movs	r3, #52	; 0x34
   21d00:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   21d04:	fb03 c30e 	mla	r3, r3, lr, ip
   21d08:	609a      	str	r2, [r3, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   21d0a:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   21d0c:	4e75      	ldr	r6, [pc, #468]	; (21ee4 <nrfx_twim_xfer+0x304>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   21d0e:	0738      	lsls	r0, r7, #28
   21d10:	d407      	bmi.n	21d22 <nrfx_twim_xfer+0x142>
   21d12:	782a      	ldrb	r2, [r5, #0]
   21d14:	2a03      	cmp	r2, #3
   21d16:	d004      	beq.n	21d22 <nrfx_twim_xfer+0x142>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21d18:	2201      	movs	r2, #1
   21d1a:	50e2      	str	r2, [r4, r3]
        if (p_xfer_desc->primary_length == 0)
   21d1c:	686b      	ldr	r3, [r5, #4]
   21d1e:	b903      	cbnz	r3, 21d22 <nrfx_twim_xfer+0x142>
   21d20:	6162      	str	r2, [r4, #20]
    if (p_cb->handler)
   21d22:	2334      	movs	r3, #52	; 0x34
   21d24:	fb03 f30e 	mul.w	r3, r3, lr
   21d28:	f85c 1003 	ldr.w	r1, [ip, r3]
   21d2c:	eb0c 0203 	add.w	r2, ip, r3
   21d30:	2900      	cmp	r1, #0
   21d32:	d176      	bne.n	21e22 <nrfx_twim_xfer+0x242>
   21d34:	2001      	movs	r0, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21d36:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   21d3a:	2b00      	cmp	r3, #0
   21d3c:	f000 8089 	beq.w	21e52 <nrfx_twim_xfer+0x272>
   21d40:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21d44:	2b00      	cmp	r3, #0
   21d46:	f040 8087 	bne.w	21e58 <nrfx_twim_xfer+0x278>
   21d4a:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   21d4e:	2b00      	cmp	r3, #0
   21d50:	f000 8095 	beq.w	21e7e <nrfx_twim_xfer+0x29e>
                transmission_finished = true;
   21d54:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21d56:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
   21d5a:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21d5e:	f8d4 5160 	ldr.w	r5, [r4, #352]	; 0x160
    return p_reg->SHORTS;
   21d62:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   21d66:	2d00      	cmp	r5, #0
   21d68:	f000 8081 	beq.w	21e6e <nrfx_twim_xfer+0x28e>
   21d6c:	f412 7f00 	tst.w	r2, #512	; 0x200
   21d70:	f402 7280 	and.w	r2, r2, #256	; 0x100
   21d74:	d17e      	bne.n	21e74 <nrfx_twim_xfer+0x294>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21d76:	6220      	str	r0, [r4, #32]
   21d78:	6160      	str	r0, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   21d7a:	2a00      	cmp	r2, #0
   21d7c:	d0db      	beq.n	21d36 <nrfx_twim_xfer+0x156>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21d7e:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
   21d82:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
                    transmission_finished = false;
   21d86:	e7d6      	b.n	21d36 <nrfx_twim_xfer+0x156>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21d88:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21d8a:	68ea      	ldr	r2, [r5, #12]
   21d8c:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21d90:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   21d94:	692b      	ldr	r3, [r5, #16]
   21d96:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   21d9a:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   21d9e:	f47f af36 	bne.w	21c0e <nrfx_twim_xfer+0x2e>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   21da2:	68aa      	ldr	r2, [r5, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   21da4:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
   21da8:	f44f 5384 	mov.w	r3, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
   21dac:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   21db0:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21db4:	2334      	movs	r3, #52	; 0x34
   21db6:	2202      	movs	r2, #2
   21db8:	fb03 c30e 	mla	r3, r3, lr, ip
   21dbc:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21dbe:	2301      	movs	r3, #1
   21dc0:	6223      	str	r3, [r4, #32]
   21dc2:	e7a2      	b.n	21d0a <nrfx_twim_xfer+0x12a>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21dc4:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21dc6:	68ea      	ldr	r2, [r5, #12]
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   21dc8:	f017 0f20 	tst.w	r7, #32
   21dcc:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21dd0:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   21dd4:	f04f 0334 	mov.w	r3, #52	; 0x34
   21dd8:	d008      	beq.n	21dec <nrfx_twim_xfer+0x20c>
    p_reg->SHORTS = mask;
   21dda:	f44f 7280 	mov.w	r2, #256	; 0x100
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   21dde:	fb03 c30e 	mla	r3, r3, lr, ip
   21de2:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
   21de6:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   21dea:	e7e7      	b.n	21dbc <nrfx_twim_xfer+0x1dc>
   21dec:	f44f 7200 	mov.w	r2, #512	; 0x200
   21df0:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21df4:	e7df      	b.n	21db6 <nrfx_twim_xfer+0x1d6>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21df6:	686b      	ldr	r3, [r5, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   21df8:	68ea      	ldr	r2, [r5, #12]
   21dfa:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   21dfe:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   21e02:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   21e06:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21e0a:	2334      	movs	r3, #52	; 0x34
   21e0c:	2202      	movs	r2, #2
   21e0e:	fb03 c30e 	mla	r3, r3, lr, ip
   21e12:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21e14:	2301      	movs	r3, #1
   21e16:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
   21e18:	2300      	movs	r3, #0
   21e1a:	e777      	b.n	21d0c <nrfx_twim_xfer+0x12c>
    switch (p_xfer_desc->type)
   21e1c:	2308      	movs	r3, #8
   21e1e:	4e32      	ldr	r6, [pc, #200]	; (21ee8 <nrfx_twim_xfer+0x308>)
   21e20:	e775      	b.n	21d0e <nrfx_twim_xfer+0x12e>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   21e22:	0779      	lsls	r1, r7, #29
            p_cb->int_mask = 0;
   21e24:	bf44      	itt	mi
   21e26:	2300      	movmi	r3, #0
   21e28:	6093      	strmi	r3, [r2, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   21e2a:	067a      	lsls	r2, r7, #25
   21e2c:	d406      	bmi.n	21e3c <nrfx_twim_xfer+0x25c>
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   21e2e:	2334      	movs	r3, #52	; 0x34
   21e30:	fb03 c30e 	mla	r3, r3, lr, ip
   21e34:	689a      	ldr	r2, [r3, #8]
   21e36:	f042 0202 	orr.w	r2, r2, #2
   21e3a:	609a      	str	r2, [r3, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   21e3c:	2334      	movs	r3, #52	; 0x34
   21e3e:	fb03 c30e 	mla	r3, r3, lr, ip
   21e42:	689a      	ldr	r2, [r3, #8]
   21e44:	f442 7200 	orr.w	r2, r2, #512	; 0x200
   21e48:	609a      	str	r2, [r3, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   21e4a:	689b      	ldr	r3, [r3, #8]
    p_reg->INTENSET = mask;
   21e4c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   21e50:	e6de      	b.n	21c10 <nrfx_twim_xfer+0x30>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21e52:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21e56:	b123      	cbz	r3, 21e62 <nrfx_twim_xfer+0x282>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21e58:	f8c4 1104 	str.w	r1, [r4, #260]	; 0x104
   21e5c:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21e60:	e773      	b.n	21d4a <nrfx_twim_xfer+0x16a>
   21e62:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   21e66:	2a00      	cmp	r2, #0
   21e68:	f43f af65 	beq.w	21d36 <nrfx_twim_xfer+0x156>
   21e6c:	e773      	b.n	21d56 <nrfx_twim_xfer+0x176>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21e6e:	6220      	str	r0, [r4, #32]
   21e70:	6160      	str	r0, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   21e72:	e760      	b.n	21d36 <nrfx_twim_xfer+0x156>
   21e74:	2a00      	cmp	r2, #0
   21e76:	d182      	bne.n	21d7e <nrfx_twim_xfer+0x19e>
        } while (!transmission_finished);
   21e78:	2b00      	cmp	r3, #0
   21e7a:	f43f af5c 	beq.w	21d36 <nrfx_twim_xfer+0x156>
        p_cb->busy = false;
   21e7e:	2134      	movs	r1, #52	; 0x34
   21e80:	2000      	movs	r0, #0
   21e82:	fb01 c20e 	mla	r2, r1, lr, ip
    uint32_t error_source = p_reg->ERRORSRC;
   21e86:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   21e8a:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
   21e8e:	f882 002f 	strb.w	r0, [r2, #47]	; 0x2f
        if (errorsrc)
   21e92:	b18b      	cbz	r3, 21eb8 <nrfx_twim_xfer+0x2d8>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   21e94:	4a15      	ldr	r2, [pc, #84]	; (21eec <nrfx_twim_xfer+0x30c>)
   21e96:	f013 0f01 	tst.w	r3, #1
   21e9a:	4e15      	ldr	r6, [pc, #84]	; (21ef0 <nrfx_twim_xfer+0x310>)
   21e9c:	bf18      	it	ne
   21e9e:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   21ea0:	f013 0f02 	tst.w	r3, #2
   21ea4:	f102 0201 	add.w	r2, r2, #1
   21ea8:	bf18      	it	ne
   21eaa:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   21eac:	f013 0f04 	tst.w	r3, #4
   21eb0:	4b10      	ldr	r3, [pc, #64]	; (21ef4 <nrfx_twim_xfer+0x314>)
   21eb2:	bf18      	it	ne
   21eb4:	461e      	movne	r6, r3
   21eb6:	e6ab      	b.n	21c10 <nrfx_twim_xfer+0x30>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   21eb8:	067b      	lsls	r3, r7, #25
   21eba:	f53f aea9 	bmi.w	21c10 <nrfx_twim_xfer+0x30>
                !xfer_completeness_check(p_twim, p_cb))
   21ebe:	4620      	mov	r0, r4
   21ec0:	fb0e c101 	mla	r1, lr, r1, ip
   21ec4:	f003 fd43 	bl	2594e <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
   21ec8:	4b09      	ldr	r3, [pc, #36]	; (21ef0 <nrfx_twim_xfer+0x310>)
   21eca:	2800      	cmp	r0, #0
   21ecc:	bf08      	it	eq
   21ece:	461e      	moveq	r6, r3
   21ed0:	e69e      	b.n	21c10 <nrfx_twim_xfer+0x30>
   21ed2:	bf00      	nop
   21ed4:	2000b338 	.word	0x2000b338
   21ed8:	0bad000a 	.word	0x0bad000a
   21edc:	019c0202 	.word	0x019c0202
   21ee0:	0bad000b 	.word	0x0bad000b
   21ee4:	0bad0000 	.word	0x0bad0000
   21ee8:	0bad0004 	.word	0x0bad0004
   21eec:	0bae0000 	.word	0x0bae0000
   21ef0:	0bad0001 	.word	0x0bad0001
   21ef4:	0bae0002 	.word	0x0bae0002

00021ef8 <nrfx_twim_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
   21ef8:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21efa:	4d5a      	ldr	r5, [pc, #360]	; (22064 <nrfx_twim_1_irq_handler+0x16c>)
   21efc:	4c5a      	ldr	r4, [pc, #360]	; (22068 <nrfx_twim_1_irq_handler+0x170>)
   21efe:	f8d5 3124 	ldr.w	r3, [r5, #292]	; 0x124
   21f02:	b087      	sub	sp, #28
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   21f04:	b1fb      	cbz	r3, 21f46 <nrfx_twim_1_irq_handler+0x4e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21f06:	2300      	movs	r3, #0
   21f08:	f8c5 3124 	str.w	r3, [r5, #292]	; 0x124
   21f0c:	f8d5 3124 	ldr.w	r3, [r5, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21f10:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21f14:	b9bb      	cbnz	r3, 21f46 <nrfx_twim_1_irq_handler+0x4e>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   21f16:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   21f18:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21f1c:	2302      	movs	r3, #2
   21f1e:	60a3      	str	r3, [r4, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   21f20:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   21f22:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21f26:	f8d5 3160 	ldr.w	r3, [r5, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   21f2a:	b11b      	cbz	r3, 21f34 <nrfx_twim_1_irq_handler+0x3c>
    return p_reg->SHORTS;
   21f2c:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
   21f30:	059e      	lsls	r6, r3, #22
   21f32:	d403      	bmi.n	21f3c <nrfx_twim_1_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21f34:	2201      	movs	r2, #1
   21f36:	4b4b      	ldr	r3, [pc, #300]	; (22064 <nrfx_twim_1_irq_handler+0x16c>)
   21f38:	621a      	str	r2, [r3, #32]
   21f3a:	615a      	str	r2, [r3, #20]
            p_cb->error = true;
   21f3c:	2301      	movs	r3, #1
   21f3e:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
}
   21f42:	b007      	add	sp, #28
   21f44:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21f46:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21f4a:	2b00      	cmp	r3, #0
   21f4c:	d05a      	beq.n	22004 <nrfx_twim_1_irq_handler+0x10c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21f4e:	2300      	movs	r3, #0
   21f50:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   21f54:	6a27      	ldr	r7, [r4, #32]
   21f56:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
   21f5a:	067d      	lsls	r5, r7, #25
   21f5c:	d40a      	bmi.n	21f74 <nrfx_twim_1_irq_handler+0x7c>
   21f5e:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   21f62:	b93b      	cbnz	r3, 21f74 <nrfx_twim_1_irq_handler+0x7c>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   21f64:	4940      	ldr	r1, [pc, #256]	; (22068 <nrfx_twim_1_irq_handler+0x170>)
   21f66:	483f      	ldr	r0, [pc, #252]	; (22064 <nrfx_twim_1_irq_handler+0x16c>)
   21f68:	f003 fcf1 	bl	2594e <xfer_completeness_check>
   21f6c:	f080 0001 	eor.w	r0, r0, #1
   21f70:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   21f74:	f017 0704 	ands.w	r7, r7, #4
            if (!p_cb->repeated || p_cb->error)
   21f78:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   21f7c:	d120      	bne.n	21fc0 <nrfx_twim_1_irq_handler+0xc8>
            event.xfer_desc = p_cb->xfer_desc;
   21f7e:	4e3b      	ldr	r6, [pc, #236]	; (2206c <nrfx_twim_1_irq_handler+0x174>)
   21f80:	ad01      	add	r5, sp, #4
   21f82:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   21f84:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   21f86:	6833      	ldr	r3, [r6, #0]
   21f88:	602b      	str	r3, [r5, #0]
   21f8a:	4b36      	ldr	r3, [pc, #216]	; (22064 <nrfx_twim_1_irq_handler+0x16c>)
   21f8c:	f8c3 7160 	str.w	r7, [r3, #352]	; 0x160
   21f90:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
   21f94:	f8c3 715c 	str.w	r7, [r3, #348]	; 0x15c
   21f98:	f8d3 215c 	ldr.w	r2, [r3, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
   21f9c:	f1bc 0f00 	cmp.w	ip, #0
   21fa0:	d002      	beq.n	21fa8 <nrfx_twim_1_irq_handler+0xb0>
   21fa2:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
   21fa6:	b15a      	cbz	r2, 21fc0 <nrfx_twim_1_irq_handler+0xc8>
    p_reg->SHORTS = mask;
   21fa8:	2200      	movs	r2, #0
   21faa:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                p_cb->int_mask = 0;
   21fae:	60a2      	str	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   21fb0:	4a2f      	ldr	r2, [pc, #188]	; (22070 <nrfx_twim_1_irq_handler+0x178>)
   21fb2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   21fb6:	f44f 7200 	mov.w	r2, #512	; 0x200
   21fba:	4b2e      	ldr	r3, [pc, #184]	; (22074 <nrfx_twim_1_irq_handler+0x17c>)
   21fbc:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    uint32_t error_source = p_reg->ERRORSRC;
   21fc0:	4a28      	ldr	r2, [pc, #160]	; (22064 <nrfx_twim_1_irq_handler+0x16c>)
   21fc2:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   21fc6:	0798      	lsls	r0, r3, #30
    p_reg->ERRORSRC = error_source;
   21fc8:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
   21fcc:	d443      	bmi.n	22056 <nrfx_twim_1_irq_handler+0x15e>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   21fce:	0759      	lsls	r1, r3, #29
   21fd0:	d443      	bmi.n	2205a <nrfx_twim_1_irq_handler+0x162>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   21fd2:	07da      	lsls	r2, r3, #31
   21fd4:	d443      	bmi.n	2205e <nrfx_twim_1_irq_handler+0x166>
    else if (p_cb->error)
   21fd6:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   21fda:	009b      	lsls	r3, r3, #2
   21fdc:	b2db      	uxtb	r3, r3
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   21fde:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
   21fe2:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   21fe6:	b90b      	cbnz	r3, 21fec <nrfx_twim_1_irq_handler+0xf4>
        p_cb->busy = false;
   21fe8:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   21fec:	6a23      	ldr	r3, [r4, #32]
   21fee:	075b      	lsls	r3, r3, #29
   21ff0:	d503      	bpl.n	21ffa <nrfx_twim_1_irq_handler+0x102>
   21ff2:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   21ff6:	2b00      	cmp	r3, #0
   21ff8:	d0a3      	beq.n	21f42 <nrfx_twim_1_irq_handler+0x4a>
        p_cb->handler(&event, p_cb->p_context);
   21ffa:	e9d4 3100 	ldrd	r3, r1, [r4]
   21ffe:	4668      	mov	r0, sp
   22000:	4798      	blx	r3
}
   22002:	e79e      	b.n	21f42 <nrfx_twim_1_irq_handler+0x4a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22004:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
   22008:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   2200c:	7b23      	ldrb	r3, [r4, #12]
   2200e:	b983      	cbnz	r3, 22032 <nrfx_twim_1_irq_handler+0x13a>
            event.xfer_desc = p_cb->xfer_desc;
   22010:	4f16      	ldr	r7, [pc, #88]	; (2206c <nrfx_twim_1_irq_handler+0x174>)
   22012:	ae01      	add	r6, sp, #4
   22014:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   22016:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   22018:	683b      	ldr	r3, [r7, #0]
   2201a:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
   2201c:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   22020:	2b00      	cmp	r3, #0
   22022:	d1cd      	bne.n	21fc0 <nrfx_twim_1_irq_handler+0xc8>
    p_reg->SHORTS = mask;
   22024:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
                p_cb->int_mask = 0;
   22028:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   2202a:	4b11      	ldr	r3, [pc, #68]	; (22070 <nrfx_twim_1_irq_handler+0x178>)
   2202c:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
   22030:	e7c1      	b.n	21fb6 <nrfx_twim_1_irq_handler+0xbe>
    p_reg->SHORTS = mask;
   22032:	f44f 7300 	mov.w	r3, #512	; 0x200
   22036:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   2203a:	f240 2302 	movw	r3, #514	; 0x202
   2203e:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   22040:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   22044:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   22048:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   2204a:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2204e:	2301      	movs	r3, #1
   22050:	60ab      	str	r3, [r5, #8]
   22052:	622b      	str	r3, [r5, #32]
            return;
   22054:	e775      	b.n	21f42 <nrfx_twim_1_irq_handler+0x4a>
   22056:	2301      	movs	r3, #1
   22058:	e7c1      	b.n	21fde <nrfx_twim_1_irq_handler+0xe6>
   2205a:	2302      	movs	r3, #2
   2205c:	e7bf      	b.n	21fde <nrfx_twim_1_irq_handler+0xe6>
   2205e:	2303      	movs	r3, #3
   22060:	e7bd      	b.n	21fde <nrfx_twim_1_irq_handler+0xe6>
   22062:	bf00      	nop
   22064:	40009000 	.word	0x40009000
   22068:	2000b338 	.word	0x2000b338
   2206c:	2000b344 	.word	0x2000b344
   22070:	019c0202 	.word	0x019c0202
   22074:	e000e100 	.word	0xe000e100

00022078 <ep_state_access>:
 * @param ep Endpoint number.
 */
static inline usbd_ep_state_t* ep_state_access(nrfx_usbd_ep_t ep)
{
    NRFX_USBD_ASSERT_EP_VALID(ep);
    return ((NRF_USBD_EPIN_CHECK(ep) ? m_ep_state.ep_in : m_ep_state.ep_out) +
   22078:	4b05      	ldr	r3, [pc, #20]	; (22090 <ep_state_access+0x18>)
   2207a:	f010 0f80 	tst.w	r0, #128	; 0x80
   2207e:	f1a3 0290 	sub.w	r2, r3, #144	; 0x90
   22082:	bf08      	it	eq
   22084:	4613      	moveq	r3, r2
        NRF_USBD_EP_NR_GET(ep));
   22086:	f000 000f 	and.w	r0, r0, #15
}
   2208a:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   2208e:	4770      	bx	lr
   22090:	2000b514 	.word	0x2000b514

00022094 <ev_usbreset_handler>:
 * @{
 */

static void ev_usbreset_handler(void)
{
    m_bus_suspend = false;
   22094:	2300      	movs	r3, #0
{
   22096:	b507      	push	{r0, r1, r2, lr}
    m_bus_suspend = false;
   22098:	4a06      	ldr	r2, [pc, #24]	; (220b4 <ev_usbreset_handler+0x20>)

    const nrfx_usbd_evt_t evt = {
            .type = NRFX_USBD_EVT_RESET
    };

    m_event_handler(&evt);
   2209a:	a801      	add	r0, sp, #4
    m_bus_suspend = false;
   2209c:	7013      	strb	r3, [r2, #0]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   2209e:	4a06      	ldr	r2, [pc, #24]	; (220b8 <ev_usbreset_handler+0x24>)
   220a0:	7013      	strb	r3, [r2, #0]
    const nrfx_usbd_evt_t evt = {
   220a2:	2301      	movs	r3, #1
   220a4:	9301      	str	r3, [sp, #4]
    m_event_handler(&evt);
   220a6:	4b05      	ldr	r3, [pc, #20]	; (220bc <ev_usbreset_handler+0x28>)
   220a8:	681b      	ldr	r3, [r3, #0]
   220aa:	4798      	blx	r3
}
   220ac:	b003      	add	sp, #12
   220ae:	f85d fb04 	ldr.w	pc, [sp], #4
   220b2:	bf00      	nop
   220b4:	2000b629 	.word	0x2000b629
   220b8:	2000b628 	.word	0x2000b628
   220bc:	2000b5ac 	.word	0x2000b5ac

000220c0 <ev_usbevent_handler>:
    };
    m_event_handler(&evt);
}

static void ev_usbevent_handler(void)
{
   220c0:	b513      	push	{r0, r1, r4, lr}
    return p_reg->EVENTCAUSE;
   220c2:	4b19      	ldr	r3, [pc, #100]	; (22128 <ev_usbevent_handler+0x68>)
   220c4:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
    p_reg->EVENTCAUSE = flags;
   220c8:	f8c3 4400 	str.w	r4, [r3, #1024]	; 0x400
    if (event & NRF_USBD_EVENTCAUSE_ISOOUTCRC_MASK)
    {
        NRFX_LOG_DEBUG("USBD event: ISOOUTCRC");
        /* Currently no support */
    }
    if (event & NRF_USBD_EVENTCAUSE_SUSPEND_MASK)
   220cc:	05e1      	lsls	r1, r4, #23
    (void) p_reg->EVENTCAUSE;
   220ce:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   220d2:	d508      	bpl.n	220e6 <ev_usbevent_handler+0x26>
    {
        NRFX_LOG_DEBUG("USBD event: SUSPEND");
        m_bus_suspend = true;
   220d4:	2201      	movs	r2, #1
   220d6:	4b15      	ldr	r3, [pc, #84]	; (2212c <ev_usbevent_handler+0x6c>)
        const nrfx_usbd_evt_t evt = {
                .type = NRFX_USBD_EVT_SUSPEND
        };
        m_event_handler(&evt);
   220d8:	a801      	add	r0, sp, #4
        m_bus_suspend = true;
   220da:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
   220dc:	2302      	movs	r3, #2
   220de:	9301      	str	r3, [sp, #4]
        m_event_handler(&evt);
   220e0:	4b13      	ldr	r3, [pc, #76]	; (22130 <ev_usbevent_handler+0x70>)
   220e2:	681b      	ldr	r3, [r3, #0]
   220e4:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   220e6:	05a2      	lsls	r2, r4, #22
   220e8:	d508      	bpl.n	220fc <ev_usbevent_handler+0x3c>
    {
        NRFX_LOG_DEBUG("USBD event: RESUME");
        m_bus_suspend = false;
   220ea:	2200      	movs	r2, #0
   220ec:	4b0f      	ldr	r3, [pc, #60]	; (2212c <ev_usbevent_handler+0x6c>)
        const nrfx_usbd_evt_t evt = {
                .type = NRFX_USBD_EVT_RESUME
        };
        m_event_handler(&evt);
   220ee:	a801      	add	r0, sp, #4
        m_bus_suspend = false;
   220f0:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
   220f2:	2303      	movs	r3, #3
   220f4:	9301      	str	r3, [sp, #4]
        m_event_handler(&evt);
   220f6:	4b0e      	ldr	r3, [pc, #56]	; (22130 <ev_usbevent_handler+0x70>)
   220f8:	681b      	ldr	r3, [r3, #0]
   220fa:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_WUREQ_MASK)
   220fc:	0563      	lsls	r3, r4, #21
   220fe:	d510      	bpl.n	22122 <ev_usbevent_handler+0x62>
    {
        NRFX_LOG_DEBUG("USBD event: WUREQ (%s)", m_bus_suspend ? "In Suspend" : "Active");
        if (m_bus_suspend)
   22100:	4b0a      	ldr	r3, [pc, #40]	; (2212c <ev_usbevent_handler+0x6c>)
   22102:	781a      	ldrb	r2, [r3, #0]
   22104:	b16a      	cbz	r2, 22122 <ev_usbevent_handler+0x62>
        {
            NRFX_ASSERT(!nrf_usbd_lowpower_check(NRF_USBD));
            m_bus_suspend = false;
   22106:	2200      	movs	r2, #0
   22108:	701a      	strb	r2, [r3, #0]
    p_reg->DPDMVALUE = ((uint32_t)val) << USBD_DPDMVALUE_STATE_Pos;
   2210a:	2201      	movs	r2, #1
   2210c:	4b06      	ldr	r3, [pc, #24]	; (22128 <ev_usbevent_handler+0x68>)
            nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_DRIVEDPDM);

            const nrfx_usbd_evt_t evt = {
                    .type = NRFX_USBD_EVT_WUREQ
            };
            m_event_handler(&evt);
   2210e:	a801      	add	r0, sp, #4
   22110:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   22114:	659a      	str	r2, [r3, #88]	; 0x58
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   22116:	6d9b      	ldr	r3, [r3, #88]	; 0x58
            const nrfx_usbd_evt_t evt = {
   22118:	2304      	movs	r3, #4
   2211a:	9301      	str	r3, [sp, #4]
            m_event_handler(&evt);
   2211c:	4b04      	ldr	r3, [pc, #16]	; (22130 <ev_usbevent_handler+0x70>)
   2211e:	681b      	ldr	r3, [r3, #0]
   22120:	4798      	blx	r3
        }
    }
}
   22122:	b002      	add	sp, #8
   22124:	bd10      	pop	{r4, pc}
   22126:	bf00      	nop
   22128:	40036000 	.word	0x40036000
   2212c:	2000b629 	.word	0x2000b629
   22130:	2000b5ac 	.word	0x2000b5ac

00022134 <nrfx_usbd_feeder_flash>:
{
   22134:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22136:	684b      	ldr	r3, [r1, #4]
   22138:	4606      	mov	r6, r0
   2213a:	429a      	cmp	r2, r3
   2213c:	bf28      	it	cs
   2213e:	461a      	movcs	r2, r3
   22140:	4615      	mov	r5, r2
   22142:	460c      	mov	r4, r1
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   22144:	4f08      	ldr	r7, [pc, #32]	; (22168 <nrfx_usbd_feeder_flash+0x34>)
   22146:	6809      	ldr	r1, [r1, #0]
   22148:	4638      	mov	r0, r7
   2214a:	f002 ff56 	bl	24ffa <memcpy>
    p_next->size = tx_size;
   2214e:	e9c6 7500 	strd	r7, r5, [r6]
    p_transfer->size -= tx_size;
   22152:	6860      	ldr	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
   22154:	6823      	ldr	r3, [r4, #0]
    p_transfer->size -= tx_size;
   22156:	1b40      	subs	r0, r0, r5
    p_transfer->p_data.addr += tx_size;
   22158:	442b      	add	r3, r5
    p_transfer->size -= tx_size;
   2215a:	6060      	str	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
   2215c:	6023      	str	r3, [r4, #0]
}
   2215e:	3800      	subs	r0, #0
   22160:	bf18      	it	ne
   22162:	2001      	movne	r0, #1
   22164:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   22166:	bf00      	nop
   22168:	2000b36c 	.word	0x2000b36c

0002216c <nrfx_usbd_feeder_flash_zlp>:
{
   2216c:	b570      	push	{r4, r5, r6, lr}
   2216e:	684b      	ldr	r3, [r1, #4]
   22170:	4606      	mov	r6, r0
   22172:	429a      	cmp	r2, r3
   22174:	bf28      	it	cs
   22176:	461a      	movcs	r2, r3
   22178:	460d      	mov	r5, r1
   2217a:	4614      	mov	r4, r2
    if (tx_size != 0)
   2217c:	b18a      	cbz	r2, 221a2 <nrfx_usbd_feeder_flash_zlp+0x36>
        memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   2217e:	6809      	ldr	r1, [r1, #0]
   22180:	4809      	ldr	r0, [pc, #36]	; (221a8 <nrfx_usbd_feeder_flash_zlp+0x3c>)
   22182:	f002 ff3a 	bl	24ffa <memcpy>
        p_next->p_data.tx = p_buffer;
   22186:	4b08      	ldr	r3, [pc, #32]	; (221a8 <nrfx_usbd_feeder_flash_zlp+0x3c>)
    p_next->size = tx_size;
   22188:	e9c6 3400 	strd	r3, r4, [r6]
    p_transfer->size -= tx_size;
   2218c:	686b      	ldr	r3, [r5, #4]
}
   2218e:	1e20      	subs	r0, r4, #0
    p_transfer->size -= tx_size;
   22190:	eba3 0304 	sub.w	r3, r3, r4
   22194:	606b      	str	r3, [r5, #4]
    p_transfer->p_data.addr += tx_size;
   22196:	682b      	ldr	r3, [r5, #0]
}
   22198:	bf18      	it	ne
   2219a:	2001      	movne	r0, #1
    p_transfer->p_data.addr += tx_size;
   2219c:	4423      	add	r3, r4
   2219e:	602b      	str	r3, [r5, #0]
}
   221a0:	bd70      	pop	{r4, r5, r6, pc}
   221a2:	4613      	mov	r3, r2
   221a4:	e7f0      	b.n	22188 <nrfx_usbd_feeder_flash_zlp+0x1c>
   221a6:	bf00      	nop
   221a8:	2000b36c 	.word	0x2000b36c

000221ac <ev_sof_handler>:
    nrfx_usbd_evt_t evt =  {
   221ac:	2300      	movs	r3, #0
{
   221ae:	b507      	push	{r0, r1, r2, lr}
    nrfx_usbd_evt_t evt =  {
   221b0:	f88d 3004 	strb.w	r3, [sp, #4]
    return p_reg->FRAMECNTR;
   221b4:	4b0b      	ldr	r3, [pc, #44]	; (221e4 <ev_sof_handler+0x38>)
    m_event_handler(&evt);
   221b6:	a801      	add	r0, sp, #4
   221b8:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
            .data = { .sof = { .framecnt = (uint16_t)nrf_usbd_framecntr_get(NRF_USBD) }}
   221bc:	f8ad 2006 	strh.w	r2, [sp, #6]
    size_t size_isoout = p_reg->SIZE.ISOOUT;
   221c0:	f8d3 34c0 	ldr.w	r3, [r3, #1216]	; 0x4c0
    m_ep_ready |= iso_ready_mask;
   221c4:	4a08      	ldr	r2, [pc, #32]	; (221e8 <ev_sof_handler+0x3c>)
    uint32_t iso_ready_mask = (1U << ep2bit(NRFX_USBD_EPIN8));
   221c6:	2b00      	cmp	r3, #0
   221c8:	bf14      	ite	ne
   221ca:	f04f 2101 	movne.w	r1, #16777472	; 0x1000100
   221ce:	f44f 7180 	moveq.w	r1, #256	; 0x100
    m_ep_ready |= iso_ready_mask;
   221d2:	6813      	ldr	r3, [r2, #0]
   221d4:	430b      	orrs	r3, r1
   221d6:	6013      	str	r3, [r2, #0]
    m_event_handler(&evt);
   221d8:	4b04      	ldr	r3, [pc, #16]	; (221ec <ev_sof_handler+0x40>)
   221da:	681b      	ldr	r3, [r3, #0]
   221dc:	4798      	blx	r3
}
   221de:	b003      	add	sp, #12
   221e0:	f85d fb04 	ldr.w	pc, [sp], #4
   221e4:	40036000 	.word	0x40036000
   221e8:	2000b5a8 	.word	0x2000b5a8
   221ec:	2000b5ac 	.word	0x2000b5ac

000221f0 <atomic_and.constprop.0.isra.0>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   221f0:	4b04      	ldr	r3, [pc, #16]	; (22204 <atomic_and.constprop.0.isra.0+0x14>)
   221f2:	e8d3 1fef 	ldaex	r1, [r3]
   221f6:	4001      	ands	r1, r0
   221f8:	e8c3 1fe2 	stlex	r2, r1, [r3]
   221fc:	2a00      	cmp	r2, #0
   221fe:	d1f8      	bne.n	221f2 <atomic_and.constprop.0.isra.0+0x2>
}
   22200:	4770      	bx	lr
   22202:	bf00      	nop
   22204:	2000b5a4 	.word	0x2000b5a4

00022208 <nrf_usbd_epin_dma_handler>:
    m_dma_pending = false;
   22208:	2200      	movs	r2, #0
{
   2220a:	b508      	push	{r3, lr}
    m_dma_pending = false;
   2220c:	4b0b      	ldr	r3, [pc, #44]	; (2223c <nrf_usbd_epin_dma_handler+0x34>)
{
   2220e:	4601      	mov	r1, r0
    m_dma_pending = false;
   22210:	701a      	strb	r2, [r3, #0]
    usbd_ep_state_t * p_state = ep_state_access(ep);
   22212:	f7ff ff31 	bl	22078 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   22216:	7b83      	ldrb	r3, [r0, #14]
   22218:	2b03      	cmp	r3, #3
   2221a:	d10a      	bne.n	22232 <nrf_usbd_epin_dma_handler+0x2a>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2221c:	4608      	mov	r0, r1
   2221e:	f003 fc05 	bl	25a2c <ep2bit>
   22222:	2301      	movs	r3, #1
   22224:	fa03 f000 	lsl.w	r0, r3, r0
   22228:	43c0      	mvns	r0, r0
}
   2222a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2222e:	f7ff bfdf 	b.w	221f0 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   22232:	6803      	ldr	r3, [r0, #0]
   22234:	2b00      	cmp	r3, #0
   22236:	d0f1      	beq.n	2221c <nrf_usbd_epin_dma_handler+0x14>
}
   22238:	bd08      	pop	{r3, pc}
   2223a:	bf00      	nop
   2223c:	2000b627 	.word	0x2000b627

00022240 <nrf_usbd_ep0in_dma_handler>:
    m_dma_pending = false;
   22240:	2200      	movs	r2, #0
   22242:	4b08      	ldr	r3, [pc, #32]	; (22264 <nrf_usbd_ep0in_dma_handler+0x24>)
   22244:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   22246:	4b08      	ldr	r3, [pc, #32]	; (22268 <nrf_usbd_ep0in_dma_handler+0x28>)
   22248:	f893 209e 	ldrb.w	r2, [r3, #158]	; 0x9e
   2224c:	2a03      	cmp	r2, #3
   2224e:	d103      	bne.n	22258 <nrf_usbd_ep0in_dma_handler+0x18>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22250:	f06f 0001 	mvn.w	r0, #1
   22254:	f7ff bfcc 	b.w	221f0 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   22258:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   2225c:	2b00      	cmp	r3, #0
   2225e:	d0f7      	beq.n	22250 <nrf_usbd_ep0in_dma_handler+0x10>
}
   22260:	4770      	bx	lr
   22262:	bf00      	nop
   22264:	2000b627 	.word	0x2000b627
   22268:	2000b484 	.word	0x2000b484

0002226c <usbd_ep_data_handler>:
    m_ep_ready |= (1U << bitpos);
   2226c:	2201      	movs	r2, #1
{
   2226e:	b573      	push	{r0, r1, r4, r5, r6, lr}
    m_ep_ready |= (1U << bitpos);
   22270:	fa02 f501 	lsl.w	r5, r2, r1
   22274:	491c      	ldr	r1, [pc, #112]	; (222e8 <usbd_ep_data_handler+0x7c>)
    if (NRF_USBD_EPIN_CHECK(ep))
   22276:	f010 0f80 	tst.w	r0, #128	; 0x80
    m_ep_ready |= (1U << bitpos);
   2227a:	680b      	ldr	r3, [r1, #0]
{
   2227c:	4604      	mov	r4, r0
    m_ep_ready |= (1U << bitpos);
   2227e:	ea43 0305 	orr.w	r3, r3, r5
   22282:	4e1a      	ldr	r6, [pc, #104]	; (222ec <usbd_ep_data_handler+0x80>)
   22284:	600b      	str	r3, [r1, #0]
    if (NRF_USBD_EPIN_CHECK(ep))
   22286:	d024      	beq.n	222d2 <usbd_ep_data_handler+0x66>
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   22288:	4b19      	ldr	r3, [pc, #100]	; (222f0 <usbd_ep_data_handler+0x84>)
   2228a:	f000 020f 	and.w	r2, r0, #15
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   2228e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   22292:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   22296:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   2229a:	681a      	ldr	r2, [r3, #0]
    if (ret)
   2229c:	b132      	cbz	r2, 222ac <usbd_ep_data_handler+0x40>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   2229e:	2200      	movs	r2, #0
            if (ep != NRFX_USBD_EPIN0)
   222a0:	2880      	cmp	r0, #128	; 0x80
   222a2:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   222a4:	681b      	ldr	r3, [r3, #0]
   222a6:	d011      	beq.n	222cc <usbd_ep_data_handler+0x60>
                nrf_usbd_epin_dma_handler(ep);
   222a8:	f7ff ffae 	bl	22208 <nrf_usbd_epin_dma_handler>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   222ac:	6833      	ldr	r3, [r6, #0]
   222ae:	402b      	ands	r3, r5
   222b0:	d10a      	bne.n	222c8 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   222b2:	2206      	movs	r2, #6
   222b4:	f88d 4006 	strb.w	r4, [sp, #6]
   222b8:	f88d 2004 	strb.w	r2, [sp, #4]
   222bc:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
   222c0:	4b0c      	ldr	r3, [pc, #48]	; (222f4 <usbd_ep_data_handler+0x88>)
   222c2:	a801      	add	r0, sp, #4
   222c4:	681b      	ldr	r3, [r3, #0]
   222c6:	4798      	blx	r3
}
   222c8:	b002      	add	sp, #8
   222ca:	bd70      	pop	{r4, r5, r6, pc}
                nrf_usbd_ep0in_dma_handler();
   222cc:	f7ff ffb8 	bl	22240 <nrf_usbd_ep0in_dma_handler>
   222d0:	e7ec      	b.n	222ac <usbd_ep_data_handler+0x40>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   222d2:	6833      	ldr	r3, [r6, #0]
   222d4:	421d      	tst	r5, r3
   222d6:	d1f7      	bne.n	222c8 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_WAITING);
   222d8:	2306      	movs	r3, #6
   222da:	f88d 0006 	strb.w	r0, [sp, #6]
   222de:	f88d 3004 	strb.w	r3, [sp, #4]
   222e2:	f88d 2007 	strb.w	r2, [sp, #7]
   222e6:	e7eb      	b.n	222c0 <usbd_ep_data_handler+0x54>
   222e8:	2000b5a8 	.word	0x2000b5a8
   222ec:	2000b5a4 	.word	0x2000b5a4
   222f0:	000269c2 	.word	0x000269c2
   222f4:	2000b5ac 	.word	0x2000b5ac

000222f8 <ev_setup_data_handler>:
{
   222f8:	b508      	push	{r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   222fa:	4b05      	ldr	r3, [pc, #20]	; (22310 <ev_setup_data_handler+0x18>)
   222fc:	781a      	ldrb	r2, [r3, #0]
   222fe:	4610      	mov	r0, r2
   22300:	f003 fb94 	bl	25a2c <ep2bit>
}
   22304:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   22308:	4601      	mov	r1, r0
   2230a:	4610      	mov	r0, r2
   2230c:	f7ff bfae 	b.w	2226c <usbd_ep_data_handler>
   22310:	2000b628 	.word	0x2000b628

00022314 <ev_dma_epout8_handler>:
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   22314:	b507      	push	{r0, r1, r2, lr}
    m_dma_pending = false;
   22316:	2200      	movs	r2, #0
   22318:	4b0d      	ldr	r3, [pc, #52]	; (22350 <ev_dma_epout8_handler+0x3c>)
   2231a:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   2231c:	4b0d      	ldr	r3, [pc, #52]	; (22354 <ev_dma_epout8_handler+0x40>)
   2231e:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
   22322:	2a03      	cmp	r2, #3
   22324:	d010      	beq.n	22348 <ev_dma_epout8_handler+0x34>
    else if (p_state->handler.consumer == NULL)
   22326:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   2232a:	b96b      	cbnz	r3, 22348 <ev_dma_epout8_handler+0x34>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2232c:	f06f 7080 	mvn.w	r0, #16777216	; 0x1000000
   22330:	f7ff ff5e 	bl	221f0 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22334:	2306      	movs	r3, #6
   22336:	f88d 3004 	strb.w	r3, [sp, #4]
   2233a:	2308      	movs	r3, #8
   2233c:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   22340:	4b05      	ldr	r3, [pc, #20]	; (22358 <ev_dma_epout8_handler+0x44>)
   22342:	a801      	add	r0, sp, #4
   22344:	681b      	ldr	r3, [r3, #0]
   22346:	4798      	blx	r3
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   22348:	b003      	add	sp, #12
   2234a:	f85d fb04 	ldr.w	pc, [sp], #4
   2234e:	bf00      	nop
   22350:	2000b627 	.word	0x2000b627
   22354:	2000b484 	.word	0x2000b484
   22358:	2000b5ac 	.word	0x2000b5ac

0002235c <ev_dma_epin8_handler>:
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   2235c:	b507      	push	{r0, r1, r2, lr}
    m_dma_pending = false;
   2235e:	2200      	movs	r2, #0
   22360:	4b10      	ldr	r3, [pc, #64]	; (223a4 <ev_dma_epin8_handler+0x48>)
   22362:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   22364:	4b10      	ldr	r3, [pc, #64]	; (223a8 <ev_dma_epin8_handler+0x4c>)
   22366:	f893 211e 	ldrb.w	r2, [r3, #286]	; 0x11e
   2236a:	2a03      	cmp	r2, #3
   2236c:	d106      	bne.n	2237c <ev_dma_epin8_handler+0x20>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2236e:	f46f 7080 	mvn.w	r0, #256	; 0x100
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   22372:	b003      	add	sp, #12
   22374:	f85d eb04 	ldr.w	lr, [sp], #4
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22378:	f7ff bf3a 	b.w	221f0 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   2237c:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
   22380:	b96b      	cbnz	r3, 2239e <ev_dma_epin8_handler+0x42>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22382:	f46f 7080 	mvn.w	r0, #256	; 0x100
   22386:	f7ff ff33 	bl	221f0 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2238a:	2306      	movs	r3, #6
   2238c:	f88d 3004 	strb.w	r3, [sp, #4]
   22390:	2388      	movs	r3, #136	; 0x88
   22392:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   22396:	4b05      	ldr	r3, [pc, #20]	; (223ac <ev_dma_epin8_handler+0x50>)
   22398:	a801      	add	r0, sp, #4
   2239a:	681b      	ldr	r3, [r3, #0]
   2239c:	4798      	blx	r3
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   2239e:	b003      	add	sp, #12
   223a0:	f85d fb04 	ldr.w	pc, [sp], #4
   223a4:	2000b627 	.word	0x2000b627
   223a8:	2000b484 	.word	0x2000b484
   223ac:	2000b5ac 	.word	0x2000b5ac

000223b0 <nrfx_usbd_uninit>:

void nrfx_usbd_uninit(void)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_INITIALIZED);

    m_event_handler = NULL;
   223b0:	2300      	movs	r3, #0
   223b2:	4a02      	ldr	r2, [pc, #8]	; (223bc <nrfx_usbd_uninit+0xc>)
   223b4:	6013      	str	r3, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_UNINITIALIZED;
   223b6:	4a02      	ldr	r2, [pc, #8]	; (223c0 <nrfx_usbd_uninit+0x10>)
   223b8:	7013      	strb	r3, [r2, #0]
    return;
}
   223ba:	4770      	bx	lr
   223bc:	2000b5ac 	.word	0x2000b5ac
   223c0:	2000b62a 	.word	0x2000b62a

000223c4 <nrfx_usbd_enable>:
    p_reg->EVENTCAUSE = flags;
   223c4:	f44f 6200 	mov.w	r2, #2048	; 0x800
   223c8:	4b13      	ldr	r3, [pc, #76]	; (22418 <nrfx_usbd_enable+0x54>)
   223ca:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   223ce:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Enabled << USBD_ENABLE_ENABLE_Pos;
   223d2:	2201      	movs	r2, #1
   223d4:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   223d8:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
    return p_reg->EVENTCAUSE;
   223dc:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    while (0 == (eventcause & nrf_usbd_eventcause_get(NRF_USBD)))
   223e0:	0512      	lsls	r2, r2, #20
   223e2:	d5fb      	bpl.n	223dc <nrfx_usbd_enable+0x18>
    p_reg->EVENTCAUSE = flags;
   223e4:	f44f 6200 	mov.w	r2, #2048	; 0x800
   223e8:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   223ec:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    p_reg->ISOSPLIT = split << USBD_ISOSPLIT_SPLIT_Pos;
   223f0:	2280      	movs	r2, #128	; 0x80
   223f2:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
    p_reg->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
   223f6:	2200      	movs	r2, #0
    else
    {
        nrfx_usbd_isoinconfig_set(NRF_USBD_ISOINCONFIG_NORESP);
    }

    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   223f8:	f240 11ff 	movw	r1, #511	; 0x1ff
   223fc:	f8c3 2530 	str.w	r2, [r3, #1328]	; 0x530
   22400:	4b06      	ldr	r3, [pc, #24]	; (2241c <nrfx_usbd_enable+0x58>)
   22402:	6019      	str	r1, [r3, #0]
    m_ep_dma_waiting = 0;
   22404:	4b06      	ldr	r3, [pc, #24]	; (22420 <nrfx_usbd_enable+0x5c>)
   22406:	601a      	str	r2, [r3, #0]
    m_dma_pending = false;
   22408:	4b06      	ldr	r3, [pc, #24]	; (22424 <nrfx_usbd_enable+0x60>)
   2240a:	701a      	strb	r2, [r3, #0]
    usbd_dma_pending_clear();
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   2240c:	4b06      	ldr	r3, [pc, #24]	; (22428 <nrfx_usbd_enable+0x64>)
   2240e:	701a      	strb	r2, [r3, #0]

    m_drv_state = NRFX_DRV_STATE_POWERED_ON;
   22410:	2202      	movs	r2, #2
   22412:	4b06      	ldr	r3, [pc, #24]	; (2242c <nrfx_usbd_enable+0x68>)
   22414:	701a      	strb	r2, [r3, #0]
    if (nrfx_usbd_errata_187())
#endif
    {
        usbd_errata_187_211_end();
    }
}
   22416:	4770      	bx	lr
   22418:	40036000 	.word	0x40036000
   2241c:	2000b5a8 	.word	0x2000b5a8
   22420:	2000b5a4 	.word	0x2000b5a4
   22424:	2000b627 	.word	0x2000b627
   22428:	2000b628 	.word	0x2000b628
   2242c:	2000b62a 	.word	0x2000b62a

00022430 <nrfx_usbd_start>:
}

void nrfx_usbd_start(bool enable_sof)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    m_bus_suspend = false;
   22430:	2200      	movs	r2, #0
   22432:	4b0a      	ldr	r3, [pc, #40]	; (2245c <nrfx_usbd_start+0x2c>)
{
   22434:	b510      	push	{r4, lr}
    m_bus_suspend = false;
   22436:	701a      	strb	r2, [r3, #0]

    uint32_t ints_to_enable =
   22438:	4a09      	ldr	r2, [pc, #36]	; (22460 <nrfx_usbd_start+0x30>)
   2243a:	4b0a      	ldr	r3, [pc, #40]	; (22464 <nrfx_usbd_start+0x34>)
    p_reg->INTENSET = mask;
   2243c:	4c0a      	ldr	r4, [pc, #40]	; (22468 <nrfx_usbd_start+0x38>)
   2243e:	2800      	cmp	r0, #0
   22440:	bf08      	it	eq
   22442:	4613      	moveq	r3, r2
   /* Enable all required interrupts */
   nrf_usbd_int_enable(NRF_USBD, ints_to_enable);

   /* Enable interrupt globally */
   NRFX_IRQ_PRIORITY_SET(USBD_IRQn, NRFX_USBD_DEFAULT_CONFIG_IRQ_PRIORITY);
   NRFX_IRQ_ENABLE(USBD_IRQn);
   22444:	2036      	movs	r0, #54	; 0x36
   22446:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   2244a:	f7fb ff55 	bl	1e2f8 <arch_irq_enable>
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Enabled << USBD_USBPULLUP_CONNECT_Pos;
   2244e:	2301      	movs	r3, #1
   22450:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    (void) p_reg->USBPULLUP;
   22454:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504

   /* Enable pullups */
   nrf_usbd_pullup_enable(NRF_USBD);
}
   22458:	bd10      	pop	{r4, pc}
   2245a:	bf00      	nop
   2245c:	2000b629 	.word	0x2000b629
   22460:	01c01407 	.word	0x01c01407
   22464:	01e01407 	.word	0x01e01407
   22468:	40036000 	.word	0x40036000

0002246c <nrfx_usbd_is_enabled>:
    return (m_drv_state >= NRFX_DRV_STATE_INITIALIZED);
}

bool nrfx_usbd_is_enabled(void)
{
    return (m_drv_state >= NRFX_DRV_STATE_POWERED_ON);
   2246c:	4b03      	ldr	r3, [pc, #12]	; (2247c <nrfx_usbd_is_enabled+0x10>)
   2246e:	7818      	ldrb	r0, [r3, #0]
}
   22470:	2801      	cmp	r0, #1
   22472:	bf94      	ite	ls
   22474:	2000      	movls	r0, #0
   22476:	2001      	movhi	r0, #1
   22478:	4770      	bx	lr
   2247a:	bf00      	nop
   2247c:	2000b62a 	.word	0x2000b62a

00022480 <nrfx_usbd_suspend>:
{
    return (nrfx_usbd_is_enabled() && NRFX_IRQ_IS_ENABLED(USBD_IRQn));
}

bool nrfx_usbd_suspend(void)
{
   22480:	b510      	push	{r4, lr}
	__asm__ volatile(
   22482:	f04f 0320 	mov.w	r3, #32
   22486:	f3ef 8111 	mrs	r1, BASEPRI
   2248a:	f383 8812 	msr	BASEPRI_MAX, r3
   2248e:	f3bf 8f6f 	isb	sy
    bool suspended = false;

    NRFX_CRITICAL_SECTION_ENTER();
    if (m_bus_suspend)
   22492:	4b0f      	ldr	r3, [pc, #60]	; (224d0 <nrfx_usbd_suspend+0x50>)
   22494:	781b      	ldrb	r3, [r3, #0]
   22496:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   2249a:	b193      	cbz	r3, 224c2 <nrfx_usbd_suspend+0x42>
    return p_reg->EVENTCAUSE;
   2249c:	4b0d      	ldr	r3, [pc, #52]	; (224d4 <nrfx_usbd_suspend+0x54>)
   2249e:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    {
        if (!(nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK))
   224a2:	f412 7200 	ands.w	r2, r2, #512	; 0x200
   224a6:	d10c      	bne.n	224c2 <nrfx_usbd_suspend+0x42>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_LowPower << USBD_LOWPOWER_LOWPOWER_Pos;
   224a8:	2401      	movs	r4, #1
   224aa:	f8c3 452c 	str.w	r4, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   224ae:	f8d3 452c 	ldr.w	r4, [r3, #1324]	; 0x52c
    return p_reg->EVENTCAUSE;
   224b2:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
        {
            nrf_usbd_lowpower_enable(NRF_USBD);
            if (nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   224b6:	05a4      	lsls	r4, r4, #22
   224b8:	d504      	bpl.n	224c4 <nrfx_usbd_suspend+0x44>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos;
   224ba:	f8c3 252c 	str.w	r2, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   224be:	f8d3 352c 	ldr.w	r3, [r3, #1324]	; 0x52c
    bool suspended = false;
   224c2:	2000      	movs	r0, #0
	__asm__ volatile(
   224c4:	f381 8811 	msr	BASEPRI, r1
   224c8:	f3bf 8f6f 	isb	sy
        }
    }
    NRFX_CRITICAL_SECTION_EXIT();

    return suspended;
}
   224cc:	bd10      	pop	{r4, pc}
   224ce:	bf00      	nop
   224d0:	2000b629 	.word	0x2000b629
   224d4:	40036000 	.word	0x40036000

000224d8 <nrfx_usbd_init>:
{
   224d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (m_drv_state != NRFX_DRV_STATE_UNINITIALIZED)
   224da:	4b1c      	ldr	r3, [pc, #112]	; (2254c <nrfx_usbd_init+0x74>)
   224dc:	781c      	ldrb	r4, [r3, #0]
   224de:	bb94      	cbnz	r4, 22546 <nrfx_usbd_init+0x6e>
    m_event_handler = event_handler;
   224e0:	4a1b      	ldr	r2, [pc, #108]	; (22550 <nrfx_usbd_init+0x78>)
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224e2:	f240 17ff 	movw	r7, #511	; 0x1ff
    m_event_handler = event_handler;
   224e6:	6010      	str	r0, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   224e8:	2201      	movs	r2, #1
        p_state->status = NRFX_USBD_EP_OK;
   224ea:	4626      	mov	r6, r4
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   224ec:	701a      	strb	r2, [r3, #0]
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   224ee:	f064 057f 	orn	r5, r4, #127	; 0x7f
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224f2:	f014 0f08 	tst.w	r4, #8
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   224f6:	b2ed      	uxtb	r5, r5
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224f8:	bf14      	ite	ne
   224fa:	4639      	movne	r1, r7
   224fc:	2140      	moveq	r1, #64	; 0x40
   224fe:	4628      	mov	r0, r5
   22500:	f003 fab4 	bl	25a6c <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   22504:	4628      	mov	r0, r5
   22506:	f7ff fdb7 	bl	22078 <ep_state_access>
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   2250a:	3401      	adds	r4, #1
   2250c:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
   2250e:	7386      	strb	r6, [r0, #14]
        p_state->handler.feeder = NULL;
   22510:	6006      	str	r6, [r0, #0]
        p_state->transfer_cnt = 0;
   22512:	6086      	str	r6, [r0, #8]
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   22514:	d1eb      	bne.n	224ee <nrfx_usbd_init+0x16>
   22516:	2400      	movs	r4, #0
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   22518:	f240 17ff 	movw	r7, #511	; 0x1ff
        p_state->status = NRFX_USBD_EP_OK;
   2251c:	4625      	mov	r5, r4
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   2251e:	f014 0f08 	tst.w	r4, #8
   22522:	b2e6      	uxtb	r6, r4
   22524:	bf14      	ite	ne
   22526:	4639      	movne	r1, r7
   22528:	2140      	moveq	r1, #64	; 0x40
   2252a:	4630      	mov	r0, r6
   2252c:	f003 fa9e 	bl	25a6c <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   22530:	4630      	mov	r0, r6
   22532:	f7ff fda1 	bl	22078 <ep_state_access>
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   22536:	3401      	adds	r4, #1
   22538:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
   2253a:	7385      	strb	r5, [r0, #14]
        p_state->handler.consumer = NULL;
   2253c:	6005      	str	r5, [r0, #0]
        p_state->transfer_cnt = 0;
   2253e:	6085      	str	r5, [r0, #8]
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   22540:	d1ed      	bne.n	2251e <nrfx_usbd_init+0x46>
    return NRFX_SUCCESS;
   22542:	4804      	ldr	r0, [pc, #16]	; (22554 <nrfx_usbd_init+0x7c>)
}
   22544:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return NRFX_ERROR_INVALID_STATE;
   22546:	4804      	ldr	r0, [pc, #16]	; (22558 <nrfx_usbd_init+0x80>)
   22548:	e7fc      	b.n	22544 <nrfx_usbd_init+0x6c>
   2254a:	bf00      	nop
   2254c:	2000b62a 	.word	0x2000b62a
   22550:	2000b5ac 	.word	0x2000b5ac
   22554:	0bad0000 	.word	0x0bad0000
   22558:	0bad0005 	.word	0x0bad0005

0002255c <nrfx_usbd_ep_transfer>:
}

nrfx_err_t nrfx_usbd_ep_transfer(
    nrfx_usbd_ep_t               ep,
    nrfx_usbd_transfer_t const * p_transfer)
{
   2255c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   22560:	4604      	mov	r4, r0
	__asm__ volatile(
   22562:	f04f 0320 	mov.w	r3, #32
   22566:	f3ef 8611 	mrs	r6, BASEPRI
   2256a:	f383 8812 	msr	BASEPRI_MAX, r3
   2256e:	f3bf 8f6f 	isb	sy
    const uint8_t ep_bitpos = ep2bit(ep);
    NRFX_ASSERT(NULL != p_transfer);

    NRFX_CRITICAL_SECTION_ENTER();
    /* Setup data transaction can go only in one direction at a time */
    if ((NRF_USBD_EP_NR_GET(ep) == 0) && (ep != m_last_setup_dir))
   22572:	f010 090f 	ands.w	r9, r0, #15
   22576:	d103      	bne.n	22580 <nrfx_usbd_ep_transfer+0x24>
   22578:	4b28      	ldr	r3, [pc, #160]	; (2261c <nrfx_usbd_ep_transfer+0xc0>)
   2257a:	781b      	ldrb	r3, [r3, #0]
   2257c:	4283      	cmp	r3, r0
   2257e:	d148      	bne.n	22612 <nrfx_usbd_ep_transfer+0xb6>
            (NRFX_USBD_ISO_DEBUG || (!NRF_USBD_EPISO_CHECK(ep))))
        {
            NRFX_LOG_DEBUG("Transfer failed: Invalid EPr\n");
        }
    }
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   22580:	4b27      	ldr	r3, [pc, #156]	; (22620 <nrfx_usbd_ep_transfer+0xc4>)
   22582:	4f28      	ldr	r7, [pc, #160]	; (22624 <nrfx_usbd_ep_transfer+0xc8>)
   22584:	681a      	ldr	r2, [r3, #0]
   22586:	683b      	ldr	r3, [r7, #0]
   22588:	43d2      	mvns	r2, r2
    const uint8_t ep_bitpos = ep2bit(ep);
   2258a:	4620      	mov	r0, r4
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   2258c:	b292      	uxth	r2, r2
   2258e:	431a      	orrs	r2, r3
   22590:	f04f 0801 	mov.w	r8, #1
    const uint8_t ep_bitpos = ep2bit(ep);
   22594:	f003 fa4a 	bl	25a2c <ep2bit>
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   22598:	fa08 f800 	lsl.w	r8, r8, r0
   2259c:	ea12 0f08 	tst.w	r2, r8
   225a0:	d139      	bne.n	22616 <nrfx_usbd_ep_transfer+0xba>
            NRFX_LOG_DEBUG("Transfer failed: EP is busy");
        }
    }
    else
    {
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   225a2:	4620      	mov	r0, r4
   225a4:	f7ff fd68 	bl	22078 <ep_state_access>
        /* Prepare transfer context and handler description */
        nrfx_usbd_transfer_t * p_context;
        if (NRF_USBD_EPIN_CHECK(ep))
        {
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   225a8:	230c      	movs	r3, #12
        if (NRF_USBD_EPIN_CHECK(ep))
   225aa:	0622      	lsls	r2, r4, #24
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   225ac:	4605      	mov	r5, r0
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   225ae:	fb03 f309 	mul.w	r3, r3, r9
        if (NRF_USBD_EPIN_CHECK(ep))
   225b2:	d52a      	bpl.n	2260a <nrfx_usbd_ep_transfer+0xae>
   225b4:	680a      	ldr	r2, [r1, #0]
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
            {
                /* RAM */
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   225b6:	6888      	ldr	r0, [r1, #8]
   225b8:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
   225bc:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   225c0:	f000 0001 	and.w	r0, r0, #1
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
   225c4:	d11e      	bne.n	22604 <nrfx_usbd_ep_transfer+0xa8>
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   225c6:	4a18      	ldr	r2, [pc, #96]	; (22628 <nrfx_usbd_ep_transfer+0xcc>)
   225c8:	4c18      	ldr	r4, [pc, #96]	; (2262c <nrfx_usbd_ep_transfer+0xd0>)
   225ca:	2800      	cmp	r0, #0
   225cc:	bf08      	it	eq
   225ce:	4622      	moveq	r2, r4
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   225d0:	4817      	ldr	r0, [pc, #92]	; (22630 <nrfx_usbd_ep_transfer+0xd4>)
   225d2:	4403      	add	r3, r0
        }
        else
        {
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT((p_transfer->p_data.rx == NULL) || (nrfx_is_in_ram(p_transfer->p_data.rx)));
            p_state->handler.consumer = nrfx_usbd_consumer;
   225d4:	602a      	str	r2, [r5, #0]
        }
        *p_context = *p_transfer;
   225d6:	c907      	ldmia	r1, {r0, r1, r2}
   225d8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        p_state->p_context = p_context;
   225dc:	606b      	str	r3, [r5, #4]

        p_state->transfer_cnt = 0;
   225de:	2300      	movs	r3, #0
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   225e0:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
   225e4:	60ab      	str	r3, [r5, #8]
        p_state->status    =  NRFX_USBD_EP_OK;
   225e6:	73ab      	strb	r3, [r5, #14]
        m_ep_dma_waiting   |= 1U << ep_bitpos;
   225e8:	683b      	ldr	r3, [r7, #0]
        ret = NRFX_SUCCESS;
   225ea:	4812      	ldr	r0, [pc, #72]	; (22634 <nrfx_usbd_ep_transfer+0xd8>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
   225ec:	ea43 0308 	orr.w	r3, r3, r8
   225f0:	603b      	str	r3, [r7, #0]
   225f2:	4b11      	ldr	r3, [pc, #68]	; (22638 <nrfx_usbd_ep_transfer+0xdc>)
   225f4:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	__asm__ volatile(
   225f8:	f386 8811 	msr	BASEPRI, r6
   225fc:	f3bf 8f6f 	isb	sy
        usbd_int_rise();
    }
    NRFX_CRITICAL_SECTION_EXIT();
    return ret;
}
   22600:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   22604:	4a0d      	ldr	r2, [pc, #52]	; (2263c <nrfx_usbd_ep_transfer+0xe0>)
   22606:	4c0e      	ldr	r4, [pc, #56]	; (22640 <nrfx_usbd_ep_transfer+0xe4>)
   22608:	e7df      	b.n	225ca <nrfx_usbd_ep_transfer+0x6e>
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
   2260a:	4a0e      	ldr	r2, [pc, #56]	; (22644 <nrfx_usbd_ep_transfer+0xe8>)
   2260c:	4413      	add	r3, r2
            p_state->handler.consumer = nrfx_usbd_consumer;
   2260e:	4a0e      	ldr	r2, [pc, #56]	; (22648 <nrfx_usbd_ep_transfer+0xec>)
   22610:	e7e0      	b.n	225d4 <nrfx_usbd_ep_transfer+0x78>
        ret = NRFX_ERROR_INVALID_ADDR;
   22612:	480e      	ldr	r0, [pc, #56]	; (2264c <nrfx_usbd_ep_transfer+0xf0>)
   22614:	e7f0      	b.n	225f8 <nrfx_usbd_ep_transfer+0x9c>
        ret = NRFX_ERROR_BUSY;
   22616:	480e      	ldr	r0, [pc, #56]	; (22650 <nrfx_usbd_ep_transfer+0xf4>)
   22618:	e7ee      	b.n	225f8 <nrfx_usbd_ep_transfer+0x9c>
   2261a:	bf00      	nop
   2261c:	2000b628 	.word	0x2000b628
   22620:	2000b5a8 	.word	0x2000b5a8
   22624:	2000b5a4 	.word	0x2000b5a4
   22628:	00025a03 	.word	0x00025a03
   2262c:	000259e1 	.word	0x000259e1
   22630:	2000b418 	.word	0x2000b418
   22634:	0bad0000 	.word	0x0bad0000
   22638:	e000e100 	.word	0xe000e100
   2263c:	0002216d 	.word	0x0002216d
   22640:	00022135 	.word	0x00022135
   22644:	2000b3ac 	.word	0x2000b3ac
   22648:	000259af 	.word	0x000259af
   2264c:	0bad000a 	.word	0x0bad000a
   22650:	0bad000b 	.word	0x0bad000b

00022654 <nrfx_usbd_epout_size_get>:
    if (NRF_USBD_EPISO_CHECK(ep))
   22654:	f010 0f08 	tst.w	r0, #8
   22658:	4b07      	ldr	r3, [pc, #28]	; (22678 <nrfx_usbd_epout_size_get+0x24>)
   2265a:	d006      	beq.n	2266a <nrfx_usbd_epout_size_get+0x16>
        size_t size_isoout = p_reg->SIZE.ISOOUT;
   2265c:	f8d3 04c0 	ldr.w	r0, [r3, #1216]	; 0x4c0
            size_isoout = 0;
   22660:	f410 3f80 	tst.w	r0, #65536	; 0x10000
   22664:	bf18      	it	ne
   22666:	2000      	movne	r0, #0
   22668:	4770      	bx	lr
    return p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   2266a:	f000 000f 	and.w	r0, r0, #15
   2266e:	f500 7094 	add.w	r0, r0, #296	; 0x128
   22672:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}

size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_epout_size_get(NRF_USBD, ep_to_hal(ep));
}
   22676:	4770      	bx	lr
   22678:	40036000 	.word	0x40036000

0002267c <usbd_dmareq_process>:
{
   2267c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (!m_dma_pending)
   22680:	4e54      	ldr	r6, [pc, #336]	; (227d4 <usbd_dmareq_process+0x158>)
{
   22682:	b085      	sub	sp, #20
    if (!m_dma_pending)
   22684:	7833      	ldrb	r3, [r6, #0]
   22686:	2b00      	cmp	r3, #0
   22688:	d169      	bne.n	2275e <usbd_dmareq_process+0xe2>
        while (0 != (req = m_ep_dma_waiting & m_ep_ready))
   2268a:	f8df 814c 	ldr.w	r8, [pc, #332]	; 227d8 <usbd_dmareq_process+0x15c>
   2268e:	4d53      	ldr	r5, [pc, #332]	; (227dc <usbd_dmareq_process+0x160>)
   22690:	f8d8 4000 	ldr.w	r4, [r8]
   22694:	682b      	ldr	r3, [r5, #0]
   22696:	401c      	ands	r4, r3
   22698:	d061      	beq.n	2275e <usbd_dmareq_process+0xe2>
            if (NRFX_USBD_CONFIG_DMASCHEDULER_ISO_BOOST && ((req & USBD_EPISO_BIT_MASK) != 0))
   2269a:	f014 2301 	ands.w	r3, r4, #16777472	; 0x1000100
    return NRF_CTZ(req);
   2269e:	bf14      	ite	ne
   226a0:	fa93 f4a3 	rbitne	r4, r3
   226a4:	fa94 f4a4 	rbiteq	r4, r4
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   226a8:	f04f 0901 	mov.w	r9, #1
    return NRF_CTZ(req);
   226ac:	fab4 f484 	clz	r4, r4
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   226b0:	fa09 f904 	lsl.w	r9, r9, r4
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   226b4:	2c0f      	cmp	r4, #15
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   226b6:	ea6f 0909 	mvn.w	r9, r9
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   226ba:	d953      	bls.n	22764 <usbd_dmareq_process+0xe8>
   226bc:	3c10      	subs	r4, #16
   226be:	b2e4      	uxtb	r4, r4
            usbd_ep_state_t * p_state = ep_state_access(ep);
   226c0:	4620      	mov	r0, r4
   226c2:	f7ff fcd9 	bl	22078 <ep_state_access>
   226c6:	4682      	mov	sl, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   226c8:	4620      	mov	r0, r4
   226ca:	f7ff ffc3 	bl	22654 <nrfx_usbd_epout_size_get>
                continue_transfer = p_state->handler.consumer(
   226ce:	f8da 7000 	ldr.w	r7, [sl]
   226d2:	4603      	mov	r3, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   226d4:	4683      	mov	fp, r0
                continue_transfer = p_state->handler.consumer(
   226d6:	f8ba 200c 	ldrh.w	r2, [sl, #12]
   226da:	f8da 1004 	ldr.w	r1, [sl, #4]
   226de:	a802      	add	r0, sp, #8
   226e0:	47b8      	blx	r7
                if (transfer.p_data.rx == NULL)
   226e2:	9b02      	ldr	r3, [sp, #8]
   226e4:	2b00      	cmp	r3, #0
   226e6:	d149      	bne.n	2277c <usbd_dmareq_process+0x100>
                if (!continue_transfer)
   226e8:	b908      	cbnz	r0, 226ee <usbd_dmareq_process+0x72>
                    p_state->handler.consumer = NULL;
   226ea:	f8ca 0000 	str.w	r0, [sl]
    m_dma_pending = true;
   226ee:	2301      	movs	r3, #1
   226f0:	7033      	strb	r3, [r6, #0]
            m_ep_ready &= ~(1U << pos);
   226f2:	682b      	ldr	r3, [r5, #0]
            p_state->transfer_cnt += transfer.size;
   226f4:	9a03      	ldr	r2, [sp, #12]
            m_ep_ready &= ~(1U << pos);
   226f6:	ea03 0309 	and.w	r3, r3, r9
   226fa:	602b      	str	r3, [r5, #0]
            p_state->transfer_cnt += transfer.size;
   226fc:	f8da 3008 	ldr.w	r3, [sl, #8]
            if (NRF_USBD_EPIN_CHECK(ep))
   22700:	b261      	sxtb	r1, r4
            p_state->transfer_cnt += transfer.size;
   22702:	4413      	add	r3, r2
    if (NRF_USBD_EPIN_CHECK(ep))
   22704:	2900      	cmp	r1, #0
   22706:	f8ca 3008 	str.w	r3, [sl, #8]
            nrf_usbd_ep_easydma_set(NRF_USBD, ep, transfer.p_data.addr, (uint32_t)transfer.size);
   2270a:	f004 0508 	and.w	r5, r4, #8
   2270e:	9802      	ldr	r0, [sp, #8]
   22710:	4b33      	ldr	r3, [pc, #204]	; (227e0 <usbd_dmareq_process+0x164>)
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   22712:	f004 040f 	and.w	r4, r4, #15
    if (NRF_USBD_EPIN_CHECK(ep))
   22716:	da4e      	bge.n	227b6 <usbd_dmareq_process+0x13a>
        if (NRF_USBD_EPISO_CHECK(ep))
   22718:	2d00      	cmp	r5, #0
   2271a:	d044      	beq.n	227a6 <usbd_dmareq_process+0x12a>
            p_reg->ISOIN.PTR    = ptr;
   2271c:	f8c3 06a0 	str.w	r0, [r3, #1696]	; 0x6a0
            p_reg->ISOIN.MAXCNT = maxcnt;
   22720:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
    return (nrf_usbd_task_t)(
   22724:	2304      	movs	r3, #4
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   22726:	2201      	movs	r2, #1
   22728:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    return (volatile uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   2272c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   22730:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   22734:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   22736:	681b      	ldr	r3, [r3, #0]
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   22738:	4a2a      	ldr	r2, [pc, #168]	; (227e4 <usbd_dmareq_process+0x168>)
   2273a:	4b2b      	ldr	r3, [pc, #172]	; (227e8 <usbd_dmareq_process+0x16c>)
   2273c:	ea13 0321 	ands.w	r3, r3, r1, asr #32
   22740:	bf38      	it	cc
   22742:	4613      	movcc	r3, r2
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   22744:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
   22748:	4925      	ldr	r1, [pc, #148]	; (227e0 <usbd_dmareq_process+0x164>)
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   2274a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2274e:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   22752:	681a      	ldr	r2, [r3, #0]
            while (!nrf_usbd_event_check(NRF_USBD, nrfx_usbd_ep_to_endevent(ep)) &&
   22754:	b91a      	cbnz	r2, 2275e <usbd_dmareq_process+0xe2>
   22756:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
   2275a:	2a00      	cmp	r2, #0
   2275c:	d0f9      	beq.n	22752 <usbd_dmareq_process+0xd6>
}
   2275e:	b005      	add	sp, #20
   22760:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   22764:	f044 0480 	orr.w	r4, r4, #128	; 0x80
            usbd_ep_state_t * p_state = ep_state_access(ep);
   22768:	4620      	mov	r0, r4
   2276a:	f7ff fc85 	bl	22078 <ep_state_access>
   2276e:	4682      	mov	sl, r0
                continue_transfer = p_state->handler.feeder(
   22770:	6803      	ldr	r3, [r0, #0]
   22772:	8982      	ldrh	r2, [r0, #12]
   22774:	6841      	ldr	r1, [r0, #4]
   22776:	a802      	add	r0, sp, #8
   22778:	4798      	blx	r3
   2277a:	e7b5      	b.n	226e8 <usbd_dmareq_process+0x6c>
                else if (transfer.size < rx_size)
   2277c:	9b03      	ldr	r3, [sp, #12]
   2277e:	459b      	cmp	fp, r3
   22780:	d9b2      	bls.n	226e8 <usbd_dmareq_process+0x6c>
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   22782:	2702      	movs	r7, #2
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   22784:	4648      	mov	r0, r9
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   22786:	f88a 700e 	strb.w	r7, [sl, #14]
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   2278a:	f7ff fd31 	bl	221f0 <atomic_and.constprop.0.isra.0>
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   2278e:	2306      	movs	r3, #6
   22790:	f88d 3004 	strb.w	r3, [sp, #4]
                    m_event_handler(&evt);
   22794:	4b15      	ldr	r3, [pc, #84]	; (227ec <usbd_dmareq_process+0x170>)
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   22796:	f88d 4006 	strb.w	r4, [sp, #6]
                    m_event_handler(&evt);
   2279a:	681b      	ldr	r3, [r3, #0]
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   2279c:	f88d 7007 	strb.w	r7, [sp, #7]
                    m_event_handler(&evt);
   227a0:	a801      	add	r0, sp, #4
   227a2:	4798      	blx	r3
                    continue;
   227a4:	e774      	b.n	22690 <usbd_dmareq_process+0x14>
            p_reg->EPIN[epnr].PTR    = ptr;
   227a6:	2514      	movs	r5, #20
   227a8:	fb05 3304 	mla	r3, r5, r4, r3
   227ac:	f8c3 0600 	str.w	r0, [r3, #1536]	; 0x600
            p_reg->EPIN[epnr].MAXCNT = maxcnt;
   227b0:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    return (nrf_usbd_task_t)(
   227b4:	e7b6      	b.n	22724 <usbd_dmareq_process+0xa8>
        if (NRF_USBD_EPISO_CHECK(ep))
   227b6:	b12d      	cbz	r5, 227c4 <usbd_dmareq_process+0x148>
            p_reg->ISOOUT.PTR    = ptr;
   227b8:	f8c3 07a0 	str.w	r0, [r3, #1952]	; 0x7a0
            p_reg->ISOOUT.MAXCNT = maxcnt;
   227bc:	f8c3 27a4 	str.w	r2, [r3, #1956]	; 0x7a4
   227c0:	2328      	movs	r3, #40	; 0x28
   227c2:	e7b0      	b.n	22726 <usbd_dmareq_process+0xaa>
            p_reg->EPOUT[epnr].PTR    = ptr;
   227c4:	2514      	movs	r5, #20
   227c6:	fb05 3304 	mla	r3, r5, r4, r3
   227ca:	f8c3 0700 	str.w	r0, [r3, #1792]	; 0x700
            p_reg->EPOUT[epnr].MAXCNT = maxcnt;
   227ce:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
   227d2:	e7f5      	b.n	227c0 <usbd_dmareq_process+0x144>
   227d4:	2000b627 	.word	0x2000b627
   227d8:	2000b5a4 	.word	0x2000b5a4
   227dc:	2000b5a8 	.word	0x2000b5a8
   227e0:	40036000 	.word	0x40036000
   227e4:	000269b0 	.word	0x000269b0
   227e8:	000269c2 	.word	0x000269c2
   227ec:	2000b5ac 	.word	0x2000b5ac

000227f0 <ev_epdata_handler>:
{
   227f0:	b538      	push	{r3, r4, r5, lr}
        dataepstatus &= ~(1UL << bitpos);
   227f2:	2501      	movs	r5, #1
    return p_reg->EPDATASTATUS;
   227f4:	4b0e      	ldr	r3, [pc, #56]	; (22830 <ev_epdata_handler+0x40>)
   227f6:	f8d3 446c 	ldr.w	r4, [r3, #1132]	; 0x46c
    p_reg->EPDATASTATUS = flags;
   227fa:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
    while (dataepstatus)
   227fe:	b91c      	cbnz	r4, 22808 <ev_epdata_handler+0x18>
}
   22800:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        usbd_dmareq_process();
   22804:	f7ff bf3a 	b.w	2267c <usbd_dmareq_process>
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
   22808:	fa94 f3a4 	rbit	r3, r4
   2280c:	fab3 f383 	clz	r3, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   22810:	2b0f      	cmp	r3, #15
   22812:	bfc8      	it	gt
   22814:	f1a3 0010 	subgt.w	r0, r3, #16
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
   22818:	4619      	mov	r1, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   2281a:	bfd4      	ite	le
   2281c:	f043 0080 	orrle.w	r0, r3, #128	; 0x80
   22820:	b2c0      	uxtbgt	r0, r0
        dataepstatus &= ~(1UL << bitpos);
   22822:	fa05 f303 	lsl.w	r3, r5, r3
   22826:	ea24 0403 	bic.w	r4, r4, r3
        (void)(usbd_ep_data_handler(ep, bitpos));
   2282a:	f7ff fd1f 	bl	2226c <usbd_ep_data_handler>
   2282e:	e7e6      	b.n	227fe <ev_epdata_handler+0xe>
   22830:	40036000 	.word	0x40036000

00022834 <nrf_usbd_epout_dma_handler>:
{
   22834:	b537      	push	{r0, r1, r2, r4, r5, lr}
    m_dma_pending = false;
   22836:	2200      	movs	r2, #0
   22838:	4b16      	ldr	r3, [pc, #88]	; (22894 <nrf_usbd_epout_dma_handler+0x60>)
{
   2283a:	4604      	mov	r4, r0
    m_dma_pending = false;
   2283c:	701a      	strb	r2, [r3, #0]
    usbd_ep_state_t * p_state = ep_state_access(ep);
   2283e:	f7ff fc1b 	bl	22078 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   22842:	7b83      	ldrb	r3, [r0, #14]
   22844:	2b03      	cmp	r3, #3
   22846:	d10d      	bne.n	22864 <nrf_usbd_epout_dma_handler+0x30>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22848:	4620      	mov	r0, r4
   2284a:	f003 f8ef 	bl	25a2c <ep2bit>
   2284e:	2301      	movs	r3, #1
   22850:	fa03 f000 	lsl.w	r0, r3, r0
   22854:	43c0      	mvns	r0, r0
   22856:	f7ff fccb 	bl	221f0 <atomic_and.constprop.0.isra.0>
}
   2285a:	b003      	add	sp, #12
   2285c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    usbd_dmareq_process();
   22860:	f7ff bf0c 	b.w	2267c <usbd_dmareq_process>
    else if (p_state->handler.consumer == NULL)
   22864:	6805      	ldr	r5, [r0, #0]
   22866:	2d00      	cmp	r5, #0
   22868:	d1f7      	bne.n	2285a <nrf_usbd_epout_dma_handler+0x26>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2286a:	4620      	mov	r0, r4
   2286c:	f003 f8de 	bl	25a2c <ep2bit>
   22870:	2301      	movs	r3, #1
   22872:	fa03 f000 	lsl.w	r0, r3, r0
   22876:	43c0      	mvns	r0, r0
   22878:	f7ff fcba 	bl	221f0 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2287c:	2306      	movs	r3, #6
   2287e:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   22882:	4b05      	ldr	r3, [pc, #20]	; (22898 <nrf_usbd_epout_dma_handler+0x64>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22884:	f88d 4006 	strb.w	r4, [sp, #6]
        m_event_handler(&evt);
   22888:	681b      	ldr	r3, [r3, #0]
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2288a:	f88d 5007 	strb.w	r5, [sp, #7]
        m_event_handler(&evt);
   2288e:	a801      	add	r0, sp, #4
   22890:	4798      	blx	r3
   22892:	e7e2      	b.n	2285a <nrf_usbd_epout_dma_handler+0x26>
   22894:	2000b627 	.word	0x2000b627
   22898:	2000b5ac 	.word	0x2000b5ac

0002289c <nrfx_usbd_ep_stall>:
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_Stall << USBD_EPSTALL_STALL_Pos) | ep;
   2289c:	4b02      	ldr	r3, [pc, #8]	; (228a8 <nrfx_usbd_ep_stall+0xc>)
   2289e:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   228a2:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518

void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep)
{
    NRFX_LOG_DEBUG("USB: EP %x stalled.", ep);
    nrf_usbd_ep_stall(NRF_USBD, ep_to_hal(ep));
}
   228a6:	4770      	bx	lr
   228a8:	40036000 	.word	0x40036000

000228ac <nrfx_usbd_ep_stall_check>:
    if (NRF_USBD_EPISO_CHECK(ep))
   228ac:	0702      	lsls	r2, r0, #28
   228ae:	d413      	bmi.n	228d8 <nrfx_usbd_ep_stall_check+0x2c>
        return p_reg->HALTED.EPIN[epnr];
   228b0:	f000 030f 	and.w	r3, r0, #15
    if (NRF_USBD_EPIN_CHECK(ep))
   228b4:	f010 0f80 	tst.w	r0, #128	; 0x80
   228b8:	4a08      	ldr	r2, [pc, #32]	; (228dc <nrfx_usbd_ep_stall_check+0x30>)
        return p_reg->HALTED.EPOUT[epnr];
   228ba:	bf0b      	itete	eq
   228bc:	f503 7388 	addeq.w	r3, r3, #272	; 0x110
        return p_reg->HALTED.EPIN[epnr];
   228c0:	f503 7384 	addne.w	r3, r3, #264	; 0x108
        return p_reg->HALTED.EPOUT[epnr];
   228c4:	eb02 0283 	addeq.w	r2, r2, r3, lsl #2
        return p_reg->HALTED.EPIN[epnr];
   228c8:	f852 0023 	ldrne.w	r0, [r2, r3, lsl #2]
        return p_reg->HALTED.EPOUT[epnr];
   228cc:	bf08      	it	eq
   228ce:	6850      	ldreq	r0, [r2, #4]
    return USBD_HALTED_EPOUT_GETSTATUS_Halted == nrf_usbd_halted_get(p_reg, ep);
   228d0:	1e43      	subs	r3, r0, #1
   228d2:	4258      	negs	r0, r3
   228d4:	4158      	adcs	r0, r3
   228d6:	4770      	bx	lr
        return false;
   228d8:	2000      	movs	r0, #0
}

bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_ep_is_stall(NRF_USBD, ep_to_hal(ep));
}
   228da:	4770      	bx	lr
   228dc:	40036000 	.word	0x40036000

000228e0 <nrfx_usbd_ep_dtoggle_clear>:
    p_reg->DTOGGLE = ep | (NRF_USBD_DTOGGLE_NOP << USBD_DTOGGLE_VALUE_Pos);
   228e0:	4b04      	ldr	r3, [pc, #16]	; (228f4 <nrfx_usbd_ep_dtoggle_clear+0x14>)
   228e2:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->DTOGGLE = ep | (op << USBD_DTOGGLE_VALUE_Pos);
   228e6:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   228ea:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    (void) p_reg->DTOGGLE;
   228ee:	f8d3 350c 	ldr.w	r3, [r3, #1292]	; 0x50c

void nrfx_usbd_ep_dtoggle_clear(nrfx_usbd_ep_t ep)
{
    nrf_usbd_dtoggle_set(NRF_USBD, ep, NRF_USBD_DTOGGLE_DATA0);
}
   228f2:	4770      	bx	lr
   228f4:	40036000 	.word	0x40036000

000228f8 <nrfx_usbd_setup_get>:

void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup)
{
   228f8:	b510      	push	{r4, lr}
   228fa:	4604      	mov	r4, r0
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
   228fc:	2208      	movs	r2, #8
   228fe:	2100      	movs	r1, #0
   22900:	f002 fb86 	bl	25010 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   22904:	4b0e      	ldr	r3, [pc, #56]	; (22940 <nrfx_usbd_setup_get+0x48>)
   22906:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
   2290a:	7022      	strb	r2, [r4, #0]
    return (uint8_t)(p_reg->BREQUEST);
   2290c:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
   22910:	7062      	strb	r2, [r4, #1]
    const uint16_t val = p_reg->WVALUEL;
   22912:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
   22916:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
   2291a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->bmRequestType = nrf_usbd_setup_bmrequesttype_get(NRF_USBD);
    p_setup->bRequest      = nrf_usbd_setup_brequest_get(NRF_USBD);
    p_setup->wValue        = nrf_usbd_setup_wvalue_get(NRF_USBD);
   2291e:	8062      	strh	r2, [r4, #2]
    const uint16_t val = p_reg->WINDEXL;
   22920:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
   22924:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
   22928:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->wIndex        = nrf_usbd_setup_windex_get(NRF_USBD);
   2292c:	80a2      	strh	r2, [r4, #4]
    const uint16_t val = p_reg->WLENGTHL;
   2292e:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
   22932:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
   22936:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    p_setup->wLength       = nrf_usbd_setup_wlength_get(NRF_USBD);
   2293a:	80e3      	strh	r3, [r4, #6]
}
   2293c:	bd10      	pop	{r4, pc}
   2293e:	bf00      	nop
   22940:	40036000 	.word	0x40036000

00022944 <nrfx_usbd_setup_data_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   22944:	2201      	movs	r2, #1
   22946:	4b02      	ldr	r3, [pc, #8]	; (22950 <nrfx_usbd_setup_data_clear+0xc>)
   22948:	64da      	str	r2, [r3, #76]	; 0x4c
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   2294a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c

void nrfx_usbd_setup_data_clear(void)
{
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0RCVOUT);
}
   2294c:	4770      	bx	lr
   2294e:	bf00      	nop
   22950:	40036000 	.word	0x40036000

00022954 <ev_dma_epout0_handler>:
    m_dma_pending = false;
   22954:	2200      	movs	r2, #0
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   22956:	b513      	push	{r0, r1, r4, lr}
    m_dma_pending = false;
   22958:	4b11      	ldr	r3, [pc, #68]	; (229a0 <ev_dma_epout0_handler+0x4c>)
   2295a:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   2295c:	4b11      	ldr	r3, [pc, #68]	; (229a4 <ev_dma_epout0_handler+0x50>)
   2295e:	7b9a      	ldrb	r2, [r3, #14]
   22960:	2a03      	cmp	r2, #3
   22962:	d106      	bne.n	22972 <ev_dma_epout0_handler+0x1e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22964:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   22968:	b002      	add	sp, #8
   2296a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2296e:	f7ff bc3f 	b.w	221f0 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.consumer == NULL)
   22972:	681c      	ldr	r4, [r3, #0]
   22974:	b974      	cbnz	r4, 22994 <ev_dma_epout0_handler+0x40>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22976:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
   2297a:	f7ff fc39 	bl	221f0 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2297e:	2306      	movs	r3, #6
   22980:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   22984:	4b08      	ldr	r3, [pc, #32]	; (229a8 <ev_dma_epout0_handler+0x54>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22986:	f8ad 4006 	strh.w	r4, [sp, #6]
        m_event_handler(&evt);
   2298a:	681b      	ldr	r3, [r3, #0]
   2298c:	a801      	add	r0, sp, #4
   2298e:	4798      	blx	r3
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   22990:	b002      	add	sp, #8
   22992:	bd10      	pop	{r4, pc}
   22994:	b002      	add	sp, #8
   22996:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        nrfx_usbd_setup_data_clear();
   2299a:	f7ff bfd3 	b.w	22944 <nrfx_usbd_setup_data_clear>
   2299e:	bf00      	nop
   229a0:	2000b627 	.word	0x2000b627
   229a4:	2000b484 	.word	0x2000b484
   229a8:	2000b5ac 	.word	0x2000b5ac

000229ac <nrfx_usbd_setup_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   229ac:	2201      	movs	r2, #1
   229ae:	4b02      	ldr	r3, [pc, #8]	; (229b8 <nrfx_usbd_setup_clear+0xc>)
   229b0:	651a      	str	r2, [r3, #80]	; 0x50
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   229b2:	6d1b      	ldr	r3, [r3, #80]	; 0x50

void nrfx_usbd_setup_clear(void)
{
    NRFX_LOG_DEBUG(">> ep0status >>");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STATUS);
}
   229b4:	4770      	bx	lr
   229b6:	bf00      	nop
   229b8:	40036000 	.word	0x40036000

000229bc <nrfx_usbd_setup_stall>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   229bc:	2201      	movs	r2, #1
   229be:	4b02      	ldr	r3, [pc, #8]	; (229c8 <nrfx_usbd_setup_stall+0xc>)
   229c0:	655a      	str	r2, [r3, #84]	; 0x54
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   229c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54

void nrfx_usbd_setup_stall(void)
{
    NRFX_LOG_DEBUG("Setup stalled.");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STALL);
}
   229c4:	4770      	bx	lr
   229c6:	bf00      	nop
   229c8:	40036000 	.word	0x40036000

000229cc <nrfx_usbd_last_setup_dir_get>:

nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void)
{
    return m_last_setup_dir;
}
   229cc:	4b01      	ldr	r3, [pc, #4]	; (229d4 <nrfx_usbd_last_setup_dir_get+0x8>)
   229ce:	7818      	ldrb	r0, [r3, #0]
   229d0:	4770      	bx	lr
   229d2:	bf00      	nop
   229d4:	2000b628 	.word	0x2000b628

000229d8 <nrfx_usbd_transfer_out_drop>:

void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep)
{
   229d8:	4602      	mov	r2, r0
   229da:	b510      	push	{r4, lr}
	__asm__ volatile(
   229dc:	f04f 0320 	mov.w	r3, #32
   229e0:	f3ef 8411 	mrs	r4, BASEPRI
   229e4:	f383 8812 	msr	BASEPRI_MAX, r3
   229e8:	f3bf 8f6f 	isb	sy
    NRFX_ASSERT(NRF_USBD_EPOUT_CHECK(ep));

    NRFX_CRITICAL_SECTION_ENTER();
    m_ep_ready &= ~(1U << ep2bit(ep));
   229ec:	f003 f81e 	bl	25a2c <ep2bit>
   229f0:	2301      	movs	r3, #1
   229f2:	490d      	ldr	r1, [pc, #52]	; (22a28 <nrfx_usbd_transfer_out_drop+0x50>)
   229f4:	fa03 f000 	lsl.w	r0, r3, r0
   229f8:	680b      	ldr	r3, [r1, #0]
   229fa:	ea23 0300 	bic.w	r3, r3, r0
   229fe:	600b      	str	r3, [r1, #0]
    if (!NRF_USBD_EPISO_CHECK(ep))
   22a00:	f012 0108 	ands.w	r1, r2, #8
   22a04:	d10a      	bne.n	22a1c <nrfx_usbd_transfer_out_drop+0x44>
    p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)] = 0;
   22a06:	f002 030f 	and.w	r3, r2, #15
   22a0a:	009b      	lsls	r3, r3, #2
   22a0c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   22a10:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
   22a14:	f8c3 14a0 	str.w	r1, [r3, #1184]	; 0x4a0
    (void) p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   22a18:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
	__asm__ volatile(
   22a1c:	f384 8811 	msr	BASEPRI, r4
   22a20:	f3bf 8f6f 	isb	sy
    {
        nrf_usbd_epout_clear(NRF_USBD, ep);
    }
    NRFX_CRITICAL_SECTION_EXIT();
}
   22a24:	bd10      	pop	{r4, pc}
   22a26:	bf00      	nop
   22a28:	2000b5a8 	.word	0x2000b5a8

00022a2c <usbd_ep_abort>:
{
   22a2c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   22a2e:	4601      	mov	r1, r0
	__asm__ volatile(
   22a30:	f04f 0320 	mov.w	r3, #32
   22a34:	f3ef 8511 	mrs	r5, BASEPRI
   22a38:	f383 8812 	msr	BASEPRI_MAX, r3
   22a3c:	f3bf 8f6f 	isb	sy
    usbd_ep_state_t * p_state = ep_state_access(ep);
   22a40:	f7ff fb1a 	bl	22078 <ep_state_access>
   22a44:	4606      	mov	r6, r0
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   22a46:	4608      	mov	r0, r1
   22a48:	f002 fff0 	bl	25a2c <ep2bit>
   22a4c:	2201      	movs	r2, #1
    if (NRF_USBD_EPOUT_CHECK(ep))
   22a4e:	f011 0f80 	tst.w	r1, #128	; 0x80
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   22a52:	fa02 f200 	lsl.w	r2, r2, r0
   22a56:	482e      	ldr	r0, [pc, #184]	; (22b10 <usbd_ep_abort+0xe4>)
    if (NRF_USBD_EPOUT_CHECK(ep))
   22a58:	d119      	bne.n	22a8e <usbd_ep_abort+0x62>
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   22a5a:	6803      	ldr	r3, [r0, #0]
   22a5c:	ea32 0303 	bics.w	r3, r2, r3
   22a60:	d00a      	beq.n	22a78 <usbd_ep_abort+0x4c>
            nrfx_usbd_transfer_out_drop(ep);
   22a62:	4608      	mov	r0, r1
   22a64:	f7ff ffb8 	bl	229d8 <nrfx_usbd_transfer_out_drop>
        p_state->status = NRFX_USBD_EP_ABORTED;
   22a68:	2303      	movs	r3, #3
   22a6a:	73b3      	strb	r3, [r6, #14]
	__asm__ volatile(
   22a6c:	f385 8811 	msr	BASEPRI, r5
   22a70:	f3bf 8f6f 	isb	sy
}
   22a74:	b003      	add	sp, #12
   22a76:	bdf0      	pop	{r4, r5, r6, r7, pc}
            p_state->handler.consumer = NULL;
   22a78:	6033      	str	r3, [r6, #0]
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22a7a:	6803      	ldr	r3, [r0, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
   22a7c:	4925      	ldr	r1, [pc, #148]	; (22b14 <usbd_ep_abort+0xe8>)
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22a7e:	ea23 0302 	bic.w	r3, r3, r2
   22a82:	6003      	str	r3, [r0, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
   22a84:	680b      	ldr	r3, [r1, #0]
   22a86:	ea23 0302 	bic.w	r3, r3, r2
   22a8a:	600b      	str	r3, [r1, #0]
   22a8c:	e7ec      	b.n	22a68 <usbd_ep_abort+0x3c>
        if(!NRF_USBD_EPISO_CHECK(ep))
   22a8e:	070b      	lsls	r3, r1, #28
   22a90:	d415      	bmi.n	22abe <usbd_ep_abort+0x92>
            if(ep != NRFX_USBD_EPIN0)
   22a92:	2980      	cmp	r1, #128	; 0x80
   22a94:	4b20      	ldr	r3, [pc, #128]	; (22b18 <usbd_ep_abort+0xec>)
   22a96:	d02f      	beq.n	22af8 <usbd_ep_abort+0xcc>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B6 + (2u * (NRF_USBD_EP_NR_GET(ep) - 1));
   22a98:	f001 040f 	and.w	r4, r1, #15
   22a9c:	f204 34da 	addw	r4, r4, #986	; 0x3da
   22aa0:	0064      	lsls	r4, r4, #1
   22aa2:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22aa6:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22aaa:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22aae:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22ab0:	f044 0402 	orr.w	r4, r4, #2
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22ab4:	433c      	orrs	r4, r7
   22ab6:	f8c3 4804 	str.w	r4, [r3, #2052]	; 0x804
                (void)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   22aba:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
        if ((m_ep_dma_waiting | (~m_ep_ready)) & (1U << ep2bit(ep)))
   22abe:	4f15      	ldr	r7, [pc, #84]	; (22b14 <usbd_ep_abort+0xe8>)
   22ac0:	6804      	ldr	r4, [r0, #0]
   22ac2:	683b      	ldr	r3, [r7, #0]
   22ac4:	ea64 0c03 	orn	ip, r4, r3
   22ac8:	ea1c 0f02 	tst.w	ip, r2
   22acc:	d0ce      	beq.n	22a6c <usbd_ep_abort+0x40>
            m_ep_ready       |=   1U << ep2bit(ep) ;
   22ace:	4313      	orrs	r3, r2
   22ad0:	603b      	str	r3, [r7, #0]
            p_state->handler.feeder = NULL;
   22ad2:	2300      	movs	r3, #0
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22ad4:	ea24 0402 	bic.w	r4, r4, r2
   22ad8:	6004      	str	r4, [r0, #0]
            p_state->handler.feeder = NULL;
   22ada:	6033      	str	r3, [r6, #0]
            p_state->status = NRFX_USBD_EP_ABORTED;
   22adc:	2303      	movs	r3, #3
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22ade:	2206      	movs	r2, #6
            p_state->status = NRFX_USBD_EP_ABORTED;
   22ae0:	73b3      	strb	r3, [r6, #14]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22ae2:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
   22ae6:	4b0d      	ldr	r3, [pc, #52]	; (22b1c <usbd_ep_abort+0xf0>)
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22ae8:	f88d 2004 	strb.w	r2, [sp, #4]
            m_event_handler(&evt);
   22aec:	681b      	ldr	r3, [r3, #0]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22aee:	f88d 1006 	strb.w	r1, [sp, #6]
            m_event_handler(&evt);
   22af2:	a801      	add	r0, sp, #4
   22af4:	4798      	blx	r3
   22af6:	e7b9      	b.n	22a6c <usbd_ep_abort+0x40>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B4;
   22af8:	f240 74b4 	movw	r4, #1972	; 0x7b4
   22afc:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22b00:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22b04:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22b08:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22b0a:	f044 0404 	orr.w	r4, r4, #4
   22b0e:	e7d1      	b.n	22ab4 <usbd_ep_abort+0x88>
   22b10:	2000b5a4 	.word	0x2000b5a4
   22b14:	2000b5a8 	.word	0x2000b5a8
   22b18:	40036000 	.word	0x40036000
   22b1c:	2000b5ac 	.word	0x2000b5ac

00022b20 <ev_setup_handler>:
{
   22b20:	b573      	push	{r0, r1, r4, r5, r6, lr}
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   22b22:	4b14      	ldr	r3, [pc, #80]	; (22b74 <ev_setup_handler+0x54>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b24:	4c14      	ldr	r4, [pc, #80]	; (22b78 <ev_setup_handler+0x58>)
   22b26:	f8d3 5480 	ldr.w	r5, [r3, #1152]	; 0x480
   22b2a:	6823      	ldr	r3, [r4, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
   22b2c:	4e13      	ldr	r6, [pc, #76]	; (22b7c <ev_setup_handler+0x5c>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b2e:	43da      	mvns	r2, r3
   22b30:	4b13      	ldr	r3, [pc, #76]	; (22b80 <ev_setup_handler+0x60>)
        & (1U <<ep2bit(m_last_setup_dir)))
   22b32:	7831      	ldrb	r1, [r6, #0]
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b34:	681b      	ldr	r3, [r3, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
   22b36:	4608      	mov	r0, r1
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b38:	b292      	uxth	r2, r2
   22b3a:	431a      	orrs	r2, r3
        & (1U <<ep2bit(m_last_setup_dir)))
   22b3c:	f002 ff76 	bl	25a2c <ep2bit>
   22b40:	2301      	movs	r3, #1
   22b42:	4083      	lsls	r3, r0
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b44:	4213      	tst	r3, r2
   22b46:	d002      	beq.n	22b4e <ev_setup_handler+0x2e>
        usbd_ep_abort(m_last_setup_dir);
   22b48:	4608      	mov	r0, r1
   22b4a:	f7ff ff6f 	bl	22a2c <usbd_ep_abort>
    (void)(NRFX_ATOMIC_FETCH_AND(
   22b4e:	f06f 1001 	mvn.w	r0, #65537	; 0x10001
        NRFX_USBD_EPOUT0 : NRFX_USBD_EPIN0;
   22b52:	f025 057f 	bic.w	r5, r5, #127	; 0x7f
    m_last_setup_dir =
   22b56:	7035      	strb	r5, [r6, #0]
    (void)(NRFX_ATOMIC_FETCH_AND(
   22b58:	f7ff fb4a 	bl	221f0 <atomic_and.constprop.0.isra.0>
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
   22b5c:	6823      	ldr	r3, [r4, #0]
    m_event_handler(&evt);
   22b5e:	a801      	add	r0, sp, #4
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
   22b60:	f043 0301 	orr.w	r3, r3, #1
   22b64:	6023      	str	r3, [r4, #0]
    const nrfx_usbd_evt_t evt = {
   22b66:	2305      	movs	r3, #5
   22b68:	9301      	str	r3, [sp, #4]
    m_event_handler(&evt);
   22b6a:	4b06      	ldr	r3, [pc, #24]	; (22b84 <ev_setup_handler+0x64>)
   22b6c:	681b      	ldr	r3, [r3, #0]
   22b6e:	4798      	blx	r3
}
   22b70:	b002      	add	sp, #8
   22b72:	bd70      	pop	{r4, r5, r6, pc}
   22b74:	40036000 	.word	0x40036000
   22b78:	2000b5a8 	.word	0x2000b5a8
   22b7c:	2000b628 	.word	0x2000b628
   22b80:	2000b5a4 	.word	0x2000b5a4
   22b84:	2000b5ac 	.word	0x2000b5ac

00022b88 <nrfx_usbd_irq_handler>:
{
   22b88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return p_reg->INTENSET;
   22b8c:	4b1a      	ldr	r3, [pc, #104]	; (22bf8 <nrfx_usbd_irq_handler+0x70>)
            active |= 1UL << event_nr;
   22b8e:	2401      	movs	r4, #1
   22b90:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
    uint32_t active = 0;
   22b94:	2300      	movs	r3, #0
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   22b96:	461d      	mov	r5, r3
    while (to_process)
   22b98:	b970      	cbnz	r0, 22bb8 <nrfx_usbd_irq_handler+0x30>
        active &= ~(1UL << event_nr);
   22b9a:	f04f 0801 	mov.w	r8, #1
        m_isr[event_nr]();
   22b9e:	4f17      	ldr	r7, [pc, #92]	; (22bfc <nrfx_usbd_irq_handler+0x74>)
    bool setup_active = 0 != (active & NRF_USBD_INT_EP0SETUP_MASK);
   22ba0:	f403 0600 	and.w	r6, r3, #8388608	; 0x800000
    active &= ~NRF_USBD_INT_EP0SETUP_MASK;
   22ba4:	f423 0400 	bic.w	r4, r3, #8388608	; 0x800000
    while (active)
   22ba8:	b9bc      	cbnz	r4, 22bda <nrfx_usbd_irq_handler+0x52>
    usbd_dmareq_process();
   22baa:	f7ff fd67 	bl	2267c <usbd_dmareq_process>
    if (setup_active)
   22bae:	b306      	cbz	r6, 22bf2 <nrfx_usbd_irq_handler+0x6a>
}
   22bb0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        m_isr[USBD_INTEN_EP0SETUP_Pos]();
   22bb4:	f7ff bfb4 	b.w	22b20 <ev_setup_handler>
        uint8_t event_nr = NRF_CTZ(to_process);
   22bb8:	fa90 f2a0 	rbit	r2, r0
   22bbc:	fab2 f282 	clz	r2, r2
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   22bc0:	490f      	ldr	r1, [pc, #60]	; (22c00 <nrfx_usbd_irq_handler+0x78>)
}

NRF_STATIC_INLINE uint32_t nrfx_bitpos_to_event(uint32_t bit)
{
    static const uint32_t event_reg_offset = 0x100u;
    return event_reg_offset + (bit * sizeof(uint32_t));
   22bc2:	0096      	lsls	r6, r2, #2
   22bc4:	4431      	add	r1, r6
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   22bc6:	680e      	ldr	r6, [r1, #0]
            active |= 1UL << event_nr;
   22bc8:	fa04 f202 	lsl.w	r2, r4, r2
    if (ret)
   22bcc:	b116      	cbz	r6, 22bd4 <nrfx_usbd_irq_handler+0x4c>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   22bce:	600d      	str	r5, [r1, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   22bd0:	6809      	ldr	r1, [r1, #0]
   22bd2:	4313      	orrs	r3, r2
        to_process &= ~(1UL << event_nr);
   22bd4:	ea20 0002 	bic.w	r0, r0, r2
   22bd8:	e7de      	b.n	22b98 <nrfx_usbd_irq_handler+0x10>
        uint8_t event_nr = NRF_CTZ(active);
   22bda:	fa94 f5a4 	rbit	r5, r4
   22bde:	fab5 f585 	clz	r5, r5
        m_isr[event_nr]();
   22be2:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
        active &= ~(1UL << event_nr);
   22be6:	fa08 f505 	lsl.w	r5, r8, r5
        m_isr[event_nr]();
   22bea:	4798      	blx	r3
        active &= ~(1UL << event_nr);
   22bec:	ea24 0405 	bic.w	r4, r4, r5
   22bf0:	e7da      	b.n	22ba8 <nrfx_usbd_irq_handler+0x20>
}
   22bf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   22bf6:	bf00      	nop
   22bf8:	40036000 	.word	0x40036000
   22bfc:	00026930 	.word	0x00026930
   22c00:	40036100 	.word	0x40036100

00022c04 <nrfx_usbd_stop>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   22c04:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
{
   22c08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22c0a:	4b1a      	ldr	r3, [pc, #104]	; (22c74 <nrfx_usbd_stop+0x70>)
    if (NRFX_IRQ_IS_ENABLED(USBD_IRQn))
   22c0c:	2036      	movs	r0, #54	; 0x36
   22c0e:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
   22c12:	f7fb fb93 	bl	1e33c <arch_irq_is_enabled>
   22c16:	b1b8      	cbz	r0, 22c48 <nrfx_usbd_stop+0x44>
        ep_waiting &= ~(1U << bitpos);
   22c18:	2701      	movs	r7, #1
    uint32_t ep_waiting = m_ep_dma_waiting | (m_ep_ready & NRFX_USBD_EPOUT_BIT_MASK);
   22c1a:	4e17      	ldr	r6, [pc, #92]	; (22c78 <nrfx_usbd_stop+0x74>)
   22c1c:	4b17      	ldr	r3, [pc, #92]	; (22c7c <nrfx_usbd_stop+0x78>)
   22c1e:	6834      	ldr	r4, [r6, #0]
   22c20:	681b      	ldr	r3, [r3, #0]
   22c22:	0c24      	lsrs	r4, r4, #16
   22c24:	0424      	lsls	r4, r4, #16
   22c26:	431c      	orrs	r4, r3
    while (0 != ep_waiting)
   22c28:	b97c      	cbnz	r4, 22c4a <nrfx_usbd_stop+0x46>
    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   22c2a:	f240 13ff 	movw	r3, #511	; 0x1ff
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Disabled << USBD_USBPULLUP_CONNECT_Pos;
   22c2e:	4d14      	ldr	r5, [pc, #80]	; (22c80 <nrfx_usbd_stop+0x7c>)
   22c30:	6033      	str	r3, [r6, #0]
        NRFX_IRQ_DISABLE(USBD_IRQn);
   22c32:	2036      	movs	r0, #54	; 0x36
   22c34:	f8c5 4504 	str.w	r4, [r5, #1284]	; 0x504
    (void) p_reg->USBPULLUP;
   22c38:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504
   22c3c:	f7fb fb6a 	bl	1e314 <arch_irq_disable>
    p_reg->INTENCLR = mask;
   22c40:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   22c44:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
}
   22c48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        uint8_t bitpos = NRF_CTZ(ep_waiting);
   22c4a:	fa94 f5a4 	rbit	r5, r4
   22c4e:	fab5 f585 	clz	r5, r5
   22c52:	4628      	mov	r0, r5
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   22c54:	2d0f      	cmp	r5, #15
   22c56:	bfc6      	itte	gt
   22c58:	f1a5 0010 	subgt.w	r0, r5, #16
   22c5c:	b2c0      	uxtbgt	r0, r0
   22c5e:	f040 0080 	orrle.w	r0, r0, #128	; 0x80
        if (!NRF_USBD_EPISO_CHECK(bit2ep(bitpos)))
   22c62:	0703      	lsls	r3, r0, #28
   22c64:	d401      	bmi.n	22c6a <nrfx_usbd_stop+0x66>
            usbd_ep_abort(bit2ep(bitpos));
   22c66:	f7ff fee1 	bl	22a2c <usbd_ep_abort>
        ep_waiting &= ~(1U << bitpos);
   22c6a:	fa07 f505 	lsl.w	r5, r7, r5
   22c6e:	ea24 0405 	bic.w	r4, r4, r5
   22c72:	e7d9      	b.n	22c28 <nrfx_usbd_stop+0x24>
   22c74:	e000e100 	.word	0xe000e100
   22c78:	2000b5a8 	.word	0x2000b5a8
   22c7c:	2000b5a4 	.word	0x2000b5a4
   22c80:	40036000 	.word	0x40036000

00022c84 <nrfx_usbd_disable>:
{
   22c84:	b508      	push	{r3, lr}
    nrfx_usbd_stop();
   22c86:	f7ff ffbd 	bl	22c04 <nrfx_usbd_stop>
    return p_reg->INTENSET;
   22c8a:	4b08      	ldr	r3, [pc, #32]	; (22cac <nrfx_usbd_disable+0x28>)
   22c8c:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
    p_reg->INTENCLR = mask;
   22c90:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Disabled << USBD_ENABLE_ENABLE_Pos;
   22c94:	2200      	movs	r2, #0
   22c96:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   22c9a:	f8d3 3500 	ldr.w	r3, [r3, #1280]	; 0x500
    m_dma_pending = false;
   22c9e:	4b04      	ldr	r3, [pc, #16]	; (22cb0 <nrfx_usbd_disable+0x2c>)
   22ca0:	701a      	strb	r2, [r3, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   22ca2:	2201      	movs	r2, #1
   22ca4:	4b03      	ldr	r3, [pc, #12]	; (22cb4 <nrfx_usbd_disable+0x30>)
   22ca6:	701a      	strb	r2, [r3, #0]
}
   22ca8:	bd08      	pop	{r3, pc}
   22caa:	bf00      	nop
   22cac:	40036000 	.word	0x40036000
   22cb0:	2000b627 	.word	0x2000b627
   22cb4:	2000b62a 	.word	0x2000b62a

00022cb8 <nrfx_usbd_ep_disable>:
{
   22cb8:	b510      	push	{r4, lr}
   22cba:	4604      	mov	r4, r0
    usbd_ep_abort(ep);
   22cbc:	f7ff feb6 	bl	22a2c <usbd_ep_abort>
        p_reg->EPINEN &= ~(1UL << epnr);
   22cc0:	2301      	movs	r3, #1
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   22cc2:	f004 000f 	and.w	r0, r4, #15
        p_reg->EPINEN &= ~(1UL << epnr);
   22cc6:	4083      	lsls	r3, r0
   22cc8:	43db      	mvns	r3, r3
   22cca:	4a0c      	ldr	r2, [pc, #48]	; (22cfc <nrfx_usbd_ep_disable+0x44>)
    if (NRF_USBD_EPIN_CHECK(ep))
   22ccc:	f014 0f80 	tst.w	r4, #128	; 0x80
        p_reg->EPINEN &= ~(1UL << epnr);
   22cd0:	bf15      	itete	ne
   22cd2:	f8d2 1510 	ldrne.w	r1, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   22cd6:	f8d2 1514 	ldreq.w	r1, [r2, #1300]	; 0x514
        p_reg->EPINEN &= ~(1UL << epnr);
   22cda:	400b      	andne	r3, r1
        p_reg->EPOUTEN &= ~(1UL << epnr);
   22cdc:	400b      	andeq	r3, r1
        p_reg->EPINEN &= ~(1UL << epnr);
   22cde:	bf15      	itete	ne
   22ce0:	f8c2 3510 	strne.w	r3, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   22ce4:	f8c2 3514 	streq.w	r3, [r2, #1300]	; 0x514
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22ce8:	4b05      	ldrne	r3, [pc, #20]	; (22d00 <nrfx_usbd_ep_disable+0x48>)
   22cea:	4b06      	ldreq	r3, [pc, #24]	; (22d04 <nrfx_usbd_ep_disable+0x4c>)
   22cec:	5c1a      	ldrb	r2, [r3, r0]
   22cee:	2301      	movs	r3, #1
   22cf0:	4093      	lsls	r3, r2
    p_reg->INTENCLR = mask;
   22cf2:	4a02      	ldr	r2, [pc, #8]	; (22cfc <nrfx_usbd_ep_disable+0x44>)
   22cf4:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
   22cf8:	bd10      	pop	{r4, pc}
   22cfa:	bf00      	nop
   22cfc:	40036000 	.word	0x40036000
   22d00:	00026b6f 	.word	0x00026b6f
   22d04:	00026b66 	.word	0x00026b66

00022d08 <nrfx_usbd_ep_enable>:
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22d08:	f010 0f80 	tst.w	r0, #128	; 0x80
{
   22d0c:	b570      	push	{r4, r5, r6, lr}
   22d0e:	4924      	ldr	r1, [pc, #144]	; (22da0 <nrfx_usbd_ep_enable+0x98>)
   22d10:	4604      	mov	r4, r0
   22d12:	f04f 0501 	mov.w	r5, #1
   22d16:	f000 030f 	and.w	r3, r0, #15
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22d1a:	d012      	beq.n	22d42 <nrfx_usbd_ep_enable+0x3a>
   22d1c:	4a21      	ldr	r2, [pc, #132]	; (22da4 <nrfx_usbd_ep_enable+0x9c>)
   22d1e:	5cd2      	ldrb	r2, [r2, r3]
   22d20:	fa05 f202 	lsl.w	r2, r5, r2
    p_reg->INTENSET = mask;
   22d24:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
        return 0 != (p_reg->EPINEN & (1UL << epnr));
   22d28:	f8d1 2510 	ldr.w	r2, [r1, #1296]	; 0x510
   22d2c:	40da      	lsrs	r2, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   22d2e:	07d0      	lsls	r0, r2, #31
   22d30:	d406      	bmi.n	22d40 <nrfx_usbd_ep_enable+0x38>
        p_reg->EPINEN |= 1UL << epnr;
   22d32:	f8d1 2510 	ldr.w	r2, [r1, #1296]	; 0x510
   22d36:	fa05 f303 	lsl.w	r3, r5, r3
   22d3a:	4313      	orrs	r3, r2
   22d3c:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
}
   22d40:	bd70      	pop	{r4, r5, r6, pc}
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22d42:	4a19      	ldr	r2, [pc, #100]	; (22da8 <nrfx_usbd_ep_enable+0xa0>)
   22d44:	5cd2      	ldrb	r2, [r2, r3]
   22d46:	fa05 f202 	lsl.w	r2, r5, r2
    p_reg->INTENSET = mask;
   22d4a:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
        return 0 != (p_reg->EPOUTEN & (1UL << epnr));
   22d4e:	f8d1 2514 	ldr.w	r2, [r1, #1300]	; 0x514
   22d52:	40da      	lsrs	r2, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   22d54:	07d2      	lsls	r2, r2, #31
   22d56:	d4f3      	bmi.n	22d40 <nrfx_usbd_ep_enable+0x38>
        p_reg->EPOUTEN |= 1UL << epnr;
   22d58:	f8d1 6514 	ldr.w	r6, [r1, #1300]	; 0x514
   22d5c:	fa05 f203 	lsl.w	r2, r5, r3
   22d60:	4332      	orrs	r2, r6
   22d62:	f8c1 2514 	str.w	r2, [r1, #1300]	; 0x514
    if ((NRF_USBD_EP_NR_GET(ep) != 0) &&
   22d66:	2b00      	cmp	r3, #0
   22d68:	d0ea      	beq.n	22d40 <nrfx_usbd_ep_enable+0x38>
        NRF_USBD_EPOUT_CHECK(ep) &&
   22d6a:	0703      	lsls	r3, r0, #28
   22d6c:	d4e8      	bmi.n	22d40 <nrfx_usbd_ep_enable+0x38>
	__asm__ volatile(
   22d6e:	f04f 0320 	mov.w	r3, #32
   22d72:	f3ef 8611 	mrs	r6, BASEPRI
   22d76:	f383 8812 	msr	BASEPRI_MAX, r3
   22d7a:	f3bf 8f6f 	isb	sy
        nrfx_usbd_transfer_out_drop(ep);
   22d7e:	f7ff fe2b 	bl	229d8 <nrfx_usbd_transfer_out_drop>
        m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22d82:	4620      	mov	r0, r4
   22d84:	f002 fe52 	bl	25a2c <ep2bit>
   22d88:	4a08      	ldr	r2, [pc, #32]	; (22dac <nrfx_usbd_ep_enable+0xa4>)
   22d8a:	fa05 f000 	lsl.w	r0, r5, r0
   22d8e:	6813      	ldr	r3, [r2, #0]
   22d90:	ea23 0300 	bic.w	r3, r3, r0
   22d94:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   22d96:	f386 8811 	msr	BASEPRI, r6
   22d9a:	f3bf 8f6f 	isb	sy
}
   22d9e:	e7cf      	b.n	22d40 <nrfx_usbd_ep_enable+0x38>
   22da0:	40036000 	.word	0x40036000
   22da4:	00026b6f 	.word	0x00026b6f
   22da8:	00026b66 	.word	0x00026b66
   22dac:	2000b5a4 	.word	0x2000b5a4

00022db0 <nrfx_usbd_ep_stall_clear>:
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   22db0:	0603      	lsls	r3, r0, #24
{
   22db2:	b510      	push	{r4, lr}
   22db4:	4604      	mov	r4, r0
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   22db6:	d405      	bmi.n	22dc4 <nrfx_usbd_ep_stall_clear+0x14>
   22db8:	f7ff fd78 	bl	228ac <nrfx_usbd_ep_stall_check>
   22dbc:	b110      	cbz	r0, 22dc4 <nrfx_usbd_ep_stall_clear+0x14>
        nrfx_usbd_transfer_out_drop(ep);
   22dbe:	4620      	mov	r0, r4
   22dc0:	f7ff fe0a 	bl	229d8 <nrfx_usbd_transfer_out_drop>
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_UnStall << USBD_EPSTALL_STALL_Pos) | ep;
   22dc4:	4b01      	ldr	r3, [pc, #4]	; (22dcc <nrfx_usbd_ep_stall_clear+0x1c>)
   22dc6:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
}
   22dca:	bd10      	pop	{r4, pc}
   22dcc:	40036000 	.word	0x40036000

00022dd0 <nrfx_usbreg_enable>:
    p_reg->INTENSET = mask;
   22dd0:	2207      	movs	r2, #7
   22dd2:	4b02      	ldr	r3, [pc, #8]	; (22ddc <nrfx_usbreg_enable+0xc>)
   22dd4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
void nrfx_usbreg_enable(void)
{
    nrf_usbreg_int_enable(NRF_USBREGULATOR, NRF_USBREG_INT_USBDETECTED |
                                            NRF_USBREG_INT_USBREMOVED  |
                                            NRF_USBREG_INT_USBPWRRDY);
}
   22dd8:	4770      	bx	lr
   22dda:	bf00      	nop
   22ddc:	40037000 	.word	0x40037000

00022de0 <nrfx_usbreg_disable>:
    p_reg->INTENCLR = mask;
   22de0:	2207      	movs	r2, #7
   22de2:	4b02      	ldr	r3, [pc, #8]	; (22dec <nrfx_usbreg_disable+0xc>)
   22de4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
void nrfx_usbreg_disable(void)
{
    nrf_usbreg_int_disable(NRF_USBREGULATOR, NRF_USBREG_INT_USBDETECTED |
                                             NRF_USBREG_INT_USBREMOVED  |
                                             NRF_USBREG_INT_USBPWRRDY);
}
   22de8:	4770      	bx	lr
   22dea:	bf00      	nop
   22dec:	40037000 	.word	0x40037000

00022df0 <nrfx_usbreg_uninit>:
   22df0:	2207      	movs	r2, #7

void nrfx_usbreg_uninit(void)
{
   22df2:	b508      	push	{r3, lr}
   22df4:	4b04      	ldr	r3, [pc, #16]	; (22e08 <nrfx_usbreg_uninit+0x18>)
    nrfx_usbreg_disable();
    NRFX_IRQ_DISABLE(nrfx_get_irq_number(NRF_USBREGULATOR));
   22df6:	2037      	movs	r0, #55	; 0x37
   22df8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   22dfc:	f7fb fa8a 	bl	1e314 <arch_irq_disable>
    m_usbevt_handler = NULL;
   22e00:	2200      	movs	r2, #0
   22e02:	4b02      	ldr	r3, [pc, #8]	; (22e0c <nrfx_usbreg_uninit+0x1c>)
   22e04:	601a      	str	r2, [r3, #0]
}
   22e06:	bd08      	pop	{r3, pc}
   22e08:	40037000 	.word	0x40037000
   22e0c:	2000b5b0 	.word	0x2000b5b0

00022e10 <nrfx_usbreg_init>:
{
   22e10:	b510      	push	{r4, lr}
   22e12:	4604      	mov	r4, r0
    nrfx_usbreg_uninit();
   22e14:	f7ff ffec 	bl	22df0 <nrfx_usbreg_uninit>
    m_usbevt_handler = p_config->handler;
   22e18:	6822      	ldr	r2, [r4, #0]
   22e1a:	4b07      	ldr	r3, [pc, #28]	; (22e38 <nrfx_usbreg_init+0x28>)
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_USBREGULATOR));
   22e1c:	2037      	movs	r0, #55	; 0x37
    m_usbevt_handler = p_config->handler;
   22e1e:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e20:	2200      	movs	r2, #0
   22e22:	4b06      	ldr	r3, [pc, #24]	; (22e3c <nrfx_usbreg_init+0x2c>)
   22e24:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   22e28:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   22e2c:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
   22e30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_USBREGULATOR));
   22e34:	f7fb ba60 	b.w	1e2f8 <arch_irq_enable>
   22e38:	2000b5b0 	.word	0x2000b5b0
   22e3c:	40037000 	.word	0x40037000

00022e40 <nrfx_usbreg_irq_handler>:

void nrfx_usbreg_irq_handler(void)
{
   22e40:	b510      	push	{r4, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e42:	4c11      	ldr	r4, [pc, #68]	; (22e88 <nrfx_usbreg_irq_handler+0x48>)
   22e44:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    if (nrf_usbreg_event_check(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBDETECTED))
   22e48:	b12b      	cbz	r3, 22e56 <nrfx_usbreg_irq_handler+0x16>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e4a:	2000      	movs	r0, #0
    {
        nrf_usbreg_event_clear(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBDETECTED);
        m_usbevt_handler(NRFX_USBREG_EVT_DETECTED);
   22e4c:	4b0f      	ldr	r3, [pc, #60]	; (22e8c <nrfx_usbreg_irq_handler+0x4c>)
   22e4e:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
   22e52:	681b      	ldr	r3, [r3, #0]
   22e54:	4798      	blx	r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e56:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    }
    if (nrf_usbreg_event_check(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBREMOVED))
   22e5a:	b133      	cbz	r3, 22e6a <nrfx_usbreg_irq_handler+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e5c:	2300      	movs	r3, #0
   22e5e:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
    {
        nrf_usbreg_event_clear(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBREMOVED);
        m_usbevt_handler(NRFX_USBREG_EVT_REMOVED);
   22e62:	4b0a      	ldr	r3, [pc, #40]	; (22e8c <nrfx_usbreg_irq_handler+0x4c>)
   22e64:	2001      	movs	r0, #1
   22e66:	681b      	ldr	r3, [r3, #0]
   22e68:	4798      	blx	r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e6a:	4b07      	ldr	r3, [pc, #28]	; (22e88 <nrfx_usbreg_irq_handler+0x48>)
   22e6c:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    }
    if (nrf_usbreg_event_check(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBPWRRDY))
   22e70:	b142      	cbz	r2, 22e84 <nrfx_usbreg_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e72:	2200      	movs	r2, #0
   22e74:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    {
        nrf_usbreg_event_clear(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBPWRRDY);
        m_usbevt_handler(NRFX_USBREG_EVT_READY);
   22e78:	4b04      	ldr	r3, [pc, #16]	; (22e8c <nrfx_usbreg_irq_handler+0x4c>)
   22e7a:	2002      	movs	r0, #2
    }
}
   22e7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_usbevt_handler(NRFX_USBREG_EVT_READY);
   22e80:	681b      	ldr	r3, [r3, #0]
   22e82:	4718      	bx	r3
}
   22e84:	bd10      	pop	{r4, pc}
   22e86:	bf00      	nop
   22e88:	40037000 	.word	0x40037000
   22e8c:	2000b5b0 	.word	0x2000b5b0

00022e90 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
   22e90:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
   22e92:	f003 021f 	and.w	r2, r3, #31
   22e96:	6002      	str	r2, [r0, #0]
}
   22e98:	4a03      	ldr	r2, [pc, #12]	; (22ea8 <nrf_gpio_pin_port_decode+0x18>)
   22e9a:	4804      	ldr	r0, [pc, #16]	; (22eac <nrf_gpio_pin_port_decode+0x1c>)
    return pin_number >> 5;
   22e9c:	095b      	lsrs	r3, r3, #5
}
   22e9e:	2b01      	cmp	r3, #1
   22ea0:	bf18      	it	ne
   22ea2:	4610      	movne	r0, r2
   22ea4:	4770      	bx	lr
   22ea6:	bf00      	nop
   22ea8:	40842500 	.word	0x40842500
   22eac:	40842800 	.word	0x40842800

00022eb0 <nrfx_twi_twim_bus_recover>:
                                                  NRF_GPIO_PIN_PULLUP,        \
                                                  NRF_GPIO_PIN_S0D1,          \
                                                  NRF_GPIO_PIN_NOSENSE)

nrfx_err_t nrfx_twi_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
   22eb0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   22eb2:	4606      	mov	r6, r0
    nrf_gpio_pin_set(scl_pin);
   22eb4:	f002 fe0d 	bl	25ad2 <nrf_gpio_pin_set>
    nrf_gpio_pin_set(sda_pin);
   22eb8:	4608      	mov	r0, r1
   22eba:	f002 fe0a 	bl	25ad2 <nrf_gpio_pin_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22ebe:	a801      	add	r0, sp, #4
   22ec0:	9601      	str	r6, [sp, #4]
   22ec2:	f7ff ffe5 	bl	22e90 <nrf_gpio_pin_port_decode>
{
   22ec6:	460c      	mov	r4, r1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   22ec8:	f240 610d 	movw	r1, #1549	; 0x60d
   22ecc:	9b01      	ldr	r3, [sp, #4]
   22ece:	9401      	str	r4, [sp, #4]
   22ed0:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   22ed4:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200

    TWI_TWIM_PIN_CONFIGURE(scl_pin);
    TWI_TWIM_PIN_CONFIGURE(sda_pin);
    NRFX_DELAY_US(4);
   22ed8:	2509      	movs	r5, #9
   22eda:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   22ede:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
   22ee0:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22ee4:	a801      	add	r0, sp, #4
   22ee6:	f7ff ffd3 	bl	22e90 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   22eea:	9b01      	ldr	r3, [sp, #4]
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22eec:	2701      	movs	r7, #1
   22eee:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   22ef2:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   22ef6:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   22efa:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
   22efc:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
   22f00:	2004      	movs	r0, #4
   22f02:	f002 fc96 	bl	25832 <nrfx_busy_wait>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22f06:	a801      	add	r0, sp, #4
   22f08:	9401      	str	r4, [sp, #4]
   22f0a:	f7ff ffc1 	bl	22e90 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22f0e:	9a01      	ldr	r2, [sp, #4]
    return p_reg->IN;
   22f10:	6903      	ldr	r3, [r0, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22f12:	40d3      	lsrs	r3, r2

    for (uint8_t i = 0; i < 9; i++)
    {
        if (nrf_gpio_pin_read(sda_pin))
   22f14:	07db      	lsls	r3, r3, #31
   22f16:	d414      	bmi.n	22f42 <nrfx_twi_twim_bus_recover+0x92>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22f18:	a801      	add	r0, sp, #4
   22f1a:	9601      	str	r6, [sp, #4]
   22f1c:	f7ff ffb8 	bl	22e90 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22f20:	9b01      	ldr	r3, [sp, #4]
    for (uint8_t i = 0; i < 9; i++)
   22f22:	3d01      	subs	r5, #1
   22f24:	fa07 f303 	lsl.w	r3, r7, r3
    p_reg->OUTCLR = clr_mask;
   22f28:	60c3      	str	r3, [r0, #12]
        }
        else
        {
            // Pulse CLOCK signal
            nrf_gpio_pin_clear(scl_pin);
            NRFX_DELAY_US(4);
   22f2a:	2004      	movs	r0, #4
   22f2c:	f002 fc81 	bl	25832 <nrfx_busy_wait>
            nrf_gpio_pin_set(scl_pin);
   22f30:	4630      	mov	r0, r6
   22f32:	f002 fdce 	bl	25ad2 <nrf_gpio_pin_set>
            NRFX_DELAY_US(4);
   22f36:	2004      	movs	r0, #4
   22f38:	f002 fc7b 	bl	25832 <nrfx_busy_wait>
    for (uint8_t i = 0; i < 9; i++)
   22f3c:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   22f40:	d1e1      	bne.n	22f06 <nrfx_twi_twim_bus_recover+0x56>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22f42:	a801      	add	r0, sp, #4
   22f44:	9401      	str	r4, [sp, #4]
   22f46:	f7ff ffa3 	bl	22e90 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22f4a:	2301      	movs	r3, #1
   22f4c:	9a01      	ldr	r2, [sp, #4]
   22f4e:	4093      	lsls	r3, r2
    p_reg->OUTCLR = clr_mask;
   22f50:	60c3      	str	r3, [r0, #12]
        }
    }

    // Generate a STOP condition on the bus
    nrf_gpio_pin_clear(sda_pin);
    NRFX_DELAY_US(4);
   22f52:	2004      	movs	r0, #4
   22f54:	f002 fc6d 	bl	25832 <nrfx_busy_wait>
    nrf_gpio_pin_set(sda_pin);
   22f58:	4620      	mov	r0, r4
   22f5a:	f002 fdba 	bl	25ad2 <nrf_gpio_pin_set>
    NRFX_DELAY_US(4);
   22f5e:	2004      	movs	r0, #4
   22f60:	f002 fc67 	bl	25832 <nrfx_busy_wait>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22f64:	a801      	add	r0, sp, #4
   22f66:	9401      	str	r4, [sp, #4]
   22f68:	f7ff ff92 	bl	22e90 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22f6c:	9a01      	ldr	r2, [sp, #4]
    return p_reg->IN;
   22f6e:	6903      	ldr	r3, [r0, #16]
    }
    else
    {
        return NRFX_ERROR_INTERNAL;
    }
}
   22f70:	4803      	ldr	r0, [pc, #12]	; (22f80 <nrfx_twi_twim_bus_recover+0xd0>)
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22f72:	40d3      	lsrs	r3, r2
   22f74:	f003 0301 	and.w	r3, r3, #1
   22f78:	1ac0      	subs	r0, r0, r3
   22f7a:	b003      	add	sp, #12
   22f7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22f7e:	bf00      	nop
   22f80:	0bad0001 	.word	0x0bad0001

00022f84 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   22f84:	4b10      	ldr	r3, [pc, #64]	; (22fc8 <z_sys_init_run_level+0x44>)
{
   22f86:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   22f88:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   22f8c:	3001      	adds	r0, #1
   22f8e:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   22f92:	42a6      	cmp	r6, r4
   22f94:	d800      	bhi.n	22f98 <z_sys_init_run_level+0x14>
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
   22f96:	bd70      	pop	{r4, r5, r6, pc}
			int rc = entry->init_fn.dev(dev);
   22f98:	e9d4 3500 	ldrd	r3, r5, [r4]
		if (dev != NULL) {
   22f9c:	b18d      	cbz	r5, 22fc2 <z_sys_init_run_level+0x3e>
			int rc = entry->init_fn.dev(dev);
   22f9e:	4628      	mov	r0, r5
   22fa0:	4798      	blx	r3
			if (rc != 0) {
   22fa2:	b138      	cbz	r0, 22fb4 <z_sys_init_run_level+0x30>
				if (rc < 0) {
   22fa4:	2800      	cmp	r0, #0
   22fa6:	bfb8      	it	lt
   22fa8:	4240      	neglt	r0, r0
				if (rc > UINT8_MAX) {
   22faa:	28ff      	cmp	r0, #255	; 0xff
   22fac:	bfa8      	it	ge
   22fae:	20ff      	movge	r0, #255	; 0xff
				dev->state->init_res = rc;
   22fb0:	68eb      	ldr	r3, [r5, #12]
   22fb2:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   22fb4:	68ea      	ldr	r2, [r5, #12]
   22fb6:	7853      	ldrb	r3, [r2, #1]
   22fb8:	f043 0301 	orr.w	r3, r3, #1
   22fbc:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   22fbe:	3408      	adds	r4, #8
   22fc0:	e7e7      	b.n	22f92 <z_sys_init_run_level+0xe>
			(void)entry->init_fn.sys();
   22fc2:	4798      	blx	r3
   22fc4:	e7fb      	b.n	22fbe <z_sys_init_run_level+0x3a>
   22fc6:	bf00      	nop
   22fc8:	00026998 	.word	0x00026998

00022fcc <bg_thread_main>:
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
   22fcc:	2201      	movs	r2, #1
{
   22fce:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   22fd0:	4b09      	ldr	r3, [pc, #36]	; (22ff8 <bg_thread_main+0x2c>)

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
   22fd2:	2003      	movs	r0, #3
	z_sys_post_kernel = true;
   22fd4:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
   22fd6:	f7ff ffd5 	bl	22f84 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
   22fda:	f001 fa05 	bl	243e8 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
   22fde:	2004      	movs	r0, #4
   22fe0:	f7ff ffd0 	bl	22f84 <z_sys_init_run_level>

	z_init_static_threads();
   22fe4:	f000 f956 	bl	23294 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
   22fe8:	f7f9 fa1c 	bl	1c424 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   22fec:	4a03      	ldr	r2, [pc, #12]	; (22ffc <bg_thread_main+0x30>)
   22fee:	7b13      	ldrb	r3, [r2, #12]
   22ff0:	f023 0301 	bic.w	r3, r3, #1
   22ff4:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   22ff6:	bd08      	pop	{r3, pc}
   22ff8:	2000b62b 	.word	0x2000b62b
   22ffc:	2000a5f0 	.word	0x2000a5f0

00023000 <z_bss_zero>:
{
   23000:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
   23002:	4803      	ldr	r0, [pc, #12]	; (23010 <z_bss_zero+0x10>)
   23004:	4a03      	ldr	r2, [pc, #12]	; (23014 <z_bss_zero+0x14>)
   23006:	2100      	movs	r1, #0
   23008:	1a12      	subs	r2, r2, r0
   2300a:	f002 fd95 	bl	25b38 <z_early_memset>
}
   2300e:	bd08      	pop	{r3, pc}
   23010:	2000a410 	.word	0x2000a410
   23014:	2000b630 	.word	0x2000b630

00023018 <z_init_cpu>:

#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   23018:	2300      	movs	r3, #0
   2301a:	2201      	movs	r2, #1
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
   2301c:	b570      	push	{r4, r5, r6, lr}
   2301e:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   23020:	e9cd 2304 	strd	r2, r3, [sp, #16]
   23024:	220f      	movs	r2, #15
   23026:	9301      	str	r3, [sp, #4]
   23028:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   2302c:	2314      	movs	r3, #20
	z_setup_new_thread(thread, stack,
   2302e:	f44f 72a0 	mov.w	r2, #320	; 0x140
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   23032:	4d0e      	ldr	r5, [pc, #56]	; (2306c <z_init_cpu+0x54>)
	struct k_thread *thread = &z_idle_threads[i];
   23034:	4e0e      	ldr	r6, [pc, #56]	; (23070 <z_init_cpu+0x58>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   23036:	fb03 5500 	mla	r5, r3, r0, r5
	z_setup_new_thread(thread, stack,
   2303a:	490e      	ldr	r1, [pc, #56]	; (23074 <z_init_cpu+0x5c>)
	struct k_thread *thread = &z_idle_threads[i];
   2303c:	eb06 16c0 	add.w	r6, r6, r0, lsl #7
{
   23040:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
   23042:	fb02 1100 	mla	r1, r2, r0, r1
   23046:	4b0c      	ldr	r3, [pc, #48]	; (23078 <z_init_cpu+0x60>)
   23048:	4630      	mov	r0, r6
   2304a:	9500      	str	r5, [sp, #0]
   2304c:	f000 f8c6 	bl	231dc <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   23050:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
   23052:	742c      	strb	r4, [r5, #16]
   23054:	f023 0304 	bic.w	r3, r3, #4
   23058:	7373      	strb	r3, [r6, #13]
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
   2305a:	4b08      	ldr	r3, [pc, #32]	; (2307c <z_init_cpu+0x64>)
   2305c:	3401      	adds	r4, #1
   2305e:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
   23062:	60ee      	str	r6, [r5, #12]
	_kernel.cpus[id].irq_stack =
   23064:	606b      	str	r3, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
   23066:	b006      	add	sp, #24
   23068:	bd70      	pop	{r4, r5, r6, pc}
   2306a:	bf00      	nop
   2306c:	2000b5b4 	.word	0x2000b5b4
   23070:	2000a570 	.word	0x2000a570
   23074:	2000c630 	.word	0x2000c630
   23078:	0002334d 	.word	0x0002334d
   2307c:	2000be30 	.word	0x2000be30

00023080 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
   23080:	b580      	push	{r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
   23082:	2000      	movs	r0, #0
{
   23084:	b0a6      	sub	sp, #152	; 0x98
	z_sys_init_run_level(INIT_LEVEL_EARLY);
   23086:	f7ff ff7d 	bl	22f84 <z_sys_init_run_level>
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   2308a:	4b2d      	ldr	r3, [pc, #180]	; (23140 <z_cstart+0xc0>)
	uint32_t msp =
   2308c:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   23090:	f382 8808 	msr	MSP, r2
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   23094:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   23098:	2400      	movs	r4, #0
   2309a:	23e0      	movs	r3, #224	; 0xe0
   2309c:	4d29      	ldr	r5, [pc, #164]	; (23144 <z_cstart+0xc4>)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
   2309e:	4e2a      	ldr	r6, [pc, #168]	; (23148 <z_cstart+0xc8>)
   230a0:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   230a4:	77ec      	strb	r4, [r5, #31]
   230a6:	762c      	strb	r4, [r5, #24]
   230a8:	766c      	strb	r4, [r5, #25]
   230aa:	76ac      	strb	r4, [r5, #26]
   230ac:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   230b0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   230b2:	4f26      	ldr	r7, [pc, #152]	; (2314c <z_cstart+0xcc>)
   230b4:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   230b8:	626b      	str	r3, [r5, #36]	; 0x24
   230ba:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   230be:	f7fb fb6d 	bl	1e79c <z_arm_fault_init>
	z_arm_cpu_idle_init();
   230c2:	f7fb f8ed 	bl	1e2a0 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   230c6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   230ca:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   230cc:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   230ce:	f7fb fd6f 	bl	1ebb0 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   230d2:	f7fb fc15 	bl	1e900 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   230d6:	f240 1301 	movw	r3, #257	; 0x101
   230da:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   230de:	ab06      	add	r3, sp, #24
   230e0:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   230e2:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	dummy_thread->resource_pool = NULL;
   230e6:	9422      	str	r4, [sp, #136]	; 0x88
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   230e8:	f002 fcff 	bl	25aea <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
   230ec:	2001      	movs	r0, #1
   230ee:	f7ff ff49 	bl	22f84 <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
   230f2:	2002      	movs	r0, #2
	_kernel.ready_q.cache = &z_main_thread;
   230f4:	4d16      	ldr	r5, [pc, #88]	; (23150 <z_cstart+0xd0>)
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
   230f6:	f7ff ff45 	bl	22f84 <z_sys_init_run_level>
	z_sched_init();
   230fa:	f000 fe23 	bl	23d44 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   230fe:	4b15      	ldr	r3, [pc, #84]	; (23154 <z_cstart+0xd4>)
	_kernel.ready_q.cache = &z_main_thread;
   23100:	61b5      	str	r5, [r6, #24]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   23102:	9305      	str	r3, [sp, #20]
   23104:	2301      	movs	r3, #1
   23106:	4914      	ldr	r1, [pc, #80]	; (23158 <z_cstart+0xd8>)
   23108:	f44f 6280 	mov.w	r2, #1024	; 0x400
   2310c:	e9cd 4303 	strd	r4, r3, [sp, #12]
   23110:	4628      	mov	r0, r5
   23112:	463b      	mov	r3, r7
   23114:	e9cd 4401 	strd	r4, r4, [sp, #4]
   23118:	9400      	str	r4, [sp, #0]
   2311a:	f000 f85f 	bl	231dc <z_setup_new_thread>
   2311e:	4606      	mov	r6, r0
   23120:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
   23122:	4628      	mov	r0, r5
   23124:	f022 0204 	bic.w	r2, r2, #4
   23128:	736a      	strb	r2, [r5, #13]
   2312a:	f002 fe93 	bl	25e54 <z_ready_thread>
	z_init_cpu(0);
   2312e:	4620      	mov	r0, r4
   23130:	f7ff ff72 	bl	23018 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   23134:	463a      	mov	r2, r7
   23136:	4631      	mov	r1, r6
   23138:	4628      	mov	r0, r5
   2313a:	f7fb f9bb 	bl	1e4b4 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   2313e:	bf00      	nop
   23140:	2000be30 	.word	0x2000be30
   23144:	e000ed00 	.word	0xe000ed00
   23148:	2000b5b4 	.word	0x2000b5b4
   2314c:	00022fcd 	.word	0x00022fcd
   23150:	2000a5f0 	.word	0x2000a5f0
   23154:	00026b82 	.word	0x00026b82
   23158:	2000c770 	.word	0x2000c770

0002315c <init_mem_slab_module>:
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
	int rc = 0;
   2315c:	2000      	movs	r0, #0
{
   2315e:	b538      	push	{r3, r4, r5, lr}

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   23160:	4c05      	ldr	r4, [pc, #20]	; (23178 <init_mem_slab_module+0x1c>)
   23162:	4d06      	ldr	r5, [pc, #24]	; (2317c <init_mem_slab_module+0x20>)
   23164:	42ac      	cmp	r4, r5
   23166:	d300      	bcc.n	2316a <init_mem_slab_module+0xe>
		z_object_init(slab);
	}

out:
	return rc;
}
   23168:	bd38      	pop	{r3, r4, r5, pc}
		rc = create_free_list(slab);
   2316a:	4620      	mov	r0, r4
   2316c:	f002 fce8 	bl	25b40 <create_free_list>
		if (rc < 0) {
   23170:	2800      	cmp	r0, #0
   23172:	dbf9      	blt.n	23168 <init_mem_slab_module+0xc>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   23174:	341c      	adds	r4, #28
   23176:	e7f5      	b.n	23164 <init_mem_slab_module+0x8>
   23178:	2000a2d8 	.word	0x2000a2d8
   2317c:	2000a2f4 	.word	0x2000a2f4

00023180 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   23180:	b573      	push	{r0, r1, r4, r5, r6, lr}
   23182:	460c      	mov	r4, r1
	__asm__ volatile(
   23184:	f04f 0520 	mov.w	r5, #32
   23188:	f3ef 8111 	mrs	r1, BASEPRI
   2318c:	f385 8812 	msr	BASEPRI_MAX, r5
   23190:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   23194:	6945      	ldr	r5, [r0, #20]
   23196:	b15d      	cbz	r5, 231b0 <k_mem_slab_alloc+0x30>
		/* take a free block */
		*mem = slab->free_list;
   23198:	6025      	str	r5, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   2319a:	682b      	ldr	r3, [r5, #0]
   2319c:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   2319e:	6983      	ldr	r3, [r0, #24]
   231a0:	3301      	adds	r3, #1
   231a2:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   231a4:	2000      	movs	r0, #0
	__asm__ volatile(
   231a6:	f381 8811 	msr	BASEPRI, r1
   231aa:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   231ae:	e011      	b.n	231d4 <k_mem_slab_alloc+0x54>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   231b0:	ea52 0603 	orrs.w	r6, r2, r3
   231b4:	d103      	bne.n	231be <k_mem_slab_alloc+0x3e>
		result = -ENOMEM;
   231b6:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   231ba:	6025      	str	r5, [r4, #0]
		result = -ENOMEM;
   231bc:	e7f3      	b.n	231a6 <k_mem_slab_alloc+0x26>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   231be:	e9cd 2300 	strd	r2, r3, [sp]
   231c2:	4602      	mov	r2, r0
   231c4:	3008      	adds	r0, #8
   231c6:	f000 fcc7 	bl	23b58 <z_pend_curr>
		if (result == 0) {
   231ca:	b918      	cbnz	r0, 231d4 <k_mem_slab_alloc+0x54>
			*mem = _current->base.swap_data;
   231cc:	4b02      	ldr	r3, [pc, #8]	; (231d8 <k_mem_slab_alloc+0x58>)
   231ce:	689b      	ldr	r3, [r3, #8]
   231d0:	695b      	ldr	r3, [r3, #20]
   231d2:	6023      	str	r3, [r4, #0]
}
   231d4:	b002      	add	sp, #8
   231d6:	bd70      	pop	{r4, r5, r6, pc}
   231d8:	2000b5b4 	.word	0x2000b5b4

000231dc <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   231dc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   231e0:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   231e2:	f100 0558 	add.w	r5, r0, #88	; 0x58
   231e6:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   231e8:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   231ea:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
   231ee:	2500      	movs	r5, #0
{
   231f0:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
   231f2:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   231f4:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   231f6:	e9c0 5506 	strd	r5, r5, [r0, #24]
   231fa:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   231fc:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   231fe:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   23200:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
   23204:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
   23208:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   2320a:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   2320c:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   2320e:	9202      	str	r2, [sp, #8]
   23210:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   23212:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   23216:	9201      	str	r2, [sp, #4]
   23218:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   2321a:	9200      	str	r2, [sp, #0]
   2321c:	4642      	mov	r2, r8
   2321e:	f7fb f92b 	bl	1e478 <arch_new_thread>
	if (!_current) {
   23222:	4b05      	ldr	r3, [pc, #20]	; (23238 <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   23224:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   23226:	689b      	ldr	r3, [r3, #8]
   23228:	b103      	cbz	r3, 2322c <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   2322a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
   2322c:	4640      	mov	r0, r8
   2322e:	6723      	str	r3, [r4, #112]	; 0x70
   23230:	b004      	add	sp, #16
   23232:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   23236:	bf00      	nop
   23238:	2000b5b4 	.word	0x2000b5b4

0002323c <z_impl_k_thread_create>:
{
   2323c:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2323e:	2500      	movs	r5, #0
{
   23240:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23242:	9505      	str	r5, [sp, #20]
   23244:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   23246:	e9dd 7612 	ldrd	r7, r6, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2324a:	9504      	str	r5, [sp, #16]
   2324c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   2324e:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23250:	9503      	str	r5, [sp, #12]
   23252:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   23254:	9502      	str	r5, [sp, #8]
   23256:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   23258:	9501      	str	r5, [sp, #4]
   2325a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   2325c:	9500      	str	r5, [sp, #0]
   2325e:	f7ff ffbd 	bl	231dc <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   23262:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
   23266:	bf08      	it	eq
   23268:	f1b7 3fff 	cmpeq.w	r7, #4294967295	; 0xffffffff
   2326c:	d005      	beq.n	2327a <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2326e:	ea56 0307 	orrs.w	r3, r6, r7
   23272:	d105      	bne.n	23280 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
   23274:	4620      	mov	r0, r4
   23276:	f000 fce5 	bl	23c44 <z_sched_start>
}
   2327a:	4620      	mov	r0, r4
   2327c:	b007      	add	sp, #28
   2327e:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   23280:	463a      	mov	r2, r7
   23282:	4633      	mov	r3, r6
   23284:	4902      	ldr	r1, [pc, #8]	; (23290 <z_impl_k_thread_create+0x54>)
   23286:	f104 0018 	add.w	r0, r4, #24
   2328a:	f000 fef1 	bl	24070 <z_add_timeout>
   2328e:	e7f4      	b.n	2327a <z_impl_k_thread_create+0x3e>
   23290:	00025edd 	.word	0x00025edd

00023294 <z_init_static_threads>:
{
   23294:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   23298:	4c29      	ldr	r4, [pc, #164]	; (23340 <z_init_static_threads+0xac>)
	_FOREACH_STATIC_THREAD(thread_data) {
   2329a:	4d2a      	ldr	r5, [pc, #168]	; (23344 <z_init_static_threads+0xb0>)
{
   2329c:	b087      	sub	sp, #28
   2329e:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
   232a0:	42ae      	cmp	r6, r5
   232a2:	f104 042c 	add.w	r4, r4, #44	; 0x2c
   232a6:	d30f      	bcc.n	232c8 <z_init_static_threads+0x34>
	k_sched_lock();
   232a8:	f000 fd1c 	bl	23ce4 <k_sched_lock>
   232ac:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   232b0:	f240 37e7 	movw	r7, #999	; 0x3e7
	_FOREACH_STATIC_THREAD(thread_data) {
   232b4:	4c22      	ldr	r4, [pc, #136]	; (23340 <z_init_static_threads+0xac>)
   232b6:	f8df 9090 	ldr.w	r9, [pc, #144]	; 23348 <z_init_static_threads+0xb4>
   232ba:	42ac      	cmp	r4, r5
   232bc:	d320      	bcc.n	23300 <z_init_static_threads+0x6c>
}
   232be:	b007      	add	sp, #28
   232c0:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   232c4:	f000 bd22 	b.w	23d0c <k_sched_unlock>
		z_setup_new_thread(
   232c8:	f854 3c04 	ldr.w	r3, [r4, #-4]
   232cc:	9305      	str	r3, [sp, #20]
   232ce:	f854 3c0c 	ldr.w	r3, [r4, #-12]
   232d2:	9304      	str	r3, [sp, #16]
   232d4:	f854 3c10 	ldr.w	r3, [r4, #-16]
   232d8:	9303      	str	r3, [sp, #12]
   232da:	f854 3c14 	ldr.w	r3, [r4, #-20]
   232de:	9302      	str	r3, [sp, #8]
   232e0:	f854 3c18 	ldr.w	r3, [r4, #-24]
   232e4:	9301      	str	r3, [sp, #4]
   232e6:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   232ea:	9300      	str	r3, [sp, #0]
   232ec:	e954 2309 	ldrd	r2, r3, [r4, #-36]	; 0x24
   232f0:	e954 010b 	ldrd	r0, r1, [r4, #-44]	; 0x2c
   232f4:	f7ff ff72 	bl	231dc <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   232f8:	f854 3c2c 	ldr.w	r3, [r4, #-44]
   232fc:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
   232fe:	e7ce      	b.n	2329e <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   23300:	6a63      	ldr	r3, [r4, #36]	; 0x24
   23302:	1c5a      	adds	r2, r3, #1
   23304:	d00d      	beq.n	23322 <z_init_static_threads+0x8e>
   23306:	2100      	movs	r1, #0
   23308:	4638      	mov	r0, r7
					    K_MSEC(thread_data->init_delay));
   2330a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   2330e:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   23312:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
   23316:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2331a:	d104      	bne.n	23326 <z_init_static_threads+0x92>
	z_sched_start(thread);
   2331c:	4640      	mov	r0, r8
   2331e:	f000 fc91 	bl	23c44 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   23322:	342c      	adds	r4, #44	; 0x2c
   23324:	e7c9      	b.n	232ba <z_init_static_threads+0x26>
   23326:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2332a:	2300      	movs	r3, #0
   2332c:	f7f8 ff12 	bl	1c154 <__aeabi_uldivmod>
   23330:	4602      	mov	r2, r0
   23332:	460b      	mov	r3, r1
   23334:	f108 0018 	add.w	r0, r8, #24
   23338:	4649      	mov	r1, r9
   2333a:	f000 fe99 	bl	24070 <z_add_timeout>
   2333e:	e7f0      	b.n	23322 <z_init_static_threads+0x8e>
   23340:	00026540 	.word	0x00026540
   23344:	00026540 	.word	0x00026540
   23348:	00025edd 	.word	0x00025edd

0002334c <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   2334c:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   2334e:	4c0b      	ldr	r4, [pc, #44]	; (2337c <idle+0x30>)
   23350:	4d0b      	ldr	r5, [pc, #44]	; (23380 <idle+0x34>)
	__asm__ volatile(
   23352:	f04f 0220 	mov.w	r2, #32
   23356:	f3ef 8311 	mrs	r3, BASEPRI
   2335a:	f382 8812 	msr	BASEPRI_MAX, r2
   2335e:	f3bf 8f6f 	isb	sy
   23362:	f002 fe52 	bl	2600a <z_get_next_timeout_expiry>
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   23366:	782b      	ldrb	r3, [r5, #0]
		_kernel.idle = z_get_next_timeout_expiry();
   23368:	6160      	str	r0, [r4, #20]
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   2336a:	b913      	cbnz	r3, 23372 <idle+0x26>
	arch_cpu_idle();
   2336c:	f7fa ff9e 	bl	1e2ac <arch_cpu_idle>
}
   23370:	e7ef      	b.n	23352 <idle+0x6>
   23372:	f7f9 fe3b 	bl	1cfec <pm_system_suspend>
   23376:	2800      	cmp	r0, #0
   23378:	d1eb      	bne.n	23352 <idle+0x6>
   2337a:	e7f7      	b.n	2336c <idle+0x20>
   2337c:	2000b5b4 	.word	0x2000b5b4
   23380:	2000b62b 	.word	0x2000b62b

00023384 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   23384:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   23388:	4604      	mov	r4, r0
   2338a:	4617      	mov	r7, r2
   2338c:	461e      	mov	r6, r3
   2338e:	f04f 0320 	mov.w	r3, #32
   23392:	f3ef 8811 	mrs	r8, BASEPRI
   23396:	f383 8812 	msr	BASEPRI_MAX, r3
   2339a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   2339e:	68c3      	ldr	r3, [r0, #12]
   233a0:	4a33      	ldr	r2, [pc, #204]	; (23470 <z_impl_k_mutex_lock+0xec>)
   233a2:	b17b      	cbz	r3, 233c4 <z_impl_k_mutex_lock+0x40>
   233a4:	6880      	ldr	r0, [r0, #8]
   233a6:	6891      	ldr	r1, [r2, #8]
   233a8:	4288      	cmp	r0, r1
   233aa:	d019      	beq.n	233e0 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   233ac:	ea57 0306 	orrs.w	r3, r7, r6
   233b0:	d118      	bne.n	233e4 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   233b2:	f388 8811 	msr	BASEPRI, r8
   233b6:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   233ba:	f06f 000f 	mvn.w	r0, #15
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   233be:	b002      	add	sp, #8
   233c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   233c4:	6891      	ldr	r1, [r2, #8]
   233c6:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   233ca:	3301      	adds	r3, #1
   233cc:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   233ce:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   233d0:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   233d2:	60a3      	str	r3, [r4, #8]
   233d4:	f388 8811 	msr	BASEPRI, r8
   233d8:	f3bf 8f6f 	isb	sy
		return 0;
   233dc:	2000      	movs	r0, #0
   233de:	e7ee      	b.n	233be <z_impl_k_mutex_lock+0x3a>
					_current->base.prio :
   233e0:	6921      	ldr	r1, [r4, #16]
   233e2:	e7f2      	b.n	233ca <z_impl_k_mutex_lock+0x46>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   233e4:	f991 100e 	ldrsb.w	r1, [r1, #14]
   233e8:	f990 300e 	ldrsb.w	r3, [r0, #14]
	return prio >= CONFIG_PRIORITY_CEILING;
}

static inline int z_get_new_prio_with_ceiling(int prio)
{
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
   233ec:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   233f0:	4299      	cmp	r1, r3
   233f2:	bfa8      	it	ge
   233f4:	4619      	movge	r1, r3
   233f6:	4291      	cmp	r1, r2
   233f8:	bfb8      	it	lt
   233fa:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   233fc:	428b      	cmp	r3, r1
   233fe:	dd2e      	ble.n	2345e <z_impl_k_mutex_lock+0xda>
		resched = adjust_owner_prio(mutex, new_prio);
   23400:	f002 fbef 	bl	25be2 <adjust_owner_prio.isra.0>
   23404:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   23406:	4622      	mov	r2, r4
   23408:	4641      	mov	r1, r8
   2340a:	e9cd 7600 	strd	r7, r6, [sp]
   2340e:	4819      	ldr	r0, [pc, #100]	; (23474 <z_impl_k_mutex_lock+0xf0>)
   23410:	f000 fba2 	bl	23b58 <z_pend_curr>
	if (got_mutex == 0) {
   23414:	2800      	cmp	r0, #0
   23416:	d0e1      	beq.n	233dc <z_impl_k_mutex_lock+0x58>
	__asm__ volatile(
   23418:	f04f 0320 	mov.w	r3, #32
   2341c:	f3ef 8611 	mrs	r6, BASEPRI
   23420:	f383 8812 	msr	BASEPRI_MAX, r3
   23424:	f3bf 8f6f 	isb	sy
	if (likely(mutex->owner != NULL)) {
   23428:	68a0      	ldr	r0, [r4, #8]
   2342a:	b1d0      	cbz	r0, 23462 <z_impl_k_mutex_lock+0xde>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   2342c:	6823      	ldr	r3, [r4, #0]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   2342e:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23430:	429c      	cmp	r4, r3
   23432:	d00a      	beq.n	2344a <z_impl_k_mutex_lock+0xc6>
   23434:	b14b      	cbz	r3, 2344a <z_impl_k_mutex_lock+0xc6>
   23436:	f993 300e 	ldrsb.w	r3, [r3, #14]
   2343a:	4299      	cmp	r1, r3
   2343c:	bfa8      	it	ge
   2343e:	4619      	movge	r1, r3
   23440:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   23444:	4299      	cmp	r1, r3
   23446:	bfb8      	it	lt
   23448:	4619      	movlt	r1, r3
		resched = adjust_owner_prio(mutex, new_prio) || resched;
   2344a:	f002 fbca 	bl	25be2 <adjust_owner_prio.isra.0>
   2344e:	b140      	cbz	r0, 23462 <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
   23450:	4631      	mov	r1, r6
   23452:	4808      	ldr	r0, [pc, #32]	; (23474 <z_impl_k_mutex_lock+0xf0>)
   23454:	f000 fbe4 	bl	23c20 <z_reschedule>
	return -EAGAIN;
   23458:	f06f 000a 	mvn.w	r0, #10
   2345c:	e7af      	b.n	233be <z_impl_k_mutex_lock+0x3a>
	bool resched = false;
   2345e:	2500      	movs	r5, #0
   23460:	e7d1      	b.n	23406 <z_impl_k_mutex_lock+0x82>
	if (resched) {
   23462:	2d00      	cmp	r5, #0
   23464:	d1f4      	bne.n	23450 <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   23466:	f386 8811 	msr	BASEPRI, r6
   2346a:	f3bf 8f6f 	isb	sy
   2346e:	e7f3      	b.n	23458 <z_impl_k_mutex_lock+0xd4>
   23470:	2000b5b4 	.word	0x2000b5b4
   23474:	2000b62c 	.word	0x2000b62c

00023478 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   23478:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   2347a:	6883      	ldr	r3, [r0, #8]
{
   2347c:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   2347e:	b36b      	cbz	r3, 234dc <z_impl_k_mutex_unlock+0x64>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   23480:	4a19      	ldr	r2, [pc, #100]	; (234e8 <z_impl_k_mutex_unlock+0x70>)
   23482:	6892      	ldr	r2, [r2, #8]
   23484:	4293      	cmp	r3, r2
   23486:	d12c      	bne.n	234e2 <z_impl_k_mutex_unlock+0x6a>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   23488:	68c3      	ldr	r3, [r0, #12]
   2348a:	2b01      	cmp	r3, #1
   2348c:	d903      	bls.n	23496 <z_impl_k_mutex_unlock+0x1e>
		mutex->lock_count--;
   2348e:	3b01      	subs	r3, #1
   23490:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
   23492:	2000      	movs	r0, #0
}
   23494:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   23496:	f04f 0320 	mov.w	r3, #32
   2349a:	f3ef 8511 	mrs	r5, BASEPRI
   2349e:	f383 8812 	msr	BASEPRI_MAX, r3
   234a2:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   234a6:	6901      	ldr	r1, [r0, #16]
   234a8:	6880      	ldr	r0, [r0, #8]
   234aa:	f002 fb9a 	bl	25be2 <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   234ae:	4620      	mov	r0, r4
   234b0:	f002 fd18 	bl	25ee4 <z_unpend_first_thread>
	mutex->owner = new_owner;
   234b4:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   234b6:	b158      	cbz	r0, 234d0 <z_impl_k_mutex_unlock+0x58>
		mutex->owner_orig_prio = new_owner->base.prio;
   234b8:	f990 200e 	ldrsb.w	r2, [r0, #14]
   234bc:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   234be:	2200      	movs	r2, #0
   234c0:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
   234c2:	f002 fcc7 	bl	25e54 <z_ready_thread>
		z_reschedule(&lock, key);
   234c6:	4629      	mov	r1, r5
   234c8:	4808      	ldr	r0, [pc, #32]	; (234ec <z_impl_k_mutex_unlock+0x74>)
   234ca:	f000 fba9 	bl	23c20 <z_reschedule>
   234ce:	e7e0      	b.n	23492 <z_impl_k_mutex_unlock+0x1a>
		mutex->lock_count = 0U;
   234d0:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   234d2:	f385 8811 	msr	BASEPRI, r5
   234d6:	f3bf 8f6f 	isb	sy
   234da:	e7da      	b.n	23492 <z_impl_k_mutex_unlock+0x1a>
		return -EINVAL;
   234dc:	f06f 0015 	mvn.w	r0, #21
   234e0:	e7d8      	b.n	23494 <z_impl_k_mutex_unlock+0x1c>
		return -EPERM;
   234e2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   234e6:	e7d5      	b.n	23494 <z_impl_k_mutex_unlock+0x1c>
   234e8:	2000b5b4 	.word	0x2000b5b4
   234ec:	2000b62c 	.word	0x2000b62c

000234f0 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   234f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   234f2:	4611      	mov	r1, r2
	__asm__ volatile(
   234f4:	f04f 0220 	mov.w	r2, #32
   234f8:	f3ef 8511 	mrs	r5, BASEPRI
   234fc:	f382 8812 	msr	BASEPRI_MAX, r2
   23500:	f3bf 8f6f 	isb	sy
   23504:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   23506:	b19c      	cbz	r4, 23530 <z_impl_k_queue_get+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   23508:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2350a:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2350c:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   23510:	4294      	cmp	r4, r2
	list->head = node;
   23512:	6003      	str	r3, [r0, #0]
	list->tail = node;
   23514:	bf08      	it	eq
   23516:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   23518:	2101      	movs	r1, #1
   2351a:	4620      	mov	r0, r4
   2351c:	f002 fbd2 	bl	25cc4 <z_queue_node_peek>
   23520:	4604      	mov	r4, r0
	__asm__ volatile(
   23522:	f385 8811 	msr	BASEPRI, r5
   23526:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   2352a:	4620      	mov	r0, r4
   2352c:	b003      	add	sp, #12
   2352e:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   23530:	ea51 0203 	orrs.w	r2, r1, r3
   23534:	d0f5      	beq.n	23522 <z_impl_k_queue_get+0x32>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   23536:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   2353a:	e9cd 1300 	strd	r1, r3, [sp]
   2353e:	4610      	mov	r0, r2
   23540:	4629      	mov	r1, r5
   23542:	f000 fb09 	bl	23b58 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   23546:	2800      	cmp	r0, #0
   23548:	d1ef      	bne.n	2352a <z_impl_k_queue_get+0x3a>
   2354a:	4b02      	ldr	r3, [pc, #8]	; (23554 <z_impl_k_queue_get+0x64>)
   2354c:	689b      	ldr	r3, [r3, #8]
   2354e:	695c      	ldr	r4, [r3, #20]
   23550:	e7eb      	b.n	2352a <z_impl_k_queue_get+0x3a>
   23552:	bf00      	nop
   23554:	2000b5b4 	.word	0x2000b5b4

00023558 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   23558:	b538      	push	{r3, r4, r5, lr}
   2355a:	4604      	mov	r4, r0
	__asm__ volatile(
   2355c:	f04f 0320 	mov.w	r3, #32
   23560:	f3ef 8511 	mrs	r5, BASEPRI
   23564:	f383 8812 	msr	BASEPRI_MAX, r3
   23568:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   2356c:	f002 fcba 	bl	25ee4 <z_unpend_first_thread>

	if (thread != NULL) {
   23570:	b148      	cbz	r0, 23586 <z_impl_k_sem_give+0x2e>
   23572:	2200      	movs	r2, #0
   23574:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   23576:	f002 fc6d 	bl	25e54 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   2357a:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   2357c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   23580:	4804      	ldr	r0, [pc, #16]	; (23594 <z_impl_k_sem_give+0x3c>)
   23582:	f000 bb4d 	b.w	23c20 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   23586:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   2358a:	429a      	cmp	r2, r3
   2358c:	bf18      	it	ne
   2358e:	3301      	addne	r3, #1
   23590:	60a3      	str	r3, [r4, #8]
}
   23592:	e7f2      	b.n	2357a <z_impl_k_sem_give+0x22>
   23594:	2000b62c 	.word	0x2000b62c

00023598 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   23598:	b513      	push	{r0, r1, r4, lr}
   2359a:	f04f 0420 	mov.w	r4, #32
   2359e:	f3ef 8111 	mrs	r1, BASEPRI
   235a2:	f384 8812 	msr	BASEPRI_MAX, r4
   235a6:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   235aa:	6884      	ldr	r4, [r0, #8]
   235ac:	b144      	cbz	r4, 235c0 <z_impl_k_sem_take+0x28>
		sem->count--;
   235ae:	3c01      	subs	r4, #1
   235b0:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
   235b2:	f381 8811 	msr	BASEPRI, r1
   235b6:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   235ba:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   235bc:	b002      	add	sp, #8
   235be:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   235c0:	ea52 0403 	orrs.w	r4, r2, r3
   235c4:	d106      	bne.n	235d4 <z_impl_k_sem_take+0x3c>
   235c6:	f381 8811 	msr	BASEPRI, r1
   235ca:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   235ce:	f06f 000f 	mvn.w	r0, #15
   235d2:	e7f3      	b.n	235bc <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   235d4:	e9cd 2300 	strd	r2, r3, [sp]
   235d8:	4602      	mov	r2, r0
   235da:	4802      	ldr	r0, [pc, #8]	; (235e4 <z_impl_k_sem_take+0x4c>)
   235dc:	f000 fabc 	bl	23b58 <z_pend_curr>
	return ret;
   235e0:	e7ec      	b.n	235bc <z_impl_k_sem_take+0x24>
   235e2:	bf00      	nop
   235e4:	2000b62c 	.word	0x2000b62c

000235e8 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
   235e8:	b570      	push	{r4, r5, r6, lr}
   235ea:	4604      	mov	r4, r0
	__asm__ volatile(
   235ec:	f04f 0320 	mov.w	r3, #32
   235f0:	f3ef 8511 	mrs	r5, BASEPRI
   235f4:	f383 8812 	msr	BASEPRI_MAX, r3
   235f8:	f3bf 8f6f 	isb	sy
   235fc:	f06f 060a 	mvn.w	r6, #10
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
   23600:	4620      	mov	r0, r4
   23602:	f002 fc6f 	bl	25ee4 <z_unpend_first_thread>
		if (thread == NULL) {
   23606:	b118      	cbz	r0, 23610 <z_impl_k_sem_reset+0x28>
   23608:	6786      	str	r6, [r0, #120]	; 0x78
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
   2360a:	f002 fc23 	bl	25e54 <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
   2360e:	e7f7      	b.n	23600 <z_impl_k_sem_reset+0x18>
	}
	sem->count = 0;
   23610:	60a0      	str	r0, [r4, #8]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
   23612:	4629      	mov	r1, r5
}
   23614:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   23618:	4801      	ldr	r0, [pc, #4]	; (23620 <z_impl_k_sem_reset+0x38>)
   2361a:	f000 bb01 	b.w	23c20 <z_reschedule>
   2361e:	bf00      	nop
   23620:	2000b62c 	.word	0x2000b62c

00023624 <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
   23624:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23628:	4604      	mov	r4, r0
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
   2362a:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   2362e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	return list->head;
   23632:	4e48      	ldr	r6, [pc, #288]	; (23754 <work_queue_main+0x130>)
{
   23634:	b085      	sub	sp, #20
   23636:	f04f 0320 	mov.w	r3, #32
   2363a:	f3ef 8711 	mrs	r7, BASEPRI
   2363e:	f383 8812 	msr	BASEPRI_MAX, r3
   23642:	f3bf 8f6f 	isb	sy
   23646:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
   2364a:	b98d      	cbnz	r5, 23670 <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
   2364c:	2102      	movs	r1, #2
   2364e:	f104 0098 	add.w	r0, r4, #152	; 0x98
   23652:	f002 fb5a 	bl	25d0a <flag_test_and_clear>
   23656:	2800      	cmp	r0, #0
   23658:	d143      	bne.n	236e2 <work_queue_main+0xbe>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
   2365a:	2300      	movs	r3, #0
   2365c:	4639      	mov	r1, r7
   2365e:	e9cd 8900 	strd	r8, r9, [sp]
   23662:	9302      	str	r3, [sp, #8]
   23664:	f104 0288 	add.w	r2, r4, #136	; 0x88
   23668:	483b      	ldr	r0, [pc, #236]	; (23758 <work_queue_main+0x134>)
   2366a:	f000 fc8f 	bl	23f8c <z_sched_wait>
			continue;
   2366e:	e7e2      	b.n	23636 <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   23670:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
   23674:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   23676:	4295      	cmp	r5, r2
	list->head = node;
   23678:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	list->tail = node;
   2367c:	bf08      	it	eq
   2367e:	f8c4 3084 	streq.w	r3, [r4, #132]	; 0x84
	*flagp |= BIT(bit);
   23682:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   23686:	f043 0302 	orr.w	r3, r3, #2
   2368a:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
   2368e:	68eb      	ldr	r3, [r5, #12]
   23690:	f023 0304 	bic.w	r3, r3, #4
   23694:	f043 0301 	orr.w	r3, r3, #1
   23698:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
   2369a:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
   2369c:	f387 8811 	msr	BASEPRI, r7
   236a0:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
		handler(work);
   236a4:	4628      	mov	r0, r5
   236a6:	4798      	blx	r3
	__asm__ volatile(
   236a8:	f04f 0320 	mov.w	r3, #32
   236ac:	f3ef 8b11 	mrs	fp, BASEPRI
   236b0:	f383 8812 	msr	BASEPRI_MAX, r3
   236b4:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
   236b8:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   236ba:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
   236bc:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   236c0:	d419      	bmi.n	236f6 <work_queue_main+0xd2>
	*flagp &= ~BIT(bit);
   236c2:	60ea      	str	r2, [r5, #12]
   236c4:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   236c8:	f023 0302 	bic.w	r3, r3, #2
   236cc:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	__asm__ volatile(
   236d0:	f38b 8811 	msr	BASEPRI, fp
   236d4:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
   236d8:	05db      	lsls	r3, r3, #23
   236da:	d4ac      	bmi.n	23636 <work_queue_main+0x12>
	z_impl_k_yield();
   236dc:	f000 fb3a 	bl	23d54 <z_impl_k_yield>
}
   236e0:	e7a9      	b.n	23636 <work_queue_main+0x12>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
   236e2:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
   236e6:	2200      	movs	r2, #0
   236e8:	2101      	movs	r1, #1
   236ea:	4628      	mov	r0, r5
   236ec:	f002 fc54 	bl	25f98 <z_sched_wake>
   236f0:	2800      	cmp	r0, #0
   236f2:	d1f8      	bne.n	236e6 <work_queue_main+0xc2>
   236f4:	e7b1      	b.n	2365a <work_queue_main+0x36>
	return list->head;
   236f6:	6830      	ldr	r0, [r6, #0]
	*flagp &= ~BIT(bit);
   236f8:	f023 0303 	bic.w	r3, r3, #3
   236fc:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   236fe:	2800      	cmp	r0, #0
   23700:	d0e0      	beq.n	236c4 <work_queue_main+0xa0>
	return node->next;
   23702:	2700      	movs	r7, #0
	parent->next = child;
   23704:	463b      	mov	r3, r7
	return node->next;
   23706:	f8d0 a000 	ldr.w	sl, [r0]
   2370a:	2800      	cmp	r0, #0
   2370c:	d0da      	beq.n	236c4 <work_queue_main+0xa0>
		if (wc->work == work) {
   2370e:	6842      	ldr	r2, [r0, #4]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
   23710:	4601      	mov	r1, r0
		if (wc->work == work) {
   23712:	4295      	cmp	r5, r2
   23714:	d10c      	bne.n	23730 <work_queue_main+0x10c>
   23716:	6801      	ldr	r1, [r0, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
   23718:	b99f      	cbnz	r7, 23742 <work_queue_main+0x11e>
   2371a:	6872      	ldr	r2, [r6, #4]
	list->head = node;
   2371c:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
   2371e:	4282      	cmp	r2, r0
   23720:	d100      	bne.n	23724 <work_queue_main+0x100>
	list->tail = node;
   23722:	6071      	str	r1, [r6, #4]
	parent->next = child;
   23724:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
   23728:	f7ff ff16 	bl	23558 <z_impl_k_sem_give>
}
   2372c:	4639      	mov	r1, r7
   2372e:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   23730:	f1ba 0f00 	cmp.w	sl, #0
   23734:	d00b      	beq.n	2374e <work_queue_main+0x12a>
	return node->next;
   23736:	f8da 2000 	ldr.w	r2, [sl]
   2373a:	4650      	mov	r0, sl
   2373c:	460f      	mov	r7, r1
   2373e:	4692      	mov	sl, r2
   23740:	e7e3      	b.n	2370a <work_queue_main+0xe6>
	parent->next = child;
   23742:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
   23744:	6872      	ldr	r2, [r6, #4]
   23746:	4282      	cmp	r2, r0
	list->tail = node;
   23748:	bf08      	it	eq
   2374a:	6077      	streq	r7, [r6, #4]
}
   2374c:	e7ea      	b.n	23724 <work_queue_main+0x100>
   2374e:	4652      	mov	r2, sl
   23750:	e7f3      	b.n	2373a <work_queue_main+0x116>
   23752:	bf00      	nop
   23754:	2000b5d8 	.word	0x2000b5d8
   23758:	2000b62c 	.word	0x2000b62c

0002375c <submit_to_queue_locked>:
{
   2375c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
   2375e:	68c3      	ldr	r3, [r0, #12]
{
   23760:	4604      	mov	r4, r0
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   23762:	079a      	lsls	r2, r3, #30
{
   23764:	460f      	mov	r7, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   23766:	f3c3 0640 	ubfx	r6, r3, #1, #1
   2376a:	d42c      	bmi.n	237c6 <submit_to_queue_locked+0x6a>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
   2376c:	075b      	lsls	r3, r3, #29
   2376e:	d41a      	bmi.n	237a6 <submit_to_queue_locked+0x4a>
		if (*queuep == NULL) {
   23770:	680b      	ldr	r3, [r1, #0]
   23772:	b90b      	cbnz	r3, 23778 <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
   23774:	6883      	ldr	r3, [r0, #8]
   23776:	600b      	str	r3, [r1, #0]
	return (*flagp & BIT(bit)) != 0U;
   23778:	68e3      	ldr	r3, [r4, #12]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
   2377a:	07dd      	lsls	r5, r3, #31
			*queuep = work->queue;
   2377c:	bf42      	ittt	mi
   2377e:	68a3      	ldrmi	r3, [r4, #8]
			ret = 2;
   23780:	2602      	movmi	r6, #2
			*queuep = work->queue;
   23782:	603b      	strmi	r3, [r7, #0]
		int rc = queue_submit_locked(*queuep, work);
   23784:	683d      	ldr	r5, [r7, #0]
		ret = 1;
   23786:	bf58      	it	pl
   23788:	2601      	movpl	r6, #1
	if (queue == NULL) {
   2378a:	2d00      	cmp	r5, #0
   2378c:	d03a      	beq.n	23804 <submit_to_queue_locked+0xa8>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   2378e:	4b1f      	ldr	r3, [pc, #124]	; (2380c <submit_to_queue_locked+0xb0>)
   23790:	689b      	ldr	r3, [r3, #8]
   23792:	42ab      	cmp	r3, r5
   23794:	d00a      	beq.n	237ac <submit_to_queue_locked+0x50>
	return (*flagp & BIT(bit)) != 0U;
   23796:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   2379a:	07d8      	lsls	r0, r3, #31
	return (*flagp & BIT(bit)) != 0U;
   2379c:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   237a0:	d414      	bmi.n	237cc <submit_to_queue_locked+0x70>
		ret = -EBUSY;
   237a2:	f06f 0612 	mvn.w	r6, #18
		*queuep = NULL;
   237a6:	2300      	movs	r3, #0
   237a8:	603b      	str	r3, [r7, #0]
	return ret;
   237aa:	e025      	b.n	237f8 <submit_to_queue_locked+0x9c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   237ac:	f002 fa07 	bl	25bbe <k_is_in_isr>
   237b0:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
   237b4:	2800      	cmp	r0, #0
   237b6:	d1f0      	bne.n	2379a <submit_to_queue_locked+0x3e>
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   237b8:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
   237ba:	f3c3 02c0 	ubfx	r2, r3, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   237be:	d5f0      	bpl.n	237a2 <submit_to_queue_locked+0x46>
	} else if (plugged && !draining) {
   237c0:	b152      	cbz	r2, 237d8 <submit_to_queue_locked+0x7c>
   237c2:	075b      	lsls	r3, r3, #29
   237c4:	d408      	bmi.n	237d8 <submit_to_queue_locked+0x7c>
		ret = -EBUSY;
   237c6:	f06f 060f 	mvn.w	r6, #15
   237ca:	e7ec      	b.n	237a6 <submit_to_queue_locked+0x4a>
	} else if (draining && !chained) {
   237cc:	2a00      	cmp	r2, #0
   237ce:	d1fa      	bne.n	237c6 <submit_to_queue_locked+0x6a>
	return (*flagp & BIT(bit)) != 0U;
   237d0:	f3c3 03c0 	ubfx	r3, r3, #3, #1
	} else if (plugged && !draining) {
   237d4:	2b00      	cmp	r3, #0
   237d6:	d1f6      	bne.n	237c6 <submit_to_queue_locked+0x6a>
	parent->next = child;
   237d8:	2300      	movs	r3, #0
   237da:	6023      	str	r3, [r4, #0]
	return list->tail;
   237dc:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
Z_GENLIST_APPEND(slist, snode)
   237e0:	b963      	cbnz	r3, 237fc <submit_to_queue_locked+0xa0>
	list->head = node;
   237e2:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
		(void)notify_queue_locked(queue);
   237e6:	4628      	mov	r0, r5
   237e8:	f002 fa9a 	bl	25d20 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
   237ec:	68e3      	ldr	r3, [r4, #12]
   237ee:	f043 0304 	orr.w	r3, r3, #4
   237f2:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
   237f4:	683b      	ldr	r3, [r7, #0]
   237f6:	60a3      	str	r3, [r4, #8]
}
   237f8:	4630      	mov	r0, r6
   237fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
   237fc:	601c      	str	r4, [r3, #0]
	list->tail = node;
   237fe:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
}
   23802:	e7f0      	b.n	237e6 <submit_to_queue_locked+0x8a>
		return -EINVAL;
   23804:	f06f 0615 	mvn.w	r6, #21
   23808:	e7cd      	b.n	237a6 <submit_to_queue_locked+0x4a>
   2380a:	bf00      	nop
   2380c:	2000b5b4 	.word	0x2000b5b4

00023810 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
   23810:	b5f0      	push	{r4, r5, r6, r7, lr}
   23812:	4604      	mov	r4, r0
	list->head = NULL;
   23814:	2000      	movs	r0, #0
   23816:	b089      	sub	sp, #36	; 0x24
	list->tail = NULL;
   23818:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
   2381c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   2381e:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = (sys_dnode_t *)list;
   23822:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
   23826:	f104 0090 	add.w	r0, r4, #144	; 0x90
   2382a:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
   2382e:	b31d      	cbz	r5, 23878 <k_work_queue_start+0x68>
   23830:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
   23832:	2800      	cmp	r0, #0
   23834:	f240 1001 	movw	r0, #257	; 0x101
   23838:	bf08      	it	eq
   2383a:	2001      	moveq	r0, #1
	*flagp = flags;
   2383c:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   23840:	2000      	movs	r0, #0
   23842:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   23846:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   2384a:	e9cd 3003 	strd	r3, r0, [sp, #12]
   2384e:	e9cd 0001 	strd	r0, r0, [sp, #4]
   23852:	e9cd 6706 	strd	r6, r7, [sp, #24]
   23856:	4620      	mov	r0, r4
   23858:	4b08      	ldr	r3, [pc, #32]	; (2387c <k_work_queue_start+0x6c>)
   2385a:	9400      	str	r4, [sp, #0]
   2385c:	f7ff fcee 	bl	2323c <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
   23860:	b125      	cbz	r5, 2386c <k_work_queue_start+0x5c>
   23862:	6829      	ldr	r1, [r5, #0]
   23864:	b111      	cbz	r1, 2386c <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
   23866:	4620      	mov	r0, r4
   23868:	f002 f9af 	bl	25bca <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
   2386c:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
   2386e:	b009      	add	sp, #36	; 0x24
   23870:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   23874:	f002 b9ac 	b.w	25bd0 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
   23878:	2001      	movs	r0, #1
   2387a:	e7df      	b.n	2383c <k_work_queue_start+0x2c>
   2387c:	00023625 	.word	0x00023625

00023880 <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
   23880:	b537      	push	{r0, r1, r2, r4, r5, lr}
   23882:	9001      	str	r0, [sp, #4]
   23884:	4608      	mov	r0, r1
	__asm__ volatile(
   23886:	f04f 0120 	mov.w	r1, #32
   2388a:	f3ef 8411 	mrs	r4, BASEPRI
   2388e:	f381 8812 	msr	BASEPRI_MAX, r1
   23892:	f3bf 8f6f 	isb	sy
	return *flagp;
   23896:	68c1      	ldr	r1, [r0, #12]
	struct k_work *work = &dwork->work;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
   23898:	f011 0f0e 	tst.w	r1, #14
   2389c:	d116      	bne.n	238cc <k_work_schedule_for_queue+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2389e:	ea53 0502 	orrs.w	r5, r3, r2
   238a2:	d108      	bne.n	238b6 <k_work_schedule_for_queue+0x36>
		return submit_to_queue_locked(work, queuep);
   238a4:	a901      	add	r1, sp, #4
   238a6:	f7ff ff59 	bl	2375c <submit_to_queue_locked>
	__asm__ volatile(
   238aa:	f384 8811 	msr	BASEPRI, r4
   238ae:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   238b2:	b003      	add	sp, #12
   238b4:	bd30      	pop	{r4, r5, pc}
	*flagp |= BIT(bit);
   238b6:	f041 0108 	orr.w	r1, r1, #8
   238ba:	60c1      	str	r1, [r0, #12]
	dwork->queue = *queuep;
   238bc:	9901      	ldr	r1, [sp, #4]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   238be:	3010      	adds	r0, #16
	dwork->queue = *queuep;
   238c0:	6181      	str	r1, [r0, #24]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   238c2:	4903      	ldr	r1, [pc, #12]	; (238d0 <k_work_schedule_for_queue+0x50>)
   238c4:	f000 fbd4 	bl	24070 <z_add_timeout>
	return ret;
   238c8:	2001      	movs	r0, #1
   238ca:	e7ee      	b.n	238aa <k_work_schedule_for_queue+0x2a>
	int ret = 0;
   238cc:	2000      	movs	r0, #0
   238ce:	e7ec      	b.n	238aa <k_work_schedule_for_queue+0x2a>
   238d0:	00025d2f 	.word	0x00025d2f

000238d4 <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
   238d4:	89c3      	ldrh	r3, [r0, #14]
   238d6:	2b7f      	cmp	r3, #127	; 0x7f
   238d8:	d812      	bhi.n	23900 <sliceable+0x2c>
	int ret = slice_ticks;
   238da:	4b0a      	ldr	r3, [pc, #40]	; (23904 <sliceable+0x30>)
   238dc:	681b      	ldr	r3, [r3, #0]
		&& slice_time(thread) != 0
   238de:	b163      	cbz	r3, 238fa <sliceable+0x26>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   238e0:	4b09      	ldr	r3, [pc, #36]	; (23908 <sliceable+0x34>)
   238e2:	f990 200e 	ldrsb.w	r2, [r0, #14]
   238e6:	681b      	ldr	r3, [r3, #0]
   238e8:	429a      	cmp	r2, r3
   238ea:	db09      	blt.n	23900 <sliceable+0x2c>
		&& !z_is_thread_prevented_from_running(thread)
   238ec:	7b43      	ldrb	r3, [r0, #13]
   238ee:	06db      	lsls	r3, r3, #27
   238f0:	d106      	bne.n	23900 <sliceable+0x2c>
		&& !z_is_idle_thread_object(thread);
   238f2:	4b06      	ldr	r3, [pc, #24]	; (2390c <sliceable+0x38>)
   238f4:	1ac3      	subs	r3, r0, r3
   238f6:	bf18      	it	ne
   238f8:	2301      	movne	r3, #1
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
   238fa:	f003 0001 	and.w	r0, r3, #1
   238fe:	4770      	bx	lr
		&& !z_is_idle_thread_object(thread);
   23900:	2300      	movs	r3, #0
   23902:	e7fa      	b.n	238fa <sliceable+0x26>
   23904:	2000b5e8 	.word	0x2000b5e8
   23908:	2000b5e4 	.word	0x2000b5e4
   2390c:	2000a570 	.word	0x2000a570

00023910 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);

	slice_expired[cpu] = true;
   23910:	2201      	movs	r2, #1
	int cpu = ARRAY_INDEX(slice_timeouts, t);
   23912:	4b04      	ldr	r3, [pc, #16]	; (23924 <slice_timeout+0x14>)
   23914:	1ac0      	subs	r0, r0, r3
   23916:	4b04      	ldr	r3, [pc, #16]	; (23928 <slice_timeout+0x18>)
   23918:	10c0      	asrs	r0, r0, #3
   2391a:	4358      	muls	r0, r3
	slice_expired[cpu] = true;
   2391c:	4b03      	ldr	r3, [pc, #12]	; (2392c <slice_timeout+0x1c>)
   2391e:	541a      	strb	r2, [r3, r0]
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
   23920:	4770      	bx	lr
   23922:	bf00      	nop
   23924:	2000a670 	.word	0x2000a670
   23928:	aaaaaaab 	.word	0xaaaaaaab
   2392c:	2000b62c 	.word	0x2000b62c

00023930 <z_reset_time_slice>:

void z_reset_time_slice(struct k_thread *curr)
{
   23930:	b570      	push	{r4, r5, r6, lr}
	int cpu = _current_cpu->id;
   23932:	4b0e      	ldr	r3, [pc, #56]	; (2396c <z_reset_time_slice+0x3c>)

	z_abort_timeout(&slice_timeouts[cpu]);
   23934:	4c0e      	ldr	r4, [pc, #56]	; (23970 <z_reset_time_slice+0x40>)
	int cpu = _current_cpu->id;
   23936:	7c1e      	ldrb	r6, [r3, #16]
{
   23938:	4605      	mov	r5, r0
	z_abort_timeout(&slice_timeouts[cpu]);
   2393a:	eb06 0346 	add.w	r3, r6, r6, lsl #1
   2393e:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
   23942:	4620      	mov	r0, r4
   23944:	f002 fb4b 	bl	25fde <z_abort_timeout>
	slice_expired[cpu] = false;
   23948:	2200      	movs	r2, #0
   2394a:	4b0a      	ldr	r3, [pc, #40]	; (23974 <z_reset_time_slice+0x44>)
	if (sliceable(curr)) {
   2394c:	4628      	mov	r0, r5
	slice_expired[cpu] = false;
   2394e:	559a      	strb	r2, [r3, r6]
	if (sliceable(curr)) {
   23950:	f7ff ffc0 	bl	238d4 <sliceable>
   23954:	b148      	cbz	r0, 2396a <z_reset_time_slice+0x3a>
	int ret = slice_ticks;
   23956:	4b08      	ldr	r3, [pc, #32]	; (23978 <z_reset_time_slice+0x48>)
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
   23958:	4620      	mov	r0, r4
			      K_TICKS(slice_time(curr) - 1));
	}
}
   2395a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			      K_TICKS(slice_time(curr) - 1));
   2395e:	681a      	ldr	r2, [r3, #0]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
   23960:	4906      	ldr	r1, [pc, #24]	; (2397c <z_reset_time_slice+0x4c>)
			      K_TICKS(slice_time(curr) - 1));
   23962:	3a01      	subs	r2, #1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
   23964:	17d3      	asrs	r3, r2, #31
   23966:	f000 bb83 	b.w	24070 <z_add_timeout>
}
   2396a:	bd70      	pop	{r4, r5, r6, pc}
   2396c:	2000b5b4 	.word	0x2000b5b4
   23970:	2000a670 	.word	0x2000a670
   23974:	2000b62c 	.word	0x2000b62c
   23978:	2000b5e8 	.word	0x2000b5e8
   2397c:	00023911 	.word	0x00023911

00023980 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
   23980:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   23982:	4d0d      	ldr	r5, [pc, #52]	; (239b8 <update_cache+0x38>)
   23984:	462b      	mov	r3, r5
   23986:	f853 4f1c 	ldr.w	r4, [r3, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2398a:	429c      	cmp	r4, r3
   2398c:	d000      	beq.n	23990 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   2398e:	b904      	cbnz	r4, 23992 <update_cache+0x12>
   23990:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
   23992:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
   23994:	b938      	cbnz	r0, 239a6 <update_cache+0x26>
	if (z_is_thread_prevented_from_running(_current)) {
   23996:	7b5a      	ldrb	r2, [r3, #13]
   23998:	06d2      	lsls	r2, r2, #27
   2399a:	d104      	bne.n	239a6 <update_cache+0x26>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   2399c:	69a2      	ldr	r2, [r4, #24]
   2399e:	b912      	cbnz	r2, 239a6 <update_cache+0x26>
	if (is_preempt(_current) || is_metairq(thread)) {
   239a0:	89da      	ldrh	r2, [r3, #14]
   239a2:	2a7f      	cmp	r2, #127	; 0x7f
   239a4:	d805      	bhi.n	239b2 <update_cache+0x32>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
   239a6:	429c      	cmp	r4, r3
   239a8:	d002      	beq.n	239b0 <update_cache+0x30>
			z_reset_time_slice(thread);
   239aa:	4620      	mov	r0, r4
   239ac:	f7ff ffc0 	bl	23930 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
   239b0:	4623      	mov	r3, r4
   239b2:	61ab      	str	r3, [r5, #24]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
   239b4:	bd38      	pop	{r3, r4, r5, pc}
   239b6:	bf00      	nop
   239b8:	2000b5b4 	.word	0x2000b5b4

000239bc <move_thread_to_end_of_prio_q>:
{
   239bc:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   239be:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   239c2:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   239c4:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
   239c6:	7b43      	ldrb	r3, [r0, #13]
   239c8:	da04      	bge.n	239d4 <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   239ca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   239ce:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   239d0:	f002 fa06 	bl	25de0 <sys_dlist_remove>
	return list->head == list;
   239d4:	4a15      	ldr	r2, [pc, #84]	; (23a2c <move_thread_to_end_of_prio_q+0x70>)
	thread->base.thread_state |= _THREAD_QUEUED;
   239d6:	7b4b      	ldrb	r3, [r1, #13]
   239d8:	4610      	mov	r0, r2
   239da:	f063 037f 	orn	r3, r3, #127	; 0x7f
   239de:	734b      	strb	r3, [r1, #13]
   239e0:	f850 3f1c 	ldr.w	r3, [r0, #28]!
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
   239e4:	6a14      	ldr	r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   239e6:	4283      	cmp	r3, r0
   239e8:	bf08      	it	eq
   239ea:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   239ec:	b923      	cbnz	r3, 239f8 <move_thread_to_end_of_prio_q+0x3c>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
   239ee:	e9c1 0400 	strd	r0, r4, [r1]

	tail->next = node;
   239f2:	6021      	str	r1, [r4, #0]
	list->tail = node;
   239f4:	6211      	str	r1, [r2, #32]
}
   239f6:	e00c      	b.n	23a12 <move_thread_to_end_of_prio_q+0x56>
	int32_t b1 = thread_1->base.prio;
   239f8:	f991 500e 	ldrsb.w	r5, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   239fc:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
   23a00:	42b5      	cmp	r5, r6
   23a02:	d00e      	beq.n	23a22 <move_thread_to_end_of_prio_q+0x66>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23a04:	42ae      	cmp	r6, r5
   23a06:	dd0c      	ble.n	23a22 <move_thread_to_end_of_prio_q+0x66>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   23a08:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   23a0a:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   23a0e:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   23a10:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   23a12:	6890      	ldr	r0, [r2, #8]
}
   23a14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   23a18:	1a43      	subs	r3, r0, r1
   23a1a:	4258      	negs	r0, r3
   23a1c:	4158      	adcs	r0, r3
   23a1e:	f7ff bfaf 	b.w	23980 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   23a22:	429c      	cmp	r4, r3
   23a24:	d0e3      	beq.n	239ee <move_thread_to_end_of_prio_q+0x32>
   23a26:	681b      	ldr	r3, [r3, #0]
   23a28:	e7e0      	b.n	239ec <move_thread_to_end_of_prio_q+0x30>
   23a2a:	bf00      	nop
   23a2c:	2000b5b4 	.word	0x2000b5b4

00023a30 <ready_thread>:
{
   23a30:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   23a32:	f990 300d 	ldrsb.w	r3, [r0, #13]
   23a36:	7b42      	ldrb	r2, [r0, #13]
   23a38:	2b00      	cmp	r3, #0
   23a3a:	db29      	blt.n	23a90 <ready_thread+0x60>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   23a3c:	06d3      	lsls	r3, r2, #27
   23a3e:	d127      	bne.n	23a90 <ready_thread+0x60>
	return node->next != NULL;
   23a40:	6983      	ldr	r3, [r0, #24]
   23a42:	bb2b      	cbnz	r3, 23a90 <ready_thread+0x60>
	return list->head == list;
   23a44:	4913      	ldr	r1, [pc, #76]	; (23a94 <ready_thread+0x64>)
	thread->base.thread_state |= _THREAD_QUEUED;
   23a46:	f062 027f 	orn	r2, r2, #127	; 0x7f
   23a4a:	7342      	strb	r2, [r0, #13]
   23a4c:	460a      	mov	r2, r1
   23a4e:	f852 4f1c 	ldr.w	r4, [r2, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23a52:	4294      	cmp	r4, r2
   23a54:	bf18      	it	ne
   23a56:	4623      	movne	r3, r4
	return (node == list->tail) ? NULL : node->next;
   23a58:	6a0c      	ldr	r4, [r1, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   23a5a:	b923      	cbnz	r3, 23a66 <ready_thread+0x36>
	node->prev = tail;
   23a5c:	e9c0 2400 	strd	r2, r4, [r0]
	tail->next = node;
   23a60:	6020      	str	r0, [r4, #0]
	list->tail = node;
   23a62:	6208      	str	r0, [r1, #32]
}
   23a64:	e00c      	b.n	23a80 <ready_thread+0x50>
	int32_t b1 = thread_1->base.prio;
   23a66:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   23a6a:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
   23a6e:	42b5      	cmp	r5, r6
   23a70:	d00a      	beq.n	23a88 <ready_thread+0x58>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23a72:	42ae      	cmp	r6, r5
   23a74:	dd08      	ble.n	23a88 <ready_thread+0x58>
	sys_dnode_t *const prev = successor->prev;
   23a76:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   23a78:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   23a7c:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   23a7e:	6058      	str	r0, [r3, #4]
		update_cache(0);
   23a80:	2000      	movs	r0, #0
}
   23a82:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   23a84:	f7ff bf7c 	b.w	23980 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   23a88:	42a3      	cmp	r3, r4
   23a8a:	d0e7      	beq.n	23a5c <ready_thread+0x2c>
   23a8c:	681b      	ldr	r3, [r3, #0]
   23a8e:	e7e4      	b.n	23a5a <ready_thread+0x2a>
}
   23a90:	bc70      	pop	{r4, r5, r6}
   23a92:	4770      	bx	lr
   23a94:	2000b5b4 	.word	0x2000b5b4

00023a98 <unready_thread>:
{
   23a98:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   23a9a:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   23a9e:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   23aa0:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
   23aa2:	7b43      	ldrb	r3, [r0, #13]
   23aa4:	da04      	bge.n	23ab0 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23aa6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   23aaa:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23aac:	f002 f998 	bl	25de0 <sys_dlist_remove>
	update_cache(thread == _current);
   23ab0:	4b04      	ldr	r3, [pc, #16]	; (23ac4 <unready_thread+0x2c>)
   23ab2:	6898      	ldr	r0, [r3, #8]
   23ab4:	1a43      	subs	r3, r0, r1
   23ab6:	4258      	negs	r0, r3
   23ab8:	4158      	adcs	r0, r3
}
   23aba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   23abe:	f7ff bf5f 	b.w	23980 <update_cache>
   23ac2:	bf00      	nop
   23ac4:	2000b5b4 	.word	0x2000b5b4

00023ac8 <pend_locked>:
{
   23ac8:	b570      	push	{r4, r5, r6, lr}
   23aca:	4615      	mov	r5, r2
   23acc:	461c      	mov	r4, r3
   23ace:	4606      	mov	r6, r0
	add_to_waitq_locked(thread, wait_q);
   23ad0:	f002 f998 	bl	25e04 <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   23ad4:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   23ad8:	bf08      	it	eq
   23ada:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
   23ade:	d008      	beq.n	23af2 <pend_locked+0x2a>
   23ae0:	462a      	mov	r2, r5
   23ae2:	4623      	mov	r3, r4
   23ae4:	f106 0018 	add.w	r0, r6, #24
   23ae8:	4902      	ldr	r1, [pc, #8]	; (23af4 <pend_locked+0x2c>)
}
   23aea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   23aee:	f000 babf 	b.w	24070 <z_add_timeout>
   23af2:	bd70      	pop	{r4, r5, r6, pc}
   23af4:	00025edd 	.word	0x00025edd

00023af8 <z_time_slice>:
{
   23af8:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   23afa:	f04f 0320 	mov.w	r3, #32
   23afe:	f3ef 8511 	mrs	r5, BASEPRI
   23b02:	f383 8812 	msr	BASEPRI_MAX, r3
   23b06:	f3bf 8f6f 	isb	sy
	struct k_thread *curr = _current;
   23b0a:	4b10      	ldr	r3, [pc, #64]	; (23b4c <z_time_slice+0x54>)
	if (pending_current == curr) {
   23b0c:	4a10      	ldr	r2, [pc, #64]	; (23b50 <z_time_slice+0x58>)
	struct k_thread *curr = _current;
   23b0e:	689c      	ldr	r4, [r3, #8]
	if (pending_current == curr) {
   23b10:	6810      	ldr	r0, [r2, #0]
   23b12:	42a0      	cmp	r0, r4
   23b14:	d106      	bne.n	23b24 <z_time_slice+0x2c>
		z_reset_time_slice(curr);
   23b16:	f7ff ff0b 	bl	23930 <z_reset_time_slice>
	__asm__ volatile(
   23b1a:	f385 8811 	msr	BASEPRI, r5
   23b1e:	f3bf 8f6f 	isb	sy
}
   23b22:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
   23b24:	2100      	movs	r1, #0
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
   23b26:	7c1b      	ldrb	r3, [r3, #16]
	pending_current = NULL;
   23b28:	6011      	str	r1, [r2, #0]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
   23b2a:	4a0a      	ldr	r2, [pc, #40]	; (23b54 <z_time_slice+0x5c>)
   23b2c:	5cd3      	ldrb	r3, [r2, r3]
   23b2e:	2b00      	cmp	r3, #0
   23b30:	d0f3      	beq.n	23b1a <z_time_slice+0x22>
   23b32:	4620      	mov	r0, r4
   23b34:	f7ff fece 	bl	238d4 <sliceable>
   23b38:	2800      	cmp	r0, #0
   23b3a:	d0ee      	beq.n	23b1a <z_time_slice+0x22>
		if (!z_is_thread_prevented_from_running(curr)) {
   23b3c:	7b63      	ldrb	r3, [r4, #13]
   23b3e:	06db      	lsls	r3, r3, #27
   23b40:	d102      	bne.n	23b48 <z_time_slice+0x50>
			move_thread_to_end_of_prio_q(curr);
   23b42:	4620      	mov	r0, r4
   23b44:	f7ff ff3a 	bl	239bc <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
   23b48:	4620      	mov	r0, r4
   23b4a:	e7e4      	b.n	23b16 <z_time_slice+0x1e>
   23b4c:	2000b5b4 	.word	0x2000b5b4
   23b50:	2000b5e0 	.word	0x2000b5e0
   23b54:	2000b62c 	.word	0x2000b62c

00023b58 <z_pend_curr>:
{
   23b58:	b570      	push	{r4, r5, r6, lr}
	pending_current = _current;
   23b5a:	480c      	ldr	r0, [pc, #48]	; (23b8c <z_pend_curr+0x34>)
   23b5c:	4d0c      	ldr	r5, [pc, #48]	; (23b90 <z_pend_curr+0x38>)
   23b5e:	6886      	ldr	r6, [r0, #8]
{
   23b60:	460c      	mov	r4, r1
	pending_current = _current;
   23b62:	602e      	str	r6, [r5, #0]
{
   23b64:	4611      	mov	r1, r2
   23b66:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
	__asm__ volatile(
   23b6a:	f04f 0620 	mov.w	r6, #32
   23b6e:	f3ef 8511 	mrs	r5, BASEPRI
   23b72:	f386 8812 	msr	BASEPRI_MAX, r6
   23b76:	f3bf 8f6f 	isb	sy
	pend_locked(_current, wait_q, timeout);
   23b7a:	6880      	ldr	r0, [r0, #8]
   23b7c:	f7ff ffa4 	bl	23ac8 <pend_locked>
	ret = arch_swap(key);
   23b80:	4620      	mov	r0, r4
}
   23b82:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   23b86:	f7fa bc1d 	b.w	1e3c4 <arch_swap>
   23b8a:	bf00      	nop
   23b8c:	2000b5b4 	.word	0x2000b5b4
   23b90:	2000b5e0 	.word	0x2000b5e0

00023b94 <z_set_prio>:
{
   23b94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   23b96:	4604      	mov	r4, r0
   23b98:	f04f 0320 	mov.w	r3, #32
   23b9c:	f3ef 8611 	mrs	r6, BASEPRI
   23ba0:	f383 8812 	msr	BASEPRI_MAX, r3
   23ba4:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
   23ba8:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
   23baa:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   23bac:	06da      	lsls	r2, r3, #27
   23bae:	d119      	bne.n	23be4 <z_set_prio+0x50>
	return node->next != NULL;
   23bb0:	6985      	ldr	r5, [r0, #24]
   23bb2:	b9bd      	cbnz	r5, 23be4 <z_set_prio+0x50>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23bb4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   23bb8:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23bba:	f002 f911 	bl	25de0 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   23bbe:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
   23bc0:	4a16      	ldr	r2, [pc, #88]	; (23c1c <z_set_prio+0x88>)
   23bc2:	f063 037f 	orn	r3, r3, #127	; 0x7f
   23bc6:	7343      	strb	r3, [r0, #13]
   23bc8:	4613      	mov	r3, r2
				thread->base.prio = prio;
   23bca:	7381      	strb	r1, [r0, #14]
   23bcc:	f853 0f1c 	ldr.w	r0, [r3, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23bd0:	4298      	cmp	r0, r3
   23bd2:	bf18      	it	ne
   23bd4:	4605      	movne	r5, r0
	return (node == list->tail) ? NULL : node->next;
   23bd6:	6a10      	ldr	r0, [r2, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   23bd8:	b95d      	cbnz	r5, 23bf2 <z_set_prio+0x5e>
	node->prev = tail;
   23bda:	e9c4 3000 	strd	r3, r0, [r4]
	tail->next = node;
   23bde:	6004      	str	r4, [r0, #0]
	list->tail = node;
   23be0:	6214      	str	r4, [r2, #32]
}
   23be2:	e011      	b.n	23c08 <z_set_prio+0x74>
   23be4:	2000      	movs	r0, #0
			thread->base.prio = prio;
   23be6:	73a1      	strb	r1, [r4, #14]
	__asm__ volatile(
   23be8:	f386 8811 	msr	BASEPRI, r6
   23bec:	f3bf 8f6f 	isb	sy
}
   23bf0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int32_t b2 = thread_2->base.prio;
   23bf2:	f995 700e 	ldrsb.w	r7, [r5, #14]
	if (b1 != b2) {
   23bf6:	42b9      	cmp	r1, r7
   23bf8:	d00b      	beq.n	23c12 <z_set_prio+0x7e>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23bfa:	428f      	cmp	r7, r1
   23bfc:	dd09      	ble.n	23c12 <z_set_prio+0x7e>
	sys_dnode_t *const prev = successor->prev;
   23bfe:	686b      	ldr	r3, [r5, #4]
	node->next = successor;
   23c00:	e9c4 5300 	strd	r5, r3, [r4]
	prev->next = node;
   23c04:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   23c06:	606c      	str	r4, [r5, #4]
			update_cache(1);
   23c08:	2001      	movs	r0, #1
   23c0a:	f7ff feb9 	bl	23980 <update_cache>
   23c0e:	2001      	movs	r0, #1
   23c10:	e7ea      	b.n	23be8 <z_set_prio+0x54>
	return (node == list->tail) ? NULL : node->next;
   23c12:	42a8      	cmp	r0, r5
   23c14:	d0e1      	beq.n	23bda <z_set_prio+0x46>
   23c16:	682d      	ldr	r5, [r5, #0]
   23c18:	e7de      	b.n	23bd8 <z_set_prio+0x44>
   23c1a:	bf00      	nop
   23c1c:	2000b5b4 	.word	0x2000b5b4

00023c20 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   23c20:	b949      	cbnz	r1, 23c36 <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   23c22:	f3ef 8005 	mrs	r0, IPSR
   23c26:	b930      	cbnz	r0, 23c36 <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   23c28:	4b05      	ldr	r3, [pc, #20]	; (23c40 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   23c2a:	699a      	ldr	r2, [r3, #24]
   23c2c:	689b      	ldr	r3, [r3, #8]
   23c2e:	429a      	cmp	r2, r3
   23c30:	d001      	beq.n	23c36 <z_reschedule+0x16>
   23c32:	f7fa bbc7 	b.w	1e3c4 <arch_swap>
   23c36:	f381 8811 	msr	BASEPRI, r1
   23c3a:	f3bf 8f6f 	isb	sy
}
   23c3e:	4770      	bx	lr
   23c40:	2000b5b4 	.word	0x2000b5b4

00023c44 <z_sched_start>:
{
   23c44:	b510      	push	{r4, lr}
	__asm__ volatile(
   23c46:	f04f 0220 	mov.w	r2, #32
   23c4a:	f3ef 8411 	mrs	r4, BASEPRI
   23c4e:	f382 8812 	msr	BASEPRI_MAX, r2
   23c52:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
   23c56:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
   23c58:	0751      	lsls	r1, r2, #29
   23c5a:	d404      	bmi.n	23c66 <z_sched_start+0x22>
	__asm__ volatile(
   23c5c:	f384 8811 	msr	BASEPRI, r4
   23c60:	f3bf 8f6f 	isb	sy
}
   23c64:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   23c66:	f022 0204 	bic.w	r2, r2, #4
   23c6a:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   23c6c:	f7ff fee0 	bl	23a30 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   23c70:	4621      	mov	r1, r4
}
   23c72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   23c76:	4801      	ldr	r0, [pc, #4]	; (23c7c <z_sched_start+0x38>)
   23c78:	f7ff bfd2 	b.w	23c20 <z_reschedule>
   23c7c:	2000b62d 	.word	0x2000b62d

00023c80 <z_impl_k_thread_suspend>:
{
   23c80:	b570      	push	{r4, r5, r6, lr}
   23c82:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   23c84:	3018      	adds	r0, #24
   23c86:	f002 f9aa 	bl	25fde <z_abort_timeout>
	__asm__ volatile(
   23c8a:	f04f 0320 	mov.w	r3, #32
   23c8e:	f3ef 8611 	mrs	r6, BASEPRI
   23c92:	f383 8812 	msr	BASEPRI_MAX, r3
   23c96:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   23c9a:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
   23c9e:	7b63      	ldrb	r3, [r4, #13]
   23ca0:	2a00      	cmp	r2, #0
   23ca2:	da05      	bge.n	23cb0 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23ca4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
   23ca8:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23caa:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23cac:	f002 f898 	bl	25de0 <sys_dlist_remove>
		update_cache(thread == _current);
   23cb0:	4d0b      	ldr	r5, [pc, #44]	; (23ce0 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   23cb2:	7b63      	ldrb	r3, [r4, #13]
   23cb4:	68a8      	ldr	r0, [r5, #8]
   23cb6:	f043 0310 	orr.w	r3, r3, #16
   23cba:	7363      	strb	r3, [r4, #13]
   23cbc:	1b03      	subs	r3, r0, r4
   23cbe:	4258      	negs	r0, r3
   23cc0:	4158      	adcs	r0, r3
   23cc2:	f7ff fe5d 	bl	23980 <update_cache>
	__asm__ volatile(
   23cc6:	f386 8811 	msr	BASEPRI, r6
   23cca:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   23cce:	68ab      	ldr	r3, [r5, #8]
   23cd0:	42a3      	cmp	r3, r4
   23cd2:	d103      	bne.n	23cdc <z_impl_k_thread_suspend+0x5c>
}
   23cd4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   23cd8:	f002 b944 	b.w	25f64 <z_reschedule_unlocked>
}
   23cdc:	bd70      	pop	{r4, r5, r6, pc}
   23cde:	bf00      	nop
   23ce0:	2000b5b4 	.word	0x2000b5b4

00023ce4 <k_sched_lock>:
	__asm__ volatile(
   23ce4:	f04f 0320 	mov.w	r3, #32
   23ce8:	f3ef 8111 	mrs	r1, BASEPRI
   23cec:	f383 8812 	msr	BASEPRI_MAX, r3
   23cf0:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
   23cf4:	4b04      	ldr	r3, [pc, #16]	; (23d08 <k_sched_lock+0x24>)
   23cf6:	689a      	ldr	r2, [r3, #8]
   23cf8:	7bd3      	ldrb	r3, [r2, #15]
   23cfa:	3b01      	subs	r3, #1
   23cfc:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   23cfe:	f381 8811 	msr	BASEPRI, r1
   23d02:	f3bf 8f6f 	isb	sy
}
   23d06:	4770      	bx	lr
   23d08:	2000b5b4 	.word	0x2000b5b4

00023d0c <k_sched_unlock>:
{
   23d0c:	b510      	push	{r4, lr}
	__asm__ volatile(
   23d0e:	f04f 0320 	mov.w	r3, #32
   23d12:	f3ef 8411 	mrs	r4, BASEPRI
   23d16:	f383 8812 	msr	BASEPRI_MAX, r3
   23d1a:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   23d1e:	4b08      	ldr	r3, [pc, #32]	; (23d40 <k_sched_unlock+0x34>)
		update_cache(0);
   23d20:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   23d22:	689a      	ldr	r2, [r3, #8]
   23d24:	7bd3      	ldrb	r3, [r2, #15]
   23d26:	3301      	adds	r3, #1
   23d28:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   23d2a:	f7ff fe29 	bl	23980 <update_cache>
	__asm__ volatile(
   23d2e:	f384 8811 	msr	BASEPRI, r4
   23d32:	f3bf 8f6f 	isb	sy
}
   23d36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   23d3a:	f002 b913 	b.w	25f64 <z_reschedule_unlocked>
   23d3e:	bf00      	nop
   23d40:	2000b5b4 	.word	0x2000b5b4

00023d44 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   23d44:	4b02      	ldr	r3, [pc, #8]	; (23d50 <z_sched_init+0xc>)
   23d46:	f103 021c 	add.w	r2, r3, #28
	list->tail = (sys_dnode_t *)list;
   23d4a:	e9c3 2207 	strd	r2, r2, [r3, #28]
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
   23d4e:	4770      	bx	lr
   23d50:	2000b5b4 	.word	0x2000b5b4

00023d54 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
   23d54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   23d56:	f04f 0320 	mov.w	r3, #32
   23d5a:	f3ef 8511 	mrs	r5, BASEPRI
   23d5e:	f383 8812 	msr	BASEPRI_MAX, r3
   23d62:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   23d66:	4919      	ldr	r1, [pc, #100]	; (23dcc <z_impl_k_yield+0x78>)
   23d68:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23d6a:	7b43      	ldrb	r3, [r0, #13]
   23d6c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   23d70:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23d72:	f002 f835 	bl	25de0 <sys_dlist_remove>
	return list->head == list;
   23d76:	4608      	mov	r0, r1
	}
	queue_thread(_current);
   23d78:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   23d7a:	7b5a      	ldrb	r2, [r3, #13]
   23d7c:	f062 027f 	orn	r2, r2, #127	; 0x7f
   23d80:	735a      	strb	r2, [r3, #13]
   23d82:	f850 2f1c 	ldr.w	r2, [r0, #28]!
	return (node == list->tail) ? NULL : node->next;
   23d86:	6a0c      	ldr	r4, [r1, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23d88:	4282      	cmp	r2, r0
   23d8a:	bf08      	it	eq
   23d8c:	2200      	moveq	r2, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   23d8e:	b922      	cbnz	r2, 23d9a <z_impl_k_yield+0x46>
	node->prev = tail;
   23d90:	e9c3 0400 	strd	r0, r4, [r3]
	tail->next = node;
   23d94:	6023      	str	r3, [r4, #0]
	list->tail = node;
   23d96:	620b      	str	r3, [r1, #32]
}
   23d98:	e00c      	b.n	23db4 <z_impl_k_yield+0x60>
	int32_t b1 = thread_1->base.prio;
   23d9a:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
   23d9e:	f992 700e 	ldrsb.w	r7, [r2, #14]
	if (b1 != b2) {
   23da2:	42be      	cmp	r6, r7
   23da4:	d00e      	beq.n	23dc4 <z_impl_k_yield+0x70>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23da6:	42b7      	cmp	r7, r6
   23da8:	dd0c      	ble.n	23dc4 <z_impl_k_yield+0x70>
	sys_dnode_t *const prev = successor->prev;
   23daa:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   23dac:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
   23db0:	600b      	str	r3, [r1, #0]
	successor->prev = node;
   23db2:	6053      	str	r3, [r2, #4]
	update_cache(1);
   23db4:	2001      	movs	r0, #1
   23db6:	f7ff fde3 	bl	23980 <update_cache>
   23dba:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
   23dbc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   23dc0:	f7fa bb00 	b.w	1e3c4 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   23dc4:	42a2      	cmp	r2, r4
   23dc6:	d0e3      	beq.n	23d90 <z_impl_k_yield+0x3c>
   23dc8:	6812      	ldr	r2, [r2, #0]
   23dca:	e7e0      	b.n	23d8e <z_impl_k_yield+0x3a>
   23dcc:	2000b5b4 	.word	0x2000b5b4

00023dd0 <z_tick_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   23dd0:	ea50 0301 	orrs.w	r3, r0, r1
{
   23dd4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23dd8:	4605      	mov	r5, r0
   23dda:	460e      	mov	r6, r1
	if (ticks == 0) {
   23ddc:	d103      	bne.n	23de6 <z_tick_sleep+0x16>
	z_impl_k_yield();
   23dde:	f7ff ffb9 	bl	23d54 <z_impl_k_yield>
		k_yield();
		return 0;
   23de2:	2000      	movs	r0, #0
   23de4:	e02c      	b.n	23e40 <z_tick_sleep+0x70>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
   23de6:	1c83      	adds	r3, r0, #2
   23de8:	f171 33ff 	sbcs.w	r3, r1, #4294967295	; 0xffffffff
   23dec:	db2a      	blt.n	23e44 <z_tick_sleep+0x74>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   23dee:	f002 f91c 	bl	2602a <sys_clock_tick_get_32>
   23df2:	182c      	adds	r4, r5, r0
   23df4:	f04f 0320 	mov.w	r3, #32
   23df8:	f3ef 8811 	mrs	r8, BASEPRI
   23dfc:	f383 8812 	msr	BASEPRI_MAX, r3
   23e00:	f3bf 8f6f 	isb	sy
	}

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   23e04:	4f11      	ldr	r7, [pc, #68]	; (23e4c <z_tick_sleep+0x7c>)
   23e06:	4b12      	ldr	r3, [pc, #72]	; (23e50 <z_tick_sleep+0x80>)
   23e08:	68b8      	ldr	r0, [r7, #8]
   23e0a:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
   23e0c:	f7ff fe44 	bl	23a98 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   23e10:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   23e12:	4910      	ldr	r1, [pc, #64]	; (23e54 <z_tick_sleep+0x84>)
   23e14:	462a      	mov	r2, r5
   23e16:	4633      	mov	r3, r6
   23e18:	3018      	adds	r0, #24
   23e1a:	f000 f929 	bl	24070 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   23e1e:	68ba      	ldr	r2, [r7, #8]
   23e20:	4640      	mov	r0, r8
	thread->base.thread_state |= _THREAD_SUSPENDED;
   23e22:	7b53      	ldrb	r3, [r2, #13]
   23e24:	f043 0310 	orr.w	r3, r3, #16
   23e28:	7353      	strb	r3, [r2, #13]
   23e2a:	f7fa facb 	bl	1e3c4 <arch_swap>

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   23e2e:	f002 f8fc 	bl	2602a <sys_clock_tick_get_32>
   23e32:	1a20      	subs	r0, r4, r0
   23e34:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
   23e38:	2801      	cmp	r0, #1
   23e3a:	f173 0300 	sbcs.w	r3, r3, #0
   23e3e:	dbd0      	blt.n	23de2 <z_tick_sleep+0x12>
		return ticks;
	}
#endif

	return 0;
}
   23e40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   23e44:	f06f 0401 	mvn.w	r4, #1
   23e48:	1a24      	subs	r4, r4, r0
   23e4a:	e7d3      	b.n	23df4 <z_tick_sleep+0x24>
   23e4c:	2000b5b4 	.word	0x2000b5b4
   23e50:	2000b5e0 	.word	0x2000b5e0
   23e54:	00025edd 	.word	0x00025edd

00023e58 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   23e58:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   23e5c:	bf08      	it	eq
   23e5e:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   23e62:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   23e64:	d106      	bne.n	23e74 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
   23e66:	4b08      	ldr	r3, [pc, #32]	; (23e88 <z_impl_k_sleep+0x30>)
   23e68:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   23e6a:	f7ff ff09 	bl	23c80 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
   23e6e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   23e72:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
   23e74:	f7ff ffac 	bl	23dd0 <z_tick_sleep>
   23e78:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   23e7c:	fb80 0303 	smull	r0, r3, r0, r3
   23e80:	0bc0      	lsrs	r0, r0, #15
   23e82:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
   23e86:	e7f4      	b.n	23e72 <z_impl_k_sleep+0x1a>
   23e88:	2000b5b4 	.word	0x2000b5b4

00023e8c <z_impl_k_usleep>:
}
#include <syscalls/k_sleep_mrsh.c>
#endif

int32_t z_impl_k_usleep(int us)
{
   23e8c:	b538      	push	{r3, r4, r5, lr}
   23e8e:	2100      	movs	r1, #0
   23e90:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   23e94:	4c08      	ldr	r4, [pc, #32]	; (23eb8 <z_impl_k_usleep+0x2c>)
   23e96:	2300      	movs	r3, #0
   23e98:	fbc0 4105 	smlal	r4, r1, r0, r5
   23e9c:	4a07      	ldr	r2, [pc, #28]	; (23ebc <z_impl_k_usleep+0x30>)
   23e9e:	4620      	mov	r0, r4
   23ea0:	f7f8 f958 	bl	1c154 <__aeabi_uldivmod>
	int32_t ticks;

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, usleep, us);

	ticks = k_us_to_ticks_ceil64(us);
	ticks = z_tick_sleep(ticks);
   23ea4:	17c1      	asrs	r1, r0, #31
   23ea6:	f7ff ff93 	bl	23dd0 <z_tick_sleep>
   23eaa:	4b04      	ldr	r3, [pc, #16]	; (23ebc <z_impl_k_usleep+0x30>)
   23eac:	fb80 0303 	smull	r0, r3, r0, r3
   23eb0:	0bc0      	lsrs	r0, r0, #15

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, usleep, us, k_ticks_to_us_floor64(ticks));

	return k_ticks_to_us_floor64(ticks);
}
   23eb2:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   23eb6:	bd38      	pop	{r3, r4, r5, pc}
   23eb8:	000f423f 	.word	0x000f423f
   23ebc:	000f4240 	.word	0x000f4240

00023ec0 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   23ec0:	4b01      	ldr	r3, [pc, #4]	; (23ec8 <z_impl_z_current_get+0x8>)
   23ec2:	6898      	ldr	r0, [r3, #8]
   23ec4:	4770      	bx	lr
   23ec6:	bf00      	nop
   23ec8:	2000b5b4 	.word	0x2000b5b4

00023ecc <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   23ecc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23ed0:	4604      	mov	r4, r0
   23ed2:	f04f 0320 	mov.w	r3, #32
   23ed6:	f3ef 8611 	mrs	r6, BASEPRI
   23eda:	f383 8812 	msr	BASEPRI_MAX, r3
   23ede:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
   23ee2:	7b03      	ldrb	r3, [r0, #12]
   23ee4:	07d9      	lsls	r1, r3, #31
   23ee6:	d50b      	bpl.n	23f00 <z_thread_abort+0x34>
	__asm__ volatile(
   23ee8:	f386 8811 	msr	BASEPRI, r6
   23eec:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
   23ef0:	4040      	eors	r0, r0
   23ef2:	f380 8811 	msr	BASEPRI, r0
   23ef6:	f04f 0004 	mov.w	r0, #4
   23efa:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   23efc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   23f00:	7b43      	ldrb	r3, [r0, #13]
   23f02:	071a      	lsls	r2, r3, #28
   23f04:	d504      	bpl.n	23f10 <z_thread_abort+0x44>
   23f06:	f386 8811 	msr	BASEPRI, r6
   23f0a:	f3bf 8f6f 	isb	sy
   23f0e:	e7f5      	b.n	23efc <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   23f10:	f023 0220 	bic.w	r2, r3, #32
   23f14:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   23f18:	09d2      	lsrs	r2, r2, #7
   23f1a:	d120      	bne.n	23f5e <z_thread_abort+0x92>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   23f1c:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   23f1e:	68a3      	ldr	r3, [r4, #8]
   23f20:	b113      	cbz	r3, 23f28 <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
   23f22:	4620      	mov	r0, r4
   23f24:	f001 ff64 	bl	25df0 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   23f28:	f104 0018 	add.w	r0, r4, #24
   23f2c:	f002 f857 	bl	25fde <z_abort_timeout>
   23f30:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   23f34:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
   23f38:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23f3a:	42bd      	cmp	r5, r7
   23f3c:	d000      	beq.n	23f40 <z_thread_abort+0x74>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   23f3e:	b9b5      	cbnz	r5, 23f6e <z_thread_abort+0xa2>
		update_cache(1);
   23f40:	2001      	movs	r0, #1
   23f42:	f7ff fd1d 	bl	23980 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   23f46:	4b10      	ldr	r3, [pc, #64]	; (23f88 <z_thread_abort+0xbc>)
   23f48:	689b      	ldr	r3, [r3, #8]
   23f4a:	42a3      	cmp	r3, r4
   23f4c:	d1db      	bne.n	23f06 <z_thread_abort+0x3a>
   23f4e:	f3ef 8305 	mrs	r3, IPSR
   23f52:	2b00      	cmp	r3, #0
   23f54:	d1d7      	bne.n	23f06 <z_thread_abort+0x3a>
   23f56:	4630      	mov	r0, r6
   23f58:	f7fa fa34 	bl	1e3c4 <arch_swap>
	return ret;
   23f5c:	e7d3      	b.n	23f06 <z_thread_abort+0x3a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23f5e:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   23f62:	f043 0308 	orr.w	r3, r3, #8
   23f66:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23f68:	f001 ff3a 	bl	25de0 <sys_dlist_remove>
}
   23f6c:	e7d7      	b.n	23f1e <z_thread_abort+0x52>
		unpend_thread_no_timeout(thread);
   23f6e:	4628      	mov	r0, r5
   23f70:	f001 ff3e 	bl	25df0 <unpend_thread_no_timeout>
   23f74:	f105 0018 	add.w	r0, r5, #24
   23f78:	f002 f831 	bl	25fde <z_abort_timeout>
		ready_thread(thread);
   23f7c:	4628      	mov	r0, r5
   23f7e:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
   23f82:	f7ff fd55 	bl	23a30 <ready_thread>
   23f86:	e7d7      	b.n	23f38 <z_thread_abort+0x6c>
   23f88:	2000b5b4 	.word	0x2000b5b4

00023f8c <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
   23f8c:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   23f8e:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
   23f92:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   23f94:	e9cd 6700 	strd	r6, r7, [sp]
   23f98:	f7ff fdde 	bl	23b58 <z_pend_curr>

	if (data != NULL) {
   23f9c:	b11c      	cbz	r4, 23fa6 <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
   23f9e:	4b03      	ldr	r3, [pc, #12]	; (23fac <z_sched_wait+0x20>)
   23fa0:	689b      	ldr	r3, [r3, #8]
   23fa2:	695b      	ldr	r3, [r3, #20]
   23fa4:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
   23fa6:	b002      	add	sp, #8
   23fa8:	bdd0      	pop	{r4, r6, r7, pc}
   23faa:	bf00      	nop
   23fac:	2000b5b4 	.word	0x2000b5b4

00023fb0 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
   23fb0:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
   23fb2:	4806      	ldr	r0, [pc, #24]	; (23fcc <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
   23fb4:	4a06      	ldr	r2, [pc, #24]	; (23fd0 <z_data_copy+0x20>)
   23fb6:	4907      	ldr	r1, [pc, #28]	; (23fd4 <z_data_copy+0x24>)
   23fb8:	1a12      	subs	r2, r2, r0
   23fba:	f001 fdbf 	bl	25b3c <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   23fbe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
   23fc2:	4a05      	ldr	r2, [pc, #20]	; (23fd8 <z_data_copy+0x28>)
   23fc4:	4905      	ldr	r1, [pc, #20]	; (23fdc <z_data_copy+0x2c>)
   23fc6:	4806      	ldr	r0, [pc, #24]	; (23fe0 <z_data_copy+0x30>)
   23fc8:	f001 bdb8 	b.w	25b3c <z_early_memcpy>
   23fcc:	2000a000 	.word	0x2000a000
   23fd0:	2000a410 	.word	0x2000a410
   23fd4:	00026bc4 	.word	0x00026bc4
   23fd8:	00000000 	.word	0x00000000
   23fdc:	00026bc4 	.word	0x00026bc4
   23fe0:	2000a000 	.word	0x2000a000

00023fe4 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   23fe4:	4b03      	ldr	r3, [pc, #12]	; (23ff4 <elapsed+0x10>)
   23fe6:	681b      	ldr	r3, [r3, #0]
   23fe8:	b90b      	cbnz	r3, 23fee <elapsed+0xa>
   23fea:	f7fc bc8d 	b.w	20908 <sys_clock_elapsed>
}
   23fee:	2000      	movs	r0, #0
   23ff0:	4770      	bx	lr
   23ff2:	bf00      	nop
   23ff4:	2000b5ec 	.word	0x2000b5ec

00023ff8 <next_timeout>:

static int32_t next_timeout(void)
{
   23ff8:	b510      	push	{r4, lr}
	return list->head == list;
   23ffa:	4b0e      	ldr	r3, [pc, #56]	; (24034 <next_timeout+0x3c>)
   23ffc:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23ffe:	429c      	cmp	r4, r3
   24000:	d104      	bne.n	2400c <next_timeout+0x14>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   24002:	f7ff ffef 	bl	23fe4 <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
   24006:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
   2400a:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
   2400c:	f7ff ffea 	bl	23fe4 <elapsed>
	if ((to == NULL) ||
   24010:	2c00      	cmp	r4, #0
   24012:	d0f8      	beq.n	24006 <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
   24014:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
   24018:	1a1b      	subs	r3, r3, r0
   2401a:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
   2401e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   24022:	f172 0100 	sbcs.w	r1, r2, #0
   24026:	daee      	bge.n	24006 <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
   24028:	2a00      	cmp	r2, #0
   2402a:	bfac      	ite	ge
   2402c:	4618      	movge	r0, r3
   2402e:	2000      	movlt	r0, #0
	return ret;
   24030:	e7eb      	b.n	2400a <next_timeout+0x12>
   24032:	bf00      	nop
   24034:	2000a284 	.word	0x2000a284

00024038 <remove_timeout>:
{
   24038:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   2403a:	b170      	cbz	r0, 2405a <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
   2403c:	4b0b      	ldr	r3, [pc, #44]	; (2406c <remove_timeout+0x34>)
   2403e:	685b      	ldr	r3, [r3, #4]
   24040:	4298      	cmp	r0, r3
   24042:	d00a      	beq.n	2405a <remove_timeout+0x22>
   24044:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
   24046:	b143      	cbz	r3, 2405a <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   24048:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   2404c:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   24050:	1912      	adds	r2, r2, r4
   24052:	eb41 0105 	adc.w	r1, r1, r5
   24056:	e9c3 2104 	strd	r2, r1, [r3, #16]
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
   2405a:	e9d0 3200 	ldrd	r3, r2, [r0]

	prev->next = next;
   2405e:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   24060:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   24062:	2300      	movs	r3, #0
	node->prev = NULL;
   24064:	e9c0 3300 	strd	r3, r3, [r0]
}
   24068:	bd30      	pop	{r4, r5, pc}
   2406a:	bf00      	nop
   2406c:	2000a284 	.word	0x2000a284

00024070 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   24070:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   24074:	bf08      	it	eq
   24076:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   2407a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2407c:	4604      	mov	r4, r0
   2407e:	461d      	mov	r5, r3
   24080:	4616      	mov	r6, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   24082:	d05c      	beq.n	2413e <z_add_timeout+0xce>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   24084:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   24086:	f04f 0320 	mov.w	r3, #32
   2408a:	f3ef 8711 	mrs	r7, BASEPRI
   2408e:	f383 8812 	msr	BASEPRI_MAX, r3
   24092:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   24096:	3201      	adds	r2, #1
   24098:	f175 33ff 	sbcs.w	r3, r5, #4294967295	; 0xffffffff
   2409c:	da24      	bge.n	240e8 <z_add_timeout+0x78>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   2409e:	f06f 0301 	mvn.w	r3, #1
   240a2:	492c      	ldr	r1, [pc, #176]	; (24154 <z_add_timeout+0xe4>)
   240a4:	e9d1 2000 	ldrd	r2, r0, [r1]
   240a8:	1a9b      	subs	r3, r3, r2
   240aa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   240ae:	eb62 0000 	sbc.w	r0, r2, r0
   240b2:	1b9e      	subs	r6, r3, r6
   240b4:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
   240b8:	2e01      	cmp	r6, #1
   240ba:	f170 0300 	sbcs.w	r3, r0, #0
   240be:	da01      	bge.n	240c4 <z_add_timeout+0x54>
   240c0:	2601      	movs	r6, #1
   240c2:	2000      	movs	r0, #0
   240c4:	e9c4 6004 	strd	r6, r0, [r4, #16]
	return list->head == list;
   240c8:	4e23      	ldr	r6, [pc, #140]	; (24158 <z_add_timeout+0xe8>)
   240ca:	f8d6 c000 	ldr.w	ip, [r6]
	return (node == list->tail) ? NULL : node->next;
   240ce:	6875      	ldr	r5, [r6, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   240d0:	45b4      	cmp	ip, r6
   240d2:	bf08      	it	eq
   240d4:	f04f 0c00 	moveq.w	ip, #0
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
   240d8:	f1bc 0f00 	cmp.w	ip, #0
   240dc:	d10d      	bne.n	240fa <z_add_timeout+0x8a>
	node->prev = tail;
   240de:	e9c4 6500 	strd	r6, r5, [r4]
	tail->next = node;
   240e2:	602c      	str	r4, [r5, #0]
	list->tail = node;
   240e4:	6074      	str	r4, [r6, #4]
}
   240e6:	e01c      	b.n	24122 <z_add_timeout+0xb2>
			to->dticks = timeout.ticks + 1 + elapsed();
   240e8:	f7ff ff7c 	bl	23fe4 <elapsed>
   240ec:	3601      	adds	r6, #1
   240ee:	f145 0500 	adc.w	r5, r5, #0
   240f2:	1836      	adds	r6, r6, r0
   240f4:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
   240f8:	e7e4      	b.n	240c4 <z_add_timeout+0x54>
			if (t->dticks > to->dticks) {
   240fa:	e9dc 2004 	ldrd	r2, r0, [ip, #16]
   240fe:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
   24102:	4293      	cmp	r3, r2
   24104:	eb71 0e00 	sbcs.w	lr, r1, r0
   24108:	da1a      	bge.n	24140 <z_add_timeout+0xd0>
				t->dticks -= to->dticks;
   2410a:	1ad2      	subs	r2, r2, r3
	sys_dnode_t *const prev = successor->prev;
   2410c:	f8dc 3004 	ldr.w	r3, [ip, #4]
   24110:	eb60 0001 	sbc.w	r0, r0, r1
   24114:	e9cc 2004 	strd	r2, r0, [ip, #16]
	node->next = successor;
   24118:	e9c4 c300 	strd	ip, r3, [r4]
	prev->next = node;
   2411c:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   2411e:	f8cc 4004 	str.w	r4, [ip, #4]
	return list->head == list;
   24122:	6833      	ldr	r3, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24124:	42b3      	cmp	r3, r6
   24126:	d006      	beq.n	24136 <z_add_timeout+0xc6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   24128:	429c      	cmp	r4, r3
   2412a:	d104      	bne.n	24136 <z_add_timeout+0xc6>
			sys_clock_set_timeout(next_timeout(), false);
   2412c:	f7ff ff64 	bl	23ff8 <next_timeout>
   24130:	2100      	movs	r1, #0
   24132:	f7fc fbb7 	bl	208a4 <sys_clock_set_timeout>
	__asm__ volatile(
   24136:	f387 8811 	msr	BASEPRI, r7
   2413a:	f3bf 8f6f 	isb	sy
		}
	}
}
   2413e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			to->dticks -= t->dticks;
   24140:	1a9b      	subs	r3, r3, r2
   24142:	eb61 0100 	sbc.w	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   24146:	45ac      	cmp	ip, r5
   24148:	e9c4 3104 	strd	r3, r1, [r4, #16]
   2414c:	d0c7      	beq.n	240de <z_add_timeout+0x6e>
   2414e:	f8dc c000 	ldr.w	ip, [ip]
   24152:	e7c1      	b.n	240d8 <z_add_timeout+0x68>
   24154:	2000a688 	.word	0x2000a688
   24158:	2000a284 	.word	0x2000a284

0002415c <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
   2415c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__asm__ volatile(
   24160:	f04f 0320 	mov.w	r3, #32
   24164:	f3ef 8c11 	mrs	ip, BASEPRI
   24168:	f383 8812 	msr	BASEPRI_MAX, r3
   2416c:	f3bf 8f6f 	isb	sy
	return list->head == list;
   24170:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 24224 <sys_clock_announce+0xc8>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
   24174:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 24228 <sys_clock_announce+0xcc>
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
		t->dticks = 0;
   24178:	2400      	movs	r4, #0
	announce_remaining = ticks;
   2417a:	f8c9 0000 	str.w	r0, [r9]
   2417e:	f8da 0000 	ldr.w	r0, [sl]
		t->dticks = 0;
   24182:	2500      	movs	r5, #0
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24184:	4550      	cmp	r0, sl
   24186:	bf08      	it	eq
   24188:	2000      	moveq	r0, #0
		curr_tick += dt;
   2418a:	4f28      	ldr	r7, [pc, #160]	; (2422c <sys_clock_announce+0xd0>)
   2418c:	46e0      	mov	r8, ip
   2418e:	e9d7 2100 	ldrd	r2, r1, [r7]
	     (t != NULL) && (t->dticks <= announce_remaining);
   24192:	f8d9 3000 	ldr.w	r3, [r9]
   24196:	b380      	cbz	r0, 241fa <sys_clock_announce+0x9e>
   24198:	e9d0 6c04 	ldrd	r6, ip, [r0, #16]
   2419c:	ea4f 7ee3 	mov.w	lr, r3, asr #31
   241a0:	42b3      	cmp	r3, r6
   241a2:	eb7e 0b0c 	sbcs.w	fp, lr, ip
   241a6:	da05      	bge.n	241b4 <sys_clock_announce+0x58>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
   241a8:	1af6      	subs	r6, r6, r3
   241aa:	eb6c 040e 	sbc.w	r4, ip, lr
   241ae:	e9c0 6404 	strd	r6, r4, [r0, #16]
   241b2:	e022      	b.n	241fa <sys_clock_announce+0x9e>
		curr_tick += dt;
   241b4:	18b2      	adds	r2, r6, r2
   241b6:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
		t->dticks = 0;
   241ba:	e9c0 4504 	strd	r4, r5, [r0, #16]
		curr_tick += dt;
   241be:	e9c7 2100 	strd	r2, r1, [r7]
		remove_timeout(t);
   241c2:	f7ff ff39 	bl	24038 <remove_timeout>
	__asm__ volatile(
   241c6:	f388 8811 	msr	BASEPRI, r8
   241ca:	f3bf 8f6f 	isb	sy
		t->fn(t);
   241ce:	6883      	ldr	r3, [r0, #8]
   241d0:	4798      	blx	r3
	__asm__ volatile(
   241d2:	f04f 0320 	mov.w	r3, #32
   241d6:	f3ef 8811 	mrs	r8, BASEPRI
   241da:	f383 8812 	msr	BASEPRI_MAX, r3
   241de:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
   241e2:	f8d9 3000 	ldr.w	r3, [r9]
	return list->head == list;
   241e6:	f8da 0000 	ldr.w	r0, [sl]
   241ea:	1b9b      	subs	r3, r3, r6
	return sys_dlist_is_empty(list) ? NULL : list->head;
   241ec:	4550      	cmp	r0, sl
	k.key = arch_irq_lock();
   241ee:	46c4      	mov	ip, r8
   241f0:	f8c9 3000 	str.w	r3, [r9]
   241f4:	d1ca      	bne.n	2418c <sys_clock_announce+0x30>
		curr_tick += dt;
   241f6:	e9d7 2100 	ldrd	r2, r1, [r7]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   241fa:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   241fc:	189a      	adds	r2, r3, r2
   241fe:	eb41 73e3 	adc.w	r3, r1, r3, asr #31
   24202:	e9c7 2300 	strd	r2, r3, [r7]
	announce_remaining = 0;
   24206:	f8c9 4000 	str.w	r4, [r9]

	sys_clock_set_timeout(next_timeout(), false);
   2420a:	f7ff fef5 	bl	23ff8 <next_timeout>
   2420e:	4621      	mov	r1, r4
   24210:	f7fc fb48 	bl	208a4 <sys_clock_set_timeout>
	__asm__ volatile(
   24214:	f388 8811 	msr	BASEPRI, r8
   24218:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
   2421c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_time_slice();
   24220:	f7ff bc6a 	b.w	23af8 <z_time_slice>
   24224:	2000a284 	.word	0x2000a284
   24228:	2000b5ec 	.word	0x2000b5ec
   2422c:	2000a688 	.word	0x2000a688

00024230 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   24230:	b510      	push	{r4, lr}
	__asm__ volatile(
   24232:	f04f 0320 	mov.w	r3, #32
   24236:	f3ef 8411 	mrs	r4, BASEPRI
   2423a:	f383 8812 	msr	BASEPRI_MAX, r3
   2423e:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
   24242:	f7ff fecf 	bl	23fe4 <elapsed>
   24246:	4603      	mov	r3, r0
   24248:	4a05      	ldr	r2, [pc, #20]	; (24260 <sys_clock_tick_get+0x30>)
   2424a:	e9d2 0100 	ldrd	r0, r1, [r2]
   2424e:	1818      	adds	r0, r3, r0
   24250:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
	__asm__ volatile(
   24254:	f384 8811 	msr	BASEPRI, r4
   24258:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   2425c:	bd10      	pop	{r4, pc}
   2425e:	bf00      	nop
   24260:	2000a688 	.word	0x2000a688

00024264 <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   24264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24266:	4604      	mov	r4, r0
	__asm__ volatile(
   24268:	f04f 0320 	mov.w	r3, #32
   2426c:	f3ef 8711 	mrs	r7, BASEPRI
   24270:	f383 8812 	msr	BASEPRI_MAX, r3
   24274:	f3bf 8f6f 	isb	sy
	 * interrupt. Then, the timeout structure for this timer will turn out
	 * to be linked to the timeout list. And in such case, since the timer
	 * was restarted, its expiration handler should not be executed then,
	 * so the function exits immediately.
	 */
	if (sys_dnode_is_linked(&t->node)) {
   24278:	6802      	ldr	r2, [r0, #0]
   2427a:	b122      	cbz	r2, 24286 <z_timer_expiration_handler+0x22>
	__asm__ volatile(
   2427c:	f387 8811 	msr	BASEPRI, r7
   24280:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   24284:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   24286:	e9d0 360a 	ldrd	r3, r6, [r0, #40]	; 0x28
   2428a:	1c58      	adds	r0, r3, #1
   2428c:	f146 0100 	adc.w	r1, r6, #0
   24290:	2802      	cmp	r0, #2
   24292:	f171 0100 	sbcs.w	r1, r1, #0
   24296:	d327      	bcc.n	242e8 <z_timer_expiration_handler+0x84>
		next.ticks = MAX(next.ticks - 1, 0);
   24298:	2b01      	cmp	r3, #1
   2429a:	f176 0100 	sbcs.w	r1, r6, #0
   2429e:	bfbc      	itt	lt
   242a0:	2301      	movlt	r3, #1
   242a2:	4616      	movlt	r6, r2
   242a4:	1e5d      	subs	r5, r3, #1
   242a6:	f146 36ff 	adc.w	r6, r6, #4294967295	; 0xffffffff
	return z_impl_k_uptime_ticks();
   242aa:	f001 fec2 	bl	26032 <z_impl_k_uptime_ticks>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
   242ae:	3001      	adds	r0, #1
   242b0:	f141 0100 	adc.w	r1, r1, #0
   242b4:	1940      	adds	r0, r0, r5
   242b6:	eb46 0101 	adc.w	r1, r6, r1
   242ba:	2801      	cmp	r0, #1
   242bc:	f171 0100 	sbcs.w	r1, r1, #0
   242c0:	db3a      	blt.n	24338 <z_timer_expiration_handler+0xd4>
   242c2:	f001 feb6 	bl	26032 <z_impl_k_uptime_ticks>
   242c6:	3001      	adds	r0, #1
   242c8:	f141 0100 	adc.w	r1, r1, #0
   242cc:	f06f 0201 	mvn.w	r2, #1
   242d0:	1940      	adds	r0, r0, r5
   242d2:	eb46 0301 	adc.w	r3, r6, r1
   242d6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   242da:	1a12      	subs	r2, r2, r0
   242dc:	eb61 0303 	sbc.w	r3, r1, r3
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   242e0:	4620      	mov	r0, r4
   242e2:	4918      	ldr	r1, [pc, #96]	; (24344 <z_timer_expiration_handler+0xe0>)
   242e4:	f7ff fec4 	bl	24070 <z_add_timeout>
	timer->status += 1U;
   242e8:	6b23      	ldr	r3, [r4, #48]	; 0x30
   242ea:	3301      	adds	r3, #1
   242ec:	6323      	str	r3, [r4, #48]	; 0x30
	if (timer->expiry_fn != NULL) {
   242ee:	6a23      	ldr	r3, [r4, #32]
   242f0:	b173      	cbz	r3, 24310 <z_timer_expiration_handler+0xac>
   242f2:	f387 8811 	msr	BASEPRI, r7
   242f6:	f3bf 8f6f 	isb	sy
		timer->expiry_fn(timer);
   242fa:	4620      	mov	r0, r4
   242fc:	6a23      	ldr	r3, [r4, #32]
   242fe:	4798      	blx	r3
	__asm__ volatile(
   24300:	f04f 0320 	mov.w	r3, #32
   24304:	f3ef 8711 	mrs	r7, BASEPRI
   24308:	f383 8812 	msr	BASEPRI_MAX, r3
   2430c:	f3bf 8f6f 	isb	sy
	return list->head == list;
   24310:	f854 5f18 	ldr.w	r5, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   24314:	42a5      	cmp	r5, r4
   24316:	d0b1      	beq.n	2427c <z_timer_expiration_handler+0x18>
	if (thread == NULL) {
   24318:	2d00      	cmp	r5, #0
   2431a:	d0af      	beq.n	2427c <z_timer_expiration_handler+0x18>
	z_unpend_thread_no_timeout(thread);
   2431c:	4628      	mov	r0, r5
   2431e:	f001 fda9 	bl	25e74 <z_unpend_thread_no_timeout>
   24322:	2300      	movs	r3, #0
   24324:	67ab      	str	r3, [r5, #120]	; 0x78
	__asm__ volatile(
   24326:	f387 8811 	msr	BASEPRI, r7
   2432a:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   2432e:	4628      	mov	r0, r5
}
   24330:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_ready_thread(thread);
   24334:	f001 bd8e 	b.w	25e54 <z_ready_thread>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
   24338:	f06f 0201 	mvn.w	r2, #1
   2433c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24340:	e7ce      	b.n	242e0 <z_timer_expiration_handler+0x7c>
   24342:	bf00      	nop
   24344:	00024265 	.word	0x00024265

00024348 <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   24348:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2434c:	bf08      	it	eq
   2434e:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   24352:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   24356:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
   2435a:	4605      	mov	r5, r0
   2435c:	461c      	mov	r4, r3
   2435e:	4691      	mov	r9, r2
   24360:	4698      	mov	r8, r3
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   24362:	d01c      	beq.n	2439e <z_impl_k_timer_start+0x56>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (Z_TICK_ABS(duration.ticks) < 0) {
   24364:	1c53      	adds	r3, r2, #1
   24366:	f174 33ff 	sbcs.w	r3, r4, #4294967295	; 0xffffffff
   2436a:	db09      	blt.n	24380 <z_impl_k_timer_start+0x38>
		duration.ticks = MAX(duration.ticks - 1, 0);
   2436c:	2a01      	cmp	r2, #1
   2436e:	f174 0300 	sbcs.w	r3, r4, #0
   24372:	bfbc      	itt	lt
   24374:	2201      	movlt	r2, #1
   24376:	2400      	movlt	r4, #0
   24378:	f112 39ff 	adds.w	r9, r2, #4294967295	; 0xffffffff
   2437c:	f144 38ff 	adc.w	r8, r4, #4294967295	; 0xffffffff
	}

	(void)z_abort_timeout(&timer->timeout);
   24380:	4628      	mov	r0, r5
   24382:	f001 fe2c 	bl	25fde <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   24386:	2300      	movs	r3, #0
	timer->period = period;
   24388:	e9c5 670a 	strd	r6, r7, [r5, #40]	; 0x28
	timer->status = 0U;
   2438c:	632b      	str	r3, [r5, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   2438e:	464a      	mov	r2, r9
   24390:	4643      	mov	r3, r8
   24392:	4628      	mov	r0, r5
		     duration);
}
   24394:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   24398:	4902      	ldr	r1, [pc, #8]	; (243a4 <z_impl_k_timer_start+0x5c>)
   2439a:	f7ff be69 	b.w	24070 <z_add_timeout>
}
   2439e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   243a2:	bf00      	nop
   243a4:	00024265 	.word	0x00024265

000243a8 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   243a8:	b573      	push	{r0, r1, r4, r5, r6, lr}
   243aa:	4606      	mov	r6, r0
   243ac:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
   243ae:	f001 fc06 	bl	25bbe <k_is_in_isr>
   243b2:	b978      	cbnz	r0, 243d4 <z_thread_aligned_alloc+0x2c>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
   243b4:	4b0b      	ldr	r3, [pc, #44]	; (243e4 <z_thread_aligned_alloc+0x3c>)
   243b6:	689b      	ldr	r3, [r3, #8]
   243b8:	6f1c      	ldr	r4, [r3, #112]	; 0x70
	}

	if (heap != NULL) {
   243ba:	b17c      	cbz	r4, 243dc <z_thread_aligned_alloc+0x34>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   243bc:	1d2a      	adds	r2, r5, #4
   243be:	d209      	bcs.n	243d4 <z_thread_aligned_alloc+0x2c>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   243c0:	2000      	movs	r0, #0
   243c2:	2100      	movs	r1, #0
   243c4:	e9cd 0100 	strd	r0, r1, [sp]
   243c8:	4620      	mov	r0, r4
   243ca:	f046 0104 	orr.w	r1, r6, #4
   243ce:	f001 fe67 	bl	260a0 <k_heap_aligned_alloc>
	if (mem == NULL) {
   243d2:	b908      	cbnz	r0, 243d8 <z_thread_aligned_alloc+0x30>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
   243d4:	2400      	movs	r4, #0
	}

	return ret;
   243d6:	e001      	b.n	243dc <z_thread_aligned_alloc+0x34>
	*heap_ref = heap;
   243d8:	6004      	str	r4, [r0, #0]
	mem = ++heap_ref;
   243da:	1d04      	adds	r4, r0, #4
}
   243dc:	4620      	mov	r0, r4
   243de:	b002      	add	sp, #8
   243e0:	bd70      	pop	{r4, r5, r6, pc}
   243e2:	bf00      	nop
   243e4:	2000b5b4 	.word	0x2000b5b4

000243e8 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
   243e8:	4801      	ldr	r0, [pc, #4]	; (243f0 <boot_banner+0x8>)
   243ea:	f000 b850 	b.w	2448e <printk>
   243ee:	bf00      	nop
   243f0:	00026b8a 	.word	0x00026b8a

000243f4 <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
   243f4:	b538      	push	{r3, r4, r5, lr}
	STRUCT_SECTION_FOREACH(k_heap, h) {
   243f6:	4c06      	ldr	r4, [pc, #24]	; (24410 <statics_init+0x1c>)
   243f8:	4d06      	ldr	r5, [pc, #24]	; (24414 <statics_init+0x20>)
   243fa:	42ac      	cmp	r4, r5
   243fc:	d301      	bcc.n	24402 <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   243fe:	2000      	movs	r0, #0
   24400:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   24402:	4620      	mov	r0, r4
   24404:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   24408:	f001 fe42 	bl	26090 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   2440c:	3414      	adds	r4, #20
   2440e:	e7f4      	b.n	243fa <statics_init+0x6>
   24410:	2000a2f4 	.word	0x2000a2f4
   24414:	2000a2f4 	.word	0x2000a2f4

00024418 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
   24418:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_work_queue_config cfg = {
   2441a:	2400      	movs	r4, #0
   2441c:	4b08      	ldr	r3, [pc, #32]	; (24440 <k_sys_work_q_init+0x28>)
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
   2441e:	f44f 6280 	mov.w	r2, #1024	; 0x400
	struct k_work_queue_config cfg = {
   24422:	9302      	str	r3, [sp, #8]
	k_work_queue_start(&k_sys_work_q,
   24424:	ab02      	add	r3, sp, #8
   24426:	9300      	str	r3, [sp, #0]
   24428:	4906      	ldr	r1, [pc, #24]	; (24444 <k_sys_work_q_init+0x2c>)
   2442a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2442e:	4806      	ldr	r0, [pc, #24]	; (24448 <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
   24430:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
   24434:	f7ff f9ec 	bl	23810 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
   24438:	4620      	mov	r0, r4
   2443a:	b004      	add	sp, #16
   2443c:	bd10      	pop	{r4, pc}
   2443e:	bf00      	nop
   24440:	00026bba 	.word	0x00026bba
   24444:	2000cb70 	.word	0x2000cb70
   24448:	2000a690 	.word	0x2000a690

0002444c <gpio_pin_configure_dt>:
{
   2444c:	4603      	mov	r3, r0
   2444e:	460a      	mov	r2, r1
   24450:	b4f0      	push	{r4, r5, r6, r7}
				  spec->pin,
   24452:	7919      	ldrb	r1, [r3, #4]
				  spec->dt_flags | extra_flags);
   24454:	88db      	ldrh	r3, [r3, #6]
	return gpio_pin_configure(spec->port,
   24456:	6800      	ldr	r0, [r0, #0]
   24458:	4313      	orrs	r3, r2
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   2445a:	02dc      	lsls	r4, r3, #11
	const struct gpio_driver_api *api =
   2445c:	6887      	ldr	r7, [r0, #8]
	struct gpio_driver_data *data =
   2445e:	6906      	ldr	r6, [r0, #16]
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   24460:	d506      	bpl.n	24470 <gpio_pin_configure_dt+0x24>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   24462:	f413 2f40 	tst.w	r3, #786432	; 0xc0000
   24466:	d003      	beq.n	24470 <gpio_pin_configure_dt+0x24>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   24468:	07da      	lsls	r2, r3, #31
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   2446a:	bf48      	it	mi
   2446c:	f483 2340 	eormi.w	r3, r3, #786432	; 0xc0000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   24470:	2501      	movs	r5, #1
   24472:	6834      	ldr	r4, [r6, #0]
   24474:	408d      	lsls	r5, r1
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   24476:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   2447a:	07db      	lsls	r3, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   2447c:	bf4c      	ite	mi
   2447e:	432c      	orrmi	r4, r5
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   24480:	43ac      	bicpl	r4, r5
   24482:	6034      	str	r4, [r6, #0]
	return api->pin_configure(port, pin, flags);
   24484:	683b      	ldr	r3, [r7, #0]
}
   24486:	bcf0      	pop	{r4, r5, r6, r7}
	return api->pin_configure(port, pin, flags);
   24488:	4718      	bx	r3

0002448a <arch_printk_char_out>:
}
   2448a:	2000      	movs	r0, #0
   2448c:	4770      	bx	lr

0002448e <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
   2448e:	b40f      	push	{r0, r1, r2, r3}
   24490:	b507      	push	{r0, r1, r2, lr}
   24492:	a904      	add	r1, sp, #16
   24494:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
   24498:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
   2449a:	f7f8 f82b 	bl	1c4f4 <vprintk>

	va_end(ap);
}
   2449e:	b003      	add	sp, #12
   244a0:	f85d eb04 	ldr.w	lr, [sp], #4
   244a4:	b004      	add	sp, #16
   244a6:	4770      	bx	lr

000244a8 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   244a8:	4604      	mov	r4, r0
   244aa:	b508      	push	{r3, lr}
   244ac:	4608      	mov	r0, r1
   244ae:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   244b0:	461a      	mov	r2, r3
   244b2:	47a0      	blx	r4
	return z_impl_z_current_get();
   244b4:	f7ff fd04 	bl	23ec0 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   244b8:	f7fa fa0c 	bl	1e8d4 <z_impl_k_thread_abort>

000244bc <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   244bc:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   244c0:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   244c2:	0840      	lsrs	r0, r0, #1
   244c4:	4770      	bx	lr

000244c6 <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   244c6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   244c8:	4603      	mov	r3, r0
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   244ca:	f7ff fff7 	bl	244bc <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   244ce:	fab0 f080 	clz	r0, r0
   244d2:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   244d6:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   244da:	f8dc 6010 	ldr.w	r6, [ip, #16]
	void *cmem = &buf[c];
   244de:	00ca      	lsls	r2, r1, #3
		((uint16_t *)cmem)[f] = val;
   244e0:	1d17      	adds	r7, r2, #4
{
   244e2:	460c      	mov	r4, r1
   244e4:	3206      	adds	r2, #6
   244e6:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
   244e8:	b956      	cbnz	r6, 24500 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   244ea:	2101      	movs	r1, #1
   244ec:	fa01 f000 	lsl.w	r0, r1, r0
   244f0:	68d9      	ldr	r1, [r3, #12]
   244f2:	4301      	orrs	r1, r0
   244f4:	60d9      	str	r1, [r3, #12]
		b->next = c;
   244f6:	f8cc 4010 	str.w	r4, [ip, #16]
   244fa:	53dd      	strh	r5, [r3, r7]
   244fc:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   244fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   24500:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   24502:	3104      	adds	r1, #4
   24504:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   24506:	53d8      	strh	r0, [r3, r7]
   24508:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   2450c:	529e      	strh	r6, [r3, r2]
   2450e:	80c5      	strh	r5, [r0, #6]
   24510:	525d      	strh	r5, [r3, r1]
   24512:	e7f4      	b.n	244fe <free_list_add+0x38>

00024514 <free_list_remove_bidx>:
{
   24514:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   24516:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   2451a:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   2451c:	4299      	cmp	r1, r3
   2451e:	f102 0104 	add.w	r1, r2, #4
   24522:	d10a      	bne.n	2453a <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   24524:	2301      	movs	r3, #1
   24526:	fa03 f202 	lsl.w	r2, r3, r2
   2452a:	68c3      	ldr	r3, [r0, #12]
   2452c:	ea23 0302 	bic.w	r3, r3, r2
   24530:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   24532:	2300      	movs	r3, #0
   24534:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   24538:	bd10      	pop	{r4, pc}
   2453a:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   2453c:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   24540:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   24544:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   24548:	80cb      	strh	r3, [r1, #6]
   2454a:	8082      	strh	r2, [r0, #4]
}
   2454c:	e7f4      	b.n	24538 <free_list_remove_bidx+0x24>

0002454e <free_list_remove>:
{
   2454e:	b508      	push	{r3, lr}
   24550:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   24552:	f7ff ffb3 	bl	244bc <chunk_size>
	return 31 - __builtin_clz(usable_sz);
   24556:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   2455a:	4618      	mov	r0, r3
}
   2455c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
   24560:	f1c2 021f 	rsb	r2, r2, #31
   24564:	f7ff bfd6 	b.w	24514 <free_list_remove_bidx>

00024568 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   24568:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2456c:	fab1 f581 	clz	r5, r1
   24570:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   24574:	eb00 0889 	add.w	r8, r0, r9, lsl #2
   24578:	f8d8 2010 	ldr.w	r2, [r8, #16]
{
   2457c:	4603      	mov	r3, r0
   2457e:	460e      	mov	r6, r1
	if (b->next) {
   24580:	b1c2      	cbz	r2, 245b4 <alloc_chunk+0x4c>
   24582:	2703      	movs	r7, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   24584:	f8d8 4010 	ldr.w	r4, [r8, #16]
			if (chunk_size(h, c) >= sz) {
   24588:	4618      	mov	r0, r3
   2458a:	4621      	mov	r1, r4
   2458c:	f7ff ff96 	bl	244bc <chunk_size>
   24590:	42b0      	cmp	r0, r6
   24592:	d306      	bcc.n	245a2 <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   24594:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   24596:	4618      	mov	r0, r3
   24598:	f7ff ffbc 	bl	24514 <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   2459c:	4620      	mov	r0, r4
   2459e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   245a2:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   245a6:	88e0      	ldrh	r0, [r4, #6]
		} while (--i && b->next != first);
   245a8:	3f01      	subs	r7, #1
			b->next = next_free_chunk(h, c);
   245aa:	f8c8 0010 	str.w	r0, [r8, #16]
		} while (--i && b->next != first);
   245ae:	d001      	beq.n	245b4 <alloc_chunk+0x4c>
   245b0:	4282      	cmp	r2, r0
   245b2:	d1e7      	bne.n	24584 <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   245b4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   245b8:	f1c5 0220 	rsb	r2, r5, #32
   245bc:	4094      	lsls	r4, r2
   245be:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
   245c0:	4014      	ands	r4, r2
   245c2:	d0eb      	beq.n	2459c <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   245c4:	fa94 f2a4 	rbit	r2, r4
   245c8:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   245cc:	1d11      	adds	r1, r2, #4
   245ce:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
   245d2:	4621      	mov	r1, r4
   245d4:	e7df      	b.n	24596 <alloc_chunk+0x2e>

000245d6 <merge_chunks>:
{
   245d6:	b538      	push	{r3, r4, r5, lr}
   245d8:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   245da:	f7ff ff6f 	bl	244bc <chunk_size>
{
   245de:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   245e0:	4604      	mov	r4, r0
   245e2:	4611      	mov	r1, r2
   245e4:	4618      	mov	r0, r3
   245e6:	f7ff ff69 	bl	244bc <chunk_size>
   245ea:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   245ec:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
   245ee:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
   245f2:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
   245f4:	4618      	mov	r0, r3
   245f6:	f7ff ff61 	bl	244bc <chunk_size>
	void *cmem = &buf[c];
   245fa:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   245fc:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
   24600:	bd38      	pop	{r3, r4, r5, pc}

00024602 <split_chunks>:
{
   24602:	b538      	push	{r3, r4, r5, lr}
   24604:	460c      	mov	r4, r1
   24606:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
   24608:	f7ff ff58 	bl	244bc <chunk_size>
	chunksz_t rsz = sz0 - lsz;
   2460c:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
   2460e:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
   24610:	4405      	add	r5, r0
   24612:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   24616:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   24618:	8060      	strh	r0, [r4, #2]
   2461a:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   2461e:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   24620:	8044      	strh	r4, [r0, #2]
   24622:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   24626:	4618      	mov	r0, r3
   24628:	4611      	mov	r1, r2
   2462a:	f7ff ff47 	bl	244bc <chunk_size>
	void *cmem = &buf[c];
   2462e:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   24630:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
   24634:	bd38      	pop	{r3, r4, r5, pc}

00024636 <free_chunk>:
{
   24636:	b538      	push	{r3, r4, r5, lr}
   24638:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
   2463a:	f7ff ff3f 	bl	244bc <chunk_size>
   2463e:	460c      	mov	r4, r1
   24640:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   24642:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   24646:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   24648:	07da      	lsls	r2, r3, #31
   2464a:	d40a      	bmi.n	24662 <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   2464c:	4628      	mov	r0, r5
   2464e:	f7ff ff7e 	bl	2454e <free_list_remove>
	return c + chunk_size(h, c);
   24652:	4621      	mov	r1, r4
   24654:	4628      	mov	r0, r5
   24656:	f7ff ff31 	bl	244bc <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   2465a:	1822      	adds	r2, r4, r0
   2465c:	4628      	mov	r0, r5
   2465e:	f7ff ffba 	bl	245d6 <merge_chunks>
		return ((uint16_t *)cmem)[f];
   24662:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   24666:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   24668:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   2466c:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   2466e:	07db      	lsls	r3, r3, #31
   24670:	d40c      	bmi.n	2468c <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   24672:	4628      	mov	r0, r5
   24674:	f7ff ff6b 	bl	2454e <free_list_remove>
		return ((uint16_t *)cmem)[f];
   24678:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   2467c:	4622      	mov	r2, r4
   2467e:	1a61      	subs	r1, r4, r1
   24680:	4628      	mov	r0, r5
   24682:	f7ff ffa8 	bl	245d6 <merge_chunks>
   24686:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   2468a:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   2468c:	4621      	mov	r1, r4
   2468e:	4628      	mov	r0, r5
}
   24690:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   24694:	f7ff bf17 	b.w	244c6 <free_list_add>

00024698 <sys_heap_free>:
	if (mem == NULL) {
   24698:	b161      	cbz	r1, 246b4 <sys_heap_free+0x1c>
   2469a:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   2469c:	3904      	subs	r1, #4
   2469e:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   246a0:	f021 0307 	bic.w	r3, r1, #7
   246a4:	4403      	add	r3, r0
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   246a6:	885a      	ldrh	r2, [r3, #2]
	free_chunk(h, c);
   246a8:	08c9      	lsrs	r1, r1, #3
   246aa:	f022 0201 	bic.w	r2, r2, #1
   246ae:	805a      	strh	r2, [r3, #2]
   246b0:	f7ff bfc1 	b.w	24636 <free_chunk>
}
   246b4:	4770      	bx	lr

000246b6 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   246b6:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   246b8:	6805      	ldr	r5, [r0, #0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
   246ba:	b909      	cbnz	r1, 246c0 <sys_heap_alloc+0xa>
		return NULL;
   246bc:	2000      	movs	r0, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
   246be:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   246c0:	68ab      	ldr	r3, [r5, #8]
   246c2:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   246c6:	d9f9      	bls.n	246bc <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   246c8:	310b      	adds	r1, #11
   246ca:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   246cc:	4621      	mov	r1, r4
   246ce:	4628      	mov	r0, r5
   246d0:	f7ff ff4a 	bl	24568 <alloc_chunk>
	if (c == 0U) {
   246d4:	4606      	mov	r6, r0
   246d6:	2800      	cmp	r0, #0
   246d8:	d0f0      	beq.n	246bc <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   246da:	4601      	mov	r1, r0
   246dc:	4628      	mov	r0, r5
   246de:	f7ff feed 	bl	244bc <chunk_size>
   246e2:	42a0      	cmp	r0, r4
   246e4:	d907      	bls.n	246f6 <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
   246e6:	4628      	mov	r0, r5
   246e8:	1932      	adds	r2, r6, r4
   246ea:	f7ff ff8a 	bl	24602 <split_chunks>
		free_list_add(h, c + chunk_sz);
   246ee:	4611      	mov	r1, r2
   246f0:	4628      	mov	r0, r5
   246f2:	f7ff fee8 	bl	244c6 <free_list_add>
	void *cmem = &buf[c];
   246f6:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   246fa:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   246fc:	8853      	ldrh	r3, [r2, #2]
   246fe:	3004      	adds	r0, #4
   24700:	f043 0301 	orr.w	r3, r3, #1
   24704:	8053      	strh	r3, [r2, #2]
	return mem;
   24706:	e7da      	b.n	246be <sys_heap_alloc+0x8>

00024708 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   24708:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2470c:	f101 39ff 	add.w	r9, r1, #4294967295	; 0xffffffff
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
	if (align != rew) {
   24710:	ea19 0901 	ands.w	r9, r9, r1
{
   24714:	460f      	mov	r7, r1
   24716:	4614      	mov	r4, r2
	struct z_heap *h = heap->heap;
   24718:	6806      	ldr	r6, [r0, #0]
	if (align != rew) {
   2471a:	d00c      	beq.n	24736 <sys_heap_aligned_alloc+0x2e>
	rew = align & -align;
   2471c:	424b      	negs	r3, r1
   2471e:	400b      	ands	r3, r1
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
   24720:	2b04      	cmp	r3, #4
   24722:	461a      	mov	r2, r3
   24724:	464f      	mov	r7, r9
   24726:	bf28      	it	cs
   24728:	2204      	movcs	r2, #4
	rew = align & -align;
   2472a:	4699      	mov	r9, r3
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   2472c:	b964      	cbnz	r4, 24748 <sys_heap_aligned_alloc+0x40>
		return NULL;
   2472e:	2500      	movs	r5, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
   24730:	4628      	mov	r0, r5
   24732:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   24736:	2904      	cmp	r1, #4
   24738:	d804      	bhi.n	24744 <sys_heap_aligned_alloc+0x3c>
}
   2473a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   2473e:	4611      	mov	r1, r2
   24740:	f7ff bfb9 	b.w	246b6 <sys_heap_alloc>
		gap = chunk_header_bytes(h);
   24744:	2204      	movs	r2, #4
   24746:	e7f1      	b.n	2472c <sys_heap_aligned_alloc+0x24>
	if (bytes == 0 || size_too_big(h, bytes)) {
   24748:	68b3      	ldr	r3, [r6, #8]
   2474a:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   2474e:	d9ee      	bls.n	2472e <sys_heap_aligned_alloc+0x26>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   24750:	f104 010b 	add.w	r1, r4, #11
   24754:	4439      	add	r1, r7
   24756:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   24758:	4630      	mov	r0, r6
   2475a:	08c9      	lsrs	r1, r1, #3
   2475c:	f7ff ff04 	bl	24568 <alloc_chunk>
	if (c0 == 0) {
   24760:	4680      	mov	r8, r0
   24762:	2800      	cmp	r0, #0
   24764:	d0e3      	beq.n	2472e <sys_heap_aligned_alloc+0x26>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   24766:	f109 0504 	add.w	r5, r9, #4
   2476a:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   2476e:	1e7b      	subs	r3, r7, #1
   24770:	4435      	add	r5, r6
   24772:	441d      	add	r5, r3
   24774:	427f      	negs	r7, r7
   24776:	403d      	ands	r5, r7
   24778:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   2477c:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   2477e:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   24780:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   24782:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   24784:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   24788:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   2478a:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   2478e:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   24792:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   24796:	d208      	bcs.n	247aa <sys_heap_aligned_alloc+0xa2>
		split_chunks(h, c0, c);
   24798:	4601      	mov	r1, r0
   2479a:	463a      	mov	r2, r7
   2479c:	4630      	mov	r0, r6
   2479e:	f7ff ff30 	bl	24602 <split_chunks>
		free_list_add(h, c0);
   247a2:	4641      	mov	r1, r8
   247a4:	4630      	mov	r0, r6
   247a6:	f7ff fe8e 	bl	244c6 <free_list_add>
	return c + chunk_size(h, c);
   247aa:	4639      	mov	r1, r7
   247ac:	4630      	mov	r0, r6
   247ae:	f7ff fe85 	bl	244bc <chunk_size>
   247b2:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   247b4:	4284      	cmp	r4, r0
   247b6:	d207      	bcs.n	247c8 <sys_heap_aligned_alloc+0xc0>
		split_chunks(h, c, c_end);
   247b8:	4630      	mov	r0, r6
   247ba:	4622      	mov	r2, r4
   247bc:	f7ff ff21 	bl	24602 <split_chunks>
		free_list_add(h, c_end);
   247c0:	4621      	mov	r1, r4
   247c2:	4630      	mov	r0, r6
   247c4:	f7ff fe7f 	bl	244c6 <free_list_add>
	void *cmem = &buf[c];
   247c8:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   247cc:	8873      	ldrh	r3, [r6, #2]
   247ce:	f043 0301 	orr.w	r3, r3, #1
   247d2:	8073      	strh	r3, [r6, #2]
   247d4:	e7ac      	b.n	24730 <sys_heap_aligned_alloc+0x28>

000247d6 <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   247d6:	b4f0      	push	{r4, r5, r6, r7}
   247d8:	4604      	mov	r4, r0
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   247da:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   247dc:	1dc8      	adds	r0, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   247de:	4411      	add	r1, r2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   247e0:	f020 0007 	bic.w	r0, r0, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   247e4:	f021 0107 	bic.w	r1, r1, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   247e8:	1a0e      	subs	r6, r1, r0
   247ea:	08f3      	lsrs	r3, r6, #3
	return 31 - __builtin_clz(usable_sz);
   247ec:	fab3 f283 	clz	r2, r3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   247f0:	6020      	str	r0, [r4, #0]
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   247f2:	2700      	movs	r7, #0
   247f4:	4604      	mov	r4, r0
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   247f6:	f1c2 0524 	rsb	r5, r2, #36	; 0x24
   247fa:	00ad      	lsls	r5, r5, #2
	h->end_chunk = heap_sz;
   247fc:	6083      	str	r3, [r0, #8]
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   247fe:	3507      	adds	r5, #7
	h->avail_buckets = 0;
   24800:	f844 7f0c 	str.w	r7, [r4, #12]!
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
   24804:	f1c2 0220 	rsb	r2, r2, #32
   24808:	08e9      	lsrs	r1, r5, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   2480a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
		h->buckets[i].next = 0;
   2480e:	f844 7f04 	str.w	r7, [r4, #4]!
	for (int i = 0; i < nb_buckets; i++) {
   24812:	4294      	cmp	r4, r2
   24814:	d1fb      	bne.n	2480e <sys_heap_init+0x38>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   24816:	004a      	lsls	r2, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   24818:	f042 0201 	orr.w	r2, r2, #1
   2481c:	8042      	strh	r2, [r0, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   2481e:	1a5a      	subs	r2, r3, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   24820:	0055      	lsls	r5, r2, #1
		((uint16_t *)cmem)[f] = val;
   24822:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   24826:	8007      	strh	r7, [r0, #0]
   24828:	8065      	strh	r5, [r4, #2]
   2482a:	1984      	adds	r4, r0, r6
   2482c:	f820 1031 	strh.w	r1, [r0, r1, lsl #3]
	void *cmem = &buf[c];
   24830:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
		((uint16_t *)cmem)[f] = val;
   24834:	8067      	strh	r7, [r4, #2]
   24836:	5382      	strh	r2, [r0, r6]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   24838:	885a      	ldrh	r2, [r3, #2]
   2483a:	f042 0201 	orr.w	r2, r2, #1
   2483e:	805a      	strh	r2, [r3, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
   24840:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   24842:	f7ff be40 	b.w	244c6 <free_list_add>

00024846 <sys_slist_find_and_remove>:
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24846:	2200      	movs	r2, #0
	return list->head;
   24848:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2484a:	b90b      	cbnz	r3, 24850 <sys_slist_find_and_remove+0xa>
   2484c:	4618      	mov	r0, r3
   2484e:	4770      	bx	lr
   24850:	428b      	cmp	r3, r1
   24852:	d110      	bne.n	24876 <sys_slist_find_and_remove+0x30>
	return node->next;
   24854:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   24856:	b942      	cbnz	r2, 2486a <sys_slist_find_and_remove+0x24>
   24858:	6842      	ldr	r2, [r0, #4]
	list->head = node;
   2485a:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   2485c:	4291      	cmp	r1, r2
   2485e:	d100      	bne.n	24862 <sys_slist_find_and_remove+0x1c>
	list->tail = node;
   24860:	6043      	str	r3, [r0, #4]
	parent->next = child;
   24862:	2300      	movs	r3, #0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24864:	2001      	movs	r0, #1
	parent->next = child;
   24866:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   24868:	4770      	bx	lr
	parent->next = child;
   2486a:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   2486c:	6843      	ldr	r3, [r0, #4]
   2486e:	4299      	cmp	r1, r3
	list->tail = node;
   24870:	bf08      	it	eq
   24872:	6042      	streq	r2, [r0, #4]
}
   24874:	e7f5      	b.n	24862 <sys_slist_find_and_remove+0x1c>
	return node->next;
   24876:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24878:	681b      	ldr	r3, [r3, #0]
   2487a:	e7e6      	b.n	2484a <sys_slist_find_and_remove+0x4>

0002487c <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   2487c:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   2487e:	f013 0307 	ands.w	r3, r3, #7
   24882:	d105      	bne.n	24890 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   24884:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
   24886:	2b00      	cmp	r3, #0
   24888:	bf0c      	ite	eq
   2488a:	2000      	moveq	r0, #0
   2488c:	2003      	movne	r0, #3
   2488e:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   24890:	2b02      	cmp	r3, #2
   24892:	d105      	bne.n	248a0 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   24894:	8b40      	ldrh	r0, [r0, #26]
   24896:	fab0 f080 	clz	r0, r0
   2489a:	0940      	lsrs	r0, r0, #5
   2489c:	0080      	lsls	r0, r0, #2
   2489e:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   248a0:	2b01      	cmp	r3, #1
   248a2:	d105      	bne.n	248b0 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   248a4:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
   248a6:	2b00      	cmp	r3, #0
   248a8:	bf0c      	ite	eq
   248aa:	2000      	moveq	r0, #0
   248ac:	2005      	movne	r0, #5
   248ae:	4770      	bx	lr
	int evt = EVT_NOP;
   248b0:	2000      	movs	r0, #0
}
   248b2:	4770      	bx	lr

000248b4 <validate_args>:
{
   248b4:	b510      	push	{r4, lr}
   248b6:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   248b8:	b100      	cbz	r0, 248bc <validate_args+0x8>
   248ba:	b911      	cbnz	r1, 248c2 <validate_args+0xe>
		return -EINVAL;
   248bc:	f06f 0015 	mvn.w	r0, #21
}
   248c0:	bd10      	pop	{r4, pc}
	int rv = sys_notify_validate(&cli->notify);
   248c2:	1d08      	adds	r0, r1, #4
   248c4:	f000 f8d6 	bl	24a74 <sys_notify_validate>
	if ((rv == 0)
   248c8:	2800      	cmp	r0, #0
   248ca:	d1f9      	bne.n	248c0 <validate_args+0xc>
	    && ((cli->notify.flags
   248cc:	68a3      	ldr	r3, [r4, #8]
   248ce:	2b03      	cmp	r3, #3
   248d0:	d9f6      	bls.n	248c0 <validate_args+0xc>
   248d2:	e7f3      	b.n	248bc <validate_args+0x8>

000248d4 <notify_one>:
{
   248d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   248d8:	460d      	mov	r5, r1
   248da:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   248dc:	4619      	mov	r1, r3
   248de:	1d28      	adds	r0, r5, #4
{
   248e0:	4690      	mov	r8, r2
   248e2:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   248e4:	f000 f8d7 	bl	24a96 <sys_notify_finalize>
	if (cb) {
   248e8:	4604      	mov	r4, r0
   248ea:	b138      	cbz	r0, 248fc <notify_one+0x28>
		cb(mgr, cli, state, res);
   248ec:	4633      	mov	r3, r6
   248ee:	4642      	mov	r2, r8
   248f0:	4629      	mov	r1, r5
   248f2:	4638      	mov	r0, r7
   248f4:	46a4      	mov	ip, r4
}
   248f6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   248fa:	4760      	bx	ip
}
   248fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024900 <transition_complete>:
{
   24900:	b410      	push	{r4}
	__asm__ volatile(
   24902:	f04f 0420 	mov.w	r4, #32
   24906:	f3ef 8211 	mrs	r2, BASEPRI
   2490a:	f384 8812 	msr	BASEPRI_MAX, r4
   2490e:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   24912:	6141      	str	r1, [r0, #20]
}
   24914:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   24916:	2101      	movs	r1, #1
   24918:	f7f7 bdfa 	b.w	1c510 <process_event>

0002491c <onoff_manager_init>:
{
   2491c:	b538      	push	{r3, r4, r5, lr}
   2491e:	460c      	mov	r4, r1
	if ((mgr == NULL)
   24920:	4605      	mov	r5, r0
   24922:	b158      	cbz	r0, 2493c <onoff_manager_init+0x20>
	    || (transitions == NULL)
   24924:	b151      	cbz	r1, 2493c <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   24926:	680b      	ldr	r3, [r1, #0]
   24928:	b143      	cbz	r3, 2493c <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   2492a:	684b      	ldr	r3, [r1, #4]
   2492c:	b133      	cbz	r3, 2493c <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   2492e:	221c      	movs	r2, #28
   24930:	2100      	movs	r1, #0
   24932:	f000 fb6d 	bl	25010 <memset>
	return 0;
   24936:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   24938:	612c      	str	r4, [r5, #16]
}
   2493a:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   2493c:	f06f 0015 	mvn.w	r0, #21
   24940:	e7fb      	b.n	2493a <onoff_manager_init+0x1e>

00024942 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   24942:	b570      	push	{r4, r5, r6, lr}
   24944:	4605      	mov	r5, r0
   24946:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   24948:	f7ff ffb4 	bl	248b4 <validate_args>

	if (rv < 0) {
   2494c:	1e04      	subs	r4, r0, #0
   2494e:	db15      	blt.n	2497c <onoff_request+0x3a>
   24950:	f04f 0320 	mov.w	r3, #32
   24954:	f3ef 8211 	mrs	r2, BASEPRI
   24958:	f383 8812 	msr	BASEPRI_MAX, r3
   2495c:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   24960:	f64f 71ff 	movw	r1, #65535	; 0xffff
   24964:	8b6b      	ldrh	r3, [r5, #26]
   24966:	8b2c      	ldrh	r4, [r5, #24]
   24968:	428b      	cmp	r3, r1
   2496a:	f004 0407 	and.w	r4, r4, #7
   2496e:	d107      	bne.n	24980 <onoff_request+0x3e>
	__asm__ volatile(
   24970:	f382 8811 	msr	BASEPRI, r2
   24974:	f3bf 8f6f 	isb	sy
		rv = -EAGAIN;
   24978:	f06f 040a 	mvn.w	r4, #10
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
   2497c:	4620      	mov	r0, r4
   2497e:	bd70      	pop	{r4, r5, r6, pc}
	if (state == ONOFF_STATE_ON) {
   24980:	2c02      	cmp	r4, #2
   24982:	d10c      	bne.n	2499e <onoff_request+0x5c>
		mgr->refs += 1U;
   24984:	3301      	adds	r3, #1
   24986:	836b      	strh	r3, [r5, #26]
   24988:	f382 8811 	msr	BASEPRI, r2
   2498c:	f3bf 8f6f 	isb	sy
			notify_one(mgr, cli, state, 0);
   24990:	2300      	movs	r3, #0
   24992:	4622      	mov	r2, r4
   24994:	4631      	mov	r1, r6
   24996:	4628      	mov	r0, r5
   24998:	f7ff ff9c 	bl	248d4 <notify_one>
   2499c:	e7ee      	b.n	2497c <onoff_request+0x3a>
	} else if ((state == ONOFF_STATE_OFF)
   2499e:	2c06      	cmp	r4, #6
   249a0:	d814      	bhi.n	249cc <onoff_request+0x8a>
   249a2:	e8df f004 	tbb	[pc, r4]
   249a6:	1304      	.short	0x1304
   249a8:	1a041313 	.word	0x1a041313
   249ac:	04          	.byte	0x04
   249ad:	00          	.byte	0x00
	parent->next = child;
   249ae:	2300      	movs	r3, #0
   249b0:	6033      	str	r3, [r6, #0]
	return list->tail;
   249b2:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_APPEND(slist, snode)
   249b4:	b93b      	cbnz	r3, 249c6 <onoff_request+0x84>
	list->head = node;
   249b6:	e9c5 6600 	strd	r6, r6, [r5]
	if (start) {
   249ba:	b9ac      	cbnz	r4, 249e8 <onoff_request+0xa6>
		process_event(mgr, EVT_RECHECK, key);
   249bc:	2102      	movs	r1, #2
   249be:	4628      	mov	r0, r5
   249c0:	f7f7 fda6 	bl	1c510 <process_event>
   249c4:	e7da      	b.n	2497c <onoff_request+0x3a>
	parent->next = child;
   249c6:	601e      	str	r6, [r3, #0]
	list->tail = node;
   249c8:	606e      	str	r6, [r5, #4]
}
   249ca:	e7f6      	b.n	249ba <onoff_request+0x78>
   249cc:	f382 8811 	msr	BASEPRI, r2
   249d0:	f3bf 8f6f 	isb	sy
		rv = -EIO;
   249d4:	f06f 0404 	mvn.w	r4, #4
   249d8:	e7d0      	b.n	2497c <onoff_request+0x3a>
   249da:	f382 8811 	msr	BASEPRI, r2
   249de:	f3bf 8f6f 	isb	sy
   249e2:	f06f 0485 	mvn.w	r4, #133	; 0x85
   249e6:	e7c9      	b.n	2497c <onoff_request+0x3a>
   249e8:	f382 8811 	msr	BASEPRI, r2
   249ec:	f3bf 8f6f 	isb	sy
		if (notify) {
   249f0:	e7c4      	b.n	2497c <onoff_request+0x3a>

000249f2 <onoff_release>:

int onoff_release(struct onoff_manager *mgr)
{
   249f2:	b510      	push	{r4, lr}
	__asm__ volatile(
   249f4:	f04f 0320 	mov.w	r3, #32
   249f8:	f3ef 8211 	mrs	r2, BASEPRI
   249fc:	f383 8812 	msr	BASEPRI_MAX, r3
   24a00:	f3bf 8f6f 	isb	sy
	bool stop = false;      /* trigger a stop transition */

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   24a04:	8b04      	ldrh	r4, [r0, #24]
   24a06:	f004 0407 	and.w	r4, r4, #7
	int rv = state;

	if (state != ONOFF_STATE_ON) {
   24a0a:	2c02      	cmp	r4, #2
   24a0c:	d00a      	beq.n	24a24 <onoff_release+0x32>
		if (state == ONOFF_STATE_ERROR) {
			rv = -EIO;
		} else {
			rv = -ENOTSUP;
   24a0e:	2c01      	cmp	r4, #1
   24a10:	bf0c      	ite	eq
   24a12:	f06f 0004 	mvneq.w	r0, #4
   24a16:	f06f 0085 	mvnne.w	r0, #133	; 0x85
	__asm__ volatile(
   24a1a:	f382 8811 	msr	BASEPRI, r2
   24a1e:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);
	}

	return rv;
   24a22:	e008      	b.n	24a36 <onoff_release+0x44>
	mgr->refs -= 1U;
   24a24:	8b43      	ldrh	r3, [r0, #26]
   24a26:	3b01      	subs	r3, #1
   24a28:	b29b      	uxth	r3, r3
   24a2a:	8343      	strh	r3, [r0, #26]
	if (stop) {
   24a2c:	b923      	cbnz	r3, 24a38 <onoff_release+0x46>
		process_event(mgr, EVT_RECHECK, key);
   24a2e:	4621      	mov	r1, r4
   24a30:	f7f7 fd6e 	bl	1c510 <process_event>
	int rv = state;
   24a34:	4620      	mov	r0, r4
}
   24a36:	bd10      	pop	{r4, pc}
	int rv = state;
   24a38:	4620      	mov	r0, r4
   24a3a:	e7ee      	b.n	24a1a <onoff_release+0x28>

00024a3c <onoff_cancel>:
	return rv;
}

int onoff_cancel(struct onoff_manager *mgr,
		 struct onoff_client *cli)
{
   24a3c:	b538      	push	{r3, r4, r5, lr}
	if ((mgr == NULL) || (cli == NULL)) {
   24a3e:	b1b0      	cbz	r0, 24a6e <onoff_cancel+0x32>
   24a40:	b1a9      	cbz	r1, 24a6e <onoff_cancel+0x32>
	__asm__ volatile(
   24a42:	f04f 0220 	mov.w	r2, #32
   24a46:	f3ef 8511 	mrs	r5, BASEPRI
   24a4a:	f382 8812 	msr	BASEPRI_MAX, r2
   24a4e:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	int rv = -EALREADY;
	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   24a52:	8b04      	ldrh	r4, [r0, #24]

	if (sys_slist_find_and_remove(&mgr->clients, &cli->node)) {
   24a54:	f7ff fef7 	bl	24846 <sys_slist_find_and_remove>
   24a58:	b130      	cbz	r0, 24a68 <onoff_cancel+0x2c>
		__ASSERT_NO_MSG((state == ONOFF_STATE_TO_ON)
				|| (state == ONOFF_STATE_TO_OFF)
				|| (state == ONOFF_STATE_RESETTING));
		rv = state;
   24a5a:	f004 0007 	and.w	r0, r4, #7
	__asm__ volatile(
   24a5e:	f385 8811 	msr	BASEPRI, r5
   24a62:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&mgr->lock, key);

	return rv;
}
   24a66:	bd38      	pop	{r3, r4, r5, pc}
	int rv = -EALREADY;
   24a68:	f06f 0077 	mvn.w	r0, #119	; 0x77
   24a6c:	e7f7      	b.n	24a5e <onoff_cancel+0x22>
		return -EINVAL;
   24a6e:	f06f 0015 	mvn.w	r0, #21
   24a72:	e7f8      	b.n	24a66 <onoff_cancel+0x2a>

00024a74 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   24a74:	4603      	mov	r3, r0
   24a76:	b158      	cbz	r0, 24a90 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   24a78:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   24a7a:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   24a7e:	2a01      	cmp	r2, #1
   24a80:	d003      	beq.n	24a8a <sys_notify_validate+0x16>
   24a82:	2a03      	cmp	r2, #3
   24a84:	d104      	bne.n	24a90 <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   24a86:	6802      	ldr	r2, [r0, #0]
   24a88:	b112      	cbz	r2, 24a90 <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   24a8a:	2000      	movs	r0, #0
   24a8c:	6098      	str	r0, [r3, #8]
   24a8e:	4770      	bx	lr
   24a90:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   24a94:	4770      	bx	lr

00024a96 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   24a96:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   24a98:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
   24a9a:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   24a9e:	2a03      	cmp	r2, #3
   24aa0:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
   24aa4:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
   24aa6:	bf14      	ite	ne
   24aa8:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   24aaa:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   24aac:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   24aae:	4770      	bx	lr

00024ab0 <encode_uint>:
{
   24ab0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24ab4:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier) != 0;
   24ab6:	78d3      	ldrb	r3, [r2, #3]
{
   24ab8:	4680      	mov	r8, r0
	switch (specifier) {
   24aba:	2b6f      	cmp	r3, #111	; 0x6f
{
   24abc:	460f      	mov	r7, r1
   24abe:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   24ac0:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
   24ac4:	d029      	beq.n	24b1a <encode_uint+0x6a>
   24ac6:	d824      	bhi.n	24b12 <encode_uint+0x62>
		return 10;
   24ac8:	2b58      	cmp	r3, #88	; 0x58
   24aca:	bf0c      	ite	eq
   24acc:	2610      	moveq	r6, #16
   24ace:	260a      	movne	r6, #10
	char *bp = bps + (bpe - bps);
   24ad0:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
   24ad4:	4632      	mov	r2, r6
   24ad6:	2300      	movs	r3, #0
   24ad8:	4640      	mov	r0, r8
   24ada:	4639      	mov	r1, r7
   24adc:	f7f7 fb3a 	bl	1c154 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24ae0:	2a09      	cmp	r2, #9
   24ae2:	b2d4      	uxtb	r4, r2
   24ae4:	d81e      	bhi.n	24b24 <encode_uint+0x74>
   24ae6:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   24ae8:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24aea:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
   24aec:	f177 0700 	sbcs.w	r7, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24af0:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
   24af4:	d301      	bcc.n	24afa <encode_uint+0x4a>
   24af6:	45d1      	cmp	r9, sl
   24af8:	d811      	bhi.n	24b1e <encode_uint+0x6e>
	if (conv->flag_hash) {
   24afa:	782b      	ldrb	r3, [r5, #0]
   24afc:	069b      	lsls	r3, r3, #26
   24afe:	d505      	bpl.n	24b0c <encode_uint+0x5c>
		if (radix == 8) {
   24b00:	2e08      	cmp	r6, #8
   24b02:	d115      	bne.n	24b30 <encode_uint+0x80>
			conv->altform_0 = true;
   24b04:	78ab      	ldrb	r3, [r5, #2]
   24b06:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   24b0a:	70ab      	strb	r3, [r5, #2]
}
   24b0c:	4648      	mov	r0, r9
   24b0e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   24b12:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 10;
   24b16:	2b70      	cmp	r3, #112	; 0x70
   24b18:	e7d7      	b.n	24aca <encode_uint+0x1a>
	switch (specifier) {
   24b1a:	2608      	movs	r6, #8
   24b1c:	e7d8      	b.n	24ad0 <encode_uint+0x20>
		value /= radix;
   24b1e:	4680      	mov	r8, r0
   24b20:	460f      	mov	r7, r1
   24b22:	e7d7      	b.n	24ad4 <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24b24:	f1bb 0f19 	cmp.w	fp, #25
   24b28:	bf94      	ite	ls
   24b2a:	3437      	addls	r4, #55	; 0x37
   24b2c:	3457      	addhi	r4, #87	; 0x57
   24b2e:	e7db      	b.n	24ae8 <encode_uint+0x38>
		} else if (radix == 16) {
   24b30:	2e10      	cmp	r6, #16
   24b32:	d1eb      	bne.n	24b0c <encode_uint+0x5c>
			conv->altform_0c = true;
   24b34:	78ab      	ldrb	r3, [r5, #2]
   24b36:	f043 0310 	orr.w	r3, r3, #16
   24b3a:	e7e6      	b.n	24b0a <encode_uint+0x5a>

00024b3c <outs>:
{
   24b3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24b40:	4607      	mov	r7, r0
   24b42:	4688      	mov	r8, r1
   24b44:	4615      	mov	r5, r2
   24b46:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   24b48:	4614      	mov	r4, r2
   24b4a:	42b4      	cmp	r4, r6
   24b4c:	d305      	bcc.n	24b5a <outs+0x1e>
   24b4e:	b10e      	cbz	r6, 24b54 <outs+0x18>
	return (int)count;
   24b50:	1b60      	subs	r0, r4, r5
   24b52:	e008      	b.n	24b66 <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   24b54:	7823      	ldrb	r3, [r4, #0]
   24b56:	2b00      	cmp	r3, #0
   24b58:	d0fa      	beq.n	24b50 <outs+0x14>
		int rc = out((int)*sp++, ctx);
   24b5a:	4641      	mov	r1, r8
   24b5c:	f814 0b01 	ldrb.w	r0, [r4], #1
   24b60:	47b8      	blx	r7
		if (rc < 0) {
   24b62:	2800      	cmp	r0, #0
   24b64:	daf1      	bge.n	24b4a <outs+0xe>
}
   24b66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024b6a <ring_buf_put_claim>:

#include <zephyr/sys/ring_buffer.h>
#include <string.h>

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
   24b6a:	4694      	mov	ip, r2
   24b6c:	b5f0      	push	{r4, r5, r6, r7, lr}
   24b6e:	4604      	mov	r4, r0
	uint32_t free_space, wrap_size;
	int32_t base;

	base = buf->put_base;
	wrap_size = buf->put_head - base;
	if (unlikely(wrap_size >= buf->size)) {
   24b70:	69c3      	ldr	r3, [r0, #28]
	base = buf->put_base;
   24b72:	68c6      	ldr	r6, [r0, #12]
	wrap_size = buf->put_head - base;
   24b74:	6845      	ldr	r5, [r0, #4]
   24b76:	6940      	ldr	r0, [r0, #20]
   24b78:	1baf      	subs	r7, r5, r6
   24b7a:	1a28      	subs	r0, r5, r0
   24b7c:	1a1a      	subs	r2, r3, r0
	if (unlikely(wrap_size >= buf->size)) {
   24b7e:	42bb      	cmp	r3, r7
		/* put_base is not yet adjusted */
		wrap_size -= buf->size;
   24b80:	bf9c      	itt	ls
   24b82:	1aff      	subls	r7, r7, r3
		base += buf->size;
   24b84:	18f6      	addls	r6, r6, r3
	}
	wrap_size = buf->size - wrap_size;

	free_space = ring_buf_space_get(buf);
	size = MIN(size, free_space);
   24b86:	4562      	cmp	r2, ip
   24b88:	bf28      	it	cs
   24b8a:	4662      	movcs	r2, ip
	wrap_size = buf->size - wrap_size;
   24b8c:	1bd8      	subs	r0, r3, r7
	size = MIN(size, wrap_size);
   24b8e:	4290      	cmp	r0, r2
   24b90:	bf28      	it	cs
   24b92:	4610      	movcs	r0, r2

	*data = &buf->buffer[buf->put_head - base];
   24b94:	6823      	ldr	r3, [r4, #0]
   24b96:	1bad      	subs	r5, r5, r6
   24b98:	442b      	add	r3, r5
   24b9a:	600b      	str	r3, [r1, #0]
	buf->put_head += size;
   24b9c:	6863      	ldr	r3, [r4, #4]
   24b9e:	4403      	add	r3, r0
   24ba0:	6063      	str	r3, [r4, #4]

	return size;
}
   24ba2:	bdf0      	pop	{r4, r5, r6, r7, pc}

00024ba4 <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->put_head - buf->put_tail;
   24ba4:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
   24ba8:	1ad2      	subs	r2, r2, r3
	if (unlikely(size > finish_space)) {
   24baa:	428a      	cmp	r2, r1
   24bac:	d30c      	bcc.n	24bc8 <ring_buf_put_finish+0x24>
		return -EINVAL;
	}

	buf->put_tail += size;
   24bae:	4419      	add	r1, r3
	buf->put_head = buf->put_tail;

	wrap_size = buf->put_tail - buf->put_base;
   24bb0:	68c3      	ldr	r3, [r0, #12]
	if (unlikely(wrap_size >= buf->size)) {
   24bb2:	69c2      	ldr	r2, [r0, #28]
	buf->put_head = buf->put_tail;
   24bb4:	e9c0 1101 	strd	r1, r1, [r0, #4]
	wrap_size = buf->put_tail - buf->put_base;
   24bb8:	1ac9      	subs	r1, r1, r3
	if (unlikely(wrap_size >= buf->size)) {
   24bba:	428a      	cmp	r2, r1
   24bbc:	d901      	bls.n	24bc2 <ring_buf_put_finish+0x1e>
		/* we wrapped: adjust put_base */
		buf->put_base += buf->size;
	}

	return 0;
   24bbe:	2000      	movs	r0, #0
   24bc0:	4770      	bx	lr
		buf->put_base += buf->size;
   24bc2:	4413      	add	r3, r2
   24bc4:	60c3      	str	r3, [r0, #12]
   24bc6:	e7fa      	b.n	24bbe <ring_buf_put_finish+0x1a>
		return -EINVAL;
   24bc8:	f06f 0015 	mvn.w	r0, #21
}
   24bcc:	4770      	bx	lr

00024bce <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
   24bce:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   24bd2:	4680      	mov	r8, r0
   24bd4:	460e      	mov	r6, r1
   24bd6:	4615      	mov	r5, r2
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
   24bd8:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
   24bda:	462a      	mov	r2, r5
   24bdc:	a901      	add	r1, sp, #4
   24bde:	4640      	mov	r0, r8
   24be0:	f7ff ffc3 	bl	24b6a <ring_buf_put_claim>
   24be4:	4604      	mov	r4, r0
		memcpy(dst, data, partial_size);
   24be6:	4602      	mov	r2, r0
   24be8:	4631      	mov	r1, r6
   24bea:	9801      	ldr	r0, [sp, #4]
   24bec:	f000 fa05 	bl	24ffa <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
   24bf0:	1b2d      	subs	r5, r5, r4
		total_size += partial_size;
   24bf2:	4427      	add	r7, r4
		data += partial_size;
   24bf4:	4426      	add	r6, r4
	} while (size && partial_size);
   24bf6:	d001      	beq.n	24bfc <ring_buf_put+0x2e>
   24bf8:	2c00      	cmp	r4, #0
   24bfa:	d1ee      	bne.n	24bda <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
   24bfc:	4639      	mov	r1, r7
   24bfe:	4640      	mov	r0, r8
   24c00:	f7ff ffd0 	bl	24ba4 <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
   24c04:	4638      	mov	r0, r7
   24c06:	b002      	add	sp, #8
   24c08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024c0c <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
   24c0c:	b5f0      	push	{r4, r5, r6, r7, lr}
   24c0e:	4604      	mov	r4, r0
   24c10:	4694      	mov	ip, r2
	uint32_t available_size, wrap_size;
	int32_t base;

	base = buf->get_base;
   24c12:	6986      	ldr	r6, [r0, #24]
	wrap_size = buf->get_head - base;
   24c14:	6905      	ldr	r5, [r0, #16]
 *
 * @return Ring buffer space used (in bytes).
 */
static inline uint32_t ring_buf_size_get(struct ring_buf *buf)
{
	return buf->put_tail - buf->get_head;
   24c16:	68a3      	ldr	r3, [r4, #8]
	if (unlikely(wrap_size >= buf->size)) {
   24c18:	69c0      	ldr	r0, [r0, #28]
	wrap_size = buf->get_head - base;
   24c1a:	1baf      	subs	r7, r5, r6
   24c1c:	1b5a      	subs	r2, r3, r5
	if (unlikely(wrap_size >= buf->size)) {
   24c1e:	42b8      	cmp	r0, r7
		/* get_base is not yet adjusted */
		wrap_size -= buf->size;
		base += buf->size;
   24c20:	bf9c      	itt	ls
   24c22:	1836      	addls	r6, r6, r0
		wrap_size -= buf->size;
   24c24:	1a3f      	subls	r7, r7, r0
	}
	wrap_size = buf->size - wrap_size;

	available_size = ring_buf_size_get(buf);
	size = MIN(size, available_size);
   24c26:	4562      	cmp	r2, ip
   24c28:	bf28      	it	cs
   24c2a:	4662      	movcs	r2, ip
	wrap_size = buf->size - wrap_size;
   24c2c:	1bc0      	subs	r0, r0, r7
	size = MIN(size, wrap_size);
   24c2e:	4290      	cmp	r0, r2
   24c30:	bf28      	it	cs
   24c32:	4610      	movcs	r0, r2

	*data = &buf->buffer[buf->get_head - base];
   24c34:	6823      	ldr	r3, [r4, #0]
   24c36:	1bad      	subs	r5, r5, r6
   24c38:	442b      	add	r3, r5
   24c3a:	600b      	str	r3, [r1, #0]
	buf->get_head += size;
   24c3c:	6923      	ldr	r3, [r4, #16]
   24c3e:	4403      	add	r3, r0
   24c40:	6123      	str	r3, [r4, #16]

	return size;
}
   24c42:	bdf0      	pop	{r4, r5, r6, r7, pc}

00024c44 <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->get_head - buf->get_tail;
   24c44:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
   24c48:	1ad2      	subs	r2, r2, r3
	if (unlikely(size > finish_space)) {
   24c4a:	428a      	cmp	r2, r1
   24c4c:	d30c      	bcc.n	24c68 <ring_buf_get_finish+0x24>
		return -EINVAL;
	}

	buf->get_tail += size;
   24c4e:	4419      	add	r1, r3
	buf->get_head = buf->get_tail;
   24c50:	e9c0 1104 	strd	r1, r1, [r0, #16]

	wrap_size = buf->get_tail - buf->get_base;
	if (unlikely(wrap_size >= buf->size)) {
   24c54:	e9d0 3206 	ldrd	r3, r2, [r0, #24]
	wrap_size = buf->get_tail - buf->get_base;
   24c58:	1ac9      	subs	r1, r1, r3
	if (unlikely(wrap_size >= buf->size)) {
   24c5a:	428a      	cmp	r2, r1
   24c5c:	d901      	bls.n	24c62 <ring_buf_get_finish+0x1e>
		/* we wrapped: adjust get_base */
		buf->get_base += buf->size;
	}

	return 0;
   24c5e:	2000      	movs	r0, #0
   24c60:	4770      	bx	lr
		buf->get_base += buf->size;
   24c62:	4413      	add	r3, r2
   24c64:	6183      	str	r3, [r0, #24]
   24c66:	e7fa      	b.n	24c5e <ring_buf_get_finish+0x1a>
		return -EINVAL;
   24c68:	f06f 0015 	mvn.w	r0, #21
}
   24c6c:	4770      	bx	lr

00024c6e <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
   24c6e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   24c72:	4680      	mov	r8, r0
   24c74:	460d      	mov	r5, r1
   24c76:	4616      	mov	r6, r2
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
   24c78:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
   24c7a:	4632      	mov	r2, r6
   24c7c:	4640      	mov	r0, r8
   24c7e:	a901      	add	r1, sp, #4
   24c80:	f7ff ffc4 	bl	24c0c <ring_buf_get_claim>
   24c84:	4604      	mov	r4, r0
		if (data) {
   24c86:	b12d      	cbz	r5, 24c94 <ring_buf_get+0x26>
			memcpy(data, src, partial_size);
   24c88:	4602      	mov	r2, r0
   24c8a:	9901      	ldr	r1, [sp, #4]
   24c8c:	4628      	mov	r0, r5
   24c8e:	f000 f9b4 	bl	24ffa <memcpy>
			data += partial_size;
   24c92:	4425      	add	r5, r4
		}
		total_size += partial_size;
		size -= partial_size;
	} while (size && partial_size);
   24c94:	1b36      	subs	r6, r6, r4
		total_size += partial_size;
   24c96:	4427      	add	r7, r4
	} while (size && partial_size);
   24c98:	d001      	beq.n	24c9e <ring_buf_get+0x30>
   24c9a:	2c00      	cmp	r4, #0
   24c9c:	d1ed      	bne.n	24c7a <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
   24c9e:	4639      	mov	r1, r7
   24ca0:	4640      	mov	r0, r8
   24ca2:	f7ff ffcf 	bl	24c44 <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
   24ca6:	4638      	mov	r0, r7
   24ca8:	b002      	add	sp, #8
   24caa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024cae <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_MCUBOOT_SIGNATURE_KEY_FILE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_MCUBOOT_EXTRA_IMGTOOL_ARGS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_MCUBOOT_BOOTLOADER_MODE_SWAP_WITHOUT_SCRATCH, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   24cae:	4770      	bx	lr

00024cb0 <nordicsemi_nrf53_init>:
{
   24cb0:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   24cb2:	f04f 0320 	mov.w	r3, #32
   24cb6:	f3ef 8511 	mrs	r5, BASEPRI
   24cba:	f383 8812 	msr	BASEPRI_MAX, r3
   24cbe:	f3bf 8f6f 	isb	sy
}

NRF_STATIC_INLINE void nrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS_Type *     p_reg,
                                                    nrf_oscillators_lfxo_cap_t cap)
{
    p_reg->XOSC32KI.INTCAP = (uint32_t)cap;
   24cc2:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   24cc6:	2401      	movs	r4, #1
   24cc8:	2202      	movs	r2, #2
		soc_secure_gpio_pin_mcu_select(forwarded_psels[i], NRF_GPIO_PIN_SEL_NETWORK);
   24cca:	4621      	mov	r1, r4
   24ccc:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
   24cd0:	202b      	movs	r0, #43	; 0x2b
   24cd2:	f8c3 4704 	str.w	r4, [r3, #1796]	; 0x704
#endif

#if NRF_REGULATORS_HAS_DCDCEN_RADIO
NRF_STATIC_INLINE void nrf_regulators_dcdcen_radio_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
    p_reg->VREGRADIO.DCDCEN = (enable) ? REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Enabled :
   24cd6:	f8c3 4904 	str.w	r4, [r3, #2308]	; 0x904
    p_reg->VREGH.DCDCEN = (enable) ? REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled :
   24cda:	f8c3 4b00 	str.w	r4, [r3, #2816]	; 0xb00
   24cde:	f000 f824 	bl	24d2a <soc_secure_gpio_pin_mcu_select>
   24ce2:	4621      	mov	r1, r4
   24ce4:	202c      	movs	r0, #44	; 0x2c
   24ce6:	f000 f820 	bl	24d2a <soc_secure_gpio_pin_mcu_select>
   24cea:	4621      	mov	r1, r4
   24cec:	202a      	movs	r0, #42	; 0x2a
   24cee:	f000 f81c 	bl	24d2a <soc_secure_gpio_pin_mcu_select>
   24cf2:	4621      	mov	r1, r4
   24cf4:	201e      	movs	r0, #30
   24cf6:	f000 f818 	bl	24d2a <soc_secure_gpio_pin_mcu_select>
	__asm__ volatile(
   24cfa:	f385 8811 	msr	BASEPRI, r5
   24cfe:	f3bf 8f6f 	isb	sy
}
   24d02:	2000      	movs	r0, #0
   24d04:	bd38      	pop	{r3, r4, r5, pc}

00024d06 <pm_state_set>:
/* Invoke Low Power/System Off specific Tasks */
__weak void pm_state_set(enum pm_state state, uint8_t substate_id)
{
	ARG_UNUSED(substate_id);

	switch (state) {
   24d06:	2806      	cmp	r0, #6
   24d08:	d108      	bne.n	24d1c <pm_state_set+0x16>
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
   24d0a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   24d0e:	2201      	movs	r2, #1
   24d10:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   24d14:	f3bf 8f4f 	dsb	sy
        __WFE();
   24d18:	bf20      	wfe
    while (true)
   24d1a:	e7fd      	b.n	24d18 <pm_state_set+0x12>
		break;
	default:
		LOG_DBG("Unsupported power state %u", state);
		break;
	}
}
   24d1c:	4770      	bx	lr

00024d1e <pm_state_exit_post_ops>:
   24d1e:	2300      	movs	r3, #0
   24d20:	f383 8811 	msr	BASEPRI, r3
   24d24:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   24d28:	4770      	bx	lr

00024d2a <soc_secure_gpio_pin_mcu_select>:
#include "tfm_platform_api.h"
#include "tfm_ioctl_api.h"

#if NRF_GPIO_HAS_SEL
void soc_secure_gpio_pin_mcu_select(uint32_t pin_number, nrf_gpio_pin_sel_t mcu)
{
   24d2a:	b507      	push	{r0, r1, r2, lr}
	uint32_t result;
	enum tfm_platform_err_t err;

	err = tfm_platform_gpio_pin_mcu_select(pin_number, mcu, &result);
   24d2c:	aa01      	add	r2, sp, #4
   24d2e:	f000 fd65 	bl	257fc <tfm_platform_gpio_pin_mcu_select>
	__ASSERT(err == TFM_PLATFORM_ERR_SUCCESS, "TFM platform error (%d)", err);
	__ASSERT(result == 0, "GPIO service error (%d)", result);
}
   24d32:	b003      	add	sp, #12
   24d34:	f85d fb04 	ldr.w	pc, [sp], #4

00024d38 <soc_secure_mem_read>:
#endif /* NRF_GPIO_HAS_SEL */

int soc_secure_mem_read(void *dst, void *src, size_t len)
{
   24d38:	b507      	push	{r0, r1, r2, lr}
	enum tfm_platform_err_t status;
	uint32_t result;

	status = tfm_platform_mem_read(dst, (uintptr_t)src, len, &result);
   24d3a:	ab01      	add	r3, sp, #4
   24d3c:	f000 fd46 	bl	257cc <tfm_platform_mem_read>

	switch (status) {
   24d40:	2802      	cmp	r0, #2
   24d42:	d00a      	beq.n	24d5a <soc_secure_mem_read+0x22>
   24d44:	2803      	cmp	r0, #3
   24d46:	d00b      	beq.n	24d60 <soc_secure_mem_read+0x28>
   24d48:	b968      	cbnz	r0, 24d66 <soc_secure_mem_read+0x2e>
	case TFM_PLATFORM_ERR_INVALID_PARAM:
		return -EINVAL;
	case TFM_PLATFORM_ERR_NOT_SUPPORTED:
		return -ENOTSUP;
	case TFM_PLATFORM_ERR_SUCCESS:
		if (result == 0) {
   24d4a:	9801      	ldr	r0, [sp, #4]
   24d4c:	3800      	subs	r0, #0
   24d4e:	bf18      	it	ne
   24d50:	2001      	movne	r0, #1
   24d52:	4240      	negs	r0, r0
		}
		/* Fallthrough */
	default:
		return -EPERM;
	}
}
   24d54:	b003      	add	sp, #12
   24d56:	f85d fb04 	ldr.w	pc, [sp], #4
		return -EINVAL;
   24d5a:	f06f 0015 	mvn.w	r0, #21
   24d5e:	e7f9      	b.n	24d54 <soc_secure_mem_read+0x1c>
	switch (status) {
   24d60:	f06f 0085 	mvn.w	r0, #133	; 0x85
   24d64:	e7f6      	b.n	24d54 <soc_secure_mem_read+0x1c>
		return -EPERM;
   24d66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24d6a:	e7f3      	b.n	24d54 <soc_secure_mem_read+0x1c>

00024d6c <get_ep_bm_from_addr>:
	if (ep_idx > 15) {
   24d6c:	f010 0f70 	tst.w	r0, #112	; 0x70
   24d70:	d109      	bne.n	24d86 <get_ep_bm_from_addr+0x1a>
	ep_idx = ep & (~USB_EP_DIR_IN);
   24d72:	f000 037f 	and.w	r3, r0, #127	; 0x7f
	if (ep & USB_EP_DIR_IN) {
   24d76:	f010 0f80 	tst.w	r0, #128	; 0x80
   24d7a:	f04f 0001 	mov.w	r0, #1
		ep_bm = BIT(ep_idx + 16);
   24d7e:	bf18      	it	ne
   24d80:	3310      	addne	r3, #16
		ep_bm = BIT(ep_idx);
   24d82:	4098      	lsls	r0, r3
   24d84:	4770      	bx	lr
	uint32_t ep_bm = 0;
   24d86:	2000      	movs	r0, #0
}
   24d88:	4770      	bx	lr

00024d8a <usb_write>:
{
   24d8a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   24d8e:	4606      	mov	r6, r0
   24d90:	460f      	mov	r7, r1
   24d92:	4690      	mov	r8, r2
   24d94:	4699      	mov	r9, r3
   24d96:	2504      	movs	r5, #4
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   24d98:	464b      	mov	r3, r9
   24d9a:	4642      	mov	r2, r8
   24d9c:	4639      	mov	r1, r7
   24d9e:	4630      	mov	r0, r6
   24da0:	f7fa fbb8 	bl	1f514 <usb_dc_ep_write>
		if (ret == -EAGAIN) {
   24da4:	f110 0f0b 	cmn.w	r0, #11
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   24da8:	4604      	mov	r4, r0
		if (ret == -EAGAIN) {
   24daa:	d103      	bne.n	24db4 <usb_write+0x2a>
	z_impl_k_yield();
   24dac:	f7fe ffd2 	bl	23d54 <z_impl_k_yield>
	} while (ret == -EAGAIN && tries--);
   24db0:	3d01      	subs	r5, #1
   24db2:	d1f1      	bne.n	24d98 <usb_write+0xe>
}
   24db4:	4620      	mov	r0, r4
   24db6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00024dba <usb_get_dev_data_by_cfg>:
	return list->head;
   24dba:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_cfg(sys_slist_t *list,
					     struct usb_cfg_data *cfg)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dbc:	b138      	cbz	r0, 24dce <usb_get_dev_data_by_cfg+0x14>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg_cur = dev->config;
   24dbe:	f850 3c04 	ldr.w	r3, [r0, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dc2:	3804      	subs	r0, #4

		if (cfg_cur == cfg) {
   24dc4:	685b      	ldr	r3, [r3, #4]
   24dc6:	428b      	cmp	r3, r1
   24dc8:	d001      	beq.n	24dce <usb_get_dev_data_by_cfg+0x14>
	return node->next;
   24dca:	6840      	ldr	r0, [r0, #4]
   24dcc:	e7f6      	b.n	24dbc <usb_get_dev_data_by_cfg+0x2>
	}

	LOG_DBG("Device data not found for cfg %p", cfg);

	return NULL;
}
   24dce:	4770      	bx	lr

00024dd0 <usb_get_dev_data_by_iface>:
	return list->head;
   24dd0:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_iface(sys_slist_t *list,
					       uint8_t iface_num)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dd2:	b148      	cbz	r0, 24de8 <usb_get_dev_data_by_iface+0x18>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
   24dd4:	f850 3c04 	ldr.w	r3, [r0, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dd8:	3804      	subs	r0, #4
		const struct usb_if_descriptor *if_desc =
   24dda:	685b      	ldr	r3, [r3, #4]
						cfg->interface_descriptor;

		if (if_desc->bInterfaceNumber == iface_num) {
   24ddc:	685b      	ldr	r3, [r3, #4]
   24dde:	789b      	ldrb	r3, [r3, #2]
   24de0:	428b      	cmp	r3, r1
   24de2:	d001      	beq.n	24de8 <usb_get_dev_data_by_iface+0x18>
	return node->next;
   24de4:	6840      	ldr	r0, [r0, #4]
   24de6:	e7f4      	b.n	24dd2 <usb_get_dev_data_by_iface+0x2>
	}

	LOG_DBG("Device data not found for iface number %u", iface_num);

	return NULL;
}
   24de8:	4770      	bx	lr

00024dea <usb_get_dev_data_by_ep>:

struct usb_dev_data *usb_get_dev_data_by_ep(sys_slist_t *list, uint8_t ep)
{
   24dea:	b530      	push	{r4, r5, lr}
	return list->head;
   24dec:	6800      	ldr	r0, [r0, #0]
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dee:	b188      	cbz	r0, 24e14 <usb_get_dev_data_by_ep+0x2a>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
   24df0:	f850 3c04 	ldr.w	r3, [r0, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24df4:	3804      	subs	r0, #4
		const struct usb_cfg_data *cfg = dev->config;
   24df6:	685b      	ldr	r3, [r3, #4]
		const struct usb_ep_cfg_data *ep_data = cfg->endpoint;
   24df8:	6a1a      	ldr	r2, [r3, #32]

		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
   24dfa:	7f1d      	ldrb	r5, [r3, #28]
   24dfc:	2300      	movs	r3, #0
			if (ep_data[i].ep_addr == ep) {
   24dfe:	3a04      	subs	r2, #4
		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
   24e00:	b2dc      	uxtb	r4, r3
   24e02:	42a5      	cmp	r5, r4
   24e04:	d801      	bhi.n	24e0a <usb_get_dev_data_by_ep+0x20>
	return node->next;
   24e06:	6840      	ldr	r0, [r0, #4]
   24e08:	e7f1      	b.n	24dee <usb_get_dev_data_by_ep+0x4>
			if (ep_data[i].ep_addr == ep) {
   24e0a:	3301      	adds	r3, #1
   24e0c:	f812 4033 	ldrb.w	r4, [r2, r3, lsl #3]
   24e10:	428c      	cmp	r4, r1
   24e12:	d1f5      	bne.n	24e00 <usb_get_dev_data_by_ep+0x16>
	}

	LOG_DBG("Device data not found for ep %u", ep);

	return NULL;
}
   24e14:	bd30      	pop	{r4, r5, pc}

00024e16 <usb_transfer_is_busy>:
{
   24e16:	b508      	push	{r3, lr}
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);
   24e18:	f7f8 fee0 	bl	1dbdc <usb_ep_get_transfer>
	if (trans && trans->status == -EBUSY) {
   24e1c:	b128      	cbz	r0, 24e2a <usb_transfer_is_busy+0x14>
   24e1e:	6840      	ldr	r0, [r0, #4]
   24e20:	f110 0f10 	cmn.w	r0, #16
   24e24:	bf14      	ite	ne
   24e26:	2000      	movne	r0, #0
   24e28:	2001      	moveq	r0, #1
}
   24e2a:	bd08      	pop	{r3, pc}

00024e2c <cdc_interface_config>:
	desc->if1.bInterfaceNumber = bInterfaceNumber + 1;
   24e2c:	1c4b      	adds	r3, r1, #1
   24e2e:	b2db      	uxtb	r3, r3
	desc->if0.bInterfaceNumber = bInterfaceNumber;
   24e30:	7081      	strb	r1, [r0, #2]
	desc->if0_union.bControlInterface = bInterfaceNumber;
   24e32:	7681      	strb	r1, [r0, #26]
	desc->if1.bInterfaceNumber = bInterfaceNumber + 1;
   24e34:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
	desc->if0_union.bSubordinateInterface0 = bInterfaceNumber + 1;
   24e38:	76c3      	strb	r3, [r0, #27]
	desc->iad_cdc.bFirstInterface = bInterfaceNumber;
   24e3a:	f800 1c06 	strb.w	r1, [r0, #-6]
}
   24e3e:	4770      	bx	lr

00024e40 <cdc_acm_irq_callback_work_handler>:
	dev_data->cb(dev_data->common.dev, dev_data->cb_data);
   24e40:	e950 3102 	ldrd	r3, r1, [r0, #-8]
   24e44:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
   24e48:	4718      	bx	r3

00024e4a <cdc_acm_irq_tx_disable>:
	dev_data->tx_irq_ena = false;
   24e4a:	2200      	movs	r2, #0
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e4c:	6903      	ldr	r3, [r0, #16]
	dev_data->tx_irq_ena = false;
   24e4e:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
}
   24e52:	4770      	bx	lr

00024e54 <cdc_acm_irq_tx_ready>:
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e54:	6903      	ldr	r3, [r0, #16]
	if (dev_data->tx_irq_ena && dev_data->tx_ready) {
   24e56:	f893 004a 	ldrb.w	r0, [r3, #74]	; 0x4a
   24e5a:	b108      	cbz	r0, 24e60 <cdc_acm_irq_tx_ready+0xc>
   24e5c:	f893 0048 	ldrb.w	r0, [r3, #72]	; 0x48
}
   24e60:	4770      	bx	lr

00024e62 <cdc_acm_irq_rx_disable>:
	dev_data->rx_irq_ena = false;
   24e62:	2200      	movs	r2, #0
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e64:	6903      	ldr	r3, [r0, #16]
	dev_data->rx_irq_ena = false;
   24e66:	f883 204b 	strb.w	r2, [r3, #75]	; 0x4b
}
   24e6a:	4770      	bx	lr

00024e6c <cdc_acm_irq_rx_ready>:
	if (dev_data->rx_ready) {
   24e6c:	6903      	ldr	r3, [r0, #16]
}
   24e6e:	f893 0049 	ldrb.w	r0, [r3, #73]	; 0x49
   24e72:	4770      	bx	lr

00024e74 <cdc_acm_irq_is_pending>:
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e74:	6903      	ldr	r3, [r0, #16]
	if (dev_data->tx_ready && dev_data->tx_irq_ena) {
   24e76:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
   24e7a:	b112      	cbz	r2, 24e82 <cdc_acm_irq_is_pending+0xe>
   24e7c:	f893 204a 	ldrb.w	r2, [r3, #74]	; 0x4a
   24e80:	b92a      	cbnz	r2, 24e8e <cdc_acm_irq_is_pending+0x1a>
	} else if (dev_data->rx_ready && dev_data->rx_irq_ena) {
   24e82:	f893 0049 	ldrb.w	r0, [r3, #73]	; 0x49
   24e86:	b118      	cbz	r0, 24e90 <cdc_acm_irq_is_pending+0x1c>
   24e88:	f893 004b 	ldrb.w	r0, [r3, #75]	; 0x4b
   24e8c:	4770      	bx	lr
		return 1;
   24e8e:	2001      	movs	r0, #1
}
   24e90:	4770      	bx	lr

00024e92 <cdc_acm_irq_update>:
}
   24e92:	2001      	movs	r0, #1
   24e94:	4770      	bx	lr

00024e96 <cdc_acm_irq_callback_set>:
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e96:	6903      	ldr	r3, [r0, #16]
	dev_data->cb_data = cb_data;
   24e98:	e9c3 1200 	strd	r1, r2, [r3]
}
   24e9c:	4770      	bx	lr

00024e9e <cdc_acm_configure>:
}
   24e9e:	2000      	movs	r0, #0
   24ea0:	4770      	bx	lr

00024ea2 <cdc_acm_config_get>:
{
   24ea2:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24ea4:	6903      	ldr	r3, [r0, #16]
	cfg->baudrate = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
   24ea6:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
   24eaa:	600a      	str	r2, [r1, #0]
	switch (dev_data->line_coding.bCharFormat) {
   24eac:	f893 2098 	ldrb.w	r2, [r3, #152]	; 0x98
   24eb0:	b16a      	cbz	r2, 24ece <cdc_acm_config_get+0x2c>
   24eb2:	2a01      	cmp	r2, #1
   24eb4:	bf0c      	ite	eq
   24eb6:	2202      	moveq	r2, #2
   24eb8:	2203      	movne	r2, #3
		cfg->stop_bits = UART_CFG_STOP_BITS_1;
   24eba:	714a      	strb	r2, [r1, #5]
	switch (dev_data->line_coding.bParityType) {
   24ebc:	f893 2099 	ldrb.w	r2, [r3, #153]	; 0x99
   24ec0:	1e50      	subs	r0, r2, #1
   24ec2:	2803      	cmp	r0, #3
   24ec4:	d805      	bhi.n	24ed2 <cdc_acm_config_get+0x30>
   24ec6:	e8df f000 	tbb	[pc, r0]
   24eca:	0505      	.short	0x0505
   24ecc:	0505      	.short	0x0505
	switch (dev_data->line_coding.bCharFormat) {
   24ece:	2201      	movs	r2, #1
   24ed0:	e7f3      	b.n	24eba <cdc_acm_config_get+0x18>
	switch (dev_data->line_coding.bParityType) {
   24ed2:	2200      	movs	r2, #0
		cfg->parity = UART_CFG_PARITY_NONE;
   24ed4:	710a      	strb	r2, [r1, #4]
	switch (dev_data->line_coding.bDataBits) {
   24ed6:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
   24eda:	2b06      	cmp	r3, #6
   24edc:	d009      	beq.n	24ef2 <cdc_acm_config_get+0x50>
   24ede:	2b07      	cmp	r3, #7
   24ee0:	d009      	beq.n	24ef6 <cdc_acm_config_get+0x54>
   24ee2:	2b05      	cmp	r3, #5
   24ee4:	bf0c      	ite	eq
   24ee6:	2300      	moveq	r3, #0
   24ee8:	2303      	movne	r3, #3
	cfg->flow_ctrl = UART_CFG_FLOW_CTRL_NONE;
   24eea:	2000      	movs	r0, #0
		cfg->data_bits = UART_CFG_DATA_BITS_5;
   24eec:	718b      	strb	r3, [r1, #6]
	cfg->flow_ctrl = UART_CFG_FLOW_CTRL_NONE;
   24eee:	71c8      	strb	r0, [r1, #7]
}
   24ef0:	bd10      	pop	{r4, pc}
	switch (dev_data->line_coding.bDataBits) {
   24ef2:	2301      	movs	r3, #1
   24ef4:	e7f9      	b.n	24eea <cdc_acm_config_get+0x48>
   24ef6:	2302      	movs	r3, #2
   24ef8:	e7f7      	b.n	24eea <cdc_acm_config_get+0x48>

00024efa <cdc_acm_fifo_read>:
{
   24efa:	b570      	push	{r4, r5, r6, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24efc:	6904      	ldr	r4, [r0, #16]
{
   24efe:	4605      	mov	r5, r0
	len = ring_buf_get(dev_data->rx_ringbuf, rx_data, size);
   24f00:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   24f04:	f7ff feb3 	bl	24c6e <ring_buf_get>
	if (ring_buf_is_empty(dev_data->rx_ringbuf)) {
   24f08:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
	len = ring_buf_get(dev_data->rx_ringbuf, rx_data, size);
   24f0c:	4606      	mov	r6, r0
	if (ring_buf_is_empty(dev_data->rx_ringbuf)) {
   24f0e:	691a      	ldr	r2, [r3, #16]
   24f10:	6899      	ldr	r1, [r3, #8]
   24f12:	4291      	cmp	r1, r2
		dev_data->rx_ready = false;
   24f14:	bf04      	itt	eq
   24f16:	2200      	moveq	r2, #0
   24f18:	f884 2049 	strbeq.w	r2, [r4, #73]	; 0x49
	if (dev_data->rx_paused == true) {
   24f1c:	f894 20a0 	ldrb.w	r2, [r4, #160]	; 0xa0
   24f20:	b19a      	cbz	r2, 24f4a <cdc_acm_fifo_read+0x50>
	return buf->size - (buf->put_head - buf->get_tail);
   24f22:	685a      	ldr	r2, [r3, #4]
   24f24:	6959      	ldr	r1, [r3, #20]
   24f26:	69db      	ldr	r3, [r3, #28]
   24f28:	1a52      	subs	r2, r2, r1
   24f2a:	1a9b      	subs	r3, r3, r2
		if (ring_buf_space_get(dev_data->rx_ringbuf) >= CDC_ACM_BUFFER_SIZE) {
   24f2c:	2b3f      	cmp	r3, #63	; 0x3f
   24f2e:	d90c      	bls.n	24f4a <cdc_acm_fifo_read+0x50>
			if (dev_data->configured) {
   24f30:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
   24f34:	b133      	cbz	r3, 24f44 <cdc_acm_fifo_read+0x4a>
				cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr, 0, dev_data);
   24f36:	686b      	ldr	r3, [r5, #4]
   24f38:	4622      	mov	r2, r4
   24f3a:	6a1b      	ldr	r3, [r3, #32]
   24f3c:	2100      	movs	r1, #0
   24f3e:	7b18      	ldrb	r0, [r3, #12]
   24f40:	f7f9 f91a 	bl	1e178 <cdc_acm_read_cb>
			dev_data->rx_paused = false;
   24f44:	2300      	movs	r3, #0
   24f46:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
}
   24f4a:	4630      	mov	r0, r6
   24f4c:	bd70      	pop	{r4, r5, r6, pc}

00024f4e <cdc_acm_poll_in>:
	int ret = cdc_acm_fifo_read(dev, c, 1);
   24f4e:	2201      	movs	r2, #1
{
   24f50:	b508      	push	{r3, lr}
	int ret = cdc_acm_fifo_read(dev, c, 1);
   24f52:	f7ff ffd2 	bl	24efa <cdc_acm_fifo_read>
}
   24f56:	3801      	subs	r0, #1
   24f58:	bf18      	it	ne
   24f5a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   24f5e:	bd08      	pop	{r3, pc}

00024f60 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   24f60:	f000 bdcf 	b.w	25b02 <z_fatal_error>

00024f64 <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
   24f64:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
   24f66:	6800      	ldr	r0, [r0, #0]
   24f68:	f000 bdcb 	b.w	25b02 <z_fatal_error>

00024f6c <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   24f6c:	2100      	movs	r1, #0
   24f6e:	2001      	movs	r0, #1
   24f70:	f7ff bff6 	b.w	24f60 <z_arm_fatal_error>

00024f74 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
   24f74:	b508      	push	{r3, lr}
	handler();
   24f76:	f7f9 fa05 	bl	1e384 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   24f7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   24f7e:	f7f9 bacd 	b.w	1e51c <z_arm_exc_exit>

00024f82 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   24f82:	6e43      	ldr	r3, [r0, #100]	; 0x64
   24f84:	f383 880b 	msr	PSPLIM, r3
}
   24f88:	4770      	bx	lr

00024f8a <z_arm_save_fp_context>:
		 * here though, since FPCA should have no impact on instruction
		 * fetching.
		 */
	}
#endif
}
   24f8a:	4770      	bx	lr

00024f8c <z_arm_restore_fp_context>:

void z_arm_restore_fp_context(const struct fpu_ctx_full *buffer)
   24f8c:	4770      	bx	lr

00024f8e <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   24f8e:	e840 f300 	tt	r3, r0
int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
		return addr_info.flags.mpu_region;
   24f92:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   24f96:	b2d8      	uxtb	r0, r3
	}

	return -EINVAL;
}
   24f98:	bf08      	it	eq
   24f9a:	f06f 0015 	mvneq.w	r0, #21
   24f9e:	4770      	bx	lr

00024fa0 <mpu_configure_region>:
{
   24fa0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	p_attr->rbar = attr->rbar &
   24fa2:	890a      	ldrh	r2, [r1, #8]
   24fa4:	894e      	ldrh	r6, [r1, #10]
	region_conf.base = new_region->start;
   24fa6:	680b      	ldr	r3, [r1, #0]
		&new_region->attr, new_region->start, new_region->size);
   24fa8:	684d      	ldr	r5, [r1, #4]
   24faa:	f002 021f 	and.w	r2, r2, #31
   24fae:	ea42 1246 	orr.w	r2, r2, r6, lsl #5
	region_conf.base = new_region->start;
   24fb2:	9300      	str	r3, [sp, #0]
   24fb4:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   24fb8:	f023 031f 	bic.w	r3, r3, #31
   24fbc:	1e6a      	subs	r2, r5, #1
   24fbe:	4413      	add	r3, r2
   24fc0:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1U)) {
   24fc4:	2807      	cmp	r0, #7
   24fc6:	9303      	str	r3, [sp, #12]
   24fc8:	d804      	bhi.n	24fd4 <mpu_configure_region+0x34>
	region_init(index, region_conf);
   24fca:	4669      	mov	r1, sp
   24fcc:	f7f9 fcb4 	bl	1e938 <region_init>
}
   24fd0:	b004      	add	sp, #16
   24fd2:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   24fd4:	f06f 0015 	mvn.w	r0, #21
	return region_allocate_and_init(index,
   24fd8:	e7fa      	b.n	24fd0 <mpu_configure_region+0x30>

00024fda <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   24fda:	4603      	mov	r3, r0
	size_t n = 0;
   24fdc:	2000      	movs	r0, #0

	while (*s != '\0') {
   24fde:	5c1a      	ldrb	r2, [r3, r0]
   24fe0:	b902      	cbnz	r2, 24fe4 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   24fe2:	4770      	bx	lr
		n++;
   24fe4:	3001      	adds	r0, #1
   24fe6:	e7fa      	b.n	24fde <strlen+0x4>

00024fe8 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   24fe8:	4603      	mov	r3, r0
	size_t n = 0;
   24fea:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   24fec:	5c1a      	ldrb	r2, [r3, r0]
   24fee:	b10a      	cbz	r2, 24ff4 <strnlen+0xc>
   24ff0:	4288      	cmp	r0, r1
   24ff2:	d100      	bne.n	24ff6 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   24ff4:	4770      	bx	lr
		n++;
   24ff6:	3001      	adds	r0, #1
   24ff8:	e7f8      	b.n	24fec <strnlen+0x4>

00024ffa <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   24ffa:	b510      	push	{r4, lr}
   24ffc:	1e43      	subs	r3, r0, #1
   24ffe:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   25000:	4291      	cmp	r1, r2
   25002:	d100      	bne.n	25006 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   25004:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   25006:	f811 4b01 	ldrb.w	r4, [r1], #1
   2500a:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   2500e:	e7f7      	b.n	25000 <memcpy+0x6>

00025010 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   25010:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
   25012:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   25014:	4402      	add	r2, r0
   25016:	4293      	cmp	r3, r2
   25018:	d100      	bne.n	2501c <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   2501a:	4770      	bx	lr
		*(d_byte++) = c_byte;
   2501c:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   25020:	e7f9      	b.n	25016 <memset+0x6>

00025022 <_stdout_hook_default>:
}
   25022:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   25026:	4770      	bx	lr

00025028 <ep_ctx_reset>:
{
   25028:	b510      	push	{r4, lr}
	ep_ctx->buf.data = ep_ctx->buf.block.data;
   2502a:	6903      	ldr	r3, [r0, #16]
{
   2502c:	4604      	mov	r4, r0
	ep_ctx->buf.curr = ep_ctx->buf.data;
   2502e:	e9c0 3305 	strd	r3, r3, [r0, #20]
	ep_ctx->buf.len  = 0U;
   25032:	2300      	movs	r3, #0
   25034:	60c3      	str	r3, [r0, #12]
	if (ep_ctx->write_in_progress) {
   25036:	7f83      	ldrb	r3, [r0, #30]
   25038:	b113      	cbz	r3, 25040 <ep_ctx_reset+0x18>
		nrfx_usbd_ep_abort(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   2503a:	7a40      	ldrb	r0, [r0, #9]
   2503c:	f000 fd47 	bl	25ace <nrfx_usbd_ep_abort>
	ep_ctx->read_complete = true;
   25040:	2301      	movs	r3, #1
   25042:	7723      	strb	r3, [r4, #28]
	ep_ctx->read_pending = false;
   25044:	2300      	movs	r3, #0
   25046:	7763      	strb	r3, [r4, #29]
	ep_ctx->trans_zlp = false;
   25048:	77e3      	strb	r3, [r4, #31]
	ep_ctx->write_in_progress = false;
   2504a:	77a3      	strb	r3, [r4, #30]
}
   2504c:	bd10      	pop	{r4, pc}

0002504e <attached_evt_delay_handler>:
	submit_dc_power_event(USBD_ATTACHED);
   2504e:	2001      	movs	r0, #1
   25050:	f7f9 be58 	b.w	1ed04 <submit_dc_power_event>

00025054 <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
   25054:	f7fe b996 	b.w	23384 <z_impl_k_mutex_lock>

00025058 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
   25058:	f7fe ba0e 	b.w	23478 <z_impl_k_mutex_unlock>

0002505c <usb_dc_ep_check_cap>:
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
   2505c:	7803      	ldrb	r3, [r0, #0]
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
   2505e:	7901      	ldrb	r1, [r0, #4]
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
   25060:	f003 020f 	and.w	r2, r3, #15
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
   25064:	b921      	cbnz	r1, 25070 <usb_dc_ep_check_cap+0x14>
   25066:	3a00      	subs	r2, #0
   25068:	bf18      	it	ne
   2506a:	2201      	movne	r2, #1
   2506c:	4250      	negs	r0, r2
   2506e:	4770      	bx	lr
	if (!NRF_USBD_EP_VALIDATE(ep_cfg->ep_addr)) {
   25070:	2a08      	cmp	r2, #8
   25072:	d806      	bhi.n	25082 <usb_dc_ep_check_cap+0x26>
	if ((ep_cfg->ep_type == USB_DC_EP_ISOCHRONOUS) &&
   25074:	2901      	cmp	r1, #1
   25076:	d107      	bne.n	25088 <usb_dc_ep_check_cap+0x2c>
   25078:	f083 0008 	eor.w	r0, r3, #8
   2507c:	f340 00c0 	sbfx	r0, r0, #3, #1
   25080:	4770      	bx	lr
		return -1;
   25082:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   25086:	4770      	bx	lr
	return 0;
   25088:	2000      	movs	r0, #0
}
   2508a:	4770      	bx	lr

0002508c <usb_dc_ep_disable>:
{
   2508c:	b538      	push	{r3, r4, r5, lr}
   2508e:	4604      	mov	r4, r0
	ep_ctx = endpoint_ctx(ep);
   25090:	f7f9 fdd0 	bl	1ec34 <endpoint_ctx>
	if (!ep_ctx) {
   25094:	4605      	mov	r5, r0
   25096:	b160      	cbz	r0, 250b2 <usb_dc_ep_disable+0x26>
	if (!ep_ctx->cfg.en) {
   25098:	7a03      	ldrb	r3, [r0, #8]
   2509a:	b16b      	cbz	r3, 250b8 <usb_dc_ep_disable+0x2c>
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
   2509c:	4620      	mov	r0, r4
	ep_ctx->write_in_progress = false;
   2509e:	2400      	movs	r4, #0
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
   250a0:	f7fd fe0a 	bl	22cb8 <nrfx_usbd_ep_disable>
	ep_ctx_reset(ep_ctx);
   250a4:	4628      	mov	r0, r5
	ep_ctx->write_in_progress = false;
   250a6:	77ac      	strb	r4, [r5, #30]
	ep_ctx_reset(ep_ctx);
   250a8:	f7ff ffbe 	bl	25028 <ep_ctx_reset>
	return 0;
   250ac:	4620      	mov	r0, r4
	ep_ctx->cfg.en = false;
   250ae:	722c      	strb	r4, [r5, #8]
}
   250b0:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   250b2:	f06f 0015 	mvn.w	r0, #21
   250b6:	e7fb      	b.n	250b0 <usb_dc_ep_disable+0x24>
		return -EALREADY;
   250b8:	f06f 0077 	mvn.w	r0, #119	; 0x77
   250bc:	e7f8      	b.n	250b0 <usb_dc_ep_disable+0x24>

000250be <usb_dc_ep_read>:
{
   250be:	b570      	push	{r4, r5, r6, lr}
   250c0:	4604      	mov	r4, r0
   250c2:	460e      	mov	r6, r1
   250c4:	4615      	mov	r5, r2
	ret = usb_dc_ep_read_wait(ep, data, max_data_len, read_bytes);
   250c6:	f7fa faa1 	bl	1f60c <usb_dc_ep_read_wait>
	if (ret) {
   250ca:	b930      	cbnz	r0, 250da <usb_dc_ep_read+0x1c>
	if (!data && !max_data_len) {
   250cc:	b906      	cbnz	r6, 250d0 <usb_dc_ep_read+0x12>
   250ce:	b125      	cbz	r5, 250da <usb_dc_ep_read+0x1c>
	ret = usb_dc_ep_read_continue(ep);
   250d0:	4620      	mov	r0, r4
}
   250d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = usb_dc_ep_read_continue(ep);
   250d6:	f7fa bae1 	b.w	1f69c <usb_dc_ep_read_continue>
}
   250da:	bd70      	pop	{r4, r5, r6, pc}

000250dc <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   250dc:	220c      	movs	r2, #12
   250de:	6903      	ldr	r3, [r0, #16]
   250e0:	b2c9      	uxtb	r1, r1
   250e2:	fb01 3302 	mla	r3, r1, r2, r3
   250e6:	6f98      	ldr	r0, [r3, #120]	; 0x78
}
   250e8:	f000 0007 	and.w	r0, r0, #7
   250ec:	4770      	bx	lr

000250ee <set_on_state>:
	__asm__ volatile(
   250ee:	f04f 0320 	mov.w	r3, #32
   250f2:	f3ef 8211 	mrs	r2, BASEPRI
   250f6:	f383 8812 	msr	BASEPRI_MAX, r3
   250fa:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   250fe:	6803      	ldr	r3, [r0, #0]
   25100:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   25104:	f043 0302 	orr.w	r3, r3, #2
   25108:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   2510a:	f382 8811 	msr	BASEPRI, r2
   2510e:	f3bf 8f6f 	isb	sy
}
   25112:	4770      	bx	lr

00025114 <stop>:
{
   25114:	b570      	push	{r4, r5, r6, lr}
   25116:	b2c9      	uxtb	r1, r1
	struct nrf_clock_control_data *data = dev->data;
   25118:	6903      	ldr	r3, [r0, #16]
	__asm__ volatile(
   2511a:	f04f 0420 	mov.w	r4, #32
   2511e:	f3ef 8511 	mrs	r5, BASEPRI
   25122:	f384 8812 	msr	BASEPRI_MAX, r4
   25126:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   2512a:	260c      	movs	r6, #12
   2512c:	fb06 3401 	mla	r4, r6, r1, r3
   25130:	6fa4      	ldr	r4, [r4, #120]	; 0x78
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   25132:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
   25136:	d008      	beq.n	2514a <stop+0x36>
   25138:	42a2      	cmp	r2, r4
   2513a:	d006      	beq.n	2514a <stop+0x36>
	__asm__ volatile(
   2513c:	f385 8811 	msr	BASEPRI, r5
   25140:	f3bf 8f6f 	isb	sy
		err = -EPERM;
   25144:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   25148:	bd70      	pop	{r4, r5, r6, pc}
		*flags = CLOCK_CONTROL_STATUS_OFF;
   2514a:	2201      	movs	r2, #1
   2514c:	fb06 3301 	mla	r3, r6, r1, r3
   25150:	679a      	str	r2, [r3, #120]	; 0x78
   25152:	f385 8811 	msr	BASEPRI, r5
   25156:	f3bf 8f6f 	isb	sy
	get_sub_config(dev, type)->stop();
   2515a:	6843      	ldr	r3, [r0, #4]
   2515c:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
   25160:	685b      	ldr	r3, [r3, #4]
   25162:	4798      	blx	r3
	return 0;
   25164:	2000      	movs	r0, #0
   25166:	e7ef      	b.n	25148 <stop+0x34>

00025168 <api_stop>:
	return stop(dev, subsys, CTX_API);
   25168:	2280      	movs	r2, #128	; 0x80
   2516a:	f7ff bfd3 	b.w	25114 <stop>

0002516e <async_start>:
{
   2516e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25170:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
   25172:	6904      	ldr	r4, [r0, #16]
	return &data->subsys[type];
   25174:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
   25176:	f04f 0520 	mov.w	r5, #32
   2517a:	f3ef 8611 	mrs	r6, BASEPRI
   2517e:	f385 8812 	msr	BASEPRI_MAX, r5
   25182:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   25186:	250c      	movs	r5, #12
   25188:	fb05 4401 	mla	r4, r5, r1, r4
   2518c:	6fa5      	ldr	r5, [r4, #120]	; 0x78
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   2518e:	f005 0c07 	and.w	ip, r5, #7
   25192:	f1bc 0f01 	cmp.w	ip, #1
   25196:	d10c      	bne.n	251b2 <async_start+0x44>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   25198:	67a7      	str	r7, [r4, #120]	; 0x78
	__asm__ volatile(
   2519a:	f386 8811 	msr	BASEPRI, r6
   2519e:	f3bf 8f6f 	isb	sy
	subdata->user_data = user_data;
   251a2:	e9c4 231c 	strd	r2, r3, [r4, #112]	; 0x70
	 get_sub_config(dev, type)->start();
   251a6:	6843      	ldr	r3, [r0, #4]
   251a8:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
   251ac:	4798      	blx	r3
	return 0;
   251ae:	2000      	movs	r0, #0
}
   251b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   251b2:	f005 05c0 	and.w	r5, r5, #192	; 0xc0
	} else if (current_ctx != ctx) {
   251b6:	42af      	cmp	r7, r5
   251b8:	f386 8811 	msr	BASEPRI, r6
   251bc:	f3bf 8f6f 	isb	sy
		err = -EALREADY;
   251c0:	bf0c      	ite	eq
   251c2:	f06f 0077 	mvneq.w	r0, #119	; 0x77
		err = -EPERM;
   251c6:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   251ca:	e7f1      	b.n	251b0 <async_start+0x42>

000251cc <api_start>:
{
   251cc:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
   251ce:	2480      	movs	r4, #128	; 0x80
   251d0:	9400      	str	r4, [sp, #0]
   251d2:	f7ff ffcc 	bl	2516e <async_start>
}
   251d6:	b002      	add	sp, #8
   251d8:	bd10      	pop	{r4, pc}

000251da <onoff_started_callback>:
{
   251da:	b410      	push	{r4}
	notify(mgr, 0);
   251dc:	241c      	movs	r4, #28
	return &data->mgr[type];
   251de:	6900      	ldr	r0, [r0, #16]
   251e0:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   251e2:	fb03 0004 	mla	r0, r3, r4, r0
   251e6:	2100      	movs	r1, #0
}
   251e8:	bc10      	pop	{r4}
	notify(mgr, 0);
   251ea:	4710      	bx	r2

000251ec <hfclkaudio_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   251ec:	2003      	movs	r0, #3
   251ee:	f7fb bd47 	b.w	20c80 <nrfx_clock_start>

000251f2 <hfclk192m_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK192M);
   251f2:	2002      	movs	r0, #2
   251f4:	f7fb bd44 	b.w	20c80 <nrfx_clock_start>

000251f8 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   251f8:	2000      	movs	r0, #0
   251fa:	f7fb bd41 	b.w	20c80 <nrfx_clock_start>

000251fe <hfclkaudio_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   251fe:	2003      	movs	r0, #3
   25200:	f000 bb19 	b.w	25836 <nrfx_clock_stop>

00025204 <hfclk192m_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK192M);
   25204:	2002      	movs	r0, #2
   25206:	f000 bb16 	b.w	25836 <nrfx_clock_stop>

0002520a <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   2520a:	2000      	movs	r0, #0
   2520c:	f000 bb13 	b.w	25836 <nrfx_clock_stop>

00025210 <blocking_start_callback>:
{
   25210:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   25212:	f7fe b9a1 	b.w	23558 <z_impl_k_sem_give>

00025216 <entropy_psa_crypto_rng_get_entropy>:
}

/* API implementation: get_entropy */
static int entropy_psa_crypto_rng_get_entropy(const struct device *dev,
					      uint8_t *buffer, uint16_t length)
{
   25216:	4608      	mov	r0, r1
   25218:	b508      	push	{r3, lr}
	psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

	ARG_UNUSED(dev);

	status = psa_generate_random(buffer, length);
   2521a:	4611      	mov	r1, r2
   2521c:	f7fb fbd6 	bl	209cc <psa_generate_random>
	if (status != PSA_SUCCESS) {
		return -EIO;
   25220:	2800      	cmp	r0, #0
	}

	return 0;
}
   25222:	bf18      	it	ne
   25224:	f06f 0004 	mvnne.w	r0, #4
   25228:	bd08      	pop	{r3, pc}

0002522a <entropy_psa_crypto_rng_init>:
{
   2522a:	b508      	push	{r3, lr}
	status = psa_crypto_init();
   2522c:	f000 facc 	bl	257c8 <psa_crypto_init>
		return -EIO;
   25230:	2800      	cmp	r0, #0
}
   25232:	bf18      	it	ne
   25234:	f06f 0004 	mvnne.w	r0, #4
   25238:	bd08      	pop	{r3, pc}

0002523a <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2523a:	6843      	ldr	r3, [r0, #4]
}
   2523c:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2523e:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   25240:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   25242:	600b      	str	r3, [r1, #0]
}
   25244:	4770      	bx	lr

00025246 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25246:	6843      	ldr	r3, [r0, #4]
	const uint32_t set_mask = value & mask;
   25248:	ea02 0001 	and.w	r0, r2, r1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2524c:	685b      	ldr	r3, [r3, #4]
	const uint32_t clear_mask = (~set_mask) & mask;
   2524e:	ea21 0102 	bic.w	r1, r1, r2
    p_reg->OUTSET = set_mask;
   25252:	6098      	str	r0, [r3, #8]
}
   25254:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   25256:	60d9      	str	r1, [r3, #12]
   25258:	4770      	bx	lr

0002525a <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2525a:	6843      	ldr	r3, [r0, #4]
}
   2525c:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2525e:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   25260:	6099      	str	r1, [r3, #8]
}
   25262:	4770      	bx	lr

00025264 <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25264:	6843      	ldr	r3, [r0, #4]
}
   25266:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25268:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   2526a:	60d9      	str	r1, [r3, #12]
}
   2526c:	4770      	bx	lr

0002526e <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2526e:	6843      	ldr	r3, [r0, #4]
   25270:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   25272:	6853      	ldr	r3, [r2, #4]
	const uint32_t set_mask = value & mask;
   25274:	ea21 0003 	bic.w	r0, r1, r3
	const uint32_t clear_mask = (~value) & mask;
   25278:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
   2527a:	6090      	str	r0, [r2, #8]
}
   2527c:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   2527e:	60d3      	str	r3, [r2, #12]
   25280:	4770      	bx	lr

00025282 <gpio_nrfx_manage_callback>:
{
   25282:	b510      	push	{r4, lr}
	return port->data;
   25284:	6903      	ldr	r3, [r0, #16]
	return list->head;
   25286:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   25288:	b1f8      	cbz	r0, 252ca <gpio_nrfx_manage_callback+0x48>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2528a:	4288      	cmp	r0, r1
   2528c:	d119      	bne.n	252c2 <gpio_nrfx_manage_callback+0x40>
Z_GENLIST_REMOVE(slist, snode)
   2528e:	689c      	ldr	r4, [r3, #8]
	return node->next;
   25290:	6808      	ldr	r0, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   25292:	42a1      	cmp	r1, r4
	list->head = node;
   25294:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   25296:	d100      	bne.n	2529a <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
   25298:	6098      	str	r0, [r3, #8]
	parent->next = child;
   2529a:	2000      	movs	r0, #0
   2529c:	6008      	str	r0, [r1, #0]
	if (set) {
   2529e:	b12a      	cbz	r2, 252ac <gpio_nrfx_manage_callback+0x2a>
	return list->head;
   252a0:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   252a2:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   252a4:	689a      	ldr	r2, [r3, #8]
	list->head = node;
   252a6:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   252a8:	b902      	cbnz	r2, 252ac <gpio_nrfx_manage_callback+0x2a>
	list->tail = node;
   252aa:	6099      	str	r1, [r3, #8]
	return 0;
   252ac:	2000      	movs	r0, #0
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   252ae:	e010      	b.n	252d2 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   252b0:	4281      	cmp	r1, r0
   252b2:	d106      	bne.n	252c2 <gpio_nrfx_manage_callback+0x40>
	return node->next;
   252b4:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
   252b6:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   252b8:	6898      	ldr	r0, [r3, #8]
   252ba:	4281      	cmp	r1, r0
   252bc:	d1ed      	bne.n	2529a <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
   252be:	609c      	str	r4, [r3, #8]
}
   252c0:	e7eb      	b.n	2529a <gpio_nrfx_manage_callback+0x18>
	return node->next;
   252c2:	4604      	mov	r4, r0
   252c4:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   252c6:	2800      	cmp	r0, #0
   252c8:	d1f2      	bne.n	252b0 <gpio_nrfx_manage_callback+0x2e>
			if (!set) {
   252ca:	2a00      	cmp	r2, #0
   252cc:	d1e8      	bne.n	252a0 <gpio_nrfx_manage_callback+0x1e>
				return -EINVAL;
   252ce:	f06f 0015 	mvn.w	r0, #21
}
   252d2:	bd10      	pop	{r4, pc}

000252d4 <i2c_nrfx_twim_configure>:
	if (I2C_ADDR_10_BITS & i2c_config) {
   252d4:	07ca      	lsls	r2, r1, #31
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   252d6:	6843      	ldr	r3, [r0, #4]
	if (I2C_ADDR_10_BITS & i2c_config) {
   252d8:	d416      	bmi.n	25308 <i2c_nrfx_twim_configure+0x34>
	switch (I2C_SPEED_GET(i2c_config)) {
   252da:	f3c1 0142 	ubfx	r1, r1, #1, #3
   252de:	2902      	cmp	r1, #2
   252e0:	d00a      	beq.n	252f8 <i2c_nrfx_twim_configure+0x24>
   252e2:	2903      	cmp	r1, #3
   252e4:	d00c      	beq.n	25300 <i2c_nrfx_twim_configure+0x2c>
   252e6:	2901      	cmp	r1, #1
   252e8:	d10e      	bne.n	25308 <i2c_nrfx_twim_configure+0x34>
    p_reg->FREQUENCY = frequency;
   252ea:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   252ee:	681b      	ldr	r3, [r3, #0]
	return 0;
   252f0:	2000      	movs	r0, #0
   252f2:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
   252f6:	4770      	bx	lr
   252f8:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   252fc:	681b      	ldr	r3, [r3, #0]
   252fe:	e7f7      	b.n	252f0 <i2c_nrfx_twim_configure+0x1c>
   25300:	f04f 627f 	mov.w	r2, #267386880	; 0xff00000
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   25304:	681b      	ldr	r3, [r3, #0]
   25306:	e7f3      	b.n	252f0 <i2c_nrfx_twim_configure+0x1c>
	switch (I2C_SPEED_GET(i2c_config)) {
   25308:	f06f 0015 	mvn.w	r0, #21
}
   2530c:	4770      	bx	lr

0002530e <irq_connect1>:
#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
   2530e:	2200      	movs	r2, #0
   25310:	2101      	movs	r1, #1
   25312:	2009      	movs	r0, #9
   25314:	f7f9 b820 	b.w	1e358 <z_arm_irq_priority_set>

00025318 <pinctrl_apply_state.constprop.0>:
 *
 * @retval 0 If succeeded.
 * @retval -ENOENT If given state id does not exist.
 * @retval -errno Negative errno for other failures.
 */
static inline int pinctrl_apply_state(const struct pinctrl_dev_config *config,
   25318:	b513      	push	{r0, r1, r4, lr}
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
   2531a:	2100      	movs	r1, #0
   2531c:	aa01      	add	r2, sp, #4
static inline int pinctrl_apply_state(const struct pinctrl_dev_config *config,
   2531e:	4604      	mov	r4, r0
	ret = pinctrl_lookup_state(config, id, &state);
   25320:	f000 f80a 	bl	25338 <pinctrl_lookup_state>
	if (ret < 0) {
   25324:	2800      	cmp	r0, #0
   25326:	db05      	blt.n	25334 <pinctrl_apply_state.constprop.0+0x1c>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
   25328:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   2532a:	6822      	ldr	r2, [r4, #0]
   2532c:	7919      	ldrb	r1, [r3, #4]
   2532e:	6818      	ldr	r0, [r3, #0]
   25330:	f7fa fe4e 	bl	1ffd0 <pinctrl_configure_pins>
}
   25334:	b002      	add	sp, #8
   25336:	bd10      	pop	{r4, pc}

00025338 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
   25338:	b530      	push	{r4, r5, lr}
	*state = &config->states[0];
   2533a:	6843      	ldr	r3, [r0, #4]
   2533c:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
   2533e:	7a05      	ldrb	r5, [r0, #8]
   25340:	6844      	ldr	r4, [r0, #4]
   25342:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   25346:	42a3      	cmp	r3, r4
   25348:	d302      	bcc.n	25350 <pinctrl_lookup_state+0x18>
		}

		(*state)++;
	}

	return -ENOENT;
   2534a:	f06f 0001 	mvn.w	r0, #1
}
   2534e:	bd30      	pop	{r4, r5, pc}
		if (id == (*state)->id) {
   25350:	795c      	ldrb	r4, [r3, #5]
   25352:	428c      	cmp	r4, r1
   25354:	d001      	beq.n	2535a <pinctrl_lookup_state+0x22>
		(*state)++;
   25356:	3308      	adds	r3, #8
   25358:	e7f0      	b.n	2533c <pinctrl_lookup_state+0x4>
			return 0;
   2535a:	2000      	movs	r0, #0
   2535c:	e7f7      	b.n	2534e <pinctrl_lookup_state+0x16>

0002535e <regulator_common_data_init>:
 */

#include <zephyr/drivers/regulator.h>

void regulator_common_data_init(const struct device *dev)
{
   2535e:	b510      	push	{r4, lr}
	struct regulator_common_data *data = dev->data;
   25360:	6904      	ldr	r4, [r0, #16]
	return z_impl_k_mutex_init(mutex);
   25362:	4620      	mov	r0, r4
   25364:	f000 fc45 	bl	25bf2 <z_impl_k_mutex_init>

	(void)k_mutex_init(&data->lock);
	data->refcnt = 0;
   25368:	2300      	movs	r3, #0
   2536a:	6163      	str	r3, [r4, #20]
}
   2536c:	bd10      	pop	{r4, pc}

0002536e <regulator_is_enabled>:

	return ret;
}

bool regulator_is_enabled(const struct device *dev)
{
   2536e:	b538      	push	{r3, r4, r5, lr}
	const struct regulator_common_config *config = dev->config;
	struct regulator_common_data *data = dev->data;
	bool enabled;

	if ((config->flags & REGULATOR_ALWAYS_ON) != 0U) {
   25370:	6843      	ldr	r3, [r0, #4]
   25372:	7e9b      	ldrb	r3, [r3, #26]
   25374:	07db      	lsls	r3, r3, #31
   25376:	d410      	bmi.n	2539a <regulator_is_enabled+0x2c>
	struct regulator_common_data *data = dev->data;
   25378:	6905      	ldr	r5, [r0, #16]
	return z_impl_k_mutex_lock(mutex, timeout);
   2537a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2537e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25382:	4628      	mov	r0, r5
   25384:	f7fd fffe 	bl	23384 <z_impl_k_mutex_lock>
		enabled = true;
	} else {
		(void)k_mutex_lock(&data->lock, K_FOREVER);
		enabled = data->refcnt != 0;
   25388:	696c      	ldr	r4, [r5, #20]
   2538a:	3c00      	subs	r4, #0
   2538c:	bf18      	it	ne
   2538e:	2401      	movne	r4, #1
	return z_impl_k_mutex_unlock(mutex);
   25390:	4628      	mov	r0, r5
   25392:	f7fe f871 	bl	23478 <z_impl_k_mutex_unlock>
		k_mutex_unlock(&data->lock);
	}

	return enabled;
}
   25396:	4620      	mov	r0, r4
   25398:	bd38      	pop	{r3, r4, r5, pc}
		enabled = true;
   2539a:	2401      	movs	r4, #1
   2539c:	e7fb      	b.n	25396 <regulator_is_enabled+0x28>

0002539e <regulator_set_voltage>:
	return false;
}

int regulator_set_voltage(const struct device *dev, int32_t min_uv,
			  int32_t max_uv)
{
   2539e:	b4f0      	push	{r4, r5, r6, r7}
	const struct regulator_common_config *config = dev->config;
	const struct regulator_driver_api *api = dev->api;

	if (api->set_voltage == NULL) {
   253a0:	e9d0 6301 	ldrd	r6, r3, [r0, #4]
   253a4:	691b      	ldr	r3, [r3, #16]
   253a6:	b13b      	cbz	r3, 253b8 <regulator_set_voltage+0x1a>
		return -ENOSYS;
	}

	/* voltage may not be allowed, even if supported */
	if ((min_uv > config->max_uv) || (max_uv < config->min_uv)) {
   253a8:	6877      	ldr	r7, [r6, #4]
   253aa:	428f      	cmp	r7, r1
   253ac:	db08      	blt.n	253c0 <regulator_set_voltage+0x22>
   253ae:	6835      	ldr	r5, [r6, #0]
   253b0:	4295      	cmp	r5, r2
   253b2:	dc05      	bgt.n	253c0 <regulator_set_voltage+0x22>
		return -EINVAL;
	}

	return api->set_voltage(dev, min_uv, max_uv);
}
   253b4:	bcf0      	pop	{r4, r5, r6, r7}
	return api->set_voltage(dev, min_uv, max_uv);
   253b6:	4718      	bx	r3
		return -ENOSYS;
   253b8:	f06f 0057 	mvn.w	r0, #87	; 0x57
}
   253bc:	bcf0      	pop	{r4, r5, r6, r7}
   253be:	4770      	bx	lr
		return -EINVAL;
   253c0:	f06f 0015 	mvn.w	r0, #21
   253c4:	e7fa      	b.n	253bc <regulator_set_voltage+0x1e>

000253c6 <regulator_set_mode>:

	return api->set_current_limit(dev, min_ua, max_ua);
}

int regulator_set_mode(const struct device *dev, regulator_mode_t mode)
{
   253c6:	b470      	push	{r4, r5, r6}
	const struct regulator_common_config *config = dev->config;
	const struct regulator_driver_api *api = dev->api;

	if (api->set_mode == NULL) {
   253c8:	e9d0 6201 	ldrd	r6, r2, [r0, #4]
   253cc:	6a15      	ldr	r5, [r2, #32]
{
   253ce:	4603      	mov	r3, r0
   253d0:	460c      	mov	r4, r1
	if (api->set_mode == NULL) {
   253d2:	b19d      	cbz	r5, 253fc <regulator_set_mode+0x36>
		return -ENOSYS;
	}

	/* no mode restrictions */
	if (config->allowed_modes_cnt == 0U) {
   253d4:	7e32      	ldrb	r2, [r6, #24]
   253d6:	b912      	cbnz	r2, 253de <regulator_set_mode+0x18>
	}

	/* check if mode is allowed, apply if it is */
	for (uint8_t i = 0U; i < config->allowed_modes_cnt; i++) {
		if (mode == config->allowed_modes[i]) {
			return api->set_mode(dev, mode);
   253d8:	462b      	mov	r3, r5
		}
	}

	return -ENOTSUP;
}
   253da:	bc70      	pop	{r4, r5, r6}
			return api->set_mode(dev, mode);
   253dc:	4718      	bx	r3
   253de:	6970      	ldr	r0, [r6, #20]
   253e0:	4402      	add	r2, r0
		if (mode == config->allowed_modes[i]) {
   253e2:	f810 1b01 	ldrb.w	r1, [r0], #1
   253e6:	42a1      	cmp	r1, r4
   253e8:	d102      	bne.n	253f0 <regulator_set_mode+0x2a>
			return api->set_mode(dev, mode);
   253ea:	4621      	mov	r1, r4
   253ec:	4618      	mov	r0, r3
   253ee:	e7f3      	b.n	253d8 <regulator_set_mode+0x12>
	for (uint8_t i = 0U; i < config->allowed_modes_cnt; i++) {
   253f0:	4290      	cmp	r0, r2
   253f2:	d1f6      	bne.n	253e2 <regulator_set_mode+0x1c>
	return -ENOTSUP;
   253f4:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   253f8:	bc70      	pop	{r4, r5, r6}
   253fa:	4770      	bx	lr
		return -ENOSYS;
   253fc:	f06f 0057 	mvn.w	r0, #87	; 0x57
   25400:	e7fa      	b.n	253f8 <regulator_set_mode+0x32>

00025402 <regulator_common_init>:
{
   25402:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   25406:	460e      	mov	r6, r1
	const struct regulator_common_config *config = dev->config;
   25408:	e9d0 8701 	ldrd	r8, r7, [r0, #4]
	if (config->initial_mode != REGULATOR_INITIAL_MODE_UNKNOWN) {
   2540c:	f898 1019 	ldrb.w	r1, [r8, #25]
{
   25410:	4604      	mov	r4, r0
	if (config->initial_mode != REGULATOR_INITIAL_MODE_UNKNOWN) {
   25412:	29ff      	cmp	r1, #255	; 0xff
	struct regulator_common_data *data = dev->data;
   25414:	6905      	ldr	r5, [r0, #16]
	if (config->initial_mode != REGULATOR_INITIAL_MODE_UNKNOWN) {
   25416:	d123      	bne.n	25460 <regulator_common_init+0x5e>
	if (config->init_uv > INT32_MIN) {
   25418:	f8d8 2008 	ldr.w	r2, [r8, #8]
   2541c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   25420:	d005      	beq.n	2542e <regulator_common_init+0x2c>
		ret = regulator_set_voltage(dev, config->init_uv, config->init_uv);
   25422:	4611      	mov	r1, r2
   25424:	4620      	mov	r0, r4
   25426:	f7ff ffba 	bl	2539e <regulator_set_voltage>
		if (ret < 0) {
   2542a:	2800      	cmp	r0, #0
   2542c:	db1c      	blt.n	25468 <regulator_common_init+0x66>
	if ((config->min_uv > INT32_MIN) || (config->max_uv < INT32_MAX)) {
   2542e:	f8d8 3000 	ldr.w	r3, [r8]
   25432:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   25436:	d01a      	beq.n	2546e <regulator_common_init+0x6c>
					int32_t *volt_uv)
{
	const struct regulator_driver_api *api =
		(const struct regulator_driver_api *)dev->api;

	if (api->get_voltage == NULL) {
   25438:	68a3      	ldr	r3, [r4, #8]
   2543a:	695b      	ldr	r3, [r3, #20]
   2543c:	b38b      	cbz	r3, 254a2 <regulator_common_init+0xa0>
		return -ENOSYS;
	}

	return api->get_voltage(dev, volt_uv);
   2543e:	4620      	mov	r0, r4
   25440:	a901      	add	r1, sp, #4
   25442:	4798      	blx	r3
		if (ret < 0) {
   25444:	2800      	cmp	r0, #0
   25446:	db0f      	blt.n	25468 <regulator_common_init+0x66>
		if (current_uv < config->min_uv) {
   25448:	f8d8 2000 	ldr.w	r2, [r8]
   2544c:	9b01      	ldr	r3, [sp, #4]
   2544e:	429a      	cmp	r2, r3
   25450:	dd22      	ble.n	25498 <regulator_common_init+0x96>
			ret = regulator_set_voltage(dev, config->max_uv, config->max_uv);
   25452:	4611      	mov	r1, r2
   25454:	4620      	mov	r0, r4
   25456:	f7ff ffa2 	bl	2539e <regulator_set_voltage>
			if (ret < 0) {
   2545a:	2800      	cmp	r0, #0
   2545c:	da0d      	bge.n	2547a <regulator_common_init+0x78>
   2545e:	e003      	b.n	25468 <regulator_common_init+0x66>
		ret = regulator_set_mode(dev, config->initial_mode);
   25460:	f7ff ffb1 	bl	253c6 <regulator_set_mode>
		if (ret < 0) {
   25464:	2800      	cmp	r0, #0
   25466:	dad7      	bge.n	25418 <regulator_common_init+0x16>
}
   25468:	b002      	add	sp, #8
   2546a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((config->min_uv > INT32_MIN) || (config->max_uv < INT32_MAX)) {
   2546e:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   25472:	f8d8 2004 	ldr.w	r2, [r8, #4]
   25476:	429a      	cmp	r2, r3
   25478:	d1de      	bne.n	25438 <regulator_common_init+0x36>
	if (is_enabled) {
   2547a:	b946      	cbnz	r6, 2548e <regulator_common_init+0x8c>
	} else if ((config->flags & REGULATOR_INIT_ENABLED) != 0U) {
   2547c:	f898 301a 	ldrb.w	r3, [r8, #26]
   25480:	079b      	lsls	r3, r3, #30
   25482:	d007      	beq.n	25494 <regulator_common_init+0x92>
		ret = api->enable(dev);
   25484:	4620      	mov	r0, r4
   25486:	683b      	ldr	r3, [r7, #0]
   25488:	4798      	blx	r3
		if (ret < 0) {
   2548a:	2800      	cmp	r0, #0
   2548c:	dbec      	blt.n	25468 <regulator_common_init+0x66>
		data->refcnt++;
   2548e:	696b      	ldr	r3, [r5, #20]
   25490:	3301      	adds	r3, #1
   25492:	616b      	str	r3, [r5, #20]
	return 0;
   25494:	2000      	movs	r0, #0
   25496:	e7e7      	b.n	25468 <regulator_common_init+0x66>
		} else if (current_uv > config->max_uv) {
   25498:	f8d8 2004 	ldr.w	r2, [r8, #4]
   2549c:	4293      	cmp	r3, r2
   2549e:	ddec      	ble.n	2547a <regulator_common_init+0x78>
   254a0:	e7d7      	b.n	25452 <regulator_common_init+0x50>
		return -ENOSYS;
   254a2:	f06f 0057 	mvn.w	r0, #87	; 0x57
   254a6:	e7df      	b.n	25468 <regulator_common_init+0x66>

000254a8 <gpio_pin_set>:
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   254a8:	2301      	movs	r3, #1
   254aa:	fa03 f101 	lsl.w	r1, r3, r1
   254ae:	6903      	ldr	r3, [r0, #16]
   254b0:	681b      	ldr	r3, [r3, #0]
   254b2:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   254b4:	bf18      	it	ne
   254b6:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   254ba:	b112      	cbz	r2, 254c2 <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   254bc:	6883      	ldr	r3, [r0, #8]
   254be:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   254c0:	4718      	bx	r3
   254c2:	6883      	ldr	r3, [r0, #8]
   254c4:	691b      	ldr	r3, [r3, #16]
   254c6:	e7fb      	b.n	254c0 <gpio_pin_set+0x18>

000254c8 <regulator_fixed_init>:
	.enable = regulator_fixed_enable,
	.disable = regulator_fixed_disable,
};

static int regulator_fixed_init(const struct device *dev)
{
   254c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct regulator_fixed_config *cfg = dev->config;
   254ca:	6844      	ldr	r4, [r0, #4]
{
   254cc:	4605      	mov	r5, r0
	int ret;

	regulator_common_data_init(dev);
   254ce:	f7ff ff46 	bl	2535e <regulator_common_data_init>

	if (!device_is_ready(cfg->enable.port)) {
   254d2:	6a60      	ldr	r0, [r4, #36]	; 0x24
   254d4:	f000 fb0a 	bl	25aec <z_device_is_ready>
   254d8:	b370      	cbz	r0, 25538 <regulator_fixed_init+0x70>
	return gpio_pin_configure(spec->port,
   254da:	6a60      	ldr	r0, [r4, #36]	; 0x24
				  spec->pin,
   254dc:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
				  spec->dt_flags | extra_flags);
   254e0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254e2:	2701      	movs	r7, #1
	struct gpio_driver_data *data =
   254e4:	f8d0 c010 	ldr.w	ip, [r0, #16]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   254e8:	07da      	lsls	r2, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254ea:	f8dc 6000 	ldr.w	r6, [ip]
	return gpio_pin_configure(spec->port,
   254ee:	bf54      	ite	pl
   254f0:	f443 13b0 	orrpl.w	r3, r3, #1441792	; 0x160000
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   254f4:	f483 13d0 	eormi.w	r3, r3, #1703936	; 0x1a0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   254f8:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254fc:	408f      	lsls	r7, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   254fe:	07db      	lsls	r3, r3, #31
	const struct gpio_driver_api *api =
   25500:	f8d0 e008 	ldr.w	lr, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
   25504:	bf4c      	ite	mi
   25506:	433e      	orrmi	r6, r7
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   25508:	43be      	bicpl	r6, r7
   2550a:	f8cc 6000 	str.w	r6, [ip]
	return api->pin_configure(port, pin, flags);
   2550e:	f8de 3000 	ldr.w	r3, [lr]
   25512:	4798      	blx	r3
		LOG_ERR("GPIO port: %s not ready", cfg->enable.port->name);
		return -ENODEV;
	}

	ret = gpio_pin_configure_dt(&cfg->enable, GPIO_OUTPUT_INACTIVE);
	if (ret < 0) {
   25514:	2800      	cmp	r0, #0
   25516:	db0a      	blt.n	2552e <regulator_fixed_init+0x66>
		return ret;
	}

	ret = regulator_common_init(dev, false);
   25518:	2100      	movs	r1, #0
   2551a:	4628      	mov	r0, r5
   2551c:	f7ff ff71 	bl	25402 <regulator_common_init>
	if (ret < 0) {
   25520:	2800      	cmp	r0, #0
   25522:	db04      	blt.n	2552e <regulator_fixed_init+0x66>
		return ret;
	}

	if (regulator_is_enabled(dev)) {
   25524:	4628      	mov	r0, r5
   25526:	f7ff ff22 	bl	2536e <regulator_is_enabled>
   2552a:	b908      	cbnz	r0, 25530 <regulator_fixed_init+0x68>
		k_busy_wait(cfg->startup_delay_us);
	}

	return 0;
   2552c:	2000      	movs	r0, #0
}
   2552e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		k_busy_wait(cfg->startup_delay_us);
   25530:	69e0      	ldr	r0, [r4, #28]
	z_impl_k_busy_wait(usec_to_wait);
   25532:	f000 fd80 	bl	26036 <z_impl_k_busy_wait>
}
   25536:	e7f9      	b.n	2552c <regulator_fixed_init+0x64>
		return -ENODEV;
   25538:	f06f 0012 	mvn.w	r0, #18
   2553c:	e7f7      	b.n	2552e <regulator_fixed_init+0x66>

0002553e <regulator_fixed_disable>:
	const struct regulator_fixed_config *cfg = dev->config;
   2553e:	6843      	ldr	r3, [r0, #4]
	return gpio_pin_set(spec->port, spec->pin, value);
   25540:	2200      	movs	r2, #0
   25542:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
   25546:	6a58      	ldr	r0, [r3, #36]	; 0x24
   25548:	f7ff bfae 	b.w	254a8 <gpio_pin_set>

0002554c <irq_connect3>:
#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(2);
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(3);
   2554c:	2200      	movs	r2, #0
   2554e:	2101      	movs	r1, #1
   25550:	200c      	movs	r0, #12
   25552:	f7f8 bf01 	b.w	1e358 <z_arm_irq_priority_set>

00025556 <irq_connect4>:
#endif

#ifdef CONFIG_SPI_4_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(4);
   25556:	2200      	movs	r2, #0
   25558:	2101      	movs	r1, #1
   2555a:	200a      	movs	r0, #10
   2555c:	f7f8 befc 	b.w	1e358 <z_arm_irq_priority_set>

00025560 <spi_context_get_next_buf.constprop.0>:
static inline void *spi_context_get_next_buf(const struct spi_buf **current,
   25560:	b510      	push	{r4, lr}
	while (*count) {
   25562:	680b      	ldr	r3, [r1, #0]
   25564:	b913      	cbnz	r3, 2556c <spi_context_get_next_buf.constprop.0+0xc>
	return NULL;
   25566:	4618      	mov	r0, r3
	*buf_len = 0;
   25568:	6013      	str	r3, [r2, #0]
	return NULL;
   2556a:	e005      	b.n	25578 <spi_context_get_next_buf.constprop.0+0x18>
		if (((*current)->len / dfs) != 0) {
   2556c:	6803      	ldr	r3, [r0, #0]
   2556e:	685c      	ldr	r4, [r3, #4]
   25570:	b11c      	cbz	r4, 2557a <spi_context_get_next_buf.constprop.0+0x1a>
			*buf_len = (*current)->len / dfs;
   25572:	6014      	str	r4, [r2, #0]
			return (*current)->buf;
   25574:	6803      	ldr	r3, [r0, #0]
   25576:	6818      	ldr	r0, [r3, #0]
}
   25578:	bd10      	pop	{r4, pc}
		++(*current);
   2557a:	3308      	adds	r3, #8
   2557c:	6003      	str	r3, [r0, #0]
		--(*count);
   2557e:	680b      	ldr	r3, [r1, #0]
   25580:	3b01      	subs	r3, #1
   25582:	600b      	str	r3, [r1, #0]
   25584:	e7ed      	b.n	25562 <spi_context_get_next_buf.constprop.0+0x2>

00025586 <gpio_pin_set_dt.isra.0>:
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
   25586:	4603      	mov	r3, r0
   25588:	460a      	mov	r2, r1
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   2558a:	7919      	ldrb	r1, [r3, #4]
   2558c:	2301      	movs	r3, #1
	return gpio_pin_set(spec->port, spec->pin, value);
   2558e:	6800      	ldr	r0, [r0, #0]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   25590:	fa03 f101 	lsl.w	r1, r3, r1
   25594:	6903      	ldr	r3, [r0, #16]
   25596:	681b      	ldr	r3, [r3, #0]
   25598:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   2559a:	bf18      	it	ne
   2559c:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   255a0:	b112      	cbz	r2, 255a8 <gpio_pin_set_dt.isra.0+0x22>
	return api->port_set_bits_raw(port, pins);
   255a2:	6883      	ldr	r3, [r0, #8]
   255a4:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   255a6:	4718      	bx	r3
   255a8:	6883      	ldr	r3, [r0, #8]
   255aa:	691b      	ldr	r3, [r3, #16]
   255ac:	e7fb      	b.n	255a6 <gpio_pin_set_dt.isra.0+0x20>

000255ae <_spi_context_cs_control>:
{
   255ae:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   255b0:	6803      	ldr	r3, [r0, #0]
{
   255b2:	4604      	mov	r4, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   255b4:	b1e3      	cbz	r3, 255f0 <_spi_context_cs_control+0x42>
   255b6:	6898      	ldr	r0, [r3, #8]
   255b8:	b1d0      	cbz	r0, 255f0 <_spi_context_cs_control+0x42>
   255ba:	6805      	ldr	r5, [r0, #0]
   255bc:	b1c5      	cbz	r5, 255f0 <_spi_context_cs_control+0x42>
		if (on) {
   255be:	b149      	cbz	r1, 255d4 <_spi_context_cs_control+0x26>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 1);
   255c0:	2101      	movs	r1, #1
   255c2:	f7ff ffe0 	bl	25586 <gpio_pin_set_dt.isra.0>
			k_busy_wait(ctx->config->cs->delay);
   255c6:	6823      	ldr	r3, [r4, #0]
   255c8:	689b      	ldr	r3, [r3, #8]
   255ca:	6898      	ldr	r0, [r3, #8]
}
   255cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   255d0:	f000 bd31 	b.w	26036 <z_impl_k_busy_wait>
			if (!force_off &&
   255d4:	b912      	cbnz	r2, 255dc <_spi_context_cs_control+0x2e>
   255d6:	889b      	ldrh	r3, [r3, #4]
   255d8:	04db      	lsls	r3, r3, #19
   255da:	d409      	bmi.n	255f0 <_spi_context_cs_control+0x42>
			k_busy_wait(ctx->config->cs->delay);
   255dc:	6880      	ldr	r0, [r0, #8]
   255de:	f000 fd2a 	bl	26036 <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   255e2:	6823      	ldr	r3, [r4, #0]
   255e4:	2100      	movs	r1, #0
   255e6:	6898      	ldr	r0, [r3, #8]
}
   255e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   255ec:	f7ff bfcb 	b.w	25586 <gpio_pin_set_dt.isra.0>
}
   255f0:	bd38      	pop	{r3, r4, r5, pc}

000255f2 <spi_context_unlock_unconditionally>:
{
   255f2:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   255f4:	2201      	movs	r2, #1
   255f6:	2100      	movs	r1, #0
{
   255f8:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   255fa:	f7ff ffd8 	bl	255ae <_spi_context_cs_control>
	if (!k_sem_count_get(&ctx->lock)) {
   255fe:	69a3      	ldr	r3, [r4, #24]
   25600:	b933      	cbnz	r3, 25610 <spi_context_unlock_unconditionally+0x1e>
		ctx->owner = NULL;
   25602:	6063      	str	r3, [r4, #4]
	z_impl_k_sem_give(sem);
   25604:	f104 0010 	add.w	r0, r4, #16
}
   25608:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2560c:	f7fd bfa4 	b.w	23558 <z_impl_k_sem_give>
   25610:	bd10      	pop	{r4, pc}

00025612 <spi_nrfx_release>:
{
   25612:	b510      	push	{r4, lr}
	struct spi_nrfx_data *dev_data = dev->data;
   25614:	6900      	ldr	r0, [r0, #16]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   25616:	6803      	ldr	r3, [r0, #0]
   25618:	428b      	cmp	r3, r1
   2561a:	d106      	bne.n	2562a <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   2561c:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   25620:	b934      	cbnz	r4, 25630 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   25622:	f7ff ffe6 	bl	255f2 <spi_context_unlock_unconditionally>
	return 0;
   25626:	4620      	mov	r0, r4
}
   25628:	bd10      	pop	{r4, pc}
		return -EINVAL;
   2562a:	f06f 0015 	mvn.w	r0, #21
   2562e:	e7fb      	b.n	25628 <spi_nrfx_release+0x16>
		return -EBUSY;
   25630:	f06f 000f 	mvn.w	r0, #15
   25634:	e7f8      	b.n	25628 <spi_nrfx_release+0x16>

00025636 <spi_nrfx_init>:
{
   25636:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	const struct spi_nrfx_config *dev_config = dev->config;
   2563a:	6844      	ldr	r4, [r0, #4]
	struct spi_nrfx_data *dev_data = dev->data;
   2563c:	6905      	ldr	r5, [r0, #16]
	err = pinctrl_apply_state(dev_config->pcfg, PINCTRL_STATE_DEFAULT);
   2563e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
	ret = pinctrl_lookup_state(config, id, &state);
   25640:	2100      	movs	r1, #0
   25642:	4630      	mov	r0, r6
   25644:	aa01      	add	r2, sp, #4
   25646:	f7ff fe77 	bl	25338 <pinctrl_lookup_state>
	if (ret < 0) {
   2564a:	2800      	cmp	r0, #0
   2564c:	db43      	blt.n	256d6 <spi_nrfx_init+0xa0>
	return pinctrl_apply_state_direct(config, state);
   2564e:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   25650:	6832      	ldr	r2, [r6, #0]
   25652:	7919      	ldrb	r1, [r3, #4]
   25654:	6818      	ldr	r0, [r3, #0]
   25656:	f7fa fcbb 	bl	1ffd0 <pinctrl_configure_pins>
	if (err < 0) {
   2565a:	2800      	cmp	r0, #0
   2565c:	db3b      	blt.n	256d6 <spi_nrfx_init+0xa0>
		data->invert |= (gpio_port_pins_t)BIT(pin);
   2565e:	2601      	movs	r6, #1
	dev_config->irq_connect();
   25660:	6a63      	ldr	r3, [r4, #36]	; 0x24
   25662:	4798      	blx	r3
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
   25664:	68ac      	ldr	r4, [r5, #8]
   25666:	3408      	adds	r4, #8
   25668:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
   2566c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   25670:	f1a4 0208 	sub.w	r2, r4, #8
   25674:	4293      	cmp	r3, r2
   25676:	d804      	bhi.n	25682 <spi_nrfx_init+0x4c>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   25678:	4628      	mov	r0, r5
   2567a:	f7ff ffba 	bl	255f2 <spi_context_unlock_unconditionally>
	return 0;
   2567e:	2000      	movs	r0, #0
	return 0;
   25680:	e029      	b.n	256d6 <spi_nrfx_init+0xa0>
		if (!device_is_ready(cs_gpio->port)) {
   25682:	f854 0c08 	ldr.w	r0, [r4, #-8]
   25686:	f000 fa31 	bl	25aec <z_device_is_ready>
   2568a:	b338      	cbz	r0, 256dc <spi_nrfx_init+0xa6>
	return gpio_pin_configure(spec->port,
   2568c:	f854 0c08 	ldr.w	r0, [r4, #-8]
				  spec->pin,
   25690:	f814 1c04 	ldrb.w	r1, [r4, #-4]
				  spec->dt_flags | extra_flags);
   25694:	f834 3c02 	ldrh.w	r3, [r4, #-2]
	struct gpio_driver_data *data =
   25698:	f8d0 c010 	ldr.w	ip, [r0, #16]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   2569c:	07da      	lsls	r2, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   2569e:	f8dc 7000 	ldr.w	r7, [ip]
	return gpio_pin_configure(spec->port,
   256a2:	bf54      	ite	pl
   256a4:	f443 13b0 	orrpl.w	r3, r3, #1441792	; 0x160000
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   256a8:	f483 13d0 	eormi.w	r3, r3, #1703936	; 0x1a0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   256ac:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   256b0:	fa06 fe01 	lsl.w	lr, r6, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   256b4:	07db      	lsls	r3, r3, #31
	const struct gpio_driver_api *api =
   256b6:	f8d0 8008 	ldr.w	r8, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
   256ba:	bf4c      	ite	mi
   256bc:	ea4e 0707 	orrmi.w	r7, lr, r7
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   256c0:	ea27 070e 	bicpl.w	r7, r7, lr
   256c4:	f8cc 7000 	str.w	r7, [ip]
	return api->pin_configure(port, pin, flags);
   256c8:	f8d8 3000 	ldr.w	r3, [r8]
   256cc:	4798      	blx	r3
		if (ret < 0) {
   256ce:	2800      	cmp	r0, #0
   256d0:	f104 0408 	add.w	r4, r4, #8
   256d4:	dac8      	bge.n	25668 <spi_nrfx_init+0x32>
}
   256d6:	b002      	add	sp, #8
   256d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return -ENODEV;
   256dc:	f06f 0012 	mvn.w	r0, #18
	if (err < 0) {
   256e0:	e7f9      	b.n	256d6 <spi_nrfx_init+0xa0>

000256e2 <finish_transaction.isra.0>:
	_spi_context_cs_control(ctx, on, false);
   256e2:	2200      	movs	r2, #0
static void finish_transaction(const struct device *dev, int error)
   256e4:	b538      	push	{r3, r4, r5, lr}
   256e6:	4604      	mov	r4, r0
   256e8:	460d      	mov	r5, r1
   256ea:	4611      	mov	r1, r2
   256ec:	f7ff ff5f 	bl	255ae <_spi_context_cs_control>
	ctx->sync_status = status;
   256f0:	6325      	str	r5, [r4, #48]	; 0x30
   256f2:	f104 0020 	add.w	r0, r4, #32
   256f6:	f7fd ff2f 	bl	23558 <z_impl_k_sem_give>
	dev_data->busy = false;
   256fa:	2300      	movs	r3, #0
   256fc:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
   25700:	bd38      	pop	{r3, r4, r5, pc}

00025702 <event_handler>:
{
   25702:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   25704:	7803      	ldrb	r3, [r0, #0]
{
   25706:	460c      	mov	r4, r1
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   25708:	2b00      	cmp	r3, #0
   2570a:	d145      	bne.n	25798 <event_handler+0x96>
		if (dev_data->chunk_len == 0) {
   2570c:	6d8d      	ldr	r5, [r1, #88]	; 0x58
   2570e:	b93d      	cbnz	r5, 25720 <event_handler+0x1e>
			finish_transaction(dev_data->dev, -ETIMEDOUT);
   25710:	6d4b      	ldr	r3, [r1, #84]	; 0x54
   25712:	f06f 0173 	mvn.w	r1, #115	; 0x73
   25716:	6918      	ldr	r0, [r3, #16]
}
   25718:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			finish_transaction(dev_data->dev, -ETIMEDOUT);
   2571c:	f7ff bfe1 	b.w	256e2 <finish_transaction.isra.0>
	if (!ctx->tx_len) {
   25720:	6c8b      	ldr	r3, [r1, #72]	; 0x48
   25722:	b193      	cbz	r3, 2574a <event_handler+0x48>
	if (len > ctx->tx_len) {
   25724:	429d      	cmp	r5, r3
   25726:	d810      	bhi.n	2574a <event_handler+0x48>
	ctx->tx_len -= len;
   25728:	1b5b      	subs	r3, r3, r5
   2572a:	648b      	str	r3, [r1, #72]	; 0x48
	if (!ctx->tx_len) {
   2572c:	bb43      	cbnz	r3, 25780 <event_handler+0x7e>
		++ctx->current_tx;
   2572e:	6b4b      	ldr	r3, [r1, #52]	; 0x34
			spi_context_get_next_buf(&ctx->current_tx,
   25730:	f101 0248 	add.w	r2, r1, #72	; 0x48
		++ctx->current_tx;
   25734:	3308      	adds	r3, #8
   25736:	634b      	str	r3, [r1, #52]	; 0x34
		--ctx->tx_count;
   25738:	6b8b      	ldr	r3, [r1, #56]	; 0x38
			spi_context_get_next_buf(&ctx->current_tx,
   2573a:	f104 0034 	add.w	r0, r4, #52	; 0x34
		--ctx->tx_count;
   2573e:	3b01      	subs	r3, #1
   25740:	638b      	str	r3, [r1, #56]	; 0x38
			spi_context_get_next_buf(&ctx->current_tx,
   25742:	3138      	adds	r1, #56	; 0x38
   25744:	f7ff ff0c 	bl	25560 <spi_context_get_next_buf.constprop.0>
		ctx->tx_buf = (const uint8_t *)
   25748:	6460      	str	r0, [r4, #68]	; 0x44
	if (!ctx->rx_len) {
   2574a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   2574c:	b19b      	cbz	r3, 25776 <event_handler+0x74>
	if (len > ctx->rx_len) {
   2574e:	429d      	cmp	r5, r3
   25750:	d811      	bhi.n	25776 <event_handler+0x74>
	ctx->rx_len -= len;
   25752:	1b5b      	subs	r3, r3, r5
   25754:	6523      	str	r3, [r4, #80]	; 0x50
	if (!ctx->rx_len) {
   25756:	b9cb      	cbnz	r3, 2578c <event_handler+0x8a>
		++ctx->current_rx;
   25758:	6be3      	ldr	r3, [r4, #60]	; 0x3c
			spi_context_get_next_buf(&ctx->current_rx,
   2575a:	f104 0250 	add.w	r2, r4, #80	; 0x50
		++ctx->current_rx;
   2575e:	3308      	adds	r3, #8
   25760:	63e3      	str	r3, [r4, #60]	; 0x3c
		--ctx->rx_count;
   25762:	6c23      	ldr	r3, [r4, #64]	; 0x40
			spi_context_get_next_buf(&ctx->current_rx,
   25764:	f104 0140 	add.w	r1, r4, #64	; 0x40
		--ctx->rx_count;
   25768:	3b01      	subs	r3, #1
   2576a:	6423      	str	r3, [r4, #64]	; 0x40
			spi_context_get_next_buf(&ctx->current_rx,
   2576c:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   25770:	f7ff fef6 	bl	25560 <spi_context_get_next_buf.constprop.0>
		ctx->rx_buf = (uint8_t *)
   25774:	64e0      	str	r0, [r4, #76]	; 0x4c
		transfer_next_chunk(dev_data->dev);
   25776:	6d60      	ldr	r0, [r4, #84]	; 0x54
}
   25778:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev_data->dev);
   2577c:	f7fa bcfe 	b.w	2017c <transfer_next_chunk>
	} else if (ctx->tx_buf) {
   25780:	6c4b      	ldr	r3, [r1, #68]	; 0x44
   25782:	2b00      	cmp	r3, #0
   25784:	d0e1      	beq.n	2574a <event_handler+0x48>
		ctx->tx_buf += dfs * len;
   25786:	442b      	add	r3, r5
   25788:	644b      	str	r3, [r1, #68]	; 0x44
   2578a:	e7de      	b.n	2574a <event_handler+0x48>
	} else if (ctx->rx_buf) {
   2578c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   2578e:	2b00      	cmp	r3, #0
   25790:	d0f1      	beq.n	25776 <event_handler+0x74>
		ctx->rx_buf += dfs * len;
   25792:	442b      	add	r3, r5
   25794:	64e3      	str	r3, [r4, #76]	; 0x4c
   25796:	e7ee      	b.n	25776 <event_handler+0x74>
}
   25798:	bd38      	pop	{r3, r4, r5, pc}

0002579a <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   2579a:	4770      	bx	lr

0002579c <event_clear>:
   2579c:	2200      	movs	r2, #0
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   2579e:	f100 0350 	add.w	r3, r0, #80	; 0x50
   257a2:	009b      	lsls	r3, r3, #2
   257a4:	b29b      	uxth	r3, r3
   257a6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   257aa:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
   257ae:	601a      	str	r2, [r3, #0]
   257b0:	681b      	ldr	r3, [r3, #0]
}
   257b2:	4770      	bx	lr

000257b4 <sys_clock_cycle_get_32>:
{
   257b4:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   257b6:	f7fa ff1b 	bl	205f0 <z_nrf_rtc_timer_read>
}
   257ba:	bd08      	pop	{r3, pc}

000257bc <k_sys_fatal_error_handler>:

	LOG_PANIC();

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
		sys_arch_reboot(0);
   257bc:	2000      	movs	r0, #0
{
   257be:	b508      	push	{r3, lr}
		sys_arch_reboot(0);
   257c0:	f7f9 f83e 	bl	1e840 <sys_arch_reboot>

000257c4 <ns_interface_init>:

	__ASSERT(tfm_ns_interface_init() == TFM_SUCCESS,
		"TF-M NS interface init failed");

	return 0;
}
   257c4:	2000      	movs	r0, #0
   257c6:	4770      	bx	lr

000257c8 <psa_crypto_init>:
}
   257c8:	2000      	movs	r0, #0
   257ca:	4770      	bx	lr

000257cc <tfm_platform_mem_read>:
#include <tfm_platform_api.h>
#include <tfm_ioctl_core_api.h>

enum tfm_platform_err_t tfm_platform_mem_read(void *destination, uint32_t addr,
					      size_t len, uint32_t *result)
{
   257cc:	b510      	push	{r4, lr}
   257ce:	b088      	sub	sp, #32
   257d0:	461c      	mov	r4, r3
	psa_invec in_vec;
	psa_outvec out_vec;
	struct tfm_read_service_args_t args;
	struct tfm_read_service_out_t out;

	in_vec.base = (const void *)&args;
   257d2:	ab05      	add	r3, sp, #20
   257d4:	9301      	str	r3, [sp, #4]
	in_vec.len = sizeof(args);
   257d6:	230c      	movs	r3, #12
   257d8:	9302      	str	r3, [sp, #8]

	out_vec.base = (void *)&out;
	out_vec.len = sizeof(out);
   257da:	2304      	movs	r3, #4

	args.destination = destination;
	args.addr = addr;
	args.len = len;
   257dc:	e9cd 1206 	strd	r1, r2, [sp, #24]
	args.destination = destination;
   257e0:	e9cd 3004 	strd	r3, r0, [sp, #16]

	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_READ_SERVICE, &in_vec,
   257e4:	eb0d 0103 	add.w	r1, sp, r3
   257e8:	aa03      	add	r2, sp, #12
   257ea:	2000      	movs	r0, #0
	out_vec.base = (void *)&out;
   257ec:	f8cd d00c 	str.w	sp, [sp, #12]
	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_READ_SERVICE, &in_vec,
   257f0:	f7fb f8c6 	bl	20980 <tfm_platform_ioctl>
				 &out_vec);

	*result = out.result;
   257f4:	9b00      	ldr	r3, [sp, #0]
   257f6:	6023      	str	r3, [r4, #0]

	return ret;
}
   257f8:	b008      	add	sp, #32
   257fa:	bd10      	pop	{r4, pc}

000257fc <tfm_platform_gpio_pin_mcu_select>:
	psa_invec in_vec;
	psa_outvec out_vec;
	struct tfm_gpio_service_args args;
	struct tfm_gpio_service_out out;

	args.type = TFM_GPIO_SERVICE_TYPE_PIN_MCU_SELECT;
   257fc:	2300      	movs	r3, #0
{
   257fe:	b510      	push	{r4, lr}
   25800:	b088      	sub	sp, #32
	args.mcu_select.pin_number = pin_number;
   25802:	e9cd 3005 	strd	r3, r0, [sp, #20]
	args.mcu_select.mcu = mcu;

	in_vec.base = (const void *)&args;
   25806:	ab05      	add	r3, sp, #20
   25808:	9301      	str	r3, [sp, #4]
	in_vec.len = sizeof(args);
   2580a:	230c      	movs	r3, #12
   2580c:	9302      	str	r3, [sp, #8]

	out_vec.base = (void *)&out;
	out_vec.len = sizeof(out);
   2580e:	2304      	movs	r3, #4
{
   25810:	4614      	mov	r4, r2
	args.mcu_select.mcu = mcu;
   25812:	9107      	str	r1, [sp, #28]

	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_GPIO_SERVICE, &in_vec,
   25814:	aa03      	add	r2, sp, #12
   25816:	eb0d 0103 	add.w	r1, sp, r3
   2581a:	2001      	movs	r0, #1
	out_vec.len = sizeof(out);
   2581c:	9304      	str	r3, [sp, #16]
	out_vec.base = (void *)&out;
   2581e:	f8cd d00c 	str.w	sp, [sp, #12]
	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_GPIO_SERVICE, &in_vec,
   25822:	f7fb f8ad 	bl	20980 <tfm_platform_ioctl>
				 &out_vec);

	*result = out.result;
   25826:	9b00      	ldr	r3, [sp, #0]
   25828:	6023      	str	r3, [r4, #0]

	return ret;
#else
	return TFM_PLATFORM_ERR_NOT_SUPPORTED;
#endif
}
   2582a:	b008      	add	sp, #32
   2582c:	bd10      	pop	{r4, pc}

0002582e <SystemInit>:
    #if (__FPU_USED == 1)
        SCB->CPACR |= (3UL << 20) | (3UL << 22);
        __DSB();
        __ISB();
    #endif
}
   2582e:	4770      	bx	lr

00025830 <nrfx_isr>:
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   25830:	4700      	bx	r0

00025832 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   25832:	f000 bc00 	b.w	26036 <z_impl_k_busy_wait>

00025836 <nrfx_clock_stop>:
    clock_stop(domain);
   25836:	f7fb b93d 	b.w	20ab4 <clock_stop>

0002583a <nrf_gpio_reconfigure>:
{
   2583a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2583c:	4616      	mov	r6, r2
   2583e:	e9dd 4708 	ldrd	r4, r7, [sp, #32]
   25842:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25844:	a801      	add	r0, sp, #4
{
   25846:	461d      	mov	r5, r3
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25848:	f7fb facc 	bl	20de4 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   2584c:	9b01      	ldr	r3, [sp, #4]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   2584e:	f1b6 0c00 	subs.w	ip, r6, #0
   25852:	bf18      	it	ne
   25854:	f04f 0c01 	movne.w	ip, #1
   25858:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   2585c:	1e0b      	subs	r3, r1, #0
   2585e:	bf18      	it	ne
   25860:	2301      	movne	r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   25862:	2d00      	cmp	r5, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   25864:	ea43 034c 	orr.w	r3, r3, ip, lsl #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   25868:	bf14      	ite	ne
   2586a:	f04f 0c0c 	movne.w	ip, #12
   2586e:	f04f 0c00 	moveq.w	ip, #0
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   25872:	2c00      	cmp	r4, #0
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   25874:	ea43 030c 	orr.w	r3, r3, ip
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   25878:	bf14      	ite	ne
   2587a:	f44f 6c70 	movne.w	ip, #3840	; 0xf00
   2587e:	f04f 0c00 	moveq.w	ip, #0
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   25882:	2f00      	cmp	r7, #0
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   25884:	ea43 030c 	orr.w	r3, r3, ip
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   25888:	bf14      	ite	ne
   2588a:	f44f 3c40 	movne.w	ip, #196608	; 0x30000
   2588e:	f04f 0c00 	moveq.w	ip, #0
    uint32_t cnf = reg->PIN_CNF[pin_number];
   25892:	f8d0 2200 	ldr.w	r2, [r0, #512]	; 0x200
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   25896:	ea43 030c 	orr.w	r3, r3, ip
    cnf &= ~to_update;
   2589a:	ea22 0303 	bic.w	r3, r2, r3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   2589e:	b101      	cbz	r1, 258a2 <nrf_gpio_reconfigure+0x68>
   258a0:	7809      	ldrb	r1, [r1, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   258a2:	b10e      	cbz	r6, 258a8 <nrf_gpio_reconfigure+0x6e>
   258a4:	7836      	ldrb	r6, [r6, #0]
   258a6:	0076      	lsls	r6, r6, #1
   258a8:	4319      	orrs	r1, r3
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   258aa:	b10d      	cbz	r5, 258b0 <nrf_gpio_reconfigure+0x76>
   258ac:	782d      	ldrb	r5, [r5, #0]
   258ae:	00ad      	lsls	r5, r5, #2
   258b0:	4331      	orrs	r1, r6
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   258b2:	b10c      	cbz	r4, 258b8 <nrf_gpio_reconfigure+0x7e>
   258b4:	7824      	ldrb	r4, [r4, #0]
   258b6:	0224      	lsls	r4, r4, #8
   258b8:	4329      	orrs	r1, r5
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
   258ba:	b10f      	cbz	r7, 258c0 <nrf_gpio_reconfigure+0x86>
   258bc:	783f      	ldrb	r7, [r7, #0]
   258be:	043f      	lsls	r7, r7, #16
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   258c0:	430c      	orrs	r4, r1
   258c2:	433c      	orrs	r4, r7
    reg->PIN_CNF[pin_number] = cnf;
   258c4:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
}
   258c8:	b003      	add	sp, #12
   258ca:	bdf0      	pop	{r4, r5, r6, r7, pc}

000258cc <nrf_gpio_cfg_sense_set>:
{
   258cc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   258ce:	f10d 030f 	add.w	r3, sp, #15
   258d2:	9301      	str	r3, [sp, #4]
   258d4:	2300      	movs	r3, #0
{
   258d6:	f88d 100f 	strb.w	r1, [sp, #15]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   258da:	461a      	mov	r2, r3
   258dc:	4619      	mov	r1, r3
   258de:	9300      	str	r3, [sp, #0]
   258e0:	f7ff ffab 	bl	2583a <nrf_gpio_reconfigure>
}
   258e4:	b005      	add	sp, #20
   258e6:	f85d fb04 	ldr.w	pc, [sp], #4

000258ea <nrfx_power_clock_irq_handler>:
 * a library with nrfx is created. In such case, forcing a linker to use this
 * function instead of another one defined as weak will require additional
 * actions, and might be even impossible.
 */
void nrfx_power_clock_irq_handler(void)
{
   258ea:	b508      	push	{r3, lr}
    nrfx_power_irq_handler();
   258ec:	f7fb fe08 	bl	21500 <nrfx_power_irq_handler>
    nrfx_clock_irq_handler();
}
   258f0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_irq_handler();
   258f4:	f7fb ba20 	b.w	20d38 <nrfx_clock_irq_handler>

000258f8 <spim_pin_uninit>:
    if (pin == NRF_SPIM_PIN_NOT_CONNECTED)
   258f8:	1c43      	adds	r3, r0, #1
{
   258fa:	b507      	push	{r0, r1, r2, lr}
    if (pin == NRF_SPIM_PIN_NOT_CONNECTED)
   258fc:	d005      	beq.n	2590a <spim_pin_uninit+0x12>
    nrf_gpio_cfg(
   258fe:	2300      	movs	r3, #0
   25900:	2201      	movs	r2, #1
   25902:	4619      	mov	r1, r3
   25904:	9300      	str	r3, [sp, #0]
   25906:	f7fb fe43 	bl	21590 <nrf_gpio_cfg.constprop.0>
}
   2590a:	b003      	add	sp, #12
   2590c:	f85d fb04 	ldr.w	pc, [sp], #4

00025910 <set_ss_pin_state>:
    if (p_cb->use_hw_ss)
   25910:	7f83      	ldrb	r3, [r0, #30]
   25912:	075a      	lsls	r2, r3, #29
   25914:	d40b      	bmi.n	2592e <set_ss_pin_state+0x1e>
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   25916:	7fc0      	ldrb	r0, [r0, #31]
   25918:	28ff      	cmp	r0, #255	; 0xff
   2591a:	d008      	beq.n	2592e <set_ss_pin_state+0x1e>
        nrf_gpio_pin_write(p_cb->ss_pin,
   2591c:	079b      	lsls	r3, r3, #30
   2591e:	bf58      	it	pl
   25920:	f081 0101 	eorpl.w	r1, r1, #1
    if (value == 0)
   25924:	b909      	cbnz	r1, 2592a <set_ss_pin_state+0x1a>
        nrf_gpio_pin_clear(pin_number);
   25926:	f7fb be23 	b.w	21570 <nrf_gpio_pin_clear>
        nrf_gpio_pin_set(pin_number);
   2592a:	f7fb be51 	b.w	215d0 <nrf_gpio_pin_set>
}
   2592e:	4770      	bx	lr

00025930 <finish_transfer>:
{
   25930:	b510      	push	{r4, lr}
   25932:	4604      	mov	r4, r0
    set_ss_pin_state(p_cb, false);
   25934:	2100      	movs	r1, #0
   25936:	f7ff ffeb 	bl	25910 <set_ss_pin_state>
    p_cb->transfer_in_progress = false;
   2593a:	2300      	movs	r3, #0
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2593c:	4620      	mov	r0, r4
    p_cb->transfer_in_progress = false;
   2593e:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   25940:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   25942:	6861      	ldr	r1, [r4, #4]
   25944:	f850 3b08 	ldr.w	r3, [r0], #8
}
   25948:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2594c:	4718      	bx	r3

0002594e <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   2594e:	7b0a      	ldrb	r2, [r1, #12]
{
   25950:	4603      	mov	r3, r0
    switch (p_cb->xfer_desc.type)
   25952:	2a03      	cmp	r2, #3
   25954:	d829      	bhi.n	259aa <xfer_completeness_check+0x5c>
   25956:	e8df f002 	tbb	[pc, r2]
   2595a:	2521      	.short	0x2521
   2595c:	0219      	.short	0x0219
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   2595e:	688a      	ldr	r2, [r1, #8]
   25960:	0350      	lsls	r0, r2, #13
   25962:	d504      	bpl.n	2596e <xfer_completeness_check+0x20>
    return p_reg->TXD.AMOUNT;
   25964:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
   25968:	6908      	ldr	r0, [r1, #16]
   2596a:	4290      	cmp	r0, r2
   2596c:	d107      	bne.n	2597e <xfer_completeness_check+0x30>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   2596e:	688a      	ldr	r2, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   25970:	0352      	lsls	r2, r2, #13
   25972:	d41a      	bmi.n	259aa <xfer_completeness_check+0x5c>
   25974:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   25978:	6949      	ldr	r1, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   2597a:	4291      	cmp	r1, r2
   2597c:	d015      	beq.n	259aa <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   2597e:	2000      	movs	r0, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   25980:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   25982:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   25986:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   2598a:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   2598c:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   25990:	6908      	ldr	r0, [r1, #16]
   25992:	4290      	cmp	r0, r2
   25994:	d1f3      	bne.n	2597e <xfer_completeness_check+0x30>
    return p_reg->RXD.AMOUNT;
   25996:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   2599a:	e7ed      	b.n	25978 <xfer_completeness_check+0x2a>
    return p_reg->TXD.AMOUNT;
   2599c:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   259a0:	6909      	ldr	r1, [r1, #16]
   259a2:	e7ea      	b.n	2597a <xfer_completeness_check+0x2c>
    return p_reg->RXD.AMOUNT;
   259a4:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   259a8:	e7fa      	b.n	259a0 <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   259aa:	2001      	movs	r0, #1
}
   259ac:	4770      	bx	lr

000259ae <nrfx_usbd_consumer>:
{
   259ae:	b530      	push	{r4, r5, lr}
    size_t size = p_transfer->size;
   259b0:	684c      	ldr	r4, [r1, #4]
    if (size < data_size)
   259b2:	429c      	cmp	r4, r3
   259b4:	d209      	bcs.n	259ca <nrfx_usbd_consumer+0x1c>
        p_next->size = 0;
   259b6:	2500      	movs	r5, #0
   259b8:	6045      	str	r5, [r0, #4]
        p_next->p_data = p_transfer->p_data;
   259ba:	6809      	ldr	r1, [r1, #0]
   259bc:	6001      	str	r1, [r0, #0]
    return (ep_size == data_size) && (size != 0);
   259be:	429a      	cmp	r2, r3
   259c0:	d10c      	bne.n	259dc <nrfx_usbd_consumer+0x2e>
   259c2:	1e20      	subs	r0, r4, #0
   259c4:	bf18      	it	ne
   259c6:	2001      	movne	r0, #1
}
   259c8:	bd30      	pop	{r4, r5, pc}
        p_next->size = data_size;
   259ca:	6043      	str	r3, [r0, #4]
        p_next->p_data = p_transfer->p_data;
   259cc:	680d      	ldr	r5, [r1, #0]
        size -= data_size;
   259ce:	1ae4      	subs	r4, r4, r3
        p_next->p_data = p_transfer->p_data;
   259d0:	6005      	str	r5, [r0, #0]
        p_transfer->p_data.addr += data_size;
   259d2:	6808      	ldr	r0, [r1, #0]
        p_transfer->size = size;
   259d4:	604c      	str	r4, [r1, #4]
        p_transfer->p_data.addr += data_size;
   259d6:	4418      	add	r0, r3
   259d8:	6008      	str	r0, [r1, #0]
   259da:	e7f0      	b.n	259be <nrfx_usbd_consumer+0x10>
    return (ep_size == data_size) && (size != 0);
   259dc:	2000      	movs	r0, #0
   259de:	e7f3      	b.n	259c8 <nrfx_usbd_consumer+0x1a>

000259e0 <nrfx_usbd_feeder_ram>:
    if (tx_size > ep_size)
   259e0:	684b      	ldr	r3, [r1, #4]
   259e2:	429a      	cmp	r2, r3
   259e4:	bf28      	it	cs
   259e6:	461a      	movcs	r2, r3
    p_next->p_data = p_transfer->p_data;
   259e8:	680b      	ldr	r3, [r1, #0]
    p_next->size = tx_size;
   259ea:	e9c0 3200 	strd	r3, r2, [r0]
    p_transfer->size -= tx_size;
   259ee:	6848      	ldr	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   259f0:	680b      	ldr	r3, [r1, #0]
    p_transfer->size -= tx_size;
   259f2:	1a80      	subs	r0, r0, r2
   259f4:	6048      	str	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   259f6:	4413      	add	r3, r2
}
   259f8:	3800      	subs	r0, #0
   259fa:	bf18      	it	ne
   259fc:	2001      	movne	r0, #1
    p_transfer->p_data.addr += tx_size;
   259fe:	600b      	str	r3, [r1, #0]
}
   25a00:	4770      	bx	lr

00025a02 <nrfx_usbd_feeder_ram_zlp>:
    if (tx_size > ep_size)
   25a02:	684b      	ldr	r3, [r1, #4]
   25a04:	429a      	cmp	r2, r3
   25a06:	bf28      	it	cs
   25a08:	461a      	movcs	r2, r3
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
   25a0a:	b16a      	cbz	r2, 25a28 <nrfx_usbd_feeder_ram_zlp+0x26>
   25a0c:	680b      	ldr	r3, [r1, #0]
    p_next->size = tx_size;
   25a0e:	e9c0 3200 	strd	r3, r2, [r0]
    p_transfer->size -= tx_size;
   25a12:	684b      	ldr	r3, [r1, #4]
}
   25a14:	1e10      	subs	r0, r2, #0
    p_transfer->size -= tx_size;
   25a16:	eba3 0302 	sub.w	r3, r3, r2
   25a1a:	604b      	str	r3, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   25a1c:	680b      	ldr	r3, [r1, #0]
}
   25a1e:	bf18      	it	ne
   25a20:	2001      	movne	r0, #1
    p_transfer->p_data.addr += tx_size;
   25a22:	4413      	add	r3, r2
   25a24:	600b      	str	r3, [r1, #0]
}
   25a26:	4770      	bx	lr
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
   25a28:	4613      	mov	r3, r2
   25a2a:	e7f0      	b.n	25a0e <nrfx_usbd_feeder_ram_zlp+0xc>

00025a2c <ep2bit>:
    return NRFX_USBD_EP_BITPOS(ep);
   25a2c:	43c3      	mvns	r3, r0
   25a2e:	f000 000f 	and.w	r0, r0, #15
   25a32:	f3c3 13c0 	ubfx	r3, r3, #7, #1
}
   25a36:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   25a3a:	4770      	bx	lr

00025a3c <ev_started_handler>:
}
   25a3c:	4770      	bx	lr

00025a3e <ev_dma_epin7_handler>:
static void ev_dma_epin7_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN7 ); }
   25a3e:	2087      	movs	r0, #135	; 0x87
   25a40:	f7fc bbe2 	b.w	22208 <nrf_usbd_epin_dma_handler>

00025a44 <ev_dma_epin6_handler>:
static void ev_dma_epin6_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN6 ); }
   25a44:	2086      	movs	r0, #134	; 0x86
   25a46:	f7fc bbdf 	b.w	22208 <nrf_usbd_epin_dma_handler>

00025a4a <ev_dma_epin5_handler>:
static void ev_dma_epin5_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN5 ); }
   25a4a:	2085      	movs	r0, #133	; 0x85
   25a4c:	f7fc bbdc 	b.w	22208 <nrf_usbd_epin_dma_handler>

00025a50 <ev_dma_epin4_handler>:
static void ev_dma_epin4_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN4 ); }
   25a50:	2084      	movs	r0, #132	; 0x84
   25a52:	f7fc bbd9 	b.w	22208 <nrf_usbd_epin_dma_handler>

00025a56 <ev_dma_epin3_handler>:
static void ev_dma_epin3_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN3 ); }
   25a56:	2083      	movs	r0, #131	; 0x83
   25a58:	f7fc bbd6 	b.w	22208 <nrf_usbd_epin_dma_handler>

00025a5c <ev_dma_epin2_handler>:
static void ev_dma_epin2_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN2 ); }
   25a5c:	2082      	movs	r0, #130	; 0x82
   25a5e:	f7fc bbd3 	b.w	22208 <nrf_usbd_epin_dma_handler>

00025a62 <ev_dma_epin1_handler>:
static void ev_dma_epin1_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN1 ); }
   25a62:	2081      	movs	r0, #129	; 0x81
   25a64:	f7fc bbd0 	b.w	22208 <nrf_usbd_epin_dma_handler>

00025a68 <ev_dma_epin0_handler>:
static void ev_dma_epin0_handler(void)  { nrf_usbd_ep0in_dma_handler(); }
   25a68:	f7fc bbea 	b.w	22240 <nrf_usbd_ep0in_dma_handler>

00025a6c <nrfx_usbd_ep_max_packet_size_set>:
{
   25a6c:	b508      	push	{r3, lr}
    usbd_ep_state_t * p_state = ep_state_access(ep);
   25a6e:	f7fc fb03 	bl	22078 <ep_state_access>
    p_state->max_packet_size = size;
   25a72:	8181      	strh	r1, [r0, #12]
}
   25a74:	bd08      	pop	{r3, pc}

00025a76 <nrfx_usbd_ep_status_get>:
{
   25a76:	b508      	push	{r3, lr}
    usbd_ep_state_t const * p_state = ep_state_access(ep);
   25a78:	f7fc fafe 	bl	22078 <ep_state_access>
	__asm__ volatile(
   25a7c:	f04f 0220 	mov.w	r2, #32
   25a80:	f3ef 8311 	mrs	r3, BASEPRI
   25a84:	f382 8812 	msr	BASEPRI_MAX, r2
   25a88:	f3bf 8f6f 	isb	sy
    *p_size = p_state->transfer_cnt;
   25a8c:	6882      	ldr	r2, [r0, #8]
   25a8e:	600a      	str	r2, [r1, #0]
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   25a90:	6802      	ldr	r2, [r0, #0]
   25a92:	b92a      	cbnz	r2, 25aa0 <nrfx_usbd_ep_status_get+0x2a>
   25a94:	7b80      	ldrb	r0, [r0, #14]
	__asm__ volatile(
   25a96:	f383 8811 	msr	BASEPRI, r3
   25a9a:	f3bf 8f6f 	isb	sy
}
   25a9e:	bd08      	pop	{r3, pc}
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   25aa0:	2004      	movs	r0, #4
   25aa2:	e7f8      	b.n	25a96 <nrfx_usbd_ep_status_get+0x20>

00025aa4 <ev_dma_epout7_handler>:
static void ev_dma_epout7_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT7); }
   25aa4:	2007      	movs	r0, #7
   25aa6:	f7fc bec5 	b.w	22834 <nrf_usbd_epout_dma_handler>

00025aaa <ev_dma_epout6_handler>:
static void ev_dma_epout6_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT6); }
   25aaa:	2006      	movs	r0, #6
   25aac:	f7fc bec2 	b.w	22834 <nrf_usbd_epout_dma_handler>

00025ab0 <ev_dma_epout5_handler>:
static void ev_dma_epout5_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT5); }
   25ab0:	2005      	movs	r0, #5
   25ab2:	f7fc bebf 	b.w	22834 <nrf_usbd_epout_dma_handler>

00025ab6 <ev_dma_epout4_handler>:
static void ev_dma_epout4_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT4); }
   25ab6:	2004      	movs	r0, #4
   25ab8:	f7fc bebc 	b.w	22834 <nrf_usbd_epout_dma_handler>

00025abc <ev_dma_epout3_handler>:
static void ev_dma_epout3_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT3); }
   25abc:	2003      	movs	r0, #3
   25abe:	f7fc beb9 	b.w	22834 <nrf_usbd_epout_dma_handler>

00025ac2 <ev_dma_epout2_handler>:
static void ev_dma_epout2_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT2); }
   25ac2:	2002      	movs	r0, #2
   25ac4:	f7fc beb6 	b.w	22834 <nrf_usbd_epout_dma_handler>

00025ac8 <ev_dma_epout1_handler>:
static void ev_dma_epout1_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT1); }
   25ac8:	2001      	movs	r0, #1
   25aca:	f7fc beb3 	b.w	22834 <nrf_usbd_epout_dma_handler>

00025ace <nrfx_usbd_ep_abort>:
    usbd_ep_abort(ep);
   25ace:	f7fc bfad 	b.w	22a2c <usbd_ep_abort>

00025ad2 <nrf_gpio_pin_set>:
{
   25ad2:	b507      	push	{r0, r1, r2, lr}
   25ad4:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25ad6:	a801      	add	r0, sp, #4
   25ad8:	f7fd f9da 	bl	22e90 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25adc:	2301      	movs	r3, #1
   25ade:	9a01      	ldr	r2, [sp, #4]
   25ae0:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
   25ae2:	6083      	str	r3, [r0, #8]
}
   25ae4:	b003      	add	sp, #12
   25ae6:	f85d fb04 	ldr.w	pc, [sp], #4

00025aea <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
   25aea:	4770      	bx	lr

00025aec <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   25aec:	b140      	cbz	r0, 25b00 <z_device_is_ready+0x14>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   25aee:	68c3      	ldr	r3, [r0, #12]
   25af0:	7858      	ldrb	r0, [r3, #1]
   25af2:	f010 0001 	ands.w	r0, r0, #1
   25af6:	bf1e      	ittt	ne
   25af8:	7818      	ldrbne	r0, [r3, #0]
   25afa:	fab0 f080 	clzne	r0, r0
   25afe:	0940      	lsrne	r0, r0, #5
}
   25b00:	4770      	bx	lr

00025b02 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   25b02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25b04:	4605      	mov	r5, r0
   25b06:	460e      	mov	r6, r1
	__asm__ volatile(
   25b08:	f04f 0320 	mov.w	r3, #32
   25b0c:	f3ef 8711 	mrs	r7, BASEPRI
   25b10:	f383 8812 	msr	BASEPRI_MAX, r3
   25b14:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   25b18:	f7fe f9d2 	bl	23ec0 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
   25b1c:	4631      	mov	r1, r6
   25b1e:	4604      	mov	r4, r0
   25b20:	4628      	mov	r0, r5
   25b22:	f7ff fe4b 	bl	257bc <k_sys_fatal_error_handler>
	__asm__ volatile(
   25b26:	f387 8811 	msr	BASEPRI, r7
   25b2a:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   25b2e:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   25b30:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   25b34:	f7f8 bece 	b.w	1e8d4 <z_impl_k_thread_abort>

00025b38 <z_early_memset>:
	(void) memset(dst, c, n);
   25b38:	f7ff ba6a 	b.w	25010 <memset>

00025b3c <z_early_memcpy>:
	(void) memcpy(dst, src, n);
   25b3c:	f7ff ba5d 	b.w	24ffa <memcpy>

00025b40 <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   25b40:	e9d0 3203 	ldrd	r3, r2, [r0, #12]
   25b44:	4313      	orrs	r3, r2
   25b46:	f013 0303 	ands.w	r3, r3, #3
   25b4a:	d10c      	bne.n	25b66 <create_free_list+0x26>
	slab->free_list = NULL;
   25b4c:	6143      	str	r3, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   25b4e:	6881      	ldr	r1, [r0, #8]
   25b50:	4299      	cmp	r1, r3
   25b52:	d801      	bhi.n	25b58 <create_free_list+0x18>
	return 0;
   25b54:	2000      	movs	r0, #0
   25b56:	4770      	bx	lr
		*(char **)p = slab->free_list;
   25b58:	6941      	ldr	r1, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   25b5a:	3301      	adds	r3, #1
		*(char **)p = slab->free_list;
   25b5c:	6011      	str	r1, [r2, #0]
		p += slab->block_size;
   25b5e:	68c1      	ldr	r1, [r0, #12]
		slab->free_list = p;
   25b60:	6142      	str	r2, [r0, #20]
		p += slab->block_size;
   25b62:	440a      	add	r2, r1
	for (j = 0U; j < slab->num_blocks; j++) {
   25b64:	e7f3      	b.n	25b4e <create_free_list+0xe>
		return -EINVAL;
   25b66:	f06f 0015 	mvn.w	r0, #21
}
   25b6a:	4770      	bx	lr

00025b6c <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   25b6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25b6e:	4604      	mov	r4, r0
   25b70:	460d      	mov	r5, r1
	__asm__ volatile(
   25b72:	f04f 0320 	mov.w	r3, #32
   25b76:	f3ef 8611 	mrs	r6, BASEPRI
   25b7a:	f383 8812 	msr	BASEPRI_MAX, r3
   25b7e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   25b82:	6947      	ldr	r7, [r0, #20]
   25b84:	b977      	cbnz	r7, 25ba4 <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   25b86:	f000 f9ad 	bl	25ee4 <z_unpend_first_thread>

		if (pending_thread != NULL) {
   25b8a:	b158      	cbz	r0, 25ba4 <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   25b8c:	682a      	ldr	r2, [r5, #0]
   25b8e:	6787      	str	r7, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   25b90:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   25b92:	f000 f95f 	bl	25e54 <z_ready_thread>
			z_reschedule(&slab->lock, key);
   25b96:	4631      	mov	r1, r6
   25b98:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   25b9c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   25ba0:	f7fe b83e 	b.w	23c20 <z_reschedule>
	**(char ***) mem = slab->free_list;
   25ba4:	682b      	ldr	r3, [r5, #0]
   25ba6:	6962      	ldr	r2, [r4, #20]
   25ba8:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   25baa:	682b      	ldr	r3, [r5, #0]
   25bac:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   25bae:	69a3      	ldr	r3, [r4, #24]
   25bb0:	3b01      	subs	r3, #1
   25bb2:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   25bb4:	f386 8811 	msr	BASEPRI, r6
   25bb8:	f3bf 8f6f 	isb	sy
}
   25bbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00025bbe <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   25bbe:	f3ef 8005 	mrs	r0, IPSR
}
   25bc2:	3800      	subs	r0, #0
   25bc4:	bf18      	it	ne
   25bc6:	2001      	movne	r0, #1
   25bc8:	4770      	bx	lr

00025bca <z_impl_k_thread_name_set>:
}
   25bca:	f06f 0057 	mvn.w	r0, #87	; 0x57
   25bce:	4770      	bx	lr

00025bd0 <z_impl_k_thread_start>:
	z_sched_start(thread);
   25bd0:	f7fe b838 	b.w	23c44 <z_sched_start>

00025bd4 <z_pm_save_idle_exit>:
{
   25bd4:	b508      	push	{r3, lr}
	pm_system_resume();
   25bd6:	f7f7 f9d1 	bl	1cf7c <pm_system_resume>
}
   25bda:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   25bde:	f7ff bddc 	b.w	2579a <sys_clock_idle_exit>

00025be2 <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
   25be2:	f990 300e 	ldrsb.w	r3, [r0, #14]
   25be6:	428b      	cmp	r3, r1
   25be8:	d001      	beq.n	25bee <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
   25bea:	f7fd bfd3 	b.w	23b94 <z_set_prio>
}
   25bee:	2000      	movs	r0, #0
   25bf0:	4770      	bx	lr

00025bf2 <z_impl_k_mutex_init>:
{
   25bf2:	4603      	mov	r3, r0
	mutex->owner = NULL;
   25bf4:	2000      	movs	r0, #0
	list->tail = (sys_dnode_t *)list;
   25bf6:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   25bfa:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   25bfe:	4770      	bx	lr

00025c00 <queue_insert>:
{
   25c00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   25c04:	4699      	mov	r9, r3
   25c06:	4604      	mov	r4, r0
   25c08:	460d      	mov	r5, r1
   25c0a:	4690      	mov	r8, r2
   25c0c:	f89d 3020 	ldrb.w	r3, [sp, #32]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   25c10:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   25c14:	f04f 0220 	mov.w	r2, #32
   25c18:	f3ef 8711 	mrs	r7, BASEPRI
   25c1c:	f382 8812 	msr	BASEPRI_MAX, r2
   25c20:	f3bf 8f6f 	isb	sy
	if (is_append) {
   25c24:	b103      	cbz	r3, 25c28 <queue_insert+0x28>
	return list->tail;
   25c26:	6845      	ldr	r5, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   25c28:	4630      	mov	r0, r6
   25c2a:	f000 f95b 	bl	25ee4 <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   25c2e:	b158      	cbz	r0, 25c48 <queue_insert+0x48>
   25c30:	2300      	movs	r3, #0
   25c32:	f8c0 8014 	str.w	r8, [r0, #20]
   25c36:	6783      	str	r3, [r0, #120]	; 0x78
	z_ready_thread(thread);
   25c38:	f000 f90c 	bl	25e54 <z_ready_thread>
	z_reschedule(&queue->lock, key);
   25c3c:	4630      	mov	r0, r6
   25c3e:	4639      	mov	r1, r7
   25c40:	f7fd ffee 	bl	23c20 <z_reschedule>
		return 0;
   25c44:	2000      	movs	r0, #0
   25c46:	e00c      	b.n	25c62 <queue_insert+0x62>
	if (alloc) {
   25c48:	f1b9 0f00 	cmp.w	r9, #0
   25c4c:	d01c      	beq.n	25c88 <queue_insert+0x88>
	return z_thread_aligned_alloc(0, size);
   25c4e:	2108      	movs	r1, #8
   25c50:	f7fe fbaa 	bl	243a8 <z_thread_aligned_alloc>
		if (anode == NULL) {
   25c54:	b938      	cbnz	r0, 25c66 <queue_insert+0x66>
	__asm__ volatile(
   25c56:	f387 8811 	msr	BASEPRI, r7
   25c5a:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   25c5e:	f06f 000b 	mvn.w	r0, #11
}
   25c62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   25c66:	2201      	movs	r2, #1
		anode->data = data;
   25c68:	f8c0 8004 	str.w	r8, [r0, #4]
   25c6c:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25c6e:	6801      	ldr	r1, [r0, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c70:	f001 0103 	and.w	r1, r1, #3
Z_GENLIST_INSERT(sflist, sfnode)
   25c74:	b965      	cbnz	r5, 25c90 <queue_insert+0x90>
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c76:	6822      	ldr	r2, [r4, #0]
   25c78:	430a      	orrs	r2, r1
   25c7a:	6002      	str	r2, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   25c7c:	6862      	ldr	r2, [r4, #4]
	list->head = node;
   25c7e:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   25c80:	2a00      	cmp	r2, #0
   25c82:	d1db      	bne.n	25c3c <queue_insert+0x3c>
	list->tail = node;
   25c84:	6060      	str	r0, [r4, #4]
}
   25c86:	e7d9      	b.n	25c3c <queue_insert+0x3c>
}
   25c88:	4640      	mov	r0, r8
	node->next_and_flags = flags;
   25c8a:	f8c8 9000 	str.w	r9, [r8]
}
   25c8e:	e7ee      	b.n	25c6e <queue_insert+0x6e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   25c90:	682a      	ldr	r2, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   25c92:	2a03      	cmp	r2, #3
   25c94:	d80b      	bhi.n	25cae <queue_insert+0xae>
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c96:	6001      	str	r1, [r0, #0]
	return list->tail;
   25c98:	6861      	ldr	r1, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   25c9a:	b911      	cbnz	r1, 25ca2 <queue_insert+0xa2>
	list->head = node;
   25c9c:	e9c4 0000 	strd	r0, r0, [r4]
}
   25ca0:	e7cc      	b.n	25c3c <queue_insert+0x3c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25ca2:	680a      	ldr	r2, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   25ca4:	f002 0203 	and.w	r2, r2, #3
   25ca8:	4302      	orrs	r2, r0
   25caa:	600a      	str	r2, [r1, #0]
   25cac:	e7ea      	b.n	25c84 <queue_insert+0x84>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   25cae:	f022 0203 	bic.w	r2, r2, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   25cb2:	430a      	orrs	r2, r1
   25cb4:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25cb6:	682a      	ldr	r2, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   25cb8:	f002 0203 	and.w	r2, r2, #3
   25cbc:	ea40 0302 	orr.w	r3, r0, r2
   25cc0:	602b      	str	r3, [r5, #0]
}
   25cc2:	e7bb      	b.n	25c3c <queue_insert+0x3c>

00025cc4 <z_queue_node_peek>:
{
   25cc4:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   25cc6:	4604      	mov	r4, r0
   25cc8:	b130      	cbz	r0, 25cd8 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25cca:	6802      	ldr	r2, [r0, #0]
   25ccc:	0793      	lsls	r3, r2, #30
   25cce:	d003      	beq.n	25cd8 <z_queue_node_peek+0x14>
		ret = anode->data;
   25cd0:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   25cd2:	b109      	cbz	r1, 25cd8 <z_queue_node_peek+0x14>
			k_free(anode);
   25cd4:	f000 f9d5 	bl	26082 <k_free>
}
   25cd8:	4620      	mov	r0, r4
   25cda:	bd10      	pop	{r4, pc}

00025cdc <k_queue_append>:
	(void)queue_insert(queue, NULL, data, false, true);
   25cdc:	2301      	movs	r3, #1
{
   25cde:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
   25ce0:	9300      	str	r3, [sp, #0]
   25ce2:	2300      	movs	r3, #0
{
   25ce4:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
   25ce6:	4619      	mov	r1, r3
   25ce8:	f7ff ff8a 	bl	25c00 <queue_insert>
}
   25cec:	b003      	add	sp, #12
   25cee:	f85d fb04 	ldr.w	pc, [sp], #4

00025cf2 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   25cf2:	b13a      	cbz	r2, 25d04 <z_impl_k_sem_init+0x12>
   25cf4:	428a      	cmp	r2, r1
   25cf6:	d305      	bcc.n	25d04 <z_impl_k_sem_init+0x12>
	sem->limit = limit;
   25cf8:	e9c0 1202 	strd	r1, r2, [r0, #8]
   25cfc:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
   25d00:	2000      	movs	r0, #0
   25d02:	4770      	bx	lr
		return -EINVAL;
   25d04:	f06f 0015 	mvn.w	r0, #21
}
   25d08:	4770      	bx	lr

00025d0a <flag_test_and_clear>:
	*flagp &= ~BIT(bit);
   25d0a:	2301      	movs	r3, #1
	return (*flagp & BIT(bit)) != 0U;
   25d0c:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
   25d0e:	408b      	lsls	r3, r1
   25d10:	ea22 0303 	bic.w	r3, r2, r3
   25d14:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
   25d16:	fa22 f001 	lsr.w	r0, r2, r1
}
   25d1a:	f000 0001 	and.w	r0, r0, #1
   25d1e:	4770      	bx	lr

00025d20 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
   25d20:	b120      	cbz	r0, 25d2c <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
   25d22:	2200      	movs	r2, #0
   25d24:	3088      	adds	r0, #136	; 0x88
   25d26:	4611      	mov	r1, r2
   25d28:	f000 b936 	b.w	25f98 <z_sched_wake>
}
   25d2c:	4770      	bx	lr

00025d2e <work_timeout>:
{
   25d2e:	b573      	push	{r0, r1, r4, r5, r6, lr}
   25d30:	4604      	mov	r4, r0
	__asm__ volatile(
   25d32:	f04f 0320 	mov.w	r3, #32
   25d36:	f3ef 8511 	mrs	r5, BASEPRI
   25d3a:	f383 8812 	msr	BASEPRI_MAX, r3
   25d3e:	f3bf 8f6f 	isb	sy
	struct k_work_q *queue = NULL;
   25d42:	2300      	movs	r3, #0
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   25d44:	f1a0 0610 	sub.w	r6, r0, #16
   25d48:	2103      	movs	r1, #3
   25d4a:	3804      	subs	r0, #4
	struct k_work_q *queue = NULL;
   25d4c:	9301      	str	r3, [sp, #4]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   25d4e:	f7ff ffdc 	bl	25d0a <flag_test_and_clear>
   25d52:	b128      	cbz	r0, 25d60 <work_timeout+0x32>
		queue = dw->queue;
   25d54:	69a3      	ldr	r3, [r4, #24]
		(void)submit_to_queue_locked(wp, &queue);
   25d56:	4630      	mov	r0, r6
   25d58:	a901      	add	r1, sp, #4
		queue = dw->queue;
   25d5a:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
   25d5c:	f7fd fcfe 	bl	2375c <submit_to_queue_locked>
	__asm__ volatile(
   25d60:	f385 8811 	msr	BASEPRI, r5
   25d64:	f3bf 8f6f 	isb	sy
}
   25d68:	b002      	add	sp, #8
   25d6a:	bd70      	pop	{r4, r5, r6, pc}

00025d6c <k_work_init>:
{
   25d6c:	b538      	push	{r3, r4, r5, lr}
   25d6e:	4604      	mov	r4, r0
   25d70:	460d      	mov	r5, r1
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   25d72:	2210      	movs	r2, #16
   25d74:	2100      	movs	r1, #0
   25d76:	f7ff f94b 	bl	25010 <memset>
   25d7a:	6065      	str	r5, [r4, #4]
}
   25d7c:	bd38      	pop	{r3, r4, r5, pc}

00025d7e <z_work_submit_to_queue>:
{
   25d7e:	b513      	push	{r0, r1, r4, lr}
   25d80:	9001      	str	r0, [sp, #4]
   25d82:	4608      	mov	r0, r1
	__asm__ volatile(
   25d84:	f04f 0320 	mov.w	r3, #32
   25d88:	f3ef 8411 	mrs	r4, BASEPRI
   25d8c:	f383 8812 	msr	BASEPRI_MAX, r3
   25d90:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
   25d94:	a901      	add	r1, sp, #4
   25d96:	f7fd fce1 	bl	2375c <submit_to_queue_locked>
	__asm__ volatile(
   25d9a:	f384 8811 	msr	BASEPRI, r4
   25d9e:	f3bf 8f6f 	isb	sy
}
   25da2:	b002      	add	sp, #8
   25da4:	bd10      	pop	{r4, pc}

00025da6 <k_work_submit_to_queue>:
{
   25da6:	b510      	push	{r4, lr}
	int ret = z_work_submit_to_queue(queue, work);
   25da8:	f7ff ffe9 	bl	25d7e <z_work_submit_to_queue>
	if (ret > 0) {
   25dac:	1e04      	subs	r4, r0, #0
   25dae:	dd09      	ble.n	25dc4 <k_work_submit_to_queue+0x1e>
	__asm__ volatile(
   25db0:	f04f 0320 	mov.w	r3, #32
   25db4:	f3ef 8011 	mrs	r0, BASEPRI
   25db8:	f383 8812 	msr	BASEPRI_MAX, r3
   25dbc:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   25dc0:	f000 f8c4 	bl	25f4c <z_reschedule_irqlock>
}
   25dc4:	4620      	mov	r0, r4
   25dc6:	bd10      	pop	{r4, pc}

00025dc8 <k_work_init_delayable>:
{
   25dc8:	b538      	push	{r3, r4, r5, lr}
	*dwork = (struct k_work_delayable){
   25dca:	2230      	movs	r2, #48	; 0x30
{
   25dcc:	460d      	mov	r5, r1
	*dwork = (struct k_work_delayable){
   25dce:	2100      	movs	r1, #0
{
   25dd0:	4604      	mov	r4, r0
	*dwork = (struct k_work_delayable){
   25dd2:	f7ff f91d 	bl	25010 <memset>
   25dd6:	f44f 7380 	mov.w	r3, #256	; 0x100
   25dda:	6065      	str	r5, [r4, #4]
   25ddc:	60e3      	str	r3, [r4, #12]
}
   25dde:	bd38      	pop	{r3, r4, r5, pc}

00025de0 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   25de0:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   25de4:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   25de6:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   25de8:	2300      	movs	r3, #0
	node->prev = NULL;
   25dea:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
   25dee:	4770      	bx	lr

00025df0 <unpend_thread_no_timeout>:
{
   25df0:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   25df2:	f7ff fff5 	bl	25de0 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   25df6:	7b43      	ldrb	r3, [r0, #13]
   25df8:	f023 0302 	bic.w	r3, r3, #2
   25dfc:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   25dfe:	2300      	movs	r3, #0
   25e00:	6083      	str	r3, [r0, #8]
}
   25e02:	bd08      	pop	{r3, pc}

00025e04 <add_to_waitq_locked>:
{
   25e04:	b538      	push	{r3, r4, r5, lr}
   25e06:	4604      	mov	r4, r0
   25e08:	460d      	mov	r5, r1
	unready_thread(thread);
   25e0a:	f7fd fe45 	bl	23a98 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   25e0e:	7b63      	ldrb	r3, [r4, #13]
   25e10:	f043 0302 	orr.w	r3, r3, #2
   25e14:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   25e16:	b1e5      	cbz	r5, 25e52 <add_to_waitq_locked+0x4e>
		thread->base.pended_on = wait_q;
   25e18:	60a5      	str	r5, [r4, #8]
	return list->head == list;
   25e1a:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25e1c:	429d      	cmp	r5, r3
   25e1e:	d109      	bne.n	25e34 <add_to_waitq_locked+0x30>
	sys_dnode_t *const tail = list->tail;
   25e20:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   25e22:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   25e26:	601c      	str	r4, [r3, #0]
	list->tail = node;
   25e28:	606c      	str	r4, [r5, #4]
}
   25e2a:	e012      	b.n	25e52 <add_to_waitq_locked+0x4e>
	return (node == list->tail) ? NULL : node->next;
   25e2c:	686a      	ldr	r2, [r5, #4]
   25e2e:	4293      	cmp	r3, r2
   25e30:	d0f6      	beq.n	25e20 <add_to_waitq_locked+0x1c>
   25e32:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   25e34:	2b00      	cmp	r3, #0
   25e36:	d0f3      	beq.n	25e20 <add_to_waitq_locked+0x1c>
	int32_t b1 = thread_1->base.prio;
   25e38:	f994 200e 	ldrsb.w	r2, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   25e3c:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
   25e40:	428a      	cmp	r2, r1
   25e42:	d0f3      	beq.n	25e2c <add_to_waitq_locked+0x28>
		if (z_sched_prio_cmp(thread, t) > 0) {
   25e44:	4291      	cmp	r1, r2
   25e46:	ddf1      	ble.n	25e2c <add_to_waitq_locked+0x28>
	sys_dnode_t *const prev = successor->prev;
   25e48:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   25e4a:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   25e4e:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   25e50:	605c      	str	r4, [r3, #4]
}
   25e52:	bd38      	pop	{r3, r4, r5, pc}

00025e54 <z_ready_thread>:
{
   25e54:	b510      	push	{r4, lr}
   25e56:	f04f 0320 	mov.w	r3, #32
   25e5a:	f3ef 8411 	mrs	r4, BASEPRI
   25e5e:	f383 8812 	msr	BASEPRI_MAX, r3
   25e62:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   25e66:	f7fd fde3 	bl	23a30 <ready_thread>
	__asm__ volatile(
   25e6a:	f384 8811 	msr	BASEPRI, r4
   25e6e:	f3bf 8f6f 	isb	sy
}
   25e72:	bd10      	pop	{r4, pc}

00025e74 <z_unpend_thread_no_timeout>:
{
   25e74:	b508      	push	{r3, lr}
	__asm__ volatile(
   25e76:	f04f 0220 	mov.w	r2, #32
   25e7a:	f3ef 8111 	mrs	r1, BASEPRI
   25e7e:	f382 8812 	msr	BASEPRI_MAX, r2
   25e82:	f3bf 8f6f 	isb	sy
		if (thread->base.pended_on != NULL) {
   25e86:	6883      	ldr	r3, [r0, #8]
   25e88:	b10b      	cbz	r3, 25e8e <z_unpend_thread_no_timeout+0x1a>
			unpend_thread_no_timeout(thread);
   25e8a:	f7ff ffb1 	bl	25df0 <unpend_thread_no_timeout>
	__asm__ volatile(
   25e8e:	f381 8811 	msr	BASEPRI, r1
   25e92:	f3bf 8f6f 	isb	sy
}
   25e96:	bd08      	pop	{r3, pc}

00025e98 <z_sched_wake_thread>:
{
   25e98:	b538      	push	{r3, r4, r5, lr}
   25e9a:	4604      	mov	r4, r0
	__asm__ volatile(
   25e9c:	f04f 0320 	mov.w	r3, #32
   25ea0:	f3ef 8511 	mrs	r5, BASEPRI
   25ea4:	f383 8812 	msr	BASEPRI_MAX, r3
   25ea8:	f3bf 8f6f 	isb	sy
		if (!killed) {
   25eac:	7b43      	ldrb	r3, [r0, #13]
   25eae:	f013 0f28 	tst.w	r3, #40	; 0x28
   25eb2:	d10b      	bne.n	25ecc <z_sched_wake_thread+0x34>
			if (thread->base.pended_on != NULL) {
   25eb4:	6883      	ldr	r3, [r0, #8]
   25eb6:	b10b      	cbz	r3, 25ebc <z_sched_wake_thread+0x24>
				unpend_thread_no_timeout(thread);
   25eb8:	f7ff ff9a 	bl	25df0 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   25ebc:	7b63      	ldrb	r3, [r4, #13]
			if (is_timeout) {
   25ebe:	b951      	cbnz	r1, 25ed6 <z_sched_wake_thread+0x3e>
   25ec0:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
			ready_thread(thread);
   25ec4:	4620      	mov	r0, r4
   25ec6:	7363      	strb	r3, [r4, #13]
   25ec8:	f7fd fdb2 	bl	23a30 <ready_thread>
	__asm__ volatile(
   25ecc:	f385 8811 	msr	BASEPRI, r5
   25ed0:	f3bf 8f6f 	isb	sy
}
   25ed4:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   25ed6:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
}
   25eda:	e7f3      	b.n	25ec4 <z_sched_wake_thread+0x2c>

00025edc <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
   25edc:	2101      	movs	r1, #1
   25ede:	3818      	subs	r0, #24
   25ee0:	f7ff bfda 	b.w	25e98 <z_sched_wake_thread>

00025ee4 <z_unpend_first_thread>:
{
   25ee4:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   25ee6:	f04f 0320 	mov.w	r3, #32
   25eea:	f3ef 8511 	mrs	r5, BASEPRI
   25eee:	f383 8812 	msr	BASEPRI_MAX, r3
   25ef2:	f3bf 8f6f 	isb	sy
	return list->head == list;
   25ef6:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25ef8:	42a0      	cmp	r0, r4
   25efa:	d00d      	beq.n	25f18 <z_unpend_first_thread+0x34>
		if (thread != NULL) {
   25efc:	b134      	cbz	r4, 25f0c <z_unpend_first_thread+0x28>
			unpend_thread_no_timeout(thread);
   25efe:	4620      	mov	r0, r4
   25f00:	f7ff ff76 	bl	25df0 <unpend_thread_no_timeout>
   25f04:	f104 0018 	add.w	r0, r4, #24
   25f08:	f000 f869 	bl	25fde <z_abort_timeout>
	__asm__ volatile(
   25f0c:	f385 8811 	msr	BASEPRI, r5
   25f10:	f3bf 8f6f 	isb	sy
}
   25f14:	4620      	mov	r0, r4
   25f16:	bd38      	pop	{r3, r4, r5, pc}
   25f18:	2400      	movs	r4, #0
   25f1a:	e7f7      	b.n	25f0c <z_unpend_first_thread+0x28>

00025f1c <z_unpend_thread>:
{
   25f1c:	4601      	mov	r1, r0
   25f1e:	b510      	push	{r4, lr}
	__asm__ volatile(
   25f20:	f04f 0320 	mov.w	r3, #32
   25f24:	f3ef 8411 	mrs	r4, BASEPRI
   25f28:	f383 8812 	msr	BASEPRI_MAX, r3
   25f2c:	f3bf 8f6f 	isb	sy
		if (thread->base.pended_on != NULL) {
   25f30:	6883      	ldr	r3, [r0, #8]
   25f32:	b10b      	cbz	r3, 25f38 <z_unpend_thread+0x1c>
			unpend_thread_no_timeout(thread);
   25f34:	f7ff ff5c 	bl	25df0 <unpend_thread_no_timeout>
	__asm__ volatile(
   25f38:	f384 8811 	msr	BASEPRI, r4
   25f3c:	f3bf 8f6f 	isb	sy
}
   25f40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   25f44:	f101 0018 	add.w	r0, r1, #24
   25f48:	f000 b849 	b.w	25fde <z_abort_timeout>

00025f4c <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   25f4c:	4603      	mov	r3, r0
   25f4e:	b920      	cbnz	r0, 25f5a <z_reschedule_irqlock+0xe>
   25f50:	f3ef 8205 	mrs	r2, IPSR
   25f54:	b90a      	cbnz	r2, 25f5a <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   25f56:	f7f8 ba35 	b.w	1e3c4 <arch_swap>
   25f5a:	f383 8811 	msr	BASEPRI, r3
   25f5e:	f3bf 8f6f 	isb	sy
}
   25f62:	4770      	bx	lr

00025f64 <z_reschedule_unlocked>:
	__asm__ volatile(
   25f64:	f04f 0320 	mov.w	r3, #32
   25f68:	f3ef 8011 	mrs	r0, BASEPRI
   25f6c:	f383 8812 	msr	BASEPRI_MAX, r3
   25f70:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   25f74:	f7ff bfea 	b.w	25f4c <z_reschedule_irqlock>

00025f78 <z_unpend_all>:
{
   25f78:	b538      	push	{r3, r4, r5, lr}
   25f7a:	4605      	mov	r5, r0
	int need_sched = 0;
   25f7c:	2000      	movs	r0, #0
	return list->head == list;
   25f7e:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25f80:	42a5      	cmp	r5, r4
   25f82:	d000      	beq.n	25f86 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   25f84:	b904      	cbnz	r4, 25f88 <z_unpend_all+0x10>
}
   25f86:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   25f88:	4620      	mov	r0, r4
   25f8a:	f7ff ffc7 	bl	25f1c <z_unpend_thread>
		z_ready_thread(thread);
   25f8e:	4620      	mov	r0, r4
   25f90:	f7ff ff60 	bl	25e54 <z_ready_thread>
		need_sched = 1;
   25f94:	2001      	movs	r0, #1
   25f96:	e7f2      	b.n	25f7e <z_unpend_all+0x6>

00025f98 <z_sched_wake>:
{
   25f98:	b538      	push	{r3, r4, r5, lr}
   25f9a:	f04f 0320 	mov.w	r3, #32
   25f9e:	f3ef 8511 	mrs	r5, BASEPRI
   25fa2:	f383 8812 	msr	BASEPRI_MAX, r3
   25fa6:	f3bf 8f6f 	isb	sy
	return list->head == list;
   25faa:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25fac:	42a0      	cmp	r0, r4
   25fae:	d012      	beq.n	25fd6 <z_sched_wake+0x3e>
		if (thread != NULL) {
   25fb0:	b19c      	cbz	r4, 25fda <z_sched_wake+0x42>
   25fb2:	67a1      	str	r1, [r4, #120]	; 0x78
	thread->base.swap_data = data;
   25fb4:	6162      	str	r2, [r4, #20]
			unpend_thread_no_timeout(thread);
   25fb6:	4620      	mov	r0, r4
   25fb8:	f7ff ff1a 	bl	25df0 <unpend_thread_no_timeout>
   25fbc:	f104 0018 	add.w	r0, r4, #24
   25fc0:	f000 f80d 	bl	25fde <z_abort_timeout>
			ready_thread(thread);
   25fc4:	4620      	mov	r0, r4
   25fc6:	f7fd fd33 	bl	23a30 <ready_thread>
			ret = true;
   25fca:	2001      	movs	r0, #1
	__asm__ volatile(
   25fcc:	f385 8811 	msr	BASEPRI, r5
   25fd0:	f3bf 8f6f 	isb	sy
}
   25fd4:	bd38      	pop	{r3, r4, r5, pc}
	bool ret = false;
   25fd6:	2000      	movs	r0, #0
   25fd8:	e7f8      	b.n	25fcc <z_sched_wake+0x34>
   25fda:	4620      	mov	r0, r4
   25fdc:	e7f6      	b.n	25fcc <z_sched_wake+0x34>

00025fde <z_abort_timeout>:
{
   25fde:	b510      	push	{r4, lr}
	__asm__ volatile(
   25fe0:	f04f 0220 	mov.w	r2, #32
   25fe4:	f3ef 8411 	mrs	r4, BASEPRI
   25fe8:	f382 8812 	msr	BASEPRI_MAX, r2
   25fec:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   25ff0:	6803      	ldr	r3, [r0, #0]
   25ff2:	b13b      	cbz	r3, 26004 <z_abort_timeout+0x26>
			remove_timeout(to);
   25ff4:	f7fe f820 	bl	24038 <remove_timeout>
			ret = 0;
   25ff8:	2000      	movs	r0, #0
	__asm__ volatile(
   25ffa:	f384 8811 	msr	BASEPRI, r4
   25ffe:	f3bf 8f6f 	isb	sy
}
   26002:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   26004:	f06f 0015 	mvn.w	r0, #21
   26008:	e7f7      	b.n	25ffa <z_abort_timeout+0x1c>

0002600a <z_get_next_timeout_expiry>:
{
   2600a:	b510      	push	{r4, lr}
	__asm__ volatile(
   2600c:	f04f 0320 	mov.w	r3, #32
   26010:	f3ef 8411 	mrs	r4, BASEPRI
   26014:	f383 8812 	msr	BASEPRI_MAX, r3
   26018:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   2601c:	f7fd ffec 	bl	23ff8 <next_timeout>
	__asm__ volatile(
   26020:	f384 8811 	msr	BASEPRI, r4
   26024:	f3bf 8f6f 	isb	sy
}
   26028:	bd10      	pop	{r4, pc}

0002602a <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   2602a:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   2602c:	f7fe f900 	bl	24230 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   26030:	bd08      	pop	{r3, pc}

00026032 <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   26032:	f7fe b8fd 	b.w	24230 <sys_clock_tick_get>

00026036 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   26036:	b108      	cbz	r0, 2603c <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   26038:	f7f6 bf5e 	b.w	1cef8 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   2603c:	4770      	bx	lr

0002603e <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2603e:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   26042:	bf08      	it	eq
   26044:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   26048:	b538      	push	{r3, r4, r5, lr}
   2604a:	460c      	mov	r4, r1
   2604c:	4605      	mov	r5, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2604e:	d014      	beq.n	2607a <sys_clock_timeout_end_calc+0x3c>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   26050:	4308      	orrs	r0, r1
   26052:	d103      	bne.n	2605c <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   26054:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   26058:	f7fe b8ea 	b.w	24230 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   2605c:	f06f 0001 	mvn.w	r0, #1
   26060:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   26064:	1b40      	subs	r0, r0, r5
   26066:	eb63 0101 	sbc.w	r1, r3, r1
   2606a:	2900      	cmp	r1, #0
   2606c:	da04      	bge.n	26078 <sys_clock_timeout_end_calc+0x3a>
		return sys_clock_tick_get() + MAX(1, dt);
   2606e:	f7fe f8df 	bl	24230 <sys_clock_tick_get>
   26072:	1940      	adds	r0, r0, r5
   26074:	eb41 0104 	adc.w	r1, r1, r4
}
   26078:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
   2607a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2607e:	4601      	mov	r1, r0
   26080:	e7fa      	b.n	26078 <sys_clock_timeout_end_calc+0x3a>

00026082 <k_free>:
	if (ptr != NULL) {
   26082:	b120      	cbz	r0, 2608e <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
   26084:	1f01      	subs	r1, r0, #4
   26086:	f850 0c04 	ldr.w	r0, [r0, #-4]
   2608a:	f000 b856 	b.w	2613a <k_heap_free>
}
   2608e:	4770      	bx	lr

00026090 <k_heap_init>:
{
   26090:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   26092:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   26096:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   2609a:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   2609c:	f7fe bb9b 	b.w	247d6 <sys_heap_init>

000260a0 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   260a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   260a4:	b085      	sub	sp, #20
   260a6:	e9dd a40e 	ldrd	sl, r4, [sp, #56]	; 0x38
   260aa:	4607      	mov	r7, r0
   260ac:	4688      	mov	r8, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   260ae:	4650      	mov	r0, sl
   260b0:	4621      	mov	r1, r4
{
   260b2:	4691      	mov	r9, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   260b4:	f7ff ffc3 	bl	2603e <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
   260b8:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   260bc:	bf08      	it	eq
   260be:	f1ba 3fff 	cmpeq.w	sl, #4294967295	; 0xffffffff
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   260c2:	4605      	mov	r5, r0
   260c4:	460e      	mov	r6, r1
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
   260c6:	bf04      	itt	eq
   260c8:	f04f 35ff 	moveq.w	r5, #4294967295	; 0xffffffff
   260cc:	f06f 4600 	mvneq.w	r6, #2147483648	; 0x80000000

	k_spinlock_key_t key = k_spin_lock(&h->lock);
   260d0:	f107 0a14 	add.w	sl, r7, #20
	__asm__ volatile(
   260d4:	f04f 0320 	mov.w	r3, #32
   260d8:	f3ef 8411 	mrs	r4, BASEPRI
   260dc:	f383 8812 	msr	BASEPRI_MAX, r3
   260e0:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   260e4:	f107 0b0c 	add.w	fp, r7, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   260e8:	464a      	mov	r2, r9
   260ea:	4641      	mov	r1, r8
   260ec:	4638      	mov	r0, r7
   260ee:	f7fe fb0b 	bl	24708 <sys_heap_aligned_alloc>
   260f2:	9003      	str	r0, [sp, #12]
		now = sys_clock_tick_get();
   260f4:	f7fe f89c 	bl	24230 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   260f8:	9b03      	ldr	r3, [sp, #12]
   260fa:	b13b      	cbz	r3, 2610c <k_heap_aligned_alloc+0x6c>
	__asm__ volatile(
   260fc:	f384 8811 	msr	BASEPRI, r4
   26100:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   26104:	4618      	mov	r0, r3
   26106:	b005      	add	sp, #20
   26108:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   2610c:	1a28      	subs	r0, r5, r0
   2610e:	eb66 0101 	sbc.w	r1, r6, r1
   26112:	2801      	cmp	r0, #1
   26114:	f171 0200 	sbcs.w	r2, r1, #0
   26118:	dbf0      	blt.n	260fc <k_heap_aligned_alloc+0x5c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   2611a:	e9cd 0100 	strd	r0, r1, [sp]
   2611e:	465a      	mov	r2, fp
   26120:	4621      	mov	r1, r4
   26122:	4650      	mov	r0, sl
   26124:	f7fd fd18 	bl	23b58 <z_pend_curr>
	__asm__ volatile(
   26128:	f04f 0320 	mov.w	r3, #32
   2612c:	f3ef 8411 	mrs	r4, BASEPRI
   26130:	f383 8812 	msr	BASEPRI_MAX, r3
   26134:	f3bf 8f6f 	isb	sy
	return k;
   26138:	e7d6      	b.n	260e8 <k_heap_aligned_alloc+0x48>

0002613a <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
   2613a:	b538      	push	{r3, r4, r5, lr}
   2613c:	4604      	mov	r4, r0
   2613e:	f04f 0320 	mov.w	r3, #32
   26142:	f3ef 8511 	mrs	r5, BASEPRI
   26146:	f383 8812 	msr	BASEPRI_MAX, r3
   2614a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   2614e:	f7fe faa3 	bl	24698 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   26152:	f104 000c 	add.w	r0, r4, #12
   26156:	f7ff ff0f 	bl	25f78 <z_unpend_all>
   2615a:	b130      	cbz	r0, 2616a <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   2615c:	4629      	mov	r1, r5
   2615e:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   26162:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   26166:	f7fd bd5b 	b.w	23c20 <z_reschedule>
	__asm__ volatile(
   2616a:	f385 8811 	msr	BASEPRI, r5
   2616e:	f3bf 8f6f 	isb	sy
}
   26172:	bd38      	pop	{r3, r4, r5, pc}

00026174 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   26174:	4770      	bx	lr
	...
