
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0001c000 <_vector_table>:
   1c000:	70 cb 00 20 b9 e7 01 00 4d 4f 02 00 8d e7 01 00     p.. ....MO......
   1c010:	8d e7 01 00 8d e7 01 00 8d e7 01 00 8d e7 01 00     ................
	...
   1c02c:	31 e4 01 00 8d e7 01 00 00 00 00 00 d1 e3 01 00     1...............
   1c03c:	8d e7 01 00                                         ....

0001c040 <_irq_vector_table>:
   1c040:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c050:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c060:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c070:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c080:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c090:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c0a0:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c0b0:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c0c0:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c0d0:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c0e0:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c0f0:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c100:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c110:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c120:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c130:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c140:	b5 e4 01 00 b5 e4 01 00 b5 e4 01 00 b5 e4 01 00     ................
   1c150:	b5 e4 01 00                                         ....

Disassembly of section text:

0001c154 <__aeabi_uldivmod>:
   1c154:	b953      	cbnz	r3, 1c16c <__aeabi_uldivmod+0x18>
   1c156:	b94a      	cbnz	r2, 1c16c <__aeabi_uldivmod+0x18>
   1c158:	2900      	cmp	r1, #0
   1c15a:	bf08      	it	eq
   1c15c:	2800      	cmpeq	r0, #0
   1c15e:	bf1c      	itt	ne
   1c160:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   1c164:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   1c168:	f000 b80c 	b.w	1c184 <__aeabi_idiv0>
   1c16c:	f1ad 0c08 	sub.w	ip, sp, #8
   1c170:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   1c174:	f000 f808 	bl	1c188 <__udivmoddi4>
   1c178:	f8dd e004 	ldr.w	lr, [sp, #4]
   1c17c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1c180:	b004      	add	sp, #16
   1c182:	4770      	bx	lr

0001c184 <__aeabi_idiv0>:
   1c184:	4770      	bx	lr
   1c186:	bf00      	nop

0001c188 <__udivmoddi4>:
   1c188:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1c18c:	4686      	mov	lr, r0
   1c18e:	468c      	mov	ip, r1
   1c190:	4608      	mov	r0, r1
   1c192:	9e08      	ldr	r6, [sp, #32]
   1c194:	4615      	mov	r5, r2
   1c196:	4674      	mov	r4, lr
   1c198:	4619      	mov	r1, r3
   1c19a:	2b00      	cmp	r3, #0
   1c19c:	f040 80c1 	bne.w	1c322 <__udivmoddi4+0x19a>
   1c1a0:	4285      	cmp	r5, r0
   1c1a2:	fab2 f282 	clz	r2, r2
   1c1a6:	d945      	bls.n	1c234 <__udivmoddi4+0xac>
   1c1a8:	b14a      	cbz	r2, 1c1be <__udivmoddi4+0x36>
   1c1aa:	f1c2 0320 	rsb	r3, r2, #32
   1c1ae:	fa00 fc02 	lsl.w	ip, r0, r2
   1c1b2:	4095      	lsls	r5, r2
   1c1b4:	4094      	lsls	r4, r2
   1c1b6:	fa2e f303 	lsr.w	r3, lr, r3
   1c1ba:	ea43 0c0c 	orr.w	ip, r3, ip
   1c1be:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c1c2:	b2a8      	uxth	r0, r5
   1c1c4:	0c23      	lsrs	r3, r4, #16
   1c1c6:	fbbc f8fe 	udiv	r8, ip, lr
   1c1ca:	fb0e cc18 	mls	ip, lr, r8, ip
   1c1ce:	fb08 f900 	mul.w	r9, r8, r0
   1c1d2:	ea43 430c 	orr.w	r3, r3, ip, lsl #16
   1c1d6:	4599      	cmp	r9, r3
   1c1d8:	d928      	bls.n	1c22c <__udivmoddi4+0xa4>
   1c1da:	18eb      	adds	r3, r5, r3
   1c1dc:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
   1c1e0:	d204      	bcs.n	1c1ec <__udivmoddi4+0x64>
   1c1e2:	4599      	cmp	r9, r3
   1c1e4:	d902      	bls.n	1c1ec <__udivmoddi4+0x64>
   1c1e6:	f1a8 0702 	sub.w	r7, r8, #2
   1c1ea:	442b      	add	r3, r5
   1c1ec:	eba3 0309 	sub.w	r3, r3, r9
   1c1f0:	b2a4      	uxth	r4, r4
   1c1f2:	fbb3 fcfe 	udiv	ip, r3, lr
   1c1f6:	fb0e 331c 	mls	r3, lr, ip, r3
   1c1fa:	fb0c f000 	mul.w	r0, ip, r0
   1c1fe:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1c202:	42a0      	cmp	r0, r4
   1c204:	d914      	bls.n	1c230 <__udivmoddi4+0xa8>
   1c206:	192c      	adds	r4, r5, r4
   1c208:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   1c20c:	d204      	bcs.n	1c218 <__udivmoddi4+0x90>
   1c20e:	42a0      	cmp	r0, r4
   1c210:	d902      	bls.n	1c218 <__udivmoddi4+0x90>
   1c212:	f1ac 0302 	sub.w	r3, ip, #2
   1c216:	442c      	add	r4, r5
   1c218:	1a24      	subs	r4, r4, r0
   1c21a:	ea43 4007 	orr.w	r0, r3, r7, lsl #16
   1c21e:	b11e      	cbz	r6, 1c228 <__udivmoddi4+0xa0>
   1c220:	40d4      	lsrs	r4, r2
   1c222:	2300      	movs	r3, #0
   1c224:	6034      	str	r4, [r6, #0]
   1c226:	6073      	str	r3, [r6, #4]
   1c228:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1c22c:	4647      	mov	r7, r8
   1c22e:	e7dd      	b.n	1c1ec <__udivmoddi4+0x64>
   1c230:	4663      	mov	r3, ip
   1c232:	e7f1      	b.n	1c218 <__udivmoddi4+0x90>
   1c234:	bb92      	cbnz	r2, 1c29c <__udivmoddi4+0x114>
   1c236:	1b43      	subs	r3, r0, r5
   1c238:	2101      	movs	r1, #1
   1c23a:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c23e:	b2af      	uxth	r7, r5
   1c240:	0c20      	lsrs	r0, r4, #16
   1c242:	fbb3 fcfe 	udiv	ip, r3, lr
   1c246:	fb0e 331c 	mls	r3, lr, ip, r3
   1c24a:	fb0c f807 	mul.w	r8, ip, r7
   1c24e:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
   1c252:	4598      	cmp	r8, r3
   1c254:	d961      	bls.n	1c31a <__udivmoddi4+0x192>
   1c256:	18eb      	adds	r3, r5, r3
   1c258:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   1c25c:	d204      	bcs.n	1c268 <__udivmoddi4+0xe0>
   1c25e:	4598      	cmp	r8, r3
   1c260:	d902      	bls.n	1c268 <__udivmoddi4+0xe0>
   1c262:	f1ac 0002 	sub.w	r0, ip, #2
   1c266:	442b      	add	r3, r5
   1c268:	eba3 0308 	sub.w	r3, r3, r8
   1c26c:	b2a4      	uxth	r4, r4
   1c26e:	fbb3 fcfe 	udiv	ip, r3, lr
   1c272:	fb0e 331c 	mls	r3, lr, ip, r3
   1c276:	fb0c f707 	mul.w	r7, ip, r7
   1c27a:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1c27e:	42a7      	cmp	r7, r4
   1c280:	d94d      	bls.n	1c31e <__udivmoddi4+0x196>
   1c282:	192c      	adds	r4, r5, r4
   1c284:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   1c288:	d204      	bcs.n	1c294 <__udivmoddi4+0x10c>
   1c28a:	42a7      	cmp	r7, r4
   1c28c:	d902      	bls.n	1c294 <__udivmoddi4+0x10c>
   1c28e:	f1ac 0302 	sub.w	r3, ip, #2
   1c292:	442c      	add	r4, r5
   1c294:	1be4      	subs	r4, r4, r7
   1c296:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   1c29a:	e7c0      	b.n	1c21e <__udivmoddi4+0x96>
   1c29c:	f1c2 0320 	rsb	r3, r2, #32
   1c2a0:	4095      	lsls	r5, r2
   1c2a2:	4094      	lsls	r4, r2
   1c2a4:	fa20 f103 	lsr.w	r1, r0, r3
   1c2a8:	fa2e f303 	lsr.w	r3, lr, r3
   1c2ac:	ea4f 4e15 	mov.w	lr, r5, lsr #16
   1c2b0:	4090      	lsls	r0, r2
   1c2b2:	b2af      	uxth	r7, r5
   1c2b4:	4303      	orrs	r3, r0
   1c2b6:	fbb1 fcfe 	udiv	ip, r1, lr
   1c2ba:	fb0e 101c 	mls	r0, lr, ip, r1
   1c2be:	0c19      	lsrs	r1, r3, #16
   1c2c0:	fb0c f807 	mul.w	r8, ip, r7
   1c2c4:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   1c2c8:	4588      	cmp	r8, r1
   1c2ca:	d922      	bls.n	1c312 <__udivmoddi4+0x18a>
   1c2cc:	1869      	adds	r1, r5, r1
   1c2ce:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   1c2d2:	d204      	bcs.n	1c2de <__udivmoddi4+0x156>
   1c2d4:	4588      	cmp	r8, r1
   1c2d6:	d902      	bls.n	1c2de <__udivmoddi4+0x156>
   1c2d8:	f1ac 0002 	sub.w	r0, ip, #2
   1c2dc:	4429      	add	r1, r5
   1c2de:	eba1 0108 	sub.w	r1, r1, r8
   1c2e2:	b29b      	uxth	r3, r3
   1c2e4:	fbb1 fcfe 	udiv	ip, r1, lr
   1c2e8:	fb0e 111c 	mls	r1, lr, ip, r1
   1c2ec:	fb0c f707 	mul.w	r7, ip, r7
   1c2f0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   1c2f4:	429f      	cmp	r7, r3
   1c2f6:	d90e      	bls.n	1c316 <__udivmoddi4+0x18e>
   1c2f8:	18eb      	adds	r3, r5, r3
   1c2fa:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
   1c2fe:	d204      	bcs.n	1c30a <__udivmoddi4+0x182>
   1c300:	429f      	cmp	r7, r3
   1c302:	d902      	bls.n	1c30a <__udivmoddi4+0x182>
   1c304:	f1ac 0102 	sub.w	r1, ip, #2
   1c308:	442b      	add	r3, r5
   1c30a:	1bdb      	subs	r3, r3, r7
   1c30c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
   1c310:	e793      	b.n	1c23a <__udivmoddi4+0xb2>
   1c312:	4660      	mov	r0, ip
   1c314:	e7e3      	b.n	1c2de <__udivmoddi4+0x156>
   1c316:	4661      	mov	r1, ip
   1c318:	e7f7      	b.n	1c30a <__udivmoddi4+0x182>
   1c31a:	4660      	mov	r0, ip
   1c31c:	e7a4      	b.n	1c268 <__udivmoddi4+0xe0>
   1c31e:	4663      	mov	r3, ip
   1c320:	e7b8      	b.n	1c294 <__udivmoddi4+0x10c>
   1c322:	4283      	cmp	r3, r0
   1c324:	d906      	bls.n	1c334 <__udivmoddi4+0x1ac>
   1c326:	b916      	cbnz	r6, 1c32e <__udivmoddi4+0x1a6>
   1c328:	2100      	movs	r1, #0
   1c32a:	4608      	mov	r0, r1
   1c32c:	e77c      	b.n	1c228 <__udivmoddi4+0xa0>
   1c32e:	e9c6 e000 	strd	lr, r0, [r6]
   1c332:	e7f9      	b.n	1c328 <__udivmoddi4+0x1a0>
   1c334:	fab3 f783 	clz	r7, r3
   1c338:	b98f      	cbnz	r7, 1c35e <__udivmoddi4+0x1d6>
   1c33a:	4283      	cmp	r3, r0
   1c33c:	d301      	bcc.n	1c342 <__udivmoddi4+0x1ba>
   1c33e:	4572      	cmp	r2, lr
   1c340:	d808      	bhi.n	1c354 <__udivmoddi4+0x1cc>
   1c342:	ebbe 0402 	subs.w	r4, lr, r2
   1c346:	eb60 0303 	sbc.w	r3, r0, r3
   1c34a:	2001      	movs	r0, #1
   1c34c:	469c      	mov	ip, r3
   1c34e:	b91e      	cbnz	r6, 1c358 <__udivmoddi4+0x1d0>
   1c350:	2100      	movs	r1, #0
   1c352:	e769      	b.n	1c228 <__udivmoddi4+0xa0>
   1c354:	4638      	mov	r0, r7
   1c356:	e7fa      	b.n	1c34e <__udivmoddi4+0x1c6>
   1c358:	e9c6 4c00 	strd	r4, ip, [r6]
   1c35c:	e7f8      	b.n	1c350 <__udivmoddi4+0x1c8>
   1c35e:	f1c7 0c20 	rsb	ip, r7, #32
   1c362:	40bb      	lsls	r3, r7
   1c364:	fa0e f507 	lsl.w	r5, lr, r7
   1c368:	fa22 f40c 	lsr.w	r4, r2, ip
   1c36c:	fa2e f10c 	lsr.w	r1, lr, ip
   1c370:	40ba      	lsls	r2, r7
   1c372:	431c      	orrs	r4, r3
   1c374:	fa20 f30c 	lsr.w	r3, r0, ip
   1c378:	40b8      	lsls	r0, r7
   1c37a:	ea4f 4914 	mov.w	r9, r4, lsr #16
   1c37e:	4301      	orrs	r1, r0
   1c380:	fa1f fe84 	uxth.w	lr, r4
   1c384:	fbb3 f8f9 	udiv	r8, r3, r9
   1c388:	fb09 3018 	mls	r0, r9, r8, r3
   1c38c:	0c0b      	lsrs	r3, r1, #16
   1c38e:	fb08 fa0e 	mul.w	sl, r8, lr
   1c392:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   1c396:	459a      	cmp	sl, r3
   1c398:	d940      	bls.n	1c41c <__udivmoddi4+0x294>
   1c39a:	18e3      	adds	r3, r4, r3
   1c39c:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
   1c3a0:	d204      	bcs.n	1c3ac <__udivmoddi4+0x224>
   1c3a2:	459a      	cmp	sl, r3
   1c3a4:	d902      	bls.n	1c3ac <__udivmoddi4+0x224>
   1c3a6:	f1a8 0002 	sub.w	r0, r8, #2
   1c3aa:	4423      	add	r3, r4
   1c3ac:	eba3 030a 	sub.w	r3, r3, sl
   1c3b0:	b289      	uxth	r1, r1
   1c3b2:	fbb3 f8f9 	udiv	r8, r3, r9
   1c3b6:	fb09 3318 	mls	r3, r9, r8, r3
   1c3ba:	fb08 fe0e 	mul.w	lr, r8, lr
   1c3be:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   1c3c2:	458e      	cmp	lr, r1
   1c3c4:	d92c      	bls.n	1c420 <__udivmoddi4+0x298>
   1c3c6:	1861      	adds	r1, r4, r1
   1c3c8:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   1c3cc:	d204      	bcs.n	1c3d8 <__udivmoddi4+0x250>
   1c3ce:	458e      	cmp	lr, r1
   1c3d0:	d902      	bls.n	1c3d8 <__udivmoddi4+0x250>
   1c3d2:	f1a8 0302 	sub.w	r3, r8, #2
   1c3d6:	4421      	add	r1, r4
   1c3d8:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
   1c3dc:	eba1 010e 	sub.w	r1, r1, lr
   1c3e0:	fba0 9802 	umull	r9, r8, r0, r2
   1c3e4:	4541      	cmp	r1, r8
   1c3e6:	46ce      	mov	lr, r9
   1c3e8:	4643      	mov	r3, r8
   1c3ea:	d302      	bcc.n	1c3f2 <__udivmoddi4+0x26a>
   1c3ec:	d106      	bne.n	1c3fc <__udivmoddi4+0x274>
   1c3ee:	454d      	cmp	r5, r9
   1c3f0:	d204      	bcs.n	1c3fc <__udivmoddi4+0x274>
   1c3f2:	3801      	subs	r0, #1
   1c3f4:	ebb9 0e02 	subs.w	lr, r9, r2
   1c3f8:	eb68 0304 	sbc.w	r3, r8, r4
   1c3fc:	2e00      	cmp	r6, #0
   1c3fe:	d0a7      	beq.n	1c350 <__udivmoddi4+0x1c8>
   1c400:	ebb5 020e 	subs.w	r2, r5, lr
   1c404:	eb61 0103 	sbc.w	r1, r1, r3
   1c408:	fa01 fc0c 	lsl.w	ip, r1, ip
   1c40c:	fa22 f307 	lsr.w	r3, r2, r7
   1c410:	40f9      	lsrs	r1, r7
   1c412:	ea4c 0303 	orr.w	r3, ip, r3
   1c416:	e9c6 3100 	strd	r3, r1, [r6]
   1c41a:	e799      	b.n	1c350 <__udivmoddi4+0x1c8>
   1c41c:	4640      	mov	r0, r8
   1c41e:	e7c5      	b.n	1c3ac <__udivmoddi4+0x224>
   1c420:	4643      	mov	r3, r8
   1c422:	e7d9      	b.n	1c3d8 <__udivmoddi4+0x250>

0001c424 <main>:
#define LED0_NODE DT_ALIAS(led0) // red led
static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);


void main(void)
{
   1c424:	b537      	push	{r0, r1, r2, r4, r5, lr}
 */
__syscall bool device_is_ready(const struct device *dev);

static inline bool z_impl_device_is_ready(const struct device *dev)
{
	return z_device_is_ready(dev);
   1c426:	4820      	ldr	r0, [pc, #128]	; (1c4a8 <main+0x84>)
   1c428:	f009 fb4c 	bl	25ac4 <z_device_is_ready>
   1c42c:	4c1e      	ldr	r4, [pc, #120]	; (1c4a8 <main+0x84>)
	int ret;

	if (!device_is_ready(led.port)) {
   1c42e:	2800      	cmp	r0, #0
   1c430:	d037      	beq.n	1c4a2 <main+0x7e>
   1c432:	4620      	mov	r0, r4
   1c434:	f009 fb46 	bl	25ac4 <z_device_is_ready>
		return;
	}
	/* STEP 4 - Verify that the device is ready for use */
	if (!device_is_ready(button.port)) {
   1c438:	2800      	cmp	r0, #0
   1c43a:	d032      	beq.n	1c4a2 <main+0x7e>
		return;
	}

	ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
   1c43c:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   1c440:	481a      	ldr	r0, [pc, #104]	; (1c4ac <main+0x88>)
   1c442:	f007 ffef 	bl	24424 <gpio_pin_configure_dt>
	if (ret < 0) {
   1c446:	2800      	cmp	r0, #0
   1c448:	db2b      	blt.n	1c4a2 <main+0x7e>
		return;
	}

	/* STEP 5 - Configure the pin connected to the button to be an input pin and set its hardware specifications */
	ret = gpio_pin_configure_dt(&button, GPIO_INPUT);
   1c44a:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   1c44e:	4818      	ldr	r0, [pc, #96]	; (1c4b0 <main+0x8c>)
   1c450:	f007 ffe8 	bl	24424 <gpio_pin_configure_dt>
	if (ret < 0) {
   1c454:	2800      	cmp	r0, #0
   1c456:	db24      	blt.n	1c4a2 <main+0x7e>
 * @retval -EWOULDBLOCK if operation would block.
 */
static inline int gpio_port_get(const struct device *port,
				gpio_port_value_t *value)
{
	const struct gpio_driver_data *const data =
   1c458:	6925      	ldr	r5, [r4, #16]
	return api->port_get_raw(port, value);
   1c45a:	68a3      	ldr	r3, [r4, #8]
   1c45c:	4620      	mov	r0, r4
   1c45e:	685b      	ldr	r3, [r3, #4]
   1c460:	a901      	add	r1, sp, #4
   1c462:	4798      	blx	r3
			(const struct gpio_driver_data *)port->data;
	int ret;

	ret = gpio_port_get_raw(port, value);
	if (ret == 0) {
   1c464:	b170      	cbz	r0, 1c484 <main+0x60>
			(const struct gpio_driver_data *)port->data;

	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1c466:	682b      	ldr	r3, [r5, #0]
   1c468:	05d9      	lsls	r1, r3, #23
   1c46a:	d414      	bmi.n	1c496 <main+0x72>
	return api->port_set_bits_raw(port, pins);
   1c46c:	68a3      	ldr	r3, [r4, #8]
   1c46e:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   1c470:	f44f 7180 	mov.w	r1, #256	; 0x100
   1c474:	4620      	mov	r0, r4
   1c476:	4798      	blx	r3
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm0 = { .val = timeout };
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
   1c478:	2100      	movs	r1, #0
   1c47a:	f640 40cd 	movw	r0, #3277	; 0xccd
   1c47e:	f007 fcd7 	bl	23e30 <z_impl_k_sleep>
 * @return Zero if the requested time has elapsed or the number of milliseconds
 * left to sleep, if thread was woken up by \ref k_wakeup call.
 */
static inline int32_t k_msleep(int32_t ms)
{
	return k_sleep(Z_TIMEOUT_MS(ms));
   1c482:	e7ea      	b.n	1c45a <main+0x36>
		*value ^= data->invert;
   1c484:	682a      	ldr	r2, [r5, #0]
   1c486:	9b01      	ldr	r3, [sp, #4]
   1c488:	4053      	eors	r3, r2
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1c48a:	05d2      	lsls	r2, r2, #23
		ret = (value & (gpio_port_pins_t)BIT(pin)) != 0 ? 1 : 0;
   1c48c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1c490:	d404      	bmi.n	1c49c <main+0x78>
	if (value != 0)	{
   1c492:	2b00      	cmp	r3, #0
   1c494:	d1ea      	bne.n	1c46c <main+0x48>
	return api->port_clear_bits_raw(port, pins);
   1c496:	68a3      	ldr	r3, [r4, #8]
   1c498:	691b      	ldr	r3, [r3, #16]
   1c49a:	e7e9      	b.n	1c470 <main+0x4c>
	if (value != 0)	{
   1c49c:	2b00      	cmp	r3, #0
   1c49e:	d0e5      	beq.n	1c46c <main+0x48>
   1c4a0:	e7f9      	b.n	1c496 <main+0x72>
		bool val = gpio_pin_get_dt(&button);
		/* STEP 6.2 - Update the LED to the status of the button */
		gpio_pin_set_dt(&led,val);
		k_msleep(SLEEP_TIME_MS); // Put the main thread to sleep for 100ms for power optimization
	}
}
   1c4a2:	b003      	add	sp, #12
   1c4a4:	bd30      	pop	{r4, r5, pc}
   1c4a6:	bf00      	nop
   1c4a8:	00026218 	.word	0x00026218
   1c4ac:	00026638 	.word	0x00026638
   1c4b0:	00026640 	.word	0x00026640

0001c4b4 <char_out>:
}

static int char_out(int c, void *ctx_p)
{
	(void) ctx_p;
	return _char_out(c);
   1c4b4:	4b01      	ldr	r3, [pc, #4]	; (1c4bc <char_out+0x8>)
   1c4b6:	681b      	ldr	r3, [r3, #0]
   1c4b8:	4718      	bx	r3
   1c4ba:	bf00      	nop
   1c4bc:	2000a0b0 	.word	0x2000a0b0

0001c4c0 <__printk_hook_install>:
	_char_out = fn;
   1c4c0:	4b01      	ldr	r3, [pc, #4]	; (1c4c8 <__printk_hook_install+0x8>)
   1c4c2:	6018      	str	r0, [r3, #0]
}
   1c4c4:	4770      	bx	lr
   1c4c6:	bf00      	nop
   1c4c8:	2000a0b0 	.word	0x2000a0b0

0001c4cc <vprintk>:
}

void vprintk(const char *fmt, va_list ap)
{
   1c4cc:	b507      	push	{r0, r1, r2, lr}
   1c4ce:	460b      	mov	r3, r1
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap);
#else
static inline
int cbvprintf(cbprintf_cb out, void *ctx, const char *format, va_list ap)
{
	return z_cbvprintf_impl(out, ctx, format, ap, 0);
   1c4d0:	2100      	movs	r1, #0
   1c4d2:	4602      	mov	r2, r0
   1c4d4:	9100      	str	r1, [sp, #0]
   1c4d6:	4803      	ldr	r0, [pc, #12]	; (1c4e4 <vprintk+0x18>)
   1c4d8:	f000 f914 	bl	1c704 <z_cbvprintf_impl>

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
   1c4dc:	b003      	add	sp, #12
   1c4de:	f85d fb04 	ldr.w	pc, [sp], #4
   1c4e2:	bf00      	nop
   1c4e4:	0001c4b5 	.word	0x0001c4b5

0001c4e8 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
   1c4e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1c4ec:	8b05      	ldrh	r5, [r0, #24]
{
   1c4ee:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
   1c4f0:	0728      	lsls	r0, r5, #28
{
   1c4f2:	4690      	mov	r8, r2
	if (processing) {
   1c4f4:	d411      	bmi.n	1c51a <process_event+0x32>

	sys_slist_init(&clients);
	do {
		onoff_transition_fn transit = NULL;

		if (evt == EVT_RECHECK) {
   1c4f6:	2902      	cmp	r1, #2
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1c4f8:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
   1c4fc:	f040 80cd 	bne.w	1c69a <process_event+0x1b2>
			evt = process_recheck(mgr);
   1c500:	4620      	mov	r0, r4
   1c502:	f008 f9a7 	bl	24854 <process_recheck>
		}

		if (evt == EVT_NOP) {
   1c506:	b178      	cbz	r0, 1c528 <process_event+0x40>
			break;
		}

		res = 0;
		if (evt == EVT_COMPLETE) {
   1c508:	3801      	subs	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c50a:	8b21      	ldrh	r1, [r4, #24]
   1c50c:	2804      	cmp	r0, #4
   1c50e:	d811      	bhi.n	1c534 <process_event+0x4c>
   1c510:	e8df f000 	tbb	[pc, r0]
   1c514:	856d10c3 	.word	0x856d10c3
   1c518:	95          	.byte	0x95
   1c519:	00          	.byte	0x00
		if (evt == EVT_COMPLETE) {
   1c51a:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
   1c51c:	bf0c      	ite	eq
   1c51e:	f045 0510 	orreq.w	r5, r5, #16
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c522:	f045 0520 	orrne.w	r5, r5, #32
   1c526:	8325      	strh	r5, [r4, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   1c528:	f388 8811 	msr	BASEPRI, r8
   1c52c:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
   1c530:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c534:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1c538:	45aa      	cmp	sl, r5
   1c53a:	f000 80a6 	beq.w	1c68a <process_event+0x1a2>
	 * a memory barrier when used like this, and we don't have a
	 * Zephyr framework for that.
	 */
	atomic_clear(&l->locked);
#endif
	arch_irq_unlock(key.key);
   1c53e:	2700      	movs	r7, #0
   1c540:	46b9      	mov	r9, r7
   1c542:	463e      	mov	r6, r7
   1c544:	68a3      	ldr	r3, [r4, #8]
   1c546:	2b00      	cmp	r3, #0
   1c548:	f000 80bd 	beq.w	1c6c6 <process_event+0x1de>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   1c54c:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   1c550:	8321      	strh	r1, [r4, #24]
   1c552:	f388 8811 	msr	BASEPRI, r8
   1c556:	f3bf 8f6f 	isb	sy
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
   1c55a:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   1c55c:	2900      	cmp	r1, #0
   1c55e:	f000 80bb 	beq.w	1c6d8 <process_event+0x1f0>
	return node->next;
   1c562:	680d      	ldr	r5, [r1, #0]
   1c564:	2900      	cmp	r1, #0
   1c566:	f000 80b7 	beq.w	1c6d8 <process_event+0x1f0>
		mon->callback(mgr, mon, state, res);
   1c56a:	4633      	mov	r3, r6
   1c56c:	4652      	mov	r2, sl
   1c56e:	4620      	mov	r0, r4
   1c570:	f8d1 8004 	ldr.w	r8, [r1, #4]
   1c574:	47c0      	blx	r8
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   1c576:	2d00      	cmp	r5, #0
   1c578:	d076      	beq.n	1c668 <process_event+0x180>
   1c57a:	682b      	ldr	r3, [r5, #0]
   1c57c:	4629      	mov	r1, r5
   1c57e:	461d      	mov	r5, r3
   1c580:	e7f0      	b.n	1c564 <process_event+0x7c>
   1c582:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
   1c586:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
   1c588:	2a01      	cmp	r2, #1
   1c58a:	d81b      	bhi.n	1c5c4 <process_event+0xdc>
	list->head = NULL;
   1c58c:	2200      	movs	r2, #0
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c58e:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
   1c592:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
   1c594:	6827      	ldr	r7, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c596:	b289      	uxth	r1, r1
	list->tail = NULL;
   1c598:	e9c4 2200 	strd	r2, r2, [r4]
		if (state == ONOFF_STATE_TO_ON) {
   1c59c:	d109      	bne.n	1c5b2 <process_event+0xca>
   1c59e:	463b      	mov	r3, r7
   1c5a0:	e003      	b.n	1c5aa <process_event+0xc2>
				mgr->refs += 1U;
   1c5a2:	8b62      	ldrh	r2, [r4, #26]
   1c5a4:	3201      	adds	r2, #1
   1c5a6:	8362      	strh	r2, [r4, #26]
	return node->next;
   1c5a8:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
   1c5aa:	2b00      	cmp	r3, #0
   1c5ac:	d1f9      	bne.n	1c5a2 <process_event+0xba>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5ae:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
   1c5b2:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c5b4:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   1c5b6:	f008 f94d 	bl	24854 <process_recheck>
   1c5ba:	2800      	cmp	r0, #0
   1c5bc:	d07b      	beq.n	1c6b6 <process_event+0x1ce>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c5be:	f041 0120 	orr.w	r1, r1, #32
   1c5c2:	e077      	b.n	1c6b4 <process_event+0x1cc>
	} else if (state == ONOFF_STATE_TO_OFF) {
   1c5c4:	2b04      	cmp	r3, #4
   1c5c6:	d10a      	bne.n	1c5de <process_event+0xf6>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5c8:	f021 0107 	bic.w	r1, r1, #7
   1c5cc:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
   1c5ce:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c5d0:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
   1c5d2:	f008 f93f 	bl	24854 <process_recheck>
   1c5d6:	b110      	cbz	r0, 1c5de <process_event+0xf6>
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c5d8:	f041 0120 	orr.w	r1, r1, #32
   1c5dc:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c5de:	8b21      	ldrh	r1, [r4, #24]
   1c5e0:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1c5e4:	45aa      	cmp	sl, r5
   1c5e6:	d050      	beq.n	1c68a <process_event+0x1a2>
   1c5e8:	2700      	movs	r7, #0
		onoff_transition_fn transit = NULL;
   1c5ea:	46b9      	mov	r9, r7
   1c5ec:	e7aa      	b.n	1c544 <process_event+0x5c>
			transit = mgr->transitions->start;
   1c5ee:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c5f0:	f021 0107 	bic.w	r1, r1, #7
   1c5f4:	f041 0106 	orr.w	r1, r1, #6
				   && !sys_slist_is_empty(&mgr->monitors);
   1c5f8:	2d06      	cmp	r5, #6
			transit = mgr->transitions->start;
   1c5fa:	f8d3 9000 	ldr.w	r9, [r3]
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c5fe:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   1c600:	d12d      	bne.n	1c65e <process_event+0x176>
		    || (transit != NULL)) {
   1c602:	f1b9 0f00 	cmp.w	r9, #0
   1c606:	d040      	beq.n	1c68a <process_event+0x1a2>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   1c608:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   1c60c:	8321      	strh	r1, [r4, #24]
   1c60e:	f388 8811 	msr	BASEPRI, r8
   1c612:	f3bf 8f6f 	isb	sy
				transit(mgr, transition_complete);
   1c616:	4620      	mov	r0, r4
   1c618:	4939      	ldr	r1, [pc, #228]	; (1c700 <process_event+0x218>)
   1c61a:	47c8      	blx	r9
   1c61c:	e029      	b.n	1c672 <process_event+0x18a>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c61e:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->stop;
   1c622:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c624:	f041 0104 	orr.w	r1, r1, #4
   1c628:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
   1c62a:	2d04      	cmp	r5, #4
			transit = mgr->transitions->stop;
   1c62c:	f8d3 9004 	ldr.w	r9, [r3, #4]
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c630:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   1c632:	d0e6      	beq.n	1c602 <process_event+0x11a>
   1c634:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c636:	f04f 0a04 	mov.w	sl, #4
		res = 0;
   1c63a:	463e      	mov	r6, r7
   1c63c:	e782      	b.n	1c544 <process_event+0x5c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c63e:	f021 0107 	bic.w	r1, r1, #7
			transit = mgr->transitions->reset;
   1c642:	6923      	ldr	r3, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c644:	f041 0105 	orr.w	r1, r1, #5
   1c648:	b289      	uxth	r1, r1
				   && !sys_slist_is_empty(&mgr->monitors);
   1c64a:	2d05      	cmp	r5, #5
			transit = mgr->transitions->reset;
   1c64c:	f8d3 9008 	ldr.w	r9, [r3, #8]
	mgr->flags = (state & ONOFF_STATE_MASK)
   1c650:	8321      	strh	r1, [r4, #24]
				   && !sys_slist_is_empty(&mgr->monitors);
   1c652:	d0d6      	beq.n	1c602 <process_event+0x11a>
   1c654:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c656:	f04f 0a05 	mov.w	sl, #5
		res = 0;
   1c65a:	463e      	mov	r6, r7
   1c65c:	e772      	b.n	1c544 <process_event+0x5c>
				   && !sys_slist_is_empty(&mgr->monitors);
   1c65e:	2700      	movs	r7, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c660:	f04f 0a06 	mov.w	sl, #6
		res = 0;
   1c664:	463e      	mov	r6, r7
   1c666:	e76d      	b.n	1c544 <process_event+0x5c>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
   1c668:	462b      	mov	r3, r5
   1c66a:	e787      	b.n	1c57c <process_event+0x94>
			if (transit != NULL) {
   1c66c:	f1b9 0f00 	cmp.w	r9, #0
   1c670:	d1d1      	bne.n	1c616 <process_event+0x12e>
	__asm__ volatile(
   1c672:	f04f 0320 	mov.w	r3, #32
   1c676:	f3ef 8811 	mrs	r8, BASEPRI
   1c67a:	f383 8812 	msr	BASEPRI_MAX, r3
   1c67e:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
   1c682:	8b23      	ldrh	r3, [r4, #24]
   1c684:	f023 0308 	bic.w	r3, r3, #8
   1c688:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
   1c68a:	8b25      	ldrh	r5, [r4, #24]
   1c68c:	06ea      	lsls	r2, r5, #27
   1c68e:	d52e      	bpl.n	1c6ee <process_event+0x206>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   1c690:	f025 0310 	bic.w	r3, r5, #16
   1c694:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   1c696:	f005 0507 	and.w	r5, r5, #7
			res = mgr->last_res;
   1c69a:	6966      	ldr	r6, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1c69c:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
   1c69e:	2e00      	cmp	r6, #0
   1c6a0:	f6bf af6f 	bge.w	1c582 <process_event+0x9a>
	list->head = NULL;
   1c6a4:	2300      	movs	r3, #0
		*clients = mgr->clients;
   1c6a6:	6827      	ldr	r7, [r4, #0]
	list->tail = NULL;
   1c6a8:	e9c4 3300 	strd	r3, r3, [r4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
   1c6ac:	f021 0107 	bic.w	r1, r1, #7
   1c6b0:	f041 0101 	orr.w	r1, r1, #1
			mgr->flags |= ONOFF_FLAG_RECHECK;
   1c6b4:	8321      	strh	r1, [r4, #24]
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
   1c6b6:	8b21      	ldrh	r1, [r4, #24]
   1c6b8:	f04f 0900 	mov.w	r9, #0
   1c6bc:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
   1c6c0:	45aa      	cmp	sl, r5
   1c6c2:	f47f af3f 	bne.w	1c544 <process_event+0x5c>
		    || !sys_slist_is_empty(&clients)
   1c6c6:	2f00      	cmp	r7, #0
   1c6c8:	d09b      	beq.n	1c602 <process_event+0x11a>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
   1c6ca:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
   1c6ce:	8321      	strh	r1, [r4, #24]
	__asm__ volatile(
   1c6d0:	f388 8811 	msr	BASEPRI, r8
   1c6d4:	f3bf 8f6f 	isb	sy
			if (!sys_slist_is_empty(&clients)) {
   1c6d8:	2f00      	cmp	r7, #0
   1c6da:	d0c7      	beq.n	1c66c <process_event+0x184>
	return node->next;
   1c6dc:	683d      	ldr	r5, [r7, #0]
		notify_one(mgr, cli, state, res);
   1c6de:	4639      	mov	r1, r7
   1c6e0:	4633      	mov	r3, r6
   1c6e2:	4652      	mov	r2, sl
   1c6e4:	4620      	mov	r0, r4
   1c6e6:	f008 f8e1 	bl	248ac <notify_one>
	list->head = node;
   1c6ea:	462f      	mov	r7, r5
	while (!sys_slist_is_empty(list)) {
   1c6ec:	e7f4      	b.n	1c6d8 <process_event+0x1f0>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
   1c6ee:	06ab      	lsls	r3, r5, #26
   1c6f0:	f57f af1a 	bpl.w	1c528 <process_event+0x40>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
   1c6f4:	f025 0320 	bic.w	r3, r5, #32
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
   1c6f8:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
   1c6fa:	f005 0507 	and.w	r5, r5, #7
		if (evt == EVT_RECHECK) {
   1c6fe:	e6ff      	b.n	1c500 <process_event+0x18>
   1c700:	000248d9 	.word	0x000248d9

0001c704 <z_cbvprintf_impl>:
	return (int)count;
}

int z_cbvprintf_impl(cbprintf_cb out, void *ctx, const char *fp,
		     va_list ap, uint32_t flags)
{
   1c704:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c708:	4681      	mov	r9, r0
   1c70a:	468b      	mov	fp, r1
   1c70c:	4617      	mov	r7, r2
   1c70e:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
   1c710:	2500      	movs	r5, #0
{
   1c712:	b095      	sub	sp, #84	; 0x54
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
   1c714:	7838      	ldrb	r0, [r7, #0]
   1c716:	b908      	cbnz	r0, 1c71c <z_cbvprintf_impl+0x18>
			OUTC(' ');
			--width;
		}
	}

	return count;
   1c718:	4628      	mov	r0, r5
   1c71a:	e357      	b.n	1cdcc <z_cbvprintf_impl+0x6c8>
			OUTC(*fp++);
   1c71c:	1c7b      	adds	r3, r7, #1
		if (*fp != '%') {
   1c71e:	2825      	cmp	r0, #37	; 0x25
			OUTC(*fp++);
   1c720:	9303      	str	r3, [sp, #12]
		if (*fp != '%') {
   1c722:	d006      	beq.n	1c732 <z_cbvprintf_impl+0x2e>
			OUTC('%');
   1c724:	4659      	mov	r1, fp
   1c726:	47c8      	blx	r9
   1c728:	2800      	cmp	r0, #0
   1c72a:	f2c0 834f 	blt.w	1cdcc <z_cbvprintf_impl+0x6c8>
   1c72e:	3501      	adds	r5, #1
		if (bps == NULL) {
   1c730:	e1fb      	b.n	1cb2a <z_cbvprintf_impl+0x426>
		} state = {
   1c732:	2218      	movs	r2, #24
   1c734:	2100      	movs	r1, #0
   1c736:	a80e      	add	r0, sp, #56	; 0x38
   1c738:	f008 fc56 	bl	24fe8 <memset>
	if (*sp == '%') {
   1c73c:	787b      	ldrb	r3, [r7, #1]
   1c73e:	2b25      	cmp	r3, #37	; 0x25
   1c740:	d07d      	beq.n	1c83e <z_cbvprintf_impl+0x13a>
   1c742:	2300      	movs	r3, #0
   1c744:	4698      	mov	r8, r3
   1c746:	469e      	mov	lr, r3
   1c748:	469c      	mov	ip, r3
   1c74a:	461e      	mov	r6, r3
   1c74c:	1c78      	adds	r0, r7, #1
   1c74e:	4601      	mov	r1, r0
		switch (*sp) {
   1c750:	f810 2b01 	ldrb.w	r2, [r0], #1
   1c754:	2a2b      	cmp	r2, #43	; 0x2b
   1c756:	f000 80a1 	beq.w	1c89c <z_cbvprintf_impl+0x198>
   1c75a:	f200 8098 	bhi.w	1c88e <z_cbvprintf_impl+0x18a>
   1c75e:	2a20      	cmp	r2, #32
   1c760:	f000 809f 	beq.w	1c8a2 <z_cbvprintf_impl+0x19e>
   1c764:	2a23      	cmp	r2, #35	; 0x23
   1c766:	f000 809f 	beq.w	1c8a8 <z_cbvprintf_impl+0x1a4>
   1c76a:	b12b      	cbz	r3, 1c778 <z_cbvprintf_impl+0x74>
   1c76c:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c770:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1c774:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c778:	f1b8 0f00 	cmp.w	r8, #0
   1c77c:	d005      	beq.n	1c78a <z_cbvprintf_impl+0x86>
   1c77e:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c782:	f043 0320 	orr.w	r3, r3, #32
   1c786:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c78a:	f1be 0f00 	cmp.w	lr, #0
   1c78e:	d005      	beq.n	1c79c <z_cbvprintf_impl+0x98>
   1c790:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c794:	f043 0310 	orr.w	r3, r3, #16
   1c798:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c79c:	f1bc 0f00 	cmp.w	ip, #0
   1c7a0:	d005      	beq.n	1c7ae <z_cbvprintf_impl+0xaa>
   1c7a2:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7a6:	f043 0308 	orr.w	r3, r3, #8
   1c7aa:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
   1c7ae:	b12e      	cbz	r6, 1c7bc <z_cbvprintf_impl+0xb8>
   1c7b0:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7b4:	f043 0304 	orr.w	r3, r3, #4
   1c7b8:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (conv->flag_zero && conv->flag_dash) {
   1c7bc:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1c7c0:	f003 0044 	and.w	r0, r3, #68	; 0x44
   1c7c4:	2844      	cmp	r0, #68	; 0x44
   1c7c6:	d103      	bne.n	1c7d0 <z_cbvprintf_impl+0xcc>
		conv->flag_zero = false;
   1c7c8:	f36f 1386 	bfc	r3, #6, #1
   1c7cc:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	conv->width_present = true;
   1c7d0:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
   1c7d4:	2a2a      	cmp	r2, #42	; 0x2a
	conv->width_present = true;
   1c7d6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1c7da:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	if (*sp == '*') {
   1c7de:	d17f      	bne.n	1c8e0 <z_cbvprintf_impl+0x1dc>
		conv->width_star = true;
   1c7e0:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
   1c7e4:	1c4b      	adds	r3, r1, #1
		conv->width_star = true;
   1c7e6:	f042 0201 	orr.w	r2, r2, #1
   1c7ea:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	conv->prec_present = (*sp == '.');
   1c7ee:	781a      	ldrb	r2, [r3, #0]
   1c7f0:	2a2e      	cmp	r2, #46	; 0x2e
   1c7f2:	bf0c      	ite	eq
   1c7f4:	2101      	moveq	r1, #1
   1c7f6:	2100      	movne	r1, #0
   1c7f8:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c7fc:	f361 0241 	bfi	r2, r1, #1, #1
   1c800:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	if (!conv->prec_present) {
   1c804:	d178      	bne.n	1c8f8 <z_cbvprintf_impl+0x1f4>
	if (*sp == '*') {
   1c806:	785a      	ldrb	r2, [r3, #1]
   1c808:	2a2a      	cmp	r2, #42	; 0x2a
   1c80a:	d06e      	beq.n	1c8ea <z_cbvprintf_impl+0x1e6>
	size_t val = 0;
   1c80c:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   1c80e:	f04f 0c0a 	mov.w	ip, #10
	++sp;
   1c812:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   1c814:	4619      	mov	r1, r3
   1c816:	f811 0b01 	ldrb.w	r0, [r1], #1
   1c81a:	f1a0 0630 	sub.w	r6, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
   1c81e:	2e09      	cmp	r6, #9
   1c820:	f240 8095 	bls.w	1c94e <z_cbvprintf_impl+0x24a>
	conv->unsupported |= ((conv->prec_value < 0)
   1c824:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
	conv->prec_value = prec;
   1c828:	9212      	str	r2, [sp, #72]	; 0x48
	conv->unsupported |= ((conv->prec_value < 0)
   1c82a:	f3c1 0040 	ubfx	r0, r1, #1, #1
   1c82e:	ea40 70d2 	orr.w	r0, r0, r2, lsr #31
   1c832:	460a      	mov	r2, r1
   1c834:	f360 0241 	bfi	r2, r0, #1, #1
   1c838:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
   1c83c:	e05c      	b.n	1c8f8 <z_cbvprintf_impl+0x1f4>
		conv->specifier = *sp++;
   1c83e:	1cba      	adds	r2, r7, #2
   1c840:	9203      	str	r2, [sp, #12]
   1c842:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->width_star) {
   1c846:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
   1c84a:	07da      	lsls	r2, r3, #31
   1c84c:	f140 812e 	bpl.w	1caac <z_cbvprintf_impl+0x3a8>
			width = va_arg(ap, int);
   1c850:	f854 8b04 	ldr.w	r8, [r4], #4
			if (width < 0) {
   1c854:	f1b8 0f00 	cmp.w	r8, #0
   1c858:	da07      	bge.n	1c86a <z_cbvprintf_impl+0x166>
				conv->flag_dash = true;
   1c85a:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				width = -width;
   1c85e:	f1c8 0800 	rsb	r8, r8, #0
				conv->flag_dash = true;
   1c862:	f042 0204 	orr.w	r2, r2, #4
   1c866:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
		if (conv->prec_star) {
   1c86a:	075e      	lsls	r6, r3, #29
   1c86c:	f140 8127 	bpl.w	1cabe <z_cbvprintf_impl+0x3ba>
			int arg = va_arg(ap, int);
   1c870:	f854 ab04 	ldr.w	sl, [r4], #4
			if (arg < 0) {
   1c874:	f1ba 0f00 	cmp.w	sl, #0
   1c878:	f280 8126 	bge.w	1cac8 <z_cbvprintf_impl+0x3c4>
				conv->prec_present = false;
   1c87c:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
   1c880:	f36f 0341 	bfc	r3, #1, #1
   1c884:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
		int precision = -1;
   1c888:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
   1c88c:	e11c      	b.n	1cac8 <z_cbvprintf_impl+0x3c4>
		switch (*sp) {
   1c88e:	2a2d      	cmp	r2, #45	; 0x2d
   1c890:	d00d      	beq.n	1c8ae <z_cbvprintf_impl+0x1aa>
   1c892:	2a30      	cmp	r2, #48	; 0x30
   1c894:	f47f af69 	bne.w	1c76a <z_cbvprintf_impl+0x66>
   1c898:	2301      	movs	r3, #1
	} while (loop);
   1c89a:	e758      	b.n	1c74e <z_cbvprintf_impl+0x4a>
		switch (*sp) {
   1c89c:	f04f 0c01 	mov.w	ip, #1
   1c8a0:	e755      	b.n	1c74e <z_cbvprintf_impl+0x4a>
   1c8a2:	f04f 0e01 	mov.w	lr, #1
   1c8a6:	e752      	b.n	1c74e <z_cbvprintf_impl+0x4a>
   1c8a8:	f04f 0801 	mov.w	r8, #1
   1c8ac:	e74f      	b.n	1c74e <z_cbvprintf_impl+0x4a>
   1c8ae:	2601      	movs	r6, #1
   1c8b0:	e74d      	b.n	1c74e <z_cbvprintf_impl+0x4a>
		val = 10U * val + *sp++ - '0';
   1c8b2:	4603      	mov	r3, r0
   1c8b4:	fb0e 6202 	mla	r2, lr, r2, r6
   1c8b8:	3a30      	subs	r2, #48	; 0x30
   1c8ba:	4618      	mov	r0, r3
   1c8bc:	f810 6b01 	ldrb.w	r6, [r0], #1
   1c8c0:	f1a6 0c30 	sub.w	ip, r6, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp) != 0) {
   1c8c4:	f1bc 0f09 	cmp.w	ip, #9
   1c8c8:	d9f3      	bls.n	1c8b2 <z_cbvprintf_impl+0x1ae>
	if (sp != wp) {
   1c8ca:	4299      	cmp	r1, r3
   1c8cc:	d08f      	beq.n	1c7ee <z_cbvprintf_impl+0xea>
		conv->unsupported |= ((conv->width_value < 0)
   1c8ce:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
		conv->width_value = width;
   1c8d2:	9211      	str	r2, [sp, #68]	; 0x44
				      || (width != (size_t)conv->width_value));
   1c8d4:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
   1c8d6:	f362 0141 	bfi	r1, r2, #1, #1
   1c8da:	f88d 1040 	strb.w	r1, [sp, #64]	; 0x40
   1c8de:	e786      	b.n	1c7ee <z_cbvprintf_impl+0xea>
   1c8e0:	460b      	mov	r3, r1
	size_t val = 0;
   1c8e2:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
   1c8e4:	f04f 0e0a 	mov.w	lr, #10
   1c8e8:	e7e7      	b.n	1c8ba <z_cbvprintf_impl+0x1b6>
		conv->prec_star = true;
   1c8ea:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
		return ++sp;
   1c8ee:	3302      	adds	r3, #2
		conv->prec_star = true;
   1c8f0:	f042 0204 	orr.w	r2, r2, #4
   1c8f4:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
	switch (*sp) {
   1c8f8:	781a      	ldrb	r2, [r3, #0]
   1c8fa:	2a6c      	cmp	r2, #108	; 0x6c
   1c8fc:	d047      	beq.n	1c98e <z_cbvprintf_impl+0x28a>
   1c8fe:	d82b      	bhi.n	1c958 <z_cbvprintf_impl+0x254>
   1c900:	2a68      	cmp	r2, #104	; 0x68
   1c902:	d031      	beq.n	1c968 <z_cbvprintf_impl+0x264>
   1c904:	2a6a      	cmp	r2, #106	; 0x6a
   1c906:	d04b      	beq.n	1c9a0 <z_cbvprintf_impl+0x29c>
   1c908:	2a4c      	cmp	r2, #76	; 0x4c
   1c90a:	d051      	beq.n	1c9b0 <z_cbvprintf_impl+0x2ac>
	conv->specifier = *sp++;
   1c90c:	461a      	mov	r2, r3
   1c90e:	f812 3b01 	ldrb.w	r3, [r2], #1
	switch (conv->specifier) {
   1c912:	2b78      	cmp	r3, #120	; 0x78
	conv->specifier = *sp++;
   1c914:	9203      	str	r2, [sp, #12]
   1c916:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
		if (conv->length_mod == LENGTH_UPPER_L) {
   1c91a:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
	switch (conv->specifier) {
   1c91e:	f200 80be 	bhi.w	1ca9e <z_cbvprintf_impl+0x39a>
   1c922:	2b6d      	cmp	r3, #109	; 0x6d
   1c924:	d851      	bhi.n	1c9ca <z_cbvprintf_impl+0x2c6>
   1c926:	2b69      	cmp	r3, #105	; 0x69
   1c928:	f200 80b9 	bhi.w	1ca9e <z_cbvprintf_impl+0x39a>
   1c92c:	2b57      	cmp	r3, #87	; 0x57
   1c92e:	d867      	bhi.n	1ca00 <z_cbvprintf_impl+0x2fc>
   1c930:	2b41      	cmp	r3, #65	; 0x41
   1c932:	d003      	beq.n	1c93c <z_cbvprintf_impl+0x238>
   1c934:	3b45      	subs	r3, #69	; 0x45
   1c936:	2b02      	cmp	r3, #2
   1c938:	f200 80b1 	bhi.w	1ca9e <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_FP;
   1c93c:	2204      	movs	r2, #4
   1c93e:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1c942:	f362 0302 	bfi	r3, r2, #0, #3
   1c946:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
			unsupported = true;
   1c94a:	2301      	movs	r3, #1
			break;
   1c94c:	e073      	b.n	1ca36 <z_cbvprintf_impl+0x332>
		val = 10U * val + *sp++ - '0';
   1c94e:	fb0c 0202 	mla	r2, ip, r2, r0
   1c952:	460b      	mov	r3, r1
   1c954:	3a30      	subs	r2, #48	; 0x30
   1c956:	e75d      	b.n	1c814 <z_cbvprintf_impl+0x110>
	switch (*sp) {
   1c958:	2a74      	cmp	r2, #116	; 0x74
   1c95a:	d025      	beq.n	1c9a8 <z_cbvprintf_impl+0x2a4>
   1c95c:	2a7a      	cmp	r2, #122	; 0x7a
   1c95e:	d1d5      	bne.n	1c90c <z_cbvprintf_impl+0x208>
		conv->length_mod = LENGTH_Z;
   1c960:	2106      	movs	r1, #6
   1c962:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c966:	e00c      	b.n	1c982 <z_cbvprintf_impl+0x27e>
		if (*++sp == 'h') {
   1c968:	785a      	ldrb	r2, [r3, #1]
   1c96a:	2a68      	cmp	r2, #104	; 0x68
   1c96c:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c970:	d106      	bne.n	1c980 <z_cbvprintf_impl+0x27c>
			conv->length_mod = LENGTH_HH;
   1c972:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
   1c974:	f361 02c6 	bfi	r2, r1, #3, #4
   1c978:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
			++sp;
   1c97c:	3302      	adds	r3, #2
   1c97e:	e7c5      	b.n	1c90c <z_cbvprintf_impl+0x208>
			conv->length_mod = LENGTH_H;
   1c980:	2102      	movs	r1, #2
   1c982:	f361 02c6 	bfi	r2, r1, #3, #4
   1c986:	f88d 2041 	strb.w	r2, [sp, #65]	; 0x41
		if (*++sp == 'h') {
   1c98a:	3301      	adds	r3, #1
   1c98c:	e7be      	b.n	1c90c <z_cbvprintf_impl+0x208>
		if (*++sp == 'l') {
   1c98e:	785a      	ldrb	r2, [r3, #1]
   1c990:	2a6c      	cmp	r2, #108	; 0x6c
   1c992:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c996:	d101      	bne.n	1c99c <z_cbvprintf_impl+0x298>
			conv->length_mod = LENGTH_LL;
   1c998:	2104      	movs	r1, #4
   1c99a:	e7eb      	b.n	1c974 <z_cbvprintf_impl+0x270>
			conv->length_mod = LENGTH_L;
   1c99c:	2103      	movs	r1, #3
   1c99e:	e7f0      	b.n	1c982 <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_J;
   1c9a0:	2105      	movs	r1, #5
   1c9a2:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c9a6:	e7ec      	b.n	1c982 <z_cbvprintf_impl+0x27e>
		conv->length_mod = LENGTH_T;
   1c9a8:	2107      	movs	r1, #7
   1c9aa:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   1c9ae:	e7e8      	b.n	1c982 <z_cbvprintf_impl+0x27e>
		conv->unsupported = true;
   1c9b0:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
   1c9b4:	f422 42f0 	bic.w	r2, r2, #30720	; 0x7800
   1c9b8:	f022 0202 	bic.w	r2, r2, #2
   1c9bc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   1c9c0:	f042 0202 	orr.w	r2, r2, #2
   1c9c4:	f8ad 2040 	strh.w	r2, [sp, #64]	; 0x40
		break;
   1c9c8:	e7df      	b.n	1c98a <z_cbvprintf_impl+0x286>
	switch (conv->specifier) {
   1c9ca:	3b6e      	subs	r3, #110	; 0x6e
   1c9cc:	b2d9      	uxtb	r1, r3
   1c9ce:	2301      	movs	r3, #1
   1c9d0:	408b      	lsls	r3, r1
   1c9d2:	f240 4182 	movw	r1, #1154	; 0x482
   1c9d6:	420b      	tst	r3, r1
   1c9d8:	d137      	bne.n	1ca4a <z_cbvprintf_impl+0x346>
   1c9da:	f013 0f24 	tst.w	r3, #36	; 0x24
   1c9de:	d151      	bne.n	1ca84 <z_cbvprintf_impl+0x380>
   1c9e0:	07d8      	lsls	r0, r3, #31
   1c9e2:	d55c      	bpl.n	1ca9e <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_PTR;
   1c9e4:	2103      	movs	r1, #3
   1c9e6:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1c9ea:	f361 0302 	bfi	r3, r1, #0, #3
   1c9ee:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
   1c9f2:	f002 0378 	and.w	r3, r2, #120	; 0x78
   1c9f6:	f1a3 0140 	sub.w	r1, r3, #64	; 0x40
   1c9fa:	424b      	negs	r3, r1
   1c9fc:	414b      	adcs	r3, r1
   1c9fe:	e01a      	b.n	1ca36 <z_cbvprintf_impl+0x332>
   1ca00:	2001      	movs	r0, #1
	switch (conv->specifier) {
   1ca02:	f1a3 0158 	sub.w	r1, r3, #88	; 0x58
   1ca06:	b2c9      	uxtb	r1, r1
   1ca08:	fa00 f101 	lsl.w	r1, r0, r1
   1ca0c:	f411 4f62 	tst.w	r1, #57856	; 0xe200
   1ca10:	d194      	bne.n	1c93c <z_cbvprintf_impl+0x238>
   1ca12:	f640 0601 	movw	r6, #2049	; 0x801
   1ca16:	4231      	tst	r1, r6
   1ca18:	d11d      	bne.n	1ca56 <z_cbvprintf_impl+0x352>
   1ca1a:	f411 3f04 	tst.w	r1, #135168	; 0x21000
   1ca1e:	d03e      	beq.n	1ca9e <z_cbvprintf_impl+0x39a>
		conv->specifier_cat = SPECIFIER_SINT;
   1ca20:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ca24:	f360 0302 	bfi	r3, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca28:	f002 0278 	and.w	r2, r2, #120	; 0x78
   1ca2c:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_SINT;
   1ca2e:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca32:	d034      	beq.n	1ca9e <z_cbvprintf_impl+0x39a>
	bool unsupported = false;
   1ca34:	2300      	movs	r3, #0
	conv->unsupported |= unsupported;
   1ca36:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
   1ca3a:	f3c2 0140 	ubfx	r1, r2, #1, #1
   1ca3e:	430b      	orrs	r3, r1
   1ca40:	f363 0241 	bfi	r2, r3, #1, #1
   1ca44:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
	return sp;
   1ca48:	e6fd      	b.n	1c846 <z_cbvprintf_impl+0x142>
		conv->specifier_cat = SPECIFIER_UINT;
   1ca4a:	2102      	movs	r1, #2
   1ca4c:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1ca50:	f361 0302 	bfi	r3, r1, #0, #3
   1ca54:	e7e8      	b.n	1ca28 <z_cbvprintf_impl+0x324>
   1ca56:	2002      	movs	r0, #2
   1ca58:	f89d 1042 	ldrb.w	r1, [sp, #66]	; 0x42
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca5c:	f002 0278 	and.w	r2, r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
   1ca60:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
   1ca64:	2a40      	cmp	r2, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
   1ca66:	f88d 1042 	strb.w	r1, [sp, #66]	; 0x42
			conv->invalid = true;
   1ca6a:	bf02      	ittt	eq
   1ca6c:	f89d 1040 	ldrbeq.w	r1, [sp, #64]	; 0x40
   1ca70:	f041 0101 	orreq.w	r1, r1, #1
   1ca74:	f88d 1040 	strbeq.w	r1, [sp, #64]	; 0x40
		if (conv->specifier == 'c') {
   1ca78:	2b63      	cmp	r3, #99	; 0x63
   1ca7a:	d1db      	bne.n	1ca34 <z_cbvprintf_impl+0x330>
			unsupported = (conv->length_mod != LENGTH_NONE);
   1ca7c:	1e13      	subs	r3, r2, #0
   1ca7e:	bf18      	it	ne
   1ca80:	2301      	movne	r3, #1
   1ca82:	e7d8      	b.n	1ca36 <z_cbvprintf_impl+0x332>
		conv->specifier_cat = SPECIFIER_PTR;
   1ca84:	2103      	movs	r1, #3
   1ca86:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
   1ca8a:	f012 0f78 	tst.w	r2, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
   1ca8e:	f361 0302 	bfi	r3, r1, #0, #3
   1ca92:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
		if (conv->length_mod != LENGTH_NONE) {
   1ca96:	bf14      	ite	ne
   1ca98:	2301      	movne	r3, #1
   1ca9a:	2300      	moveq	r3, #0
   1ca9c:	e7cb      	b.n	1ca36 <z_cbvprintf_impl+0x332>
		conv->invalid = true;
   1ca9e:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1caa2:	f043 0301 	orr.w	r3, r3, #1
   1caa6:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
		break;
   1caaa:	e7c3      	b.n	1ca34 <z_cbvprintf_impl+0x330>
		} else if (conv->width_present) {
   1caac:	f99d 2040 	ldrsb.w	r2, [sp, #64]	; 0x40
   1cab0:	2a00      	cmp	r2, #0
		int width = -1;
   1cab2:	bfac      	ite	ge
   1cab4:	f04f 38ff 	movge.w	r8, #4294967295	; 0xffffffff
			width = conv->width_value;
   1cab8:	f8dd 8044 	ldrlt.w	r8, [sp, #68]	; 0x44
   1cabc:	e6d5      	b.n	1c86a <z_cbvprintf_impl+0x166>
		} else if (conv->prec_present) {
   1cabe:	0798      	lsls	r0, r3, #30
   1cac0:	f57f aee2 	bpl.w	1c888 <z_cbvprintf_impl+0x184>
			precision = conv->prec_value;
   1cac4:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
		conv->pad0_value = 0;
   1cac8:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
   1caca:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
			= (enum specifier_cat_enum)conv->specifier_cat;
   1cace:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
			= (enum length_mod_enum)conv->length_mod;
   1cad2:	f89d 1041 	ldrb.w	r1, [sp, #65]	; 0x41
		enum specifier_cat_enum specifier_cat
   1cad6:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
   1cada:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
   1cadc:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
   1cae0:	d133      	bne.n	1cb4a <z_cbvprintf_impl+0x446>
			switch (length_mod) {
   1cae2:	1ecb      	subs	r3, r1, #3
   1cae4:	2b04      	cmp	r3, #4
   1cae6:	d804      	bhi.n	1caf2 <z_cbvprintf_impl+0x3ee>
   1cae8:	e8df f003 	tbb	[pc, r3]
   1caec:	21464621 	.word	0x21464621
   1caf0:	21          	.byte	0x21
   1caf1:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
   1caf2:	6823      	ldr	r3, [r4, #0]
			if (length_mod == LENGTH_HH) {
   1caf4:	2901      	cmp	r1, #1
				value->sint = va_arg(ap, int);
   1caf6:	ea4f 72e3 	mov.w	r2, r3, asr #31
   1cafa:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
   1cafe:	d11c      	bne.n	1cb3a <z_cbvprintf_impl+0x436>
				value->sint = (signed char)value->sint;
   1cb00:	f99d 3038 	ldrsb.w	r3, [sp, #56]	; 0x38
   1cb04:	17da      	asrs	r2, r3, #31
   1cb06:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
				value->sint = va_arg(ap, int);
   1cb0a:	3404      	adds	r4, #4
		if (conv->invalid || conv->unsupported) {
   1cb0c:	f89d 3040 	ldrb.w	r3, [sp, #64]	; 0x40
   1cb10:	f013 0603 	ands.w	r6, r3, #3
   1cb14:	d050      	beq.n	1cbb8 <z_cbvprintf_impl+0x4b4>
			OUTS(sp, fp);
   1cb16:	463a      	mov	r2, r7
   1cb18:	4659      	mov	r1, fp
   1cb1a:	4648      	mov	r0, r9
   1cb1c:	9b03      	ldr	r3, [sp, #12]
   1cb1e:	f007 fff9 	bl	24b14 <outs>
   1cb22:	2800      	cmp	r0, #0
   1cb24:	f2c0 8152 	blt.w	1cdcc <z_cbvprintf_impl+0x6c8>
   1cb28:	4405      	add	r5, r0
			continue;
   1cb2a:	9f03      	ldr	r7, [sp, #12]
   1cb2c:	e5f2      	b.n	1c714 <z_cbvprintf_impl+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
   1cb2e:	f854 3b04 	ldr.w	r3, [r4], #4
   1cb32:	17da      	asrs	r2, r3, #31
				value->uint = (unsigned char)value->uint;
   1cb34:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
   1cb38:	e7e8      	b.n	1cb0c <z_cbvprintf_impl+0x408>
			} else if (length_mod == LENGTH_H) {
   1cb3a:	2902      	cmp	r1, #2
   1cb3c:	d1e5      	bne.n	1cb0a <z_cbvprintf_impl+0x406>
				value->sint = (short)value->sint;
   1cb3e:	b21a      	sxth	r2, r3
   1cb40:	f343 33c0 	sbfx	r3, r3, #15, #1
   1cb44:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   1cb48:	e7df      	b.n	1cb0a <z_cbvprintf_impl+0x406>
		} else if (specifier_cat == SPECIFIER_UINT) {
   1cb4a:	2b02      	cmp	r3, #2
   1cb4c:	d124      	bne.n	1cb98 <z_cbvprintf_impl+0x494>
			switch (length_mod) {
   1cb4e:	1ecb      	subs	r3, r1, #3
   1cb50:	2b04      	cmp	r3, #4
   1cb52:	d804      	bhi.n	1cb5e <z_cbvprintf_impl+0x45a>
   1cb54:	e8df f003 	tbb	[pc, r3]
   1cb58:	18101018 	.word	0x18101018
   1cb5c:	18          	.byte	0x18
   1cb5d:	00          	.byte	0x00
			if (length_mod == LENGTH_HH) {
   1cb5e:	2901      	cmp	r1, #1
   1cb60:	f04f 0200 	mov.w	r2, #0
				value->uint = va_arg(ap, unsigned int);
   1cb64:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
   1cb68:	d014      	beq.n	1cb94 <z_cbvprintf_impl+0x490>
			} else if (length_mod == LENGTH_H) {
   1cb6a:	2902      	cmp	r1, #2
				value->uint = va_arg(ap, unsigned int);
   1cb6c:	e9cd 320e 	strd	r3, r2, [sp, #56]	; 0x38
			} else if (length_mod == LENGTH_H) {
   1cb70:	d1cc      	bne.n	1cb0c <z_cbvprintf_impl+0x408>
				value->uint = (unsigned short)value->uint;
   1cb72:	b29b      	uxth	r3, r3
			value->ptr = va_arg(ap, void *);
   1cb74:	930e      	str	r3, [sp, #56]	; 0x38
   1cb76:	e7c9      	b.n	1cb0c <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap,
   1cb78:	3407      	adds	r4, #7
   1cb7a:	f024 0407 	bic.w	r4, r4, #7
				value->uint =
   1cb7e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
   1cb82:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
			if (length_mod == LENGTH_HH) {
   1cb86:	e7c1      	b.n	1cb0c <z_cbvprintf_impl+0x408>
					(uint_value_type)va_arg(ap, size_t);
   1cb88:	f854 3b04 	ldr.w	r3, [r4], #4
   1cb8c:	930e      	str	r3, [sp, #56]	; 0x38
   1cb8e:	2300      	movs	r3, #0
   1cb90:	930f      	str	r3, [sp, #60]	; 0x3c
			} else if (length_mod == LENGTH_H) {
   1cb92:	e7bb      	b.n	1cb0c <z_cbvprintf_impl+0x408>
				value->uint = (unsigned char)value->uint;
   1cb94:	b2db      	uxtb	r3, r3
   1cb96:	e7cd      	b.n	1cb34 <z_cbvprintf_impl+0x430>
		} else if (specifier_cat == SPECIFIER_FP) {
   1cb98:	2b04      	cmp	r3, #4
   1cb9a:	d108      	bne.n	1cbae <z_cbvprintf_impl+0x4aa>
					(sint_value_type)va_arg(ap, long long);
   1cb9c:	3407      	adds	r4, #7
				value->ldbl = va_arg(ap, long double);
   1cb9e:	f024 0407 	bic.w	r4, r4, #7
   1cba2:	e9d4 2300 	ldrd	r2, r3, [r4]
   1cba6:	3408      	adds	r4, #8
   1cba8:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   1cbac:	e7ae      	b.n	1cb0c <z_cbvprintf_impl+0x408>
		} else if (specifier_cat == SPECIFIER_PTR) {
   1cbae:	2b03      	cmp	r3, #3
   1cbb0:	d1ac      	bne.n	1cb0c <z_cbvprintf_impl+0x408>
			value->ptr = va_arg(ap, void *);
   1cbb2:	f854 3b04 	ldr.w	r3, [r4], #4
   1cbb6:	e7dd      	b.n	1cb74 <z_cbvprintf_impl+0x470>
		switch (conv->specifier) {
   1cbb8:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
   1cbbc:	2878      	cmp	r0, #120	; 0x78
   1cbbe:	d8b4      	bhi.n	1cb2a <z_cbvprintf_impl+0x426>
   1cbc0:	2862      	cmp	r0, #98	; 0x62
   1cbc2:	d81c      	bhi.n	1cbfe <z_cbvprintf_impl+0x4fa>
   1cbc4:	2825      	cmp	r0, #37	; 0x25
   1cbc6:	f43f adad 	beq.w	1c724 <z_cbvprintf_impl+0x20>
   1cbca:	2858      	cmp	r0, #88	; 0x58
   1cbcc:	d1ad      	bne.n	1cb2a <z_cbvprintf_impl+0x426>
			bps = encode_uint(value->uint, conv, buf, bpe);
   1cbce:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   1cbd2:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cbd6:	9300      	str	r3, [sp, #0]
   1cbd8:	aa10      	add	r2, sp, #64	; 0x40
   1cbda:	ab08      	add	r3, sp, #32
   1cbdc:	f007 ff54 	bl	24a88 <encode_uint>
			if (precision >= 0) {
   1cbe0:	f1ba 0f00 	cmp.w	sl, #0
			bps = encode_uint(value->uint, conv, buf, bpe);
   1cbe4:	4607      	mov	r7, r0
			if (precision >= 0) {
   1cbe6:	f280 8099 	bge.w	1cd1c <z_cbvprintf_impl+0x618>
		if (bps == NULL) {
   1cbea:	2f00      	cmp	r7, #0
   1cbec:	d09d      	beq.n	1cb2a <z_cbvprintf_impl+0x426>
		size_t nj_len = (bpe - bps);
   1cbee:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cbf2:	1bd8      	subs	r0, r3, r7
		if (sign != 0) {
   1cbf4:	2e00      	cmp	r6, #0
   1cbf6:	f000 80c0 	beq.w	1cd7a <z_cbvprintf_impl+0x676>
			nj_len += 1U;
   1cbfa:	3001      	adds	r0, #1
   1cbfc:	e0bd      	b.n	1cd7a <z_cbvprintf_impl+0x676>
		switch (conv->specifier) {
   1cbfe:	3863      	subs	r0, #99	; 0x63
   1cc00:	2815      	cmp	r0, #21
   1cc02:	d892      	bhi.n	1cb2a <z_cbvprintf_impl+0x426>
   1cc04:	a201      	add	r2, pc, #4	; (adr r2, 1cc0c <z_cbvprintf_impl+0x508>)
   1cc06:	f852 f020 	ldr.w	pc, [r2, r0, lsl #2]
   1cc0a:	bf00      	nop
   1cc0c:	0001cce1 	.word	0x0001cce1
   1cc10:	0001ccf3 	.word	0x0001ccf3
   1cc14:	0001cb2b 	.word	0x0001cb2b
   1cc18:	0001cb2b 	.word	0x0001cb2b
   1cc1c:	0001cb2b 	.word	0x0001cb2b
   1cc20:	0001cb2b 	.word	0x0001cb2b
   1cc24:	0001ccf3 	.word	0x0001ccf3
   1cc28:	0001cb2b 	.word	0x0001cb2b
   1cc2c:	0001cb2b 	.word	0x0001cb2b
   1cc30:	0001cb2b 	.word	0x0001cb2b
   1cc34:	0001cb2b 	.word	0x0001cb2b
   1cc38:	0001cd7f 	.word	0x0001cd7f
   1cc3c:	0001cd17 	.word	0x0001cd17
   1cc40:	0001cd3d 	.word	0x0001cd3d
   1cc44:	0001cb2b 	.word	0x0001cb2b
   1cc48:	0001cb2b 	.word	0x0001cb2b
   1cc4c:	0001cc65 	.word	0x0001cc65
   1cc50:	0001cb2b 	.word	0x0001cb2b
   1cc54:	0001cd17 	.word	0x0001cd17
   1cc58:	0001cb2b 	.word	0x0001cb2b
   1cc5c:	0001cb2b 	.word	0x0001cb2b
   1cc60:	0001cd17 	.word	0x0001cd17
			if (precision >= 0) {
   1cc64:	f1ba 0f00 	cmp.w	sl, #0
			bps = (const char *)value->ptr;
   1cc68:	9f0e      	ldr	r7, [sp, #56]	; 0x38
			if (precision >= 0) {
   1cc6a:	db35      	blt.n	1ccd8 <z_cbvprintf_impl+0x5d4>
				len = strnlen(bps, precision);
   1cc6c:	4651      	mov	r1, sl
   1cc6e:	4638      	mov	r0, r7
   1cc70:	f008 f9a6 	bl	24fc0 <strnlen>
			bpe = bps + len;
   1cc74:	eb07 0a00 	add.w	sl, r7, r0
		if (bps == NULL) {
   1cc78:	2f00      	cmp	r7, #0
   1cc7a:	f43f af56 	beq.w	1cb2a <z_cbvprintf_impl+0x426>
		char sign = 0;
   1cc7e:	2600      	movs	r6, #0
		if (conv->altform_0c) {
   1cc80:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1cc84:	f013 0210 	ands.w	r2, r3, #16
   1cc88:	9205      	str	r2, [sp, #20]
   1cc8a:	f000 8092 	beq.w	1cdb2 <z_cbvprintf_impl+0x6ae>
			nj_len += 2U;
   1cc8e:	3002      	adds	r0, #2
		if (conv->pad_fp) {
   1cc90:	065b      	lsls	r3, r3, #25
		nj_len += conv->pad0_value;
   1cc92:	9a11      	ldr	r2, [sp, #68]	; 0x44
			nj_len += conv->pad0_pre_exp;
   1cc94:	bf48      	it	mi
   1cc96:	9b12      	ldrmi	r3, [sp, #72]	; 0x48
		nj_len += conv->pad0_value;
   1cc98:	4410      	add	r0, r2
			nj_len += conv->pad0_pre_exp;
   1cc9a:	bf48      	it	mi
   1cc9c:	18c0      	addmi	r0, r0, r3
		if (width > 0) {
   1cc9e:	f1b8 0f00 	cmp.w	r8, #0
		nj_len += conv->pad0_value;
   1cca2:	9204      	str	r2, [sp, #16]
		if (width > 0) {
   1cca4:	f340 809f 	ble.w	1cde6 <z_cbvprintf_impl+0x6e2>
			if (!conv->flag_dash) {
   1cca8:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
			width -= (int)nj_len;
   1ccac:	eba8 0800 	sub.w	r8, r8, r0
			if (!conv->flag_dash) {
   1ccb0:	f3c2 0380 	ubfx	r3, r2, #2, #1
   1ccb4:	0750      	lsls	r0, r2, #29
   1ccb6:	9306      	str	r3, [sp, #24]
   1ccb8:	f100 8095 	bmi.w	1cde6 <z_cbvprintf_impl+0x6e2>
				if (conv->flag_zero) {
   1ccbc:	0651      	lsls	r1, r2, #25
   1ccbe:	f140 8088 	bpl.w	1cdd2 <z_cbvprintf_impl+0x6ce>
					if (sign != 0) {
   1ccc2:	b13e      	cbz	r6, 1ccd4 <z_cbvprintf_impl+0x5d0>
						OUTC(sign);
   1ccc4:	4659      	mov	r1, fp
   1ccc6:	4630      	mov	r0, r6
   1ccc8:	47c8      	blx	r9
   1ccca:	2800      	cmp	r0, #0
   1cccc:	db7e      	blt.n	1cdcc <z_cbvprintf_impl+0x6c8>
   1ccce:	9b06      	ldr	r3, [sp, #24]
   1ccd0:	3501      	adds	r5, #1
   1ccd2:	461e      	mov	r6, r3
					pad = '0';
   1ccd4:	2230      	movs	r2, #48	; 0x30
   1ccd6:	e07d      	b.n	1cdd4 <z_cbvprintf_impl+0x6d0>
				len = strlen(bps);
   1ccd8:	4638      	mov	r0, r7
   1ccda:	f008 f96a 	bl	24fb2 <strlen>
   1ccde:	e7c9      	b.n	1cc74 <z_cbvprintf_impl+0x570>
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   1cce0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
		char sign = 0;
   1cce2:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
   1cce4:	2001      	movs	r0, #1
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
   1cce6:	f88d 3020 	strb.w	r3, [sp, #32]
			bps = buf;
   1ccea:	af08      	add	r7, sp, #32
			bpe = buf + 1;
   1ccec:	f10d 0a21 	add.w	sl, sp, #33	; 0x21
   1ccf0:	e7c6      	b.n	1cc80 <z_cbvprintf_impl+0x57c>
			if (conv->flag_plus) {
   1ccf2:	0719      	lsls	r1, r3, #28
			} else if (conv->flag_space) {
   1ccf4:	bf5a      	itte	pl
   1ccf6:	f3c3 1300 	ubfxpl	r3, r3, #4, #1
   1ccfa:	015e      	lslpl	r6, r3, #5
				sign = '+';
   1ccfc:	262b      	movmi	r6, #43	; 0x2b
			sint = value->sint;
   1ccfe:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
			if (sint < 0) {
   1cd02:	2b00      	cmp	r3, #0
   1cd04:	f6bf af63 	bge.w	1cbce <z_cbvprintf_impl+0x4ca>
				value->uint = (uint_value_type)-sint;
   1cd08:	4252      	negs	r2, r2
   1cd0a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
   1cd0e:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-sint;
   1cd10:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
   1cd14:	e75b      	b.n	1cbce <z_cbvprintf_impl+0x4ca>
		switch (conv->specifier) {
   1cd16:	2600      	movs	r6, #0
   1cd18:	e759      	b.n	1cbce <z_cbvprintf_impl+0x4ca>
		char sign = 0;
   1cd1a:	2600      	movs	r6, #0
				conv->flag_zero = false;
   1cd1c:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
				size_t len = bpe - bps;
   1cd20:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cd24:	1bdb      	subs	r3, r3, r7
				conv->flag_zero = false;
   1cd26:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
   1cd2a:	459a      	cmp	sl, r3
				conv->flag_zero = false;
   1cd2c:	f88d 2040 	strb.w	r2, [sp, #64]	; 0x40
				if (len < (size_t)precision) {
   1cd30:	f67f af5b 	bls.w	1cbea <z_cbvprintf_impl+0x4e6>
					conv->pad0_value = precision - (int)len;
   1cd34:	ebaa 0303 	sub.w	r3, sl, r3
   1cd38:	9311      	str	r3, [sp, #68]	; 0x44
   1cd3a:	e756      	b.n	1cbea <z_cbvprintf_impl+0x4e6>
			if (value->ptr != NULL) {
   1cd3c:	980e      	ldr	r0, [sp, #56]	; 0x38
   1cd3e:	b390      	cbz	r0, 1cda6 <z_cbvprintf_impl+0x6a2>
				bps = encode_uint((uintptr_t)value->ptr, conv,
   1cd40:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cd44:	9300      	str	r3, [sp, #0]
   1cd46:	2100      	movs	r1, #0
   1cd48:	ab08      	add	r3, sp, #32
   1cd4a:	aa10      	add	r2, sp, #64	; 0x40
   1cd4c:	f007 fe9c 	bl	24a88 <encode_uint>
				conv->altform_0c = true;
   1cd50:	f8bd 3042 	ldrh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
   1cd54:	f1ba 0f00 	cmp.w	sl, #0
				conv->altform_0c = true;
   1cd58:	f003 03ef 	and.w	r3, r3, #239	; 0xef
   1cd5c:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
   1cd60:	f043 0310 	orr.w	r3, r3, #16
				bps = encode_uint((uintptr_t)value->ptr, conv,
   1cd64:	4607      	mov	r7, r0
				conv->altform_0c = true;
   1cd66:	f8ad 3042 	strh.w	r3, [sp, #66]	; 0x42
			if (precision >= 0) {
   1cd6a:	dad6      	bge.n	1cd1a <z_cbvprintf_impl+0x616>
		if (bps == NULL) {
   1cd6c:	2800      	cmp	r0, #0
   1cd6e:	f43f aedc 	beq.w	1cb2a <z_cbvprintf_impl+0x426>
		char sign = 0;
   1cd72:	2600      	movs	r6, #0
		size_t nj_len = (bpe - bps);
   1cd74:	f10d 0336 	add.w	r3, sp, #54	; 0x36
   1cd78:	1a18      	subs	r0, r3, r0
		if (sign != 0) {
   1cd7a:	469a      	mov	sl, r3
   1cd7c:	e780      	b.n	1cc80 <z_cbvprintf_impl+0x57c>
				store_count(conv, value->ptr, count);
   1cd7e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	switch ((enum length_mod_enum)conv->length_mod) {
   1cd80:	2907      	cmp	r1, #7
   1cd82:	f63f aed2 	bhi.w	1cb2a <z_cbvprintf_impl+0x426>
   1cd86:	e8df f001 	tbb	[pc, r1]
   1cd8a:	040c      	.short	0x040c
   1cd8c:	08080c06 	.word	0x08080c06
   1cd90:	0c0c      	.short	0x0c0c
		*(signed char *)dp = (signed char)count;
   1cd92:	701d      	strb	r5, [r3, #0]
		if (bps == NULL) {
   1cd94:	e6c9      	b.n	1cb2a <z_cbvprintf_impl+0x426>
		*(short *)dp = (short)count;
   1cd96:	801d      	strh	r5, [r3, #0]
		if (bps == NULL) {
   1cd98:	e6c7      	b.n	1cb2a <z_cbvprintf_impl+0x426>
		*(intmax_t *)dp = (intmax_t)count;
   1cd9a:	17ea      	asrs	r2, r5, #31
   1cd9c:	e9c3 5200 	strd	r5, r2, [r3]
		if (bps == NULL) {
   1cda0:	e6c3      	b.n	1cb2a <z_cbvprintf_impl+0x426>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
   1cda2:	601d      	str	r5, [r3, #0]
		if (bps == NULL) {
   1cda4:	e6c1      	b.n	1cb2a <z_cbvprintf_impl+0x426>
   1cda6:	4f2f      	ldr	r7, [pc, #188]	; (1ce64 <z_cbvprintf_impl+0x760>)
		char sign = 0;
   1cda8:	4606      	mov	r6, r0
			bpe = bps + 5;
   1cdaa:	f107 0a05 	add.w	sl, r7, #5
		size_t nj_len = (bpe - bps);
   1cdae:	2005      	movs	r0, #5
   1cdb0:	e766      	b.n	1cc80 <z_cbvprintf_impl+0x57c>
		} else if (conv->altform_0) {
   1cdb2:	071a      	lsls	r2, r3, #28
			nj_len += 1U;
   1cdb4:	bf48      	it	mi
   1cdb6:	3001      	addmi	r0, #1
   1cdb8:	e76a      	b.n	1cc90 <z_cbvprintf_impl+0x58c>
					OUTC(pad);
   1cdba:	4610      	mov	r0, r2
   1cdbc:	9307      	str	r3, [sp, #28]
   1cdbe:	9206      	str	r2, [sp, #24]
   1cdc0:	4659      	mov	r1, fp
   1cdc2:	47c8      	blx	r9
   1cdc4:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   1cdc8:	2800      	cmp	r0, #0
   1cdca:	da04      	bge.n	1cdd6 <z_cbvprintf_impl+0x6d2>
#undef OUTS
#undef OUTC
}
   1cdcc:	b015      	add	sp, #84	; 0x54
   1cdce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
   1cdd2:	2220      	movs	r2, #32
					pad = '0';
   1cdd4:	4643      	mov	r3, r8
				while (width-- > 0) {
   1cdd6:	4619      	mov	r1, r3
   1cdd8:	2900      	cmp	r1, #0
   1cdda:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
   1cdde:	dcec      	bgt.n	1cdba <z_cbvprintf_impl+0x6b6>
   1cde0:	4445      	add	r5, r8
   1cde2:	4698      	mov	r8, r3
   1cde4:	1a6d      	subs	r5, r5, r1
		if (sign != 0) {
   1cde6:	b12e      	cbz	r6, 1cdf4 <z_cbvprintf_impl+0x6f0>
			OUTC(sign);
   1cde8:	4659      	mov	r1, fp
   1cdea:	4630      	mov	r0, r6
   1cdec:	47c8      	blx	r9
   1cdee:	2800      	cmp	r0, #0
   1cdf0:	dbec      	blt.n	1cdcc <z_cbvprintf_impl+0x6c8>
   1cdf2:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
   1cdf4:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   1cdf8:	06da      	lsls	r2, r3, #27
   1cdfa:	d401      	bmi.n	1ce00 <z_cbvprintf_impl+0x6fc>
   1cdfc:	071b      	lsls	r3, r3, #28
   1cdfe:	d505      	bpl.n	1ce0c <z_cbvprintf_impl+0x708>
				OUTC('0');
   1ce00:	4659      	mov	r1, fp
   1ce02:	2030      	movs	r0, #48	; 0x30
   1ce04:	47c8      	blx	r9
   1ce06:	2800      	cmp	r0, #0
   1ce08:	dbe0      	blt.n	1cdcc <z_cbvprintf_impl+0x6c8>
   1ce0a:	3501      	adds	r5, #1
			if (conv->altform_0c) {
   1ce0c:	9b05      	ldr	r3, [sp, #20]
   1ce0e:	b133      	cbz	r3, 1ce1e <z_cbvprintf_impl+0x71a>
				OUTC(conv->specifier);
   1ce10:	4659      	mov	r1, fp
   1ce12:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
   1ce16:	47c8      	blx	r9
   1ce18:	2800      	cmp	r0, #0
   1ce1a:	dbd7      	blt.n	1cdcc <z_cbvprintf_impl+0x6c8>
   1ce1c:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   1ce1e:	9e04      	ldr	r6, [sp, #16]
   1ce20:	442e      	add	r6, r5
   1ce22:	e005      	b.n	1ce30 <z_cbvprintf_impl+0x72c>
				OUTC('0');
   1ce24:	4659      	mov	r1, fp
   1ce26:	2030      	movs	r0, #48	; 0x30
   1ce28:	47c8      	blx	r9
   1ce2a:	2800      	cmp	r0, #0
   1ce2c:	dbce      	blt.n	1cdcc <z_cbvprintf_impl+0x6c8>
   1ce2e:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
   1ce30:	1b73      	subs	r3, r6, r5
   1ce32:	2b00      	cmp	r3, #0
   1ce34:	dcf6      	bgt.n	1ce24 <z_cbvprintf_impl+0x720>
			OUTS(bps, bpe);
   1ce36:	4653      	mov	r3, sl
   1ce38:	463a      	mov	r2, r7
   1ce3a:	4659      	mov	r1, fp
   1ce3c:	4648      	mov	r0, r9
   1ce3e:	f007 fe69 	bl	24b14 <outs>
   1ce42:	2800      	cmp	r0, #0
   1ce44:	dbc2      	blt.n	1cdcc <z_cbvprintf_impl+0x6c8>
   1ce46:	4405      	add	r5, r0
		while (width > 0) {
   1ce48:	44a8      	add	r8, r5
   1ce4a:	eba8 0305 	sub.w	r3, r8, r5
   1ce4e:	2b00      	cmp	r3, #0
   1ce50:	f77f ae6b 	ble.w	1cb2a <z_cbvprintf_impl+0x426>
			OUTC(' ');
   1ce54:	4659      	mov	r1, fp
   1ce56:	2020      	movs	r0, #32
   1ce58:	47c8      	blx	r9
   1ce5a:	2800      	cmp	r0, #0
   1ce5c:	dbb6      	blt.n	1cdcc <z_cbvprintf_impl+0x6c8>
   1ce5e:	3501      	adds	r5, #1
			--width;
   1ce60:	e7f3      	b.n	1ce4a <z_cbvprintf_impl+0x746>
   1ce62:	bf00      	nop
   1ce64:	000269bd 	.word	0x000269bd

0001ce68 <z_arm_on_enter_cpu_idle>:
		DIV_ROUND_UP(200 * CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
				 1000000);
	static uint32_t timestamps[5];
	static bool timestamps_filled;
	static uint8_t current;
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
   1ce68:	2305      	movs	r3, #5

	return true;
}

bool z_arm_on_enter_cpu_idle(void)
{
   1ce6a:	b570      	push	{r4, r5, r6, lr}
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
   1ce6c:	4d14      	ldr	r5, [pc, #80]	; (1cec0 <z_arm_on_enter_cpu_idle+0x58>)
   1ce6e:	4e15      	ldr	r6, [pc, #84]	; (1cec4 <z_arm_on_enter_cpu_idle+0x5c>)
   1ce70:	782c      	ldrb	r4, [r5, #0]
   1ce72:	3401      	adds	r4, #1
   1ce74:	fbb4 f3f3 	udiv	r3, r4, r3
   1ce78:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   1ce7c:	1ae4      	subs	r4, r4, r3
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
   1ce7e:	f008 fc85 	bl	2578c <sys_clock_cycle_get_32>
	if (timestamps_filled &&
   1ce82:	4a11      	ldr	r2, [pc, #68]	; (1cec8 <z_arm_on_enter_cpu_idle+0x60>)
   1ce84:	7813      	ldrb	r3, [r2, #0]
   1ce86:	b123      	cbz	r3, 1ce92 <z_arm_on_enter_cpu_idle+0x2a>
	    (now - timestamps[oldest]) < (window_cycles + 1)) {
   1ce88:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
   1ce8c:	1ac0      	subs	r0, r0, r3
	if (timestamps_filled &&
   1ce8e:	2807      	cmp	r0, #7
   1ce90:	d913      	bls.n	1ceba <z_arm_on_enter_cpu_idle+0x52>
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE bool nrf_power_event_check(NRF_POWER_Type const * p_reg, nrf_power_event_t event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1ce92:	4b0e      	ldr	r3, [pc, #56]	; (1cecc <z_arm_on_enter_cpu_idle+0x64>)
   1ce94:	f8d3 1114 	ldr.w	r1, [r3, #276]	; 0x114
	if (nrf_power_event_check(NRF_POWER, NRF_POWER_EVENT_SLEEPENTER)) {
   1ce98:	b141      	cbz	r1, 1ceac <z_arm_on_enter_cpu_idle+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1ce9a:	2100      	movs	r1, #0
   1ce9c:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
   1cea0:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
	uint8_t oldest = (current + 1) % ARRAY_SIZE(timestamps);
   1cea4:	702c      	strb	r4, [r5, #0]
		if (current == 0) {
   1cea6:	b90c      	cbnz	r4, 1ceac <z_arm_on_enter_cpu_idle+0x44>
			timestamps_filled = true;
   1cea8:	2301      	movs	r3, #1
   1ceaa:	7013      	strb	r3, [r2, #0]
	timestamps[current] = k_cycle_get_32();
   1ceac:	782c      	ldrb	r4, [r5, #0]
   1ceae:	f008 fc6d 	bl	2578c <sys_clock_cycle_get_32>
   1ceb2:	f846 0024 	str.w	r0, [r6, r4, lsl #2]
	return true;
   1ceb6:	2001      	movs	r0, #1
		suppress_message = true;
	}
#endif

	return ok_to_sleep;
}
   1ceb8:	bd70      	pop	{r4, r5, r6, pc}
		return false;
   1ceba:	2000      	movs	r0, #0
   1cebc:	e7fc      	b.n	1ceb8 <z_arm_on_enter_cpu_idle+0x50>
   1cebe:	bf00      	nop
   1cec0:	2000b5f1 	.word	0x2000b5f1
   1cec4:	2000a730 	.word	0x2000a730
   1cec8:	2000b5f0 	.word	0x2000b5f0
   1cecc:	40005000 	.word	0x40005000

0001ced0 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   1ced0:	b148      	cbz	r0, 1cee6 <arch_busy_wait+0x16>

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
   1ced2:	4b05      	ldr	r3, [pc, #20]	; (1cee8 <arch_busy_wait+0x18>)
   1ced4:	4a05      	ldr	r2, [pc, #20]	; (1ceec <arch_busy_wait+0x1c>)
   1ced6:	681b      	ldr	r3, [r3, #0]
   1ced8:	fbb3 f3f2 	udiv	r3, r3, r2
    delay_cycles(cycles);
   1cedc:	4358      	muls	r0, r3
   1cede:	4b04      	ldr	r3, [pc, #16]	; (1cef0 <arch_busy_wait+0x20>)
   1cee0:	f043 0301 	orr.w	r3, r3, #1
   1cee4:	4718      	bx	r3
}

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   1cee6:	4770      	bx	lr
   1cee8:	2000a204 	.word	0x2000a204
   1ceec:	000f4240 	.word	0x000f4240
   1cef0:	00026630 	.word	0x00026630

0001cef4 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
   1cef4:	f008 bc87 	b.w	25806 <SystemInit>

0001cef8 <pm_state_notify>:
/*
 * Function called to notify when the system is entering / exiting a
 * power state
 */
static inline void pm_state_notify(bool entering_state)
{
   1cef8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1cefc:	4605      	mov	r5, r0
	__asm__ volatile(
   1cefe:	f04f 0320 	mov.w	r3, #32
   1cf02:	f3ef 8611 	mrs	r6, BASEPRI
   1cf06:	f383 8812 	msr	BASEPRI_MAX, r3
   1cf0a:	f3bf 8f6f 	isb	sy
		} else {
			callback = notifier->state_exit;
		}

		if (callback) {
			callback(z_cpus_pm_state[_current_cpu->id].state);
   1cf0e:	f04f 090c 	mov.w	r9, #12
	return list->head;
   1cf12:	4b0d      	ldr	r3, [pc, #52]	; (1cf48 <pm_state_notify+0x50>)
   1cf14:	4f0d      	ldr	r7, [pc, #52]	; (1cf4c <pm_state_notify+0x54>)
   1cf16:	681c      	ldr	r4, [r3, #0]
   1cf18:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1cf50 <pm_state_notify+0x58>
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
   1cf1c:	b92c      	cbnz	r4, 1cf2a <pm_state_notify+0x32>
	__asm__ volatile(
   1cf1e:	f386 8811 	msr	BASEPRI, r6
   1cf22:	f3bf 8f6f 	isb	sy
		}
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}
   1cf26:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			callback = notifier->state_exit;
   1cf2a:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
			callback = notifier->state_entry;
   1cf2e:	2d00      	cmp	r5, #0
   1cf30:	bf18      	it	ne
   1cf32:	4613      	movne	r3, r2
		if (callback) {
   1cf34:	b12b      	cbz	r3, 1cf42 <pm_state_notify+0x4a>
			callback(z_cpus_pm_state[_current_cpu->id].state);
   1cf36:	f898 2010 	ldrb.w	r2, [r8, #16]
   1cf3a:	fb09 f202 	mul.w	r2, r9, r2
   1cf3e:	5cb8      	ldrb	r0, [r7, r2]
   1cf40:	4798      	blx	r3
	return node->next;
   1cf42:	6824      	ldr	r4, [r4, #0]
   1cf44:	e7ea      	b.n	1cf1c <pm_state_notify+0x24>
   1cf46:	bf00      	nop
   1cf48:	2000a75c 	.word	0x2000a75c
   1cf4c:	2000a750 	.word	0x2000a750
   1cf50:	2000b5b4 	.word	0x2000b5b4

0001cf54 <pm_system_resume>:
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
   1cf54:	2201      	movs	r2, #1

void pm_system_resume(void)
{
   1cf56:	b570      	push	{r4, r5, r6, lr}
	uint8_t id = CURRENT_CPU;
   1cf58:	4b16      	ldr	r3, [pc, #88]	; (1cfb4 <pm_system_resume+0x60>)
   1cf5a:	7c1c      	ldrb	r4, [r3, #16]
   1cf5c:	f004 031f 	and.w	r3, r4, #31
   1cf60:	409a      	lsls	r2, r3
	atomic_val_t old;

	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
   1cf62:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1cf64:	4b14      	ldr	r3, [pc, #80]	; (1cfb8 <pm_system_resume+0x64>)
   1cf66:	0961      	lsrs	r1, r4, #5
   1cf68:	eb03 0381 	add.w	r3, r3, r1, lsl #2
   1cf6c:	e8d3 1fef 	ldaex	r1, [r3]
   1cf70:	ea01 0500 	and.w	r5, r1, r0
   1cf74:	e8c3 5fe6 	stlex	r6, r5, [r3]
   1cf78:	2e00      	cmp	r6, #0
   1cf7a:	d1f7      	bne.n	1cf6c <pm_system_resume+0x18>
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
   1cf7c:	420a      	tst	r2, r1
   1cf7e:	d013      	beq.n	1cfa8 <pm_system_resume+0x54>
	if (pm_state_exit_post_ops != NULL) {
   1cf80:	4b0e      	ldr	r3, [pc, #56]	; (1cfbc <pm_system_resume+0x68>)
   1cf82:	4d0f      	ldr	r5, [pc, #60]	; (1cfc0 <pm_system_resume+0x6c>)
   1cf84:	b18b      	cbz	r3, 1cfaa <pm_system_resume+0x56>
		pm_state_exit_post_ops(info->state, info->substate_id);
   1cf86:	230c      	movs	r3, #12
   1cf88:	4363      	muls	r3, r4
   1cf8a:	18ea      	adds	r2, r5, r3
   1cf8c:	7851      	ldrb	r1, [r2, #1]
   1cf8e:	5ce8      	ldrb	r0, [r5, r3]
   1cf90:	f007 feb1 	bl	24cf6 <pm_state_exit_post_ops>
		pm_exit_pos_ops(&z_cpus_pm_state[id]);
		pm_state_notify(false);
   1cf94:	2000      	movs	r0, #0
   1cf96:	f7ff ffaf 	bl	1cef8 <pm_state_notify>
		z_cpus_pm_state[id] = (struct pm_state_info){PM_STATE_ACTIVE,
   1cf9a:	230c      	movs	r3, #12
   1cf9c:	435c      	muls	r4, r3
   1cf9e:	2300      	movs	r3, #0
   1cfa0:	192a      	adds	r2, r5, r4
   1cfa2:	512b      	str	r3, [r5, r4]
   1cfa4:	e9c2 3301 	strd	r3, r3, [r2, #4]
			0, 0};
	}
}
   1cfa8:	bd70      	pop	{r4, r5, r6, pc}
   1cfaa:	f383 8811 	msr	BASEPRI, r3
   1cfae:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
   1cfb2:	e7ef      	b.n	1cf94 <pm_system_resume+0x40>
   1cfb4:	2000b5b4 	.word	0x2000b5b4
   1cfb8:	2000a764 	.word	0x2000a764
   1cfbc:	00024cf7 	.word	0x00024cf7
   1cfc0:	2000a750 	.word	0x2000a750

0001cfc4 <pm_system_suspend>:

	return true;
}

bool pm_system_suspend(int32_t ticks)
{
   1cfc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t id = CURRENT_CPU;
   1cfc8:	4b32      	ldr	r3, [pc, #200]	; (1d094 <pm_system_suspend+0xd0>)
{
   1cfca:	4607      	mov	r7, r0
	uint8_t id = CURRENT_CPU;
   1cfcc:	7c1d      	ldrb	r5, [r3, #16]
	__asm__ volatile(
   1cfce:	f04f 0320 	mov.w	r3, #32
   1cfd2:	f3ef 8811 	mrs	r8, BASEPRI
   1cfd6:	f383 8812 	msr	BASEPRI_MAX, r3
   1cfda:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key;

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	key = k_spin_lock(&pm_forced_state_lock);
	if (z_cpus_pm_forced_state[id].state != PM_STATE_ACTIVE) {
   1cfde:	240c      	movs	r4, #12
   1cfe0:	436c      	muls	r4, r5
   1cfe2:	4b2d      	ldr	r3, [pc, #180]	; (1d098 <pm_system_suspend+0xd4>)
   1cfe4:	4e2d      	ldr	r6, [pc, #180]	; (1d09c <pm_system_suspend+0xd8>)
   1cfe6:	5d19      	ldrb	r1, [r3, r4]
   1cfe8:	191a      	adds	r2, r3, r4
   1cfea:	2900      	cmp	r1, #0
   1cfec:	d047      	beq.n	1d07e <pm_system_suspend+0xba>
		z_cpus_pm_state[id] = z_cpus_pm_forced_state[id];
   1cfee:	ca07      	ldmia	r2, {r0, r1, r2}
   1cff0:	eb06 0c04 	add.w	ip, r6, r4
   1cff4:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
		z_cpus_pm_forced_state[id].state = PM_STATE_ACTIVE;
   1cff8:	2200      	movs	r2, #0
   1cffa:	551a      	strb	r2, [r3, r4]
	__asm__ volatile(
   1cffc:	f388 8811 	msr	BASEPRI, r8
   1d000:	f3bf 8f6f 	isb	sy
			z_cpus_pm_state[id] = *info;
		}
	}
	k_spin_unlock(&pm_forced_state_lock, key);

	if (z_cpus_pm_state[id].state == PM_STATE_ACTIVE) {
   1d004:	230c      	movs	r3, #12
   1d006:	436b      	muls	r3, r5
   1d008:	5cf0      	ldrb	r0, [r6, r3]
   1d00a:	18f2      	adds	r2, r6, r3
   1d00c:	b3a8      	cbz	r0, 1d07a <pm_system_suspend+0xb6>
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);
		return false;
	}

	if (ticks != K_TICKS_FOREVER) {
   1d00e:	1c7b      	adds	r3, r7, #1
   1d010:	d010      	beq.n	1d034 <pm_system_suspend+0x70>
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
   1d012:	f44f 4000 	mov.w	r0, #32768	; 0x8000
   1d016:	2100      	movs	r1, #0
   1d018:	f8d2 c008 	ldr.w	ip, [r2, #8]
   1d01c:	4c20      	ldr	r4, [pc, #128]	; (1d0a0 <pm_system_suspend+0xdc>)
   1d01e:	2300      	movs	r3, #0
   1d020:	fbec 4100 	umlal	r4, r1, ip, r0
   1d024:	4a1f      	ldr	r2, [pc, #124]	; (1d0a4 <pm_system_suspend+0xe0>)
   1d026:	4620      	mov	r0, r4
   1d028:	f7ff f894 	bl	1c154 <__aeabi_uldivmod>
		/*
		 * We need to set the timer to interrupt a little bit early to
		 * accommodate the time required by the CPU to fully wake up.
		 */
		sys_clock_set_timeout(ticks -
   1d02c:	2101      	movs	r1, #1
   1d02e:	1a38      	subs	r0, r7, r0
   1d030:	f003 fc24 	bl	2087c <sys_clock_set_timeout>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
   1d034:	f006 fe42 	bl	23cbc <k_sched_lock>
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
   1d038:	2001      	movs	r0, #1
   1d03a:	f7ff ff5d 	bl	1cef8 <pm_state_notify>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1d03e:	4b1a      	ldr	r3, [pc, #104]	; (1d0a8 <pm_system_suspend+0xe4>)
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
   1d040:	096a      	lsrs	r2, r5, #5
   1d042:	eb03 0382 	add.w	r3, r3, r2, lsl #2
	atomic_val_t mask = ATOMIC_MASK(bit);
   1d046:	2201      	movs	r2, #1
   1d048:	f005 011f 	and.w	r1, r5, #31
   1d04c:	408a      	lsls	r2, r1
   1d04e:	e8d3 0fef 	ldaex	r0, [r3]
   1d052:	4310      	orrs	r0, r2
   1d054:	e8c3 0fe1 	stlex	r1, r0, [r3]
   1d058:	2900      	cmp	r1, #0
   1d05a:	d1f8      	bne.n	1d04e <pm_system_suspend+0x8a>
	if (pm_state_set != NULL) {
   1d05c:	4b13      	ldr	r3, [pc, #76]	; (1d0ac <pm_system_suspend+0xe8>)
   1d05e:	b13b      	cbz	r3, 1d070 <pm_system_suspend+0xac>
		pm_state_set(info->state, info->substate_id);
   1d060:	230c      	movs	r3, #12
   1d062:	fb03 f005 	mul.w	r0, r3, r5
   1d066:	1833      	adds	r3, r6, r0
   1d068:	7859      	ldrb	r1, [r3, #1]
   1d06a:	5c30      	ldrb	r0, [r6, r0]
   1d06c:	f007 fe37 	bl	24cde <pm_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_cpus_pm_state[id].state);
	pm_system_resume();
   1d070:	f7ff ff70 	bl	1cf54 <pm_system_resume>
	k_sched_unlock();
   1d074:	f006 fe36 	bl	23ce4 <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks,
				   z_cpus_pm_state[id].state);

	return true;
   1d078:	2001      	movs	r0, #1
}
   1d07a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		info = pm_policy_next_state(id, ticks);
   1d07e:	4601      	mov	r1, r0
   1d080:	4628      	mov	r0, r5
   1d082:	f000 f815 	bl	1d0b0 <pm_policy_next_state>
		if (info != NULL) {
   1d086:	2800      	cmp	r0, #0
   1d088:	d0b8      	beq.n	1cffc <pm_system_suspend+0x38>
			z_cpus_pm_state[id] = *info;
   1d08a:	c807      	ldmia	r0, {r0, r1, r2}
   1d08c:	4434      	add	r4, r6
   1d08e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
   1d092:	e7b3      	b.n	1cffc <pm_system_suspend+0x38>
   1d094:	2000b5b4 	.word	0x2000b5b4
   1d098:	2000a744 	.word	0x2000a744
   1d09c:	2000a750 	.word	0x2000a750
   1d0a0:	000f423f 	.word	0x000f423f
   1d0a4:	000f4240 	.word	0x000f4240
   1d0a8:	2000a764 	.word	0x2000a764
   1d0ac:	00024cdf 	.word	0x00024cdf

0001d0b0 <pm_policy_next_state>:
	}
}

#ifdef CONFIG_PM_POLICY_DEFAULT
const struct pm_state_info *pm_policy_next_state(uint8_t cpu, int32_t ticks)
{
   1d0b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d0b4:	b085      	sub	sp, #20
   1d0b6:	460e      	mov	r6, r1
	uint8_t num_cpu_states;
	const struct pm_state_info *cpu_states;

	num_cpu_states = pm_state_cpu_get_all(cpu, &cpu_states);
   1d0b8:	a903      	add	r1, sp, #12
   1d0ba:	f000 f843 	bl	1d144 <pm_state_cpu_get_all>
   1d0be:	f44f 4700 	mov.w	r7, #32768	; 0x8000
   1d0c2:	4604      	mov	r4, r0
   1d0c4:	f04f 0b00 	mov.w	fp, #0

		min_residency = k_us_to_ticks_ceil32(state->min_residency_us);
		exit_latency = k_us_to_ticks_ceil32(state->exit_latency_us);

		/* skip state if it brings too much latency */
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   1d0c8:	4b1b      	ldr	r3, [pc, #108]	; (1d138 <pm_policy_next_state+0x88>)
   1d0ca:	9d03      	ldr	r5, [sp, #12]
   1d0cc:	f8d3 a000 	ldr.w	sl, [r3]
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   1d0d0:	1e43      	subs	r3, r0, #1
   1d0d2:	b21b      	sxth	r3, r3
   1d0d4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
   1d0d8:	f8df 8060 	ldr.w	r8, [pc, #96]	; 1d13c <pm_policy_next_state+0x8c>
   1d0dc:	eb05 0583 	add.w	r5, r5, r3, lsl #2
   1d0e0:	b924      	cbnz	r4, 1d0ec <pm_policy_next_state+0x3c>
		    (ticks >= (min_residency + exit_latency))) {
			return state;
		}
	}

	return NULL;
   1d0e2:	46a1      	mov	r9, r4
}
   1d0e4:	4648      	mov	r0, r9
   1d0e6:	b005      	add	sp, #20
   1d0e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d0ec:	46c4      	mov	ip, r8
   1d0ee:	4659      	mov	r1, fp
   1d0f0:	6868      	ldr	r0, [r5, #4]
   1d0f2:	2300      	movs	r3, #0
   1d0f4:	fbe0 c107 	umlal	ip, r1, r0, r7
   1d0f8:	4a11      	ldr	r2, [pc, #68]	; (1d140 <pm_policy_next_state+0x90>)
   1d0fa:	4660      	mov	r0, ip
   1d0fc:	f7ff f82a 	bl	1c154 <__aeabi_uldivmod>
   1d100:	46c4      	mov	ip, r8
   1d102:	4659      	mov	r1, fp
   1d104:	9001      	str	r0, [sp, #4]
   1d106:	68a8      	ldr	r0, [r5, #8]
   1d108:	2300      	movs	r3, #0
   1d10a:	fbe0 c107 	umlal	ip, r1, r0, r7
   1d10e:	4a0c      	ldr	r2, [pc, #48]	; (1d140 <pm_policy_next_state+0x90>)
   1d110:	4660      	mov	r0, ip
   1d112:	f7ff f81f 	bl	1c154 <__aeabi_uldivmod>
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   1d116:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
		const struct pm_state_info *state = &cpu_states[i];
   1d11a:	46a9      	mov	r9, r5
		if ((max_latency_ticks != K_TICKS_FOREVER) &&
   1d11c:	d001      	beq.n	1d122 <pm_policy_next_state+0x72>
   1d11e:	4582      	cmp	sl, r0
   1d120:	d905      	bls.n	1d12e <pm_policy_next_state+0x7e>
		if ((ticks == K_TICKS_FOREVER) ||
   1d122:	1c73      	adds	r3, r6, #1
   1d124:	d0de      	beq.n	1d0e4 <pm_policy_next_state+0x34>
		    (ticks >= (min_residency + exit_latency))) {
   1d126:	9b01      	ldr	r3, [sp, #4]
   1d128:	4418      	add	r0, r3
		if ((ticks == K_TICKS_FOREVER) ||
   1d12a:	42b0      	cmp	r0, r6
   1d12c:	d9da      	bls.n	1d0e4 <pm_policy_next_state+0x34>
	for (int16_t i = (int16_t)num_cpu_states - 1; i >= 0; i--) {
   1d12e:	3c01      	subs	r4, #1
   1d130:	b2a4      	uxth	r4, r4
   1d132:	3d0c      	subs	r5, #12
   1d134:	e7d4      	b.n	1d0e0 <pm_policy_next_state+0x30>
   1d136:	bf00      	nop
   1d138:	2000a0b4 	.word	0x2000a0b4
   1d13c:	000f423f 	.word	0x000f423f
   1d140:	000f4240 	.word	0x000f4240

0001d144 <pm_state_cpu_get_all>:
	DT_FOREACH_CHILD_SEP(DT_PATH(cpus), DT_NUM_CPU_POWER_STATES, (,))
};

uint8_t pm_state_cpu_get_all(uint8_t cpu, const struct pm_state_info **states)
{
	if (cpu >= ARRAY_SIZE(cpus_states)) {
   1d144:	b908      	cbnz	r0, 1d14a <pm_state_cpu_get_all+0x6>
		return 0;
	}

	*states = cpus_states[cpu];
   1d146:	4b02      	ldr	r3, [pc, #8]	; (1d150 <pm_state_cpu_get_all+0xc>)
   1d148:	600b      	str	r3, [r1, #0]

	return states_per_cpu[cpu];
}
   1d14a:	2000      	movs	r0, #0
   1d14c:	4770      	bx	lr
   1d14e:	bf00      	nop
   1d150:	00026648 	.word	0x00026648

0001d154 <class_handler>:
 * usb_enable() is no longer needed.
 */

static int class_handler(struct usb_setup_packet *pSetup,
			 int32_t *len, uint8_t **data)
{
   1d154:	b4f0      	push	{r4, r5, r6, r7}
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d156:	4b0c      	ldr	r3, [pc, #48]	; (1d188 <class_handler+0x34>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d158:	4e0c      	ldr	r6, [pc, #48]	; (1d18c <class_handler+0x38>)
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d15a:	6a5f      	ldr	r7, [r3, #36]	; 0x24
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d15c:	4b0c      	ldr	r3, [pc, #48]	; (1d190 <class_handler+0x3c>)
   1d15e:	42b3      	cmp	r3, r6
   1d160:	d303      	bcc.n	1d16a <class_handler+0x16>
			return iface->class_handler(pSetup, len, data);
		}
	}

	return -ENOTSUP;
}
   1d162:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1d166:	bcf0      	pop	{r4, r5, r6, r7}
   1d168:	4770      	bx	lr
		if_descr = cfg_data->interface_descriptor;
   1d16a:	685d      	ldr	r5, [r3, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d16c:	42bd      	cmp	r5, r7
   1d16e:	d309      	bcc.n	1d184 <class_handler+0x30>
		if (iface->class_handler &&
   1d170:	691c      	ldr	r4, [r3, #16]
   1d172:	b13c      	cbz	r4, 1d184 <class_handler+0x30>
		    if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
   1d174:	f895 c002 	ldrb.w	ip, [r5, #2]
   1d178:	7905      	ldrb	r5, [r0, #4]
		if (iface->class_handler &&
   1d17a:	45ac      	cmp	ip, r5
   1d17c:	d102      	bne.n	1d184 <class_handler+0x30>
			return iface->class_handler(pSetup, len, data);
   1d17e:	4623      	mov	r3, r4
}
   1d180:	bcf0      	pop	{r4, r5, r6, r7}
			return iface->class_handler(pSetup, len, data);
   1d182:	4718      	bx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d184:	3324      	adds	r3, #36	; 0x24
   1d186:	e7ea      	b.n	1d15e <class_handler+0xa>
   1d188:	2000a768 	.word	0x2000a768
   1d18c:	2000a410 	.word	0x2000a410
   1d190:	2000a3ec 	.word	0x2000a3ec

0001d194 <custom_handler>:

static int custom_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
   1d194:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d198:	4605      	mov	r5, r0
   1d19a:	460e      	mov	r6, r1
   1d19c:	4617      	mov	r7, r2
	struct usb_interface_cfg_data *iface;

	LOG_DBG("bRequest 0x%02x, wIndex 0x%04x",
		pSetup->bRequest, pSetup->wIndex);

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d19e:	4c12      	ldr	r4, [pc, #72]	; (1d1e8 <custom_handler+0x54>)
   1d1a0:	f8df 8048 	ldr.w	r8, [pc, #72]	; 1d1ec <custom_handler+0x58>
		if_descr = cfg_data->interface_descriptor;
		/*
		 * Wind forward until it is within the range
		 * of the current descriptor.
		 */
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d1a4:	f8df 9048 	ldr.w	r9, [pc, #72]	; 1d1f0 <custom_handler+0x5c>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d1a8:	4544      	cmp	r4, r8
   1d1aa:	d303      	bcc.n	1d1b4 <custom_handler+0x20>
			}
		}
	}

	return -ENOTSUP;
}
   1d1ac:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1d1b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if_descr = cfg_data->interface_descriptor;
   1d1b4:	6862      	ldr	r2, [r4, #4]
		if ((uint8_t *)if_descr < usb_dev.descriptors) {
   1d1b6:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
   1d1ba:	429a      	cmp	r2, r3
   1d1bc:	d312      	bcc.n	1d1e4 <custom_handler+0x50>
		if (iface->custom_handler == NULL) {
   1d1be:	69a3      	ldr	r3, [r4, #24]
   1d1c0:	b183      	cbz	r3, 1d1e4 <custom_handler+0x50>
		if (if_descr->bInterfaceNumber == (pSetup->wIndex & 0xFF)) {
   1d1c2:	7890      	ldrb	r0, [r2, #2]
   1d1c4:	7929      	ldrb	r1, [r5, #4]
   1d1c6:	4288      	cmp	r0, r1
   1d1c8:	d105      	bne.n	1d1d6 <custom_handler+0x42>
			return iface->custom_handler(pSetup, len, data);
   1d1ca:	463a      	mov	r2, r7
   1d1cc:	4631      	mov	r1, r6
   1d1ce:	4628      	mov	r0, r5
}
   1d1d0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			return iface->custom_handler(pSetup, len, data);
   1d1d4:	4718      	bx	r3
			if (if_descr->bInterfaceClass == USB_BCC_AUDIO) {
   1d1d6:	7952      	ldrb	r2, [r2, #5]
   1d1d8:	2a01      	cmp	r2, #1
   1d1da:	d103      	bne.n	1d1e4 <custom_handler+0x50>
				(void)iface->custom_handler(pSetup, len, data);
   1d1dc:	463a      	mov	r2, r7
   1d1de:	4631      	mov	r1, r6
   1d1e0:	4628      	mov	r0, r5
   1d1e2:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d1e4:	3424      	adds	r4, #36	; 0x24
   1d1e6:	e7df      	b.n	1d1a8 <custom_handler+0x14>
   1d1e8:	2000a3ec 	.word	0x2000a3ec
   1d1ec:	2000a410 	.word	0x2000a410
   1d1f0:	2000a768 	.word	0x2000a768

0001d1f4 <vendor_handler>:

static int vendor_handler(struct usb_setup_packet *pSetup,
			  int32_t *len, uint8_t **data)
{
   1d1f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1d1f8:	4605      	mov	r5, r0
   1d1fa:	460e      	mov	r6, r1
   1d1fc:	4617      	mov	r7, r2
		if (!usb_handle_os_desc_feature(pSetup, len, data)) {
			return 0;
		}
	}

	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d1fe:	4c0a      	ldr	r4, [pc, #40]	; (1d228 <vendor_handler+0x34>)
   1d200:	f8df 8028 	ldr.w	r8, [pc, #40]	; 1d22c <vendor_handler+0x38>
   1d204:	4544      	cmp	r4, r8
   1d206:	d302      	bcc.n	1d20e <vendor_handler+0x1a>
				return 0;
			}
		}
	}

	return -ENOTSUP;
   1d208:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1d20c:	e009      	b.n	1d222 <vendor_handler+0x2e>
		if (iface->vendor_handler) {
   1d20e:	6963      	ldr	r3, [r4, #20]
   1d210:	b90b      	cbnz	r3, 1d216 <vendor_handler+0x22>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d212:	3424      	adds	r4, #36	; 0x24
   1d214:	e7f6      	b.n	1d204 <vendor_handler+0x10>
			if (!iface->vendor_handler(pSetup, len, data)) {
   1d216:	463a      	mov	r2, r7
   1d218:	4631      	mov	r1, r6
   1d21a:	4628      	mov	r0, r5
   1d21c:	4798      	blx	r3
   1d21e:	2800      	cmp	r0, #0
   1d220:	d1f7      	bne.n	1d212 <vendor_handler+0x1e>
}
   1d222:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1d226:	bf00      	nop
   1d228:	2000a3ec 	.word	0x2000a3ec
   1d22c:	2000a410 	.word	0x2000a410

0001d230 <disable_endpoint>:
{
   1d230:	b510      	push	{r4, lr}
   1d232:	4604      	mov	r4, r0
	ret = usb_dc_ep_disable(ep_addr);
   1d234:	f007 ff16 	bl	25064 <usb_dc_ep_disable>
	if (ret == -EALREADY) {
   1d238:	f110 0f78 	cmn.w	r0, #120	; 0x78
   1d23c:	d000      	beq.n	1d240 <disable_endpoint+0x10>
	} else if (ret) {
   1d23e:	b950      	cbnz	r0, 1d256 <disable_endpoint+0x26>
	ep_bm = get_ep_bm_from_addr(ep_addr);
   1d240:	4620      	mov	r0, r4
   1d242:	f007 fd7f 	bl	24d44 <get_ep_bm_from_addr>
	usb_dev.ep_bm &= ~ep_bm;
   1d246:	4a04      	ldr	r2, [pc, #16]	; (1d258 <disable_endpoint+0x28>)
   1d248:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
   1d24c:	ea23 0300 	bic.w	r3, r3, r0
	return 0;
   1d250:	2000      	movs	r0, #0
	usb_dev.ep_bm &= ~ep_bm;
   1d252:	f8c2 30c4 	str.w	r3, [r2, #196]	; 0xc4
}
   1d256:	bd10      	pop	{r4, pc}
   1d258:	2000a768 	.word	0x2000a768

0001d25c <usb_reset_alt_setting>:
	memset(usb_dev.alt_setting, 0, ARRAY_SIZE(usb_dev.alt_setting));
   1d25c:	2208      	movs	r2, #8
   1d25e:	2100      	movs	r1, #0
   1d260:	4801      	ldr	r0, [pc, #4]	; (1d268 <usb_reset_alt_setting+0xc>)
   1d262:	f007 bec1 	b.w	24fe8 <memset>
   1d266:	bf00      	nop
   1d268:	2000a823 	.word	0x2000a823

0001d26c <is_ep_valid.part.0>:
static bool is_ep_valid(uint8_t ep)
   1d26c:	b570      	push	{r4, r5, r6, lr}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d26e:	4b0b      	ldr	r3, [pc, #44]	; (1d29c <is_ep_valid.part.0+0x30>)
   1d270:	4c0b      	ldr	r4, [pc, #44]	; (1d2a0 <is_ep_valid.part.0+0x34>)
   1d272:	42a3      	cmp	r3, r4
   1d274:	d301      	bcc.n	1d27a <is_ep_valid.part.0+0xe>
	return false;
   1d276:	2000      	movs	r0, #0
}
   1d278:	bd70      	pop	{r4, r5, r6, pc}
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d27a:	2200      	movs	r2, #0
		ep_data = cfg_data->endpoint;
   1d27c:	6a19      	ldr	r1, [r3, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d27e:	7f1e      	ldrb	r6, [r3, #28]
			if (ep_data[n].ep_addr == ep) {
   1d280:	3904      	subs	r1, #4
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d282:	b2d5      	uxtb	r5, r2
   1d284:	42ae      	cmp	r6, r5
   1d286:	d801      	bhi.n	1d28c <is_ep_valid.part.0+0x20>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d288:	3324      	adds	r3, #36	; 0x24
   1d28a:	e7f2      	b.n	1d272 <is_ep_valid.part.0+0x6>
			if (ep_data[n].ep_addr == ep) {
   1d28c:	3201      	adds	r2, #1
   1d28e:	f811 5032 	ldrb.w	r5, [r1, r2, lsl #3]
   1d292:	4285      	cmp	r5, r0
   1d294:	d1f5      	bne.n	1d282 <is_ep_valid.part.0+0x16>
		return true;
   1d296:	2001      	movs	r0, #1
   1d298:	e7ee      	b.n	1d278 <is_ep_valid.part.0+0xc>
   1d29a:	bf00      	nop
   1d29c:	2000a3ec 	.word	0x2000a3ec
   1d2a0:	2000a410 	.word	0x2000a410

0001d2a4 <usb_handle_request.constprop.0>:
static bool usb_handle_request(struct usb_setup_packet *setup,
   1d2a4:	b508      	push	{r3, lr}
	handler = usb_dev.req_handlers[type];
   1d2a6:	4809      	ldr	r0, [pc, #36]	; (1d2cc <usb_handle_request.constprop.0+0x28>)
	uint32_t type = setup->RequestType.type;
   1d2a8:	7803      	ldrb	r3, [r0, #0]
   1d2aa:	f3c3 1341 	ubfx	r3, r3, #5, #2
	handler = usb_dev.req_handlers[type];
   1d2ae:	330a      	adds	r3, #10
   1d2b0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	if (handler == NULL) {
   1d2b4:	b13b      	cbz	r3, 1d2c6 <usb_handle_request.constprop.0+0x22>
	if ((*handler)(setup, len, data) < 0) {
   1d2b6:	f100 0208 	add.w	r2, r0, #8
   1d2ba:	f100 0110 	add.w	r1, r0, #16
   1d2be:	4798      	blx	r3
   1d2c0:	43c0      	mvns	r0, r0
   1d2c2:	0fc0      	lsrs	r0, r0, #31
}
   1d2c4:	bd08      	pop	{r3, pc}
		return false;
   1d2c6:	4618      	mov	r0, r3
   1d2c8:	e7fc      	b.n	1d2c4 <usb_handle_request.constprop.0+0x20>
   1d2ca:	bf00      	nop
   1d2cc:	2000a768 	.word	0x2000a768

0001d2d0 <forward_status_cb>:
	if (status == USB_DC_DISCONNECTED) {
   1d2d0:	2804      	cmp	r0, #4
{
   1d2d2:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d2d6:	4604      	mov	r4, r0
   1d2d8:	460f      	mov	r7, r1
   1d2da:	f8df 9094 	ldr.w	r9, [pc, #148]	; 1d370 <forward_status_cb+0xa0>
	if (status == USB_DC_DISCONNECTED) {
   1d2de:	d016      	beq.n	1d30e <forward_status_cb+0x3e>
	if (status == USB_DC_DISCONNECTED || status == USB_DC_RESET) {
   1d2e0:	2801      	cmp	r0, #1
   1d2e2:	d12d      	bne.n	1d340 <forward_status_cb+0x70>
		if (usb_dev.configured) {
   1d2e4:	f8df 808c 	ldr.w	r8, [pc, #140]	; 1d374 <forward_status_cb+0xa4>
   1d2e8:	f898 30b9 	ldrb.w	r3, [r8, #185]	; 0xb9
   1d2ec:	b343      	cbz	r3, 1d340 <forward_status_cb+0x70>
			usb_cancel_transfers();
   1d2ee:	f000 fdb9 	bl	1de64 <usb_cancel_transfers>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d2f2:	4d21      	ldr	r5, [pc, #132]	; (1d378 <forward_status_cb+0xa8>)
   1d2f4:	454d      	cmp	r5, r9
   1d2f6:	d220      	bcs.n	1d33a <forward_status_cb+0x6a>
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d2f8:	f04f 0a00 	mov.w	sl, #0
		ep_data = cfg_data->endpoint;
   1d2fc:	f8d5 b020 	ldr.w	fp, [r5, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d300:	7f2b      	ldrb	r3, [r5, #28]
   1d302:	fa5f f68a 	uxtb.w	r6, sl
   1d306:	42b3      	cmp	r3, r6
   1d308:	d804      	bhi.n	1d314 <forward_status_cb+0x44>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d30a:	3524      	adds	r5, #36	; 0x24
   1d30c:	e7f2      	b.n	1d2f4 <forward_status_cb+0x24>
		usb_reset_alt_setting();
   1d30e:	f7ff ffa5 	bl	1d25c <usb_reset_alt_setting>
	if (status == USB_DC_DISCONNECTED || status == USB_DC_RESET) {
   1d312:	e7e7      	b.n	1d2e4 <forward_status_cb+0x14>
			ret = endpoint_callback(&ep_data[n]);
   1d314:	eb0b 06c6 	add.w	r6, fp, r6, lsl #3
	ret = usb_dc_ep_disable(ep_data->ep_addr);
   1d318:	7930      	ldrb	r0, [r6, #4]
   1d31a:	f007 fea3 	bl	25064 <usb_dc_ep_disable>
   1d31e:	4602      	mov	r2, r0
	ep_bm = get_ep_bm_from_addr(ep_data->ep_addr);
   1d320:	7930      	ldrb	r0, [r6, #4]
   1d322:	f007 fd0f 	bl	24d44 <get_ep_bm_from_addr>
	usb_dev.ep_bm &= ~ep_bm;
   1d326:	f8d8 30c4 	ldr.w	r3, [r8, #196]	; 0xc4
			if (ret < 0) {
   1d32a:	2a00      	cmp	r2, #0
	usb_dev.ep_bm &= ~ep_bm;
   1d32c:	ea23 0300 	bic.w	r3, r3, r0
   1d330:	f8c8 30c4 	str.w	r3, [r8, #196]	; 0xc4
			if (ret < 0) {
   1d334:	f10a 0a01 	add.w	sl, sl, #1
   1d338:	dae2      	bge.n	1d300 <forward_status_cb+0x30>
			usb_dev.configured = false;
   1d33a:	2300      	movs	r3, #0
   1d33c:	f888 30b9 	strb.w	r3, [r8, #185]	; 0xb9
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d340:	4d0d      	ldr	r5, [pc, #52]	; (1d378 <forward_status_cb+0xa8>)
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d342:	454d      	cmp	r5, r9
   1d344:	d308      	bcc.n	1d358 <forward_status_cb+0x88>
	if (usb_dev.user_status_callback) {
   1d346:	4b0b      	ldr	r3, [pc, #44]	; (1d374 <forward_status_cb+0xa4>)
   1d348:	6a1b      	ldr	r3, [r3, #32]
   1d34a:	b16b      	cbz	r3, 1d368 <forward_status_cb+0x98>
		usb_dev.user_status_callback(status, param);
   1d34c:	4639      	mov	r1, r7
   1d34e:	4620      	mov	r0, r4
}
   1d350:	b001      	add	sp, #4
   1d352:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		usb_dev.user_status_callback(status, param);
   1d356:	4718      	bx	r3
		if (cfg_data->cb_usb_status) {
   1d358:	68eb      	ldr	r3, [r5, #12]
   1d35a:	b11b      	cbz	r3, 1d364 <forward_status_cb+0x94>
			cfg_data->cb_usb_status(cfg_data, status, param);
   1d35c:	463a      	mov	r2, r7
   1d35e:	4621      	mov	r1, r4
   1d360:	4628      	mov	r0, r5
   1d362:	4798      	blx	r3
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d364:	3524      	adds	r5, #36	; 0x24
   1d366:	e7ec      	b.n	1d342 <forward_status_cb+0x72>
}
   1d368:	b001      	add	sp, #4
   1d36a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d36e:	bf00      	nop
   1d370:	2000a410 	.word	0x2000a410
   1d374:	2000a768 	.word	0x2000a768
   1d378:	2000a3ec 	.word	0x2000a3ec

0001d37c <usb_halt_endpoint_req.isra.0>:
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
   1d37c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	uint8_t ep = setup->wIndex;
   1d37e:	b2c4      	uxtb	r4, r0
	if (USB_EP_GET_IDX(ep) == 0) {
   1d380:	0663      	lsls	r3, r4, #25
static bool usb_halt_endpoint_req(struct usb_setup_packet *setup, bool halt)
   1d382:	460d      	mov	r5, r1
	uint8_t ep = setup->wIndex;
   1d384:	f88d 4007 	strb.w	r4, [sp, #7]
	if (USB_EP_GET_IDX(ep) == 0) {
   1d388:	d007      	beq.n	1d39a <usb_halt_endpoint_req.isra.0+0x1e>
   1d38a:	4620      	mov	r0, r4
   1d38c:	f7ff ff6e 	bl	1d26c <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
   1d390:	b178      	cbz	r0, 1d3b2 <usb_halt_endpoint_req.isra.0+0x36>
	return (usb_dev.configuration != 0);
   1d392:	4b0d      	ldr	r3, [pc, #52]	; (1d3c8 <usb_halt_endpoint_req.isra.0+0x4c>)
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
   1d394:	f893 00ba 	ldrb.w	r0, [r3, #186]	; 0xba
   1d398:	b158      	cbz	r0, 1d3b2 <usb_halt_endpoint_req.isra.0+0x36>
			usb_dc_ep_set_stall(ep);
   1d39a:	4620      	mov	r0, r4
   1d39c:	4e0a      	ldr	r6, [pc, #40]	; (1d3c8 <usb_halt_endpoint_req.isra.0+0x4c>)
		if (halt) {
   1d39e:	b155      	cbz	r5, 1d3b6 <usb_halt_endpoint_req.isra.0+0x3a>
			usb_dc_ep_set_stall(ep);
   1d3a0:	f002 f816 	bl	1f3d0 <usb_dc_ep_set_stall>
			if (usb_dev.status_callback) {
   1d3a4:	69f3      	ldr	r3, [r6, #28]
   1d3a6:	b11b      	cbz	r3, 1d3b0 <usb_halt_endpoint_req.isra.0+0x34>
				usb_dev.status_callback(USB_DC_SET_HALT, &ep);
   1d3a8:	2008      	movs	r0, #8
   1d3aa:	f10d 0107 	add.w	r1, sp, #7
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
   1d3ae:	4798      	blx	r3
		return true;
   1d3b0:	2001      	movs	r0, #1
}
   1d3b2:	b002      	add	sp, #8
   1d3b4:	bd70      	pop	{r4, r5, r6, pc}
			usb_dc_ep_clear_stall(ep);
   1d3b6:	f002 f833 	bl	1f420 <usb_dc_ep_clear_stall>
			if (usb_dev.status_callback) {
   1d3ba:	69f3      	ldr	r3, [r6, #28]
   1d3bc:	2b00      	cmp	r3, #0
   1d3be:	d0f7      	beq.n	1d3b0 <usb_halt_endpoint_req.isra.0+0x34>
				usb_dev.status_callback(USB_DC_CLEAR_HALT, &ep);
   1d3c0:	2009      	movs	r0, #9
   1d3c2:	f10d 0107 	add.w	r1, sp, #7
   1d3c6:	e7f2      	b.n	1d3ae <usb_halt_endpoint_req.isra.0+0x32>
   1d3c8:	2000a768 	.word	0x2000a768

0001d3cc <set_endpoint>:
{
   1d3cc:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ep_cfg.ep_addr = ep_desc->bEndpointAddress;
   1d3ce:	7886      	ldrb	r6, [r0, #2]
	if (ep_bm & usb_dev.ep_bm) {
   1d3d0:	4c1e      	ldr	r4, [pc, #120]	; (1d44c <set_endpoint+0x80>)
	ep_cfg.ep_addr = ep_desc->bEndpointAddress;
   1d3d2:	f88d 6000 	strb.w	r6, [sp]
	ep_cfg.ep_mps = sys_le16_to_cpu(ep_desc->wMaxPacketSize);
   1d3d6:	7903      	ldrb	r3, [r0, #4]
   1d3d8:	7942      	ldrb	r2, [r0, #5]
   1d3da:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1d3de:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
   1d3e2:	78c3      	ldrb	r3, [r0, #3]
	ep_bm = get_ep_bm_from_addr(ep_desc->bEndpointAddress);
   1d3e4:	4630      	mov	r0, r6
	ep_cfg.ep_type = ep_desc->bmAttributes & USB_EP_TRANSFER_TYPE_MASK;
   1d3e6:	f003 0303 	and.w	r3, r3, #3
   1d3ea:	f88d 3004 	strb.w	r3, [sp, #4]
	ep_bm = get_ep_bm_from_addr(ep_desc->bEndpointAddress);
   1d3ee:	f007 fca9 	bl	24d44 <get_ep_bm_from_addr>
	if (ep_bm & usb_dev.ep_bm) {
   1d3f2:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
	ep_bm = get_ep_bm_from_addr(ep_desc->bEndpointAddress);
   1d3f6:	4605      	mov	r5, r0
	if (ep_bm & usb_dev.ep_bm) {
   1d3f8:	4218      	tst	r0, r3
   1d3fa:	d00b      	beq.n	1d414 <set_endpoint+0x48>
	usb_cancel_transfer(ep_cfg.ep_addr);
   1d3fc:	4630      	mov	r0, r6
   1d3fe:	f000 fd13 	bl	1de28 <usb_cancel_transfer>
	return disable_endpoint(ep_cfg.ep_addr) ? false : true;
   1d402:	4630      	mov	r0, r6
   1d404:	f7ff ff14 	bl	1d230 <disable_endpoint>
		if (!k_is_in_isr()) {
   1d408:	f008 fbc5 	bl	25b96 <k_is_in_isr>
   1d40c:	b910      	cbnz	r0, 1d414 <set_endpoint+0x48>
		union { uintptr_t x; int32_t val; } parm0 = { .val = us };
		return (int32_t) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_USLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_usleep(us);
   1d40e:	2096      	movs	r0, #150	; 0x96
   1d410:	f006 fd28 	bl	23e64 <z_impl_k_usleep>
	ret = usb_dc_ep_configure(&ep_cfg);
   1d414:	4668      	mov	r0, sp
   1d416:	f001 ffb7 	bl	1f388 <usb_dc_ep_configure>
	if (ret == -EALREADY) {
   1d41a:	f110 0f78 	cmn.w	r0, #120	; 0x78
   1d41e:	d003      	beq.n	1d428 <set_endpoint+0x5c>
	} else if (ret) {
   1d420:	b110      	cbz	r0, 1d428 <set_endpoint+0x5c>
		return false;
   1d422:	2000      	movs	r0, #0
}
   1d424:	b002      	add	sp, #8
   1d426:	bd70      	pop	{r4, r5, r6, pc}
	ret = usb_dc_ep_enable(ep_cfg.ep_addr);
   1d428:	f89d 0000 	ldrb.w	r0, [sp]
   1d42c:	f002 f834 	bl	1f498 <usb_dc_ep_enable>
	if (ret == -EALREADY) {
   1d430:	f110 0f78 	cmn.w	r0, #120	; 0x78
   1d434:	d001      	beq.n	1d43a <set_endpoint+0x6e>
	} else if (ret) {
   1d436:	2800      	cmp	r0, #0
   1d438:	d1f3      	bne.n	1d422 <set_endpoint+0x56>
	usb_dev.configured = true;
   1d43a:	2001      	movs	r0, #1
	usb_dev.ep_bm |= ep_bm;
   1d43c:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
	usb_dev.configured = true;
   1d440:	f884 00b9 	strb.w	r0, [r4, #185]	; 0xb9
	usb_dev.ep_bm |= ep_bm;
   1d444:	432b      	orrs	r3, r5
   1d446:	f8c4 30c4 	str.w	r3, [r4, #196]	; 0xc4
	return true;
   1d44a:	e7eb      	b.n	1d424 <set_endpoint+0x58>
   1d44c:	2000a768 	.word	0x2000a768

0001d450 <usb_handle_standard_request>:
{
   1d450:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (usb_dev.custom_req_handler &&
   1d454:	4d92      	ldr	r5, [pc, #584]	; (1d6a0 <usb_handle_standard_request+0x250>)
{
   1d456:	4604      	mov	r4, r0
	if (usb_dev.custom_req_handler &&
   1d458:	69ab      	ldr	r3, [r5, #24]
{
   1d45a:	460e      	mov	r6, r1
   1d45c:	4617      	mov	r7, r2
	if (usb_dev.custom_req_handler &&
   1d45e:	b9c3      	cbnz	r3, 1d492 <usb_handle_standard_request+0x42>
	switch (setup->RequestType.recipient) {
   1d460:	7820      	ldrb	r0, [r4, #0]
   1d462:	f000 001f 	and.w	r0, r0, #31
   1d466:	2801      	cmp	r0, #1
   1d468:	d076      	beq.n	1d558 <usb_handle_standard_request+0x108>
   1d46a:	2802      	cmp	r0, #2
   1d46c:	f000 80dc 	beq.w	1d628 <usb_handle_standard_request+0x1d8>
   1d470:	bb00      	cbnz	r0, 1d4b4 <usb_handle_standard_request+0x64>
	if (usb_reqtype_is_to_host(setup)) {
   1d472:	f994 1000 	ldrsb.w	r1, [r4]
	uint8_t *data = *data_buf;
   1d476:	683a      	ldr	r2, [r7, #0]
	if (usb_reqtype_is_to_host(setup)) {
   1d478:	2900      	cmp	r1, #0
		switch (setup->bRequest) {
   1d47a:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   1d47c:	da2e      	bge.n	1d4dc <usb_handle_standard_request+0x8c>
		switch (setup->bRequest) {
   1d47e:	2b06      	cmp	r3, #6
   1d480:	d00c      	beq.n	1d49c <usb_handle_standard_request+0x4c>
   1d482:	2b08      	cmp	r3, #8
   1d484:	d025      	beq.n	1d4d2 <usb_handle_standard_request+0x82>
   1d486:	b9ab      	cbnz	r3, 1d4b4 <usb_handle_standard_request+0x64>
	data[1] = 0U;
   1d488:	7053      	strb	r3, [r2, #1]
		data[0] |= USB_GET_STATUS_SELF_POWERED;
   1d48a:	2301      	movs	r3, #1
   1d48c:	7013      	strb	r3, [r2, #0]
		*len = 2;
   1d48e:	2302      	movs	r3, #2
   1d490:	e103      	b.n	1d69a <usb_handle_standard_request+0x24a>
	    !usb_dev.custom_req_handler(setup, len, data_buf)) {
   1d492:	4798      	blx	r3
	if (usb_dev.custom_req_handler &&
   1d494:	2800      	cmp	r0, #0
   1d496:	d1e3      	bne.n	1d460 <usb_handle_standard_request+0x10>
		return 0;
   1d498:	2000      	movs	r0, #0
   1d49a:	e00d      	b.n	1d4b8 <usb_handle_standard_request+0x68>
			return usb_get_descriptor(setup, len, data_buf);
   1d49c:	8863      	ldrh	r3, [r4, #2]
	type = USB_GET_DESCRIPTOR_TYPE(setup->wValue);
   1d49e:	0a19      	lsrs	r1, r3, #8
	if ((type == USB_DESC_INTERFACE) || (type == USB_DESC_ENDPOINT) ||
   1d4a0:	1f0a      	subs	r2, r1, #4
   1d4a2:	2a01      	cmp	r2, #1
	type = USB_GET_DESCRIPTOR_TYPE(setup->wValue);
   1d4a4:	468c      	mov	ip, r1
	if ((type == USB_DESC_INTERFACE) || (type == USB_DESC_ENDPOINT) ||
   1d4a6:	d905      	bls.n	1d4b4 <usb_handle_standard_request+0x64>
   1d4a8:	2907      	cmp	r1, #7
   1d4aa:	d803      	bhi.n	1d4b4 <usb_handle_standard_request+0x64>
	index = USB_GET_DESCRIPTOR_INDEX(setup->wValue);
   1d4ac:	b2da      	uxtb	r2, r3
	p = (uint8_t *)usb_dev.descriptors;
   1d4ae:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	while (p[DESC_bLength] != 0U) {
   1d4b0:	781c      	ldrb	r4, [r3, #0]
   1d4b2:	b91c      	cbnz	r4, 1d4bc <usb_handle_standard_request+0x6c>
			rc = -EINVAL;
   1d4b4:	f06f 0015 	mvn.w	r0, #21
}
   1d4b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (p[DESC_bDescriptorType] == type) {
   1d4bc:	785d      	ldrb	r5, [r3, #1]
   1d4be:	4565      	cmp	r5, ip
   1d4c0:	d103      	bne.n	1d4ca <usb_handle_standard_request+0x7a>
			if (cur_index == index) {
   1d4c2:	4282      	cmp	r2, r0
   1d4c4:	f000 80e4 	beq.w	1d690 <usb_handle_standard_request+0x240>
			cur_index++;
   1d4c8:	3001      	adds	r0, #1
		p += p[DESC_bLength];
   1d4ca:	4423      	add	r3, r4
   1d4cc:	e7f0      	b.n	1d4b0 <usb_handle_standard_request+0x60>
			*len = p[DESC_bLength];
   1d4ce:	781b      	ldrb	r3, [r3, #0]
   1d4d0:	e0e3      	b.n	1d69a <usb_handle_standard_request+0x24a>
			data[0] = usb_dev.configuration;
   1d4d2:	f895 30ba 	ldrb.w	r3, [r5, #186]	; 0xba
   1d4d6:	7013      	strb	r3, [r2, #0]
				*len = 1;
   1d4d8:	2301      	movs	r3, #1
   1d4da:	e0de      	b.n	1d69a <usb_handle_standard_request+0x24a>
		switch (setup->bRequest) {
   1d4dc:	2b05      	cmp	r3, #5
   1d4de:	d011      	beq.n	1d504 <usb_handle_standard_request+0xb4>
   1d4e0:	2b09      	cmp	r3, #9
   1d4e2:	d1e7      	bne.n	1d4b4 <usb_handle_standard_request+0x64>
	if (setup->wValue == 0U) {
   1d4e4:	8863      	ldrh	r3, [r4, #2]
	uint8_t *p = (uint8_t *)usb_dev.descriptors;
   1d4e6:	6a6e      	ldr	r6, [r5, #36]	; 0x24
	if (setup->wValue == 0U) {
   1d4e8:	2b00      	cmp	r3, #0
   1d4ea:	d132      	bne.n	1d552 <usb_handle_standard_request+0x102>
		usb_reset_alt_setting();
   1d4ec:	f7ff feb6 	bl	1d25c <usb_reset_alt_setting>
		usb_dev.configuration = setup->wValue;
   1d4f0:	8863      	ldrh	r3, [r4, #2]
   1d4f2:	f885 30ba 	strb.w	r3, [r5, #186]	; 0xba
		if (usb_dev.status_callback) {
   1d4f6:	69eb      	ldr	r3, [r5, #28]
   1d4f8:	2b00      	cmp	r3, #0
   1d4fa:	d0cd      	beq.n	1d498 <usb_handle_standard_request+0x48>
			usb_dev.status_callback(USB_DC_CONFIGURED,
   1d4fc:	2003      	movs	r0, #3
   1d4fe:	4969      	ldr	r1, [pc, #420]	; (1d6a4 <usb_handle_standard_request+0x254>)
   1d500:	4798      	blx	r3
   1d502:	e7c9      	b.n	1d498 <usb_handle_standard_request+0x48>
			return !usb_dc_set_address(setup->wValue);
   1d504:	78a0      	ldrb	r0, [r4, #2]
   1d506:	f001 ff2d 	bl	1f364 <usb_dc_set_address>
		if (usb_handle_std_device_req(setup, len, data_buf) == false) {
   1d50a:	2800      	cmp	r0, #0
   1d50c:	d0c4      	beq.n	1d498 <usb_handle_standard_request+0x48>
   1d50e:	e7d1      	b.n	1d4b4 <usb_handle_standard_request+0x64>
		switch (p[DESC_bDescriptorType]) {
   1d510:	7873      	ldrb	r3, [r6, #1]
   1d512:	2b04      	cmp	r3, #4
   1d514:	d010      	beq.n	1d538 <usb_handle_standard_request+0xe8>
   1d516:	2b05      	cmp	r3, #5
   1d518:	d011      	beq.n	1d53e <usb_handle_standard_request+0xee>
   1d51a:	2b02      	cmp	r3, #2
   1d51c:	d104      	bne.n	1d528 <usb_handle_standard_request+0xd8>
			cur_config = p[CONF_DESC_bConfigurationValue];
   1d51e:	7977      	ldrb	r7, [r6, #5]
			if (cur_config == setup->wValue) {
   1d520:	8863      	ldrh	r3, [r4, #2]
				found = true;
   1d522:	42bb      	cmp	r3, r7
   1d524:	bf08      	it	eq
   1d526:	2001      	moveq	r0, #1
		p += p[DESC_bLength];
   1d528:	7833      	ldrb	r3, [r6, #0]
   1d52a:	441e      	add	r6, r3
	while (p[DESC_bLength] != 0U) {
   1d52c:	7833      	ldrb	r3, [r6, #0]
   1d52e:	2b00      	cmp	r3, #0
   1d530:	d1ee      	bne.n	1d510 <usb_handle_standard_request+0xc0>
	if (found) {
   1d532:	2800      	cmp	r0, #0
   1d534:	d0be      	beq.n	1d4b4 <usb_handle_standard_request+0x64>
   1d536:	e7d9      	b.n	1d4ec <usb_handle_standard_request+0x9c>
			cur_alt_setting =
   1d538:	f896 8003 	ldrb.w	r8, [r6, #3]
			break;
   1d53c:	e7f4      	b.n	1d528 <usb_handle_standard_request+0xd8>
			if ((cur_config != setup->wValue) ||
   1d53e:	8863      	ldrh	r3, [r4, #2]
   1d540:	42bb      	cmp	r3, r7
   1d542:	d1f1      	bne.n	1d528 <usb_handle_standard_request+0xd8>
   1d544:	f1b8 0f00 	cmp.w	r8, #0
   1d548:	d1ee      	bne.n	1d528 <usb_handle_standard_request+0xd8>
			found = set_endpoint((struct usb_ep_descriptor *)p);
   1d54a:	4630      	mov	r0, r6
   1d54c:	f7ff ff3e 	bl	1d3cc <set_endpoint>
			break;
   1d550:	e7ea      	b.n	1d528 <usb_handle_standard_request+0xd8>
	uint8_t cur_config = 0xFF;
   1d552:	27ff      	movs	r7, #255	; 0xff
	uint8_t cur_alt_setting = 0xFF;
   1d554:	46b8      	mov	r8, r7
   1d556:	e7e9      	b.n	1d52c <usb_handle_standard_request+0xdc>
	if (!is_device_configured() ||
   1d558:	f895 30ba 	ldrb.w	r3, [r5, #186]	; 0xba
   1d55c:	f8d7 c000 	ldr.w	ip, [r7]
   1d560:	2b00      	cmp	r3, #0
   1d562:	d0a7      	beq.n	1d4b4 <usb_handle_standard_request+0x64>
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
   1d564:	6a6f      	ldr	r7, [r5, #36]	; 0x24
	   (!is_interface_valid((uint8_t)setup->wIndex))) {
   1d566:	88a2      	ldrh	r2, [r4, #4]
	const uint8_t *p = (uint8_t *)usb_dev.descriptors;
   1d568:	463b      	mov	r3, r7
	   (!is_interface_valid((uint8_t)setup->wIndex))) {
   1d56a:	f894 e004 	ldrb.w	lr, [r4, #4]
	while (p[DESC_bLength] != 0U) {
   1d56e:	7818      	ldrb	r0, [r3, #0]
   1d570:	2800      	cmp	r0, #0
   1d572:	d09f      	beq.n	1d4b4 <usb_handle_standard_request+0x64>
		if (p[DESC_bDescriptorType] == USB_DESC_CONFIGURATION) {
   1d574:	7859      	ldrb	r1, [r3, #1]
   1d576:	2902      	cmp	r1, #2
   1d578:	d104      	bne.n	1d584 <usb_handle_standard_request+0x134>
			if (interface < cfg_descr->bNumInterfaces) {
   1d57a:	f893 8004 	ldrb.w	r8, [r3, #4]
   1d57e:	45f0      	cmp	r8, lr
   1d580:	f200 8092 	bhi.w	1d6a8 <usb_handle_standard_request+0x258>
		p += p[DESC_bLength];
   1d584:	4403      	add	r3, r0
   1d586:	e7f2      	b.n	1d56e <usb_handle_standard_request+0x11e>
			data[0] = 0U;
   1d588:	f88c 3000 	strb.w	r3, [ip]
			data[1] = 0U;
   1d58c:	f88c 3001 	strb.w	r3, [ip, #1]
			*len = 2;
   1d590:	6031      	str	r1, [r6, #0]
			return true;
   1d592:	e781      	b.n	1d498 <usb_handle_standard_request+0x48>
		p += p[DESC_bLength];
   1d594:	441f      	add	r7, r3
   1d596:	e093      	b.n	1d6c0 <usb_handle_standard_request+0x270>
		if (setup->bRequest == USB_SREQ_SET_INTERFACE) {
   1d598:	2b0b      	cmp	r3, #11
   1d59a:	d18b      	bne.n	1d4b4 <usb_handle_standard_request+0x64>
	bool ret = false;
   1d59c:	2600      	movs	r6, #0
	uint8_t cur_iface = 0xFF;
   1d59e:	f04f 08ff 	mov.w	r8, #255	; 0xff
	const uint8_t *if_desc = NULL;
   1d5a2:	46b2      	mov	sl, r6
	uint8_t cur_alt_setting = 0xFF;
   1d5a4:	46c1      	mov	r9, r8
   1d5a6:	e006      	b.n	1d5b6 <usb_handle_standard_request+0x166>
		switch (p[DESC_bDescriptorType]) {
   1d5a8:	787b      	ldrb	r3, [r7, #1]
   1d5aa:	2b04      	cmp	r3, #4
   1d5ac:	d00f      	beq.n	1d5ce <usb_handle_standard_request+0x17e>
   1d5ae:	2b05      	cmp	r3, #5
   1d5b0:	d021      	beq.n	1d5f6 <usb_handle_standard_request+0x1a6>
		p += p[DESC_bLength];
   1d5b2:	783b      	ldrb	r3, [r7, #0]
   1d5b4:	441f      	add	r7, r3
	while (p[DESC_bLength] != 0U) {
   1d5b6:	783b      	ldrb	r3, [r7, #0]
   1d5b8:	2b00      	cmp	r3, #0
   1d5ba:	d1f5      	bne.n	1d5a8 <usb_handle_standard_request+0x158>
	if (usb_dev.status_callback) {
   1d5bc:	69eb      	ldr	r3, [r5, #28]
   1d5be:	b113      	cbz	r3, 1d5c6 <usb_handle_standard_request+0x176>
		usb_dev.status_callback(USB_DC_INTERFACE, if_desc);
   1d5c0:	4651      	mov	r1, sl
   1d5c2:	2007      	movs	r0, #7
   1d5c4:	4798      	blx	r3
		if (usb_handle_std_interface_req(setup, len, data_buf) == false) {
   1d5c6:	2e00      	cmp	r6, #0
   1d5c8:	f47f af66 	bne.w	1d498 <usb_handle_standard_request+0x48>
   1d5cc:	e772      	b.n	1d4b4 <usb_handle_standard_request+0x64>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
   1d5ce:	f897 8002 	ldrb.w	r8, [r7, #2]
			if (cur_iface == setup->wIndex &&
   1d5d2:	88a3      	ldrh	r3, [r4, #4]
			cur_alt_setting = p[INTF_DESC_bAlternateSetting];
   1d5d4:	f897 9003 	ldrb.w	r9, [r7, #3]
			if (cur_iface == setup->wIndex &&
   1d5d8:	4598      	cmp	r8, r3
   1d5da:	d1ea      	bne.n	1d5b2 <usb_handle_standard_request+0x162>
			    cur_alt_setting == setup->wValue) {
   1d5dc:	8863      	ldrh	r3, [r4, #2]
			if (cur_iface == setup->wIndex &&
   1d5de:	4599      	cmp	r9, r3
   1d5e0:	d1e7      	bne.n	1d5b2 <usb_handle_standard_request+0x162>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
   1d5e2:	f1b8 0f07 	cmp.w	r8, #7
   1d5e6:	d81c      	bhi.n	1d622 <usb_handle_standard_request+0x1d2>
		usb_dev.alt_setting[iface] = alt_setting;
   1d5e8:	eb05 0308 	add.w	r3, r5, r8
		return true;
   1d5ec:	46ba      	mov	sl, r7
   1d5ee:	2601      	movs	r6, #1
				ret = usb_set_alt_setting(setup->wIndex,
   1d5f0:	f883 90bb 	strb.w	r9, [r3, #187]	; 0xbb
		return true;
   1d5f4:	e7dd      	b.n	1d5b2 <usb_handle_standard_request+0x162>
			if (cur_iface == setup->wIndex) {
   1d5f6:	88a3      	ldrh	r3, [r4, #4]
   1d5f8:	4543      	cmp	r3, r8
   1d5fa:	d1da      	bne.n	1d5b2 <usb_handle_standard_request+0x162>
	if (cur_alt_setting != alt_setting) {
   1d5fc:	78a3      	ldrb	r3, [r4, #2]
   1d5fe:	454b      	cmp	r3, r9
   1d600:	d00a      	beq.n	1d618 <usb_handle_standard_request+0x1c8>
		ret = reset_endpoint(ep_desc);
   1d602:	78be      	ldrb	r6, [r7, #2]
	usb_cancel_transfer(ep_cfg.ep_addr);
   1d604:	4630      	mov	r0, r6
   1d606:	f000 fc0f 	bl	1de28 <usb_cancel_transfer>
	return disable_endpoint(ep_cfg.ep_addr) ? false : true;
   1d60a:	4630      	mov	r0, r6
   1d60c:	f7ff fe10 	bl	1d230 <disable_endpoint>
   1d610:	fab0 f680 	clz	r6, r0
   1d614:	0976      	lsrs	r6, r6, #5
   1d616:	e7cc      	b.n	1d5b2 <usb_handle_standard_request+0x162>
		ret = set_endpoint(ep_desc);
   1d618:	4638      	mov	r0, r7
   1d61a:	f7ff fed7 	bl	1d3cc <set_endpoint>
   1d61e:	4606      	mov	r6, r0
   1d620:	e7c7      	b.n	1d5b2 <usb_handle_standard_request+0x162>
   1d622:	46ba      	mov	sl, r7
	return false;
   1d624:	2600      	movs	r6, #0
   1d626:	e7c4      	b.n	1d5b2 <usb_handle_standard_request+0x162>
	if (usb_reqtype_is_to_host(setup)) {
   1d628:	f994 2000 	ldrsb.w	r2, [r4]
		switch (setup->bRequest) {
   1d62c:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   1d62e:	2a00      	cmp	r2, #0
   1d630:	da18      	bge.n	1d664 <usb_handle_standard_request+0x214>
		if (setup->bRequest == USB_SREQ_GET_STATUS) {
   1d632:	2b00      	cmp	r3, #0
   1d634:	f47f af3e 	bne.w	1d4b4 <usb_handle_standard_request+0x64>
	uint8_t ep = setup->wIndex;
   1d638:	7924      	ldrb	r4, [r4, #4]
   1d63a:	683f      	ldr	r7, [r7, #0]
	if (USB_EP_GET_IDX(ep) == 0) {
   1d63c:	0663      	lsls	r3, r4, #25
   1d63e:	d00a      	beq.n	1d656 <usb_handle_standard_request+0x206>
   1d640:	4620      	mov	r0, r4
   1d642:	f7ff fe13 	bl	1d26c <is_ep_valid.part.0>
	if (!is_ep_valid(ep)) {
   1d646:	2800      	cmp	r0, #0
   1d648:	f43f af34 	beq.w	1d4b4 <usb_handle_standard_request+0x64>
	if ((USB_EP_GET_IDX(ep) == 0) || is_device_configured()) {
   1d64c:	f895 30ba 	ldrb.w	r3, [r5, #186]	; 0xba
   1d650:	2b00      	cmp	r3, #0
   1d652:	f43f af2f 	beq.w	1d4b4 <usb_handle_standard_request+0x64>
		usb_dc_ep_is_stalled(ep, &data[0]);
   1d656:	4639      	mov	r1, r7
   1d658:	4620      	mov	r0, r4
   1d65a:	f001 ff01 	bl	1f460 <usb_dc_ep_is_stalled>
		data[1] = 0U;
   1d65e:	2300      	movs	r3, #0
   1d660:	707b      	strb	r3, [r7, #1]
   1d662:	e714      	b.n	1d48e <usb_handle_standard_request+0x3e>
		switch (setup->bRequest) {
   1d664:	2b01      	cmp	r3, #1
   1d666:	d008      	beq.n	1d67a <usb_handle_standard_request+0x22a>
   1d668:	2b03      	cmp	r3, #3
   1d66a:	f47f af23 	bne.w	1d4b4 <usb_handle_standard_request+0x64>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
   1d66e:	8863      	ldrh	r3, [r4, #2]
   1d670:	2b00      	cmp	r3, #0
   1d672:	f47f af1f 	bne.w	1d4b4 <usb_handle_standard_request+0x64>
				return usb_halt_endpoint_req(setup, true);
   1d676:	2101      	movs	r1, #1
   1d678:	e003      	b.n	1d682 <usb_handle_standard_request+0x232>
			if (setup->wValue == USB_SFS_ENDPOINT_HALT) {
   1d67a:	8861      	ldrh	r1, [r4, #2]
   1d67c:	2900      	cmp	r1, #0
   1d67e:	f47f af19 	bne.w	1d4b4 <usb_handle_standard_request+0x64>
				return usb_halt_endpoint_req(setup, true);
   1d682:	88a0      	ldrh	r0, [r4, #4]
   1d684:	f7ff fe7a 	bl	1d37c <usb_halt_endpoint_req.isra.0>
		if (usb_handle_std_endpoint_req(setup, len, data_buf) == false) {
   1d688:	2800      	cmp	r0, #0
   1d68a:	f47f af05 	bne.w	1d498 <usb_handle_standard_request+0x48>
   1d68e:	e711      	b.n	1d4b4 <usb_handle_standard_request+0x64>
		if (type == USB_DESC_CONFIGURATION) {
   1d690:	2902      	cmp	r1, #2
		*data = p;
   1d692:	603b      	str	r3, [r7, #0]
		if (type == USB_DESC_CONFIGURATION) {
   1d694:	f47f af1b 	bne.w	1d4ce <usb_handle_standard_request+0x7e>
			*len = (p[CONF_DESC_wTotalLength]) |
   1d698:	885b      	ldrh	r3, [r3, #2]
		*len = 2;
   1d69a:	6033      	str	r3, [r6, #0]
		return true;
   1d69c:	e6fc      	b.n	1d498 <usb_handle_standard_request+0x48>
   1d69e:	bf00      	nop
   1d6a0:	2000a768 	.word	0x2000a768
   1d6a4:	2000a822 	.word	0x2000a822
	if (usb_reqtype_is_to_host(setup)) {
   1d6a8:	f994 0000 	ldrsb.w	r0, [r4]
		switch (setup->bRequest) {
   1d6ac:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_host(setup)) {
   1d6ae:	2800      	cmp	r0, #0
   1d6b0:	f6bf af72 	bge.w	1d598 <usb_handle_standard_request+0x148>
		switch (setup->bRequest) {
   1d6b4:	2b00      	cmp	r3, #0
   1d6b6:	f43f af67 	beq.w	1d588 <usb_handle_standard_request+0x138>
   1d6ba:	2b0a      	cmp	r3, #10
   1d6bc:	f47f aefa 	bne.w	1d4b4 <usb_handle_standard_request+0x64>
	while (p[DESC_bLength] != 0U) {
   1d6c0:	783b      	ldrb	r3, [r7, #0]
   1d6c2:	2b00      	cmp	r3, #0
   1d6c4:	f43f aef6 	beq.w	1d4b4 <usb_handle_standard_request+0x64>
		if (p[DESC_bDescriptorType] == USB_DESC_INTERFACE) {
   1d6c8:	7879      	ldrb	r1, [r7, #1]
   1d6ca:	2904      	cmp	r1, #4
   1d6cc:	f47f af62 	bne.w	1d594 <usb_handle_standard_request+0x144>
			cur_iface = p[INTF_DESC_bInterfaceNumber];
   1d6d0:	78b9      	ldrb	r1, [r7, #2]
			if (cur_iface == setup->wIndex) {
   1d6d2:	428a      	cmp	r2, r1
   1d6d4:	f47f af5e 	bne.w	1d594 <usb_handle_standard_request+0x144>
	if (iface < ARRAY_SIZE(usb_dev.alt_setting)) {
   1d6d8:	2a07      	cmp	r2, #7
	return 0;
   1d6da:	bf8e      	itee	hi
   1d6dc:	2300      	movhi	r3, #0
		return usb_dev.alt_setting[iface];
   1d6de:	1952      	addls	r2, r2, r5
   1d6e0:	f892 30bb 	ldrbls.w	r3, [r2, #187]	; 0xbb
				data[0] = usb_get_alt_setting(cur_iface);
   1d6e4:	f88c 3000 	strb.w	r3, [ip]
   1d6e8:	e6f6      	b.n	1d4d8 <usb_handle_standard_request+0x88>
   1d6ea:	bf00      	nop

0001d6ec <usb_data_to_host>:
{
   1d6ec:	b513      	push	{r0, r1, r4, lr}
	if (usb_dev.zlp_flag == false) {
   1d6ee:	4c13      	ldr	r4, [pc, #76]	; (1d73c <usb_data_to_host+0x50>)
   1d6f0:	7d23      	ldrb	r3, [r4, #20]
   1d6f2:	b9cb      	cbnz	r3, 1d728 <usb_data_to_host+0x3c>
		uint32_t chunk = usb_dev.data_buf_residue;
   1d6f4:	68e2      	ldr	r2, [r4, #12]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
   1d6f6:	ab01      	add	r3, sp, #4
   1d6f8:	2080      	movs	r0, #128	; 0x80
   1d6fa:	68a1      	ldr	r1, [r4, #8]
		uint32_t chunk = usb_dev.data_buf_residue;
   1d6fc:	9201      	str	r2, [sp, #4]
		usb_write(USB_CONTROL_EP_IN, usb_dev.data_buf,
   1d6fe:	f007 fb30 	bl	24d62 <usb_write>
		usb_dev.data_buf += chunk;
   1d702:	9a01      	ldr	r2, [sp, #4]
   1d704:	68a3      	ldr	r3, [r4, #8]
   1d706:	4413      	add	r3, r2
   1d708:	60a3      	str	r3, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
   1d70a:	68e3      	ldr	r3, [r4, #12]
   1d70c:	1a9b      	subs	r3, r3, r2
   1d70e:	60e3      	str	r3, [r4, #12]
		if (!usb_dev.data_buf_residue && chunk &&
   1d710:	b943      	cbnz	r3, 1d724 <usb_data_to_host+0x38>
   1d712:	b13a      	cbz	r2, 1d724 <usb_data_to_host+0x38>
		    usb_dev.setup.wLength > usb_dev.data_buf_len) {
   1d714:	6923      	ldr	r3, [r4, #16]
   1d716:	88e2      	ldrh	r2, [r4, #6]
		if (!usb_dev.data_buf_residue && chunk &&
   1d718:	429a      	cmp	r2, r3
   1d71a:	dd03      	ble.n	1d724 <usb_data_to_host+0x38>
			if (!(usb_dev.data_buf_len % USB_MAX_CTRL_MPS)) {
   1d71c:	069b      	lsls	r3, r3, #26
   1d71e:	d101      	bne.n	1d724 <usb_data_to_host+0x38>
				usb_dev.zlp_flag = true;
   1d720:	2301      	movs	r3, #1
   1d722:	7523      	strb	r3, [r4, #20]
}
   1d724:	b002      	add	sp, #8
   1d726:	bd10      	pop	{r4, pc}
		usb_dev.zlp_flag = false;
   1d728:	2300      	movs	r3, #0
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
   1d72a:	2080      	movs	r0, #128	; 0x80
   1d72c:	461a      	mov	r2, r3
   1d72e:	4619      	mov	r1, r3
		usb_dev.zlp_flag = false;
   1d730:	7523      	strb	r3, [r4, #20]
}
   1d732:	b002      	add	sp, #8
   1d734:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usb_dc_ep_write(USB_CONTROL_EP_IN, NULL, 0, NULL);
   1d738:	f001 bed8 	b.w	1f4ec <usb_dc_ep_write>
   1d73c:	2000a768 	.word	0x2000a768

0001d740 <usb_handle_control_transfer>:
	uint32_t chunk = 0U;
   1d740:	2300      	movs	r3, #0
{
   1d742:	b530      	push	{r4, r5, lr}
   1d744:	b085      	sub	sp, #20
   1d746:	4602      	mov	r2, r0
   1d748:	460d      	mov	r5, r1
	uint32_t chunk = 0U;
   1d74a:	9301      	str	r3, [sp, #4]
	if (ep == USB_CONTROL_EP_OUT && ep_status == USB_DC_EP_SETUP) {
   1d74c:	2800      	cmp	r0, #0
   1d74e:	d158      	bne.n	1d802 <usb_handle_control_transfer+0xc2>
   1d750:	2900      	cmp	r1, #0
   1d752:	d135      	bne.n	1d7c0 <usb_handle_control_transfer+0x80>
		if (usb_dc_ep_read(ep, (uint8_t *)&setup_raw,
   1d754:	2208      	movs	r2, #8
   1d756:	460b      	mov	r3, r1
   1d758:	eb0d 0102 	add.w	r1, sp, r2
   1d75c:	f007 fc9b 	bl	25096 <usb_dc_ep_read>
   1d760:	2800      	cmp	r0, #0
   1d762:	da04      	bge.n	1d76e <usb_handle_control_transfer+0x2e>
			usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
   1d764:	2080      	movs	r0, #128	; 0x80
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
   1d766:	f001 fe33 	bl	1f3d0 <usb_dc_ep_set_stall>
}
   1d76a:	b005      	add	sp, #20
   1d76c:	bd30      	pop	{r4, r5, pc}
		setup->bmRequestType = setup_raw.bmRequestType;
   1d76e:	4c2a      	ldr	r4, [pc, #168]	; (1d818 <usb_handle_control_transfer+0xd8>)
   1d770:	9a02      	ldr	r2, [sp, #8]
		usb_dev.data_buf_residue = 0;
   1d772:	e9c4 5503 	strd	r5, r5, [r4, #12]
		setup->bmRequestType = setup_raw.bmRequestType;
   1d776:	6022      	str	r2, [r4, #0]
		setup->wIndex = sys_le16_to_cpu(setup_raw.wIndex);
   1d778:	9a03      	ldr	r2, [sp, #12]
		setup->wLength = sys_le16_to_cpu(setup_raw.wLength);
   1d77a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
		setup->wIndex = sys_le16_to_cpu(setup_raw.wIndex);
   1d77e:	6062      	str	r2, [r4, #4]
		usb_dev.data_buf = usb_dev.req_data;
   1d780:	f104 0238 	add.w	r2, r4, #56	; 0x38
   1d784:	60a2      	str	r2, [r4, #8]
		if (usb_reqtype_is_to_device(setup)) {
   1d786:	f99d 2008 	ldrsb.w	r2, [sp, #8]
		usb_dev.zlp_flag = false;
   1d78a:	7525      	strb	r5, [r4, #20]
		if (usb_reqtype_is_to_device(setup)) {
   1d78c:	2a00      	cmp	r2, #0
   1d78e:	db0a      	blt.n	1d7a6 <usb_handle_control_transfer+0x66>
			if (setup->wLength > CONFIG_USB_REQUEST_BUFFER_SIZE) {
   1d790:	2b80      	cmp	r3, #128	; 0x80
   1d792:	d904      	bls.n	1d79e <usb_handle_control_transfer+0x5e>
				usb_dc_ep_set_stall(USB_CONTROL_EP_IN);
   1d794:	2080      	movs	r0, #128	; 0x80
   1d796:	f001 fe1b 	bl	1f3d0 <usb_dc_ep_set_stall>
				usb_dc_ep_set_stall(USB_CONTROL_EP_OUT);
   1d79a:	2000      	movs	r0, #0
   1d79c:	e7e3      	b.n	1d766 <usb_handle_control_transfer+0x26>
			if (setup->wLength) {
   1d79e:	b113      	cbz	r3, 1d7a6 <usb_handle_control_transfer+0x66>
				usb_dev.data_buf_residue = setup->wLength;
   1d7a0:	e9c4 3303 	strd	r3, r3, [r4, #12]
				return;
   1d7a4:	e7e1      	b.n	1d76a <usb_handle_control_transfer+0x2a>
		if (!usb_handle_request(setup,
   1d7a6:	f7ff fd7d 	bl	1d2a4 <usb_handle_request.constprop.0>
   1d7aa:	2800      	cmp	r0, #0
   1d7ac:	d0da      	beq.n	1d764 <usb_handle_control_transfer+0x24>
		usb_dev.data_buf_residue = MIN(usb_dev.data_buf_len,
   1d7ae:	88e2      	ldrh	r2, [r4, #6]
   1d7b0:	6923      	ldr	r3, [r4, #16]
   1d7b2:	429a      	cmp	r2, r3
   1d7b4:	bfd4      	ite	le
   1d7b6:	60e2      	strle	r2, [r4, #12]
   1d7b8:	60e3      	strgt	r3, [r4, #12]
			usb_data_to_host();
   1d7ba:	f7ff ff97 	bl	1d6ec <usb_data_to_host>
   1d7be:	e7d4      	b.n	1d76a <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue <= 0) {
   1d7c0:	4c15      	ldr	r4, [pc, #84]	; (1d818 <usb_handle_control_transfer+0xd8>)
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   1d7c2:	ab01      	add	r3, sp, #4
   1d7c4:	e9d4 1502 	ldrd	r1, r5, [r4, #8]
		if (usb_dev.data_buf_residue <= 0) {
   1d7c8:	2d00      	cmp	r5, #0
   1d7ca:	dc04      	bgt.n	1d7d6 <usb_handle_control_transfer+0x96>
			if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   1d7cc:	f007 fc63 	bl	25096 <usb_dc_ep_read>
   1d7d0:	2800      	cmp	r0, #0
   1d7d2:	daca      	bge.n	1d76a <usb_handle_control_transfer+0x2a>
   1d7d4:	e7c6      	b.n	1d764 <usb_handle_control_transfer+0x24>
		if (usb_dc_ep_read(USB_CONTROL_EP_OUT,
   1d7d6:	462a      	mov	r2, r5
   1d7d8:	f007 fc5d 	bl	25096 <usb_dc_ep_read>
   1d7dc:	2800      	cmp	r0, #0
   1d7de:	dbd9      	blt.n	1d794 <usb_handle_control_transfer+0x54>
		usb_dev.data_buf += chunk;
   1d7e0:	9a01      	ldr	r2, [sp, #4]
   1d7e2:	68a3      	ldr	r3, [r4, #8]
   1d7e4:	4413      	add	r3, r2
   1d7e6:	60a3      	str	r3, [r4, #8]
		usb_dev.data_buf_residue -= chunk;
   1d7e8:	68e3      	ldr	r3, [r4, #12]
   1d7ea:	1a9b      	subs	r3, r3, r2
   1d7ec:	60e3      	str	r3, [r4, #12]
		if (usb_dev.data_buf_residue == 0) {
   1d7ee:	2b00      	cmp	r3, #0
   1d7f0:	d1bb      	bne.n	1d76a <usb_handle_control_transfer+0x2a>
			usb_dev.data_buf = usb_dev.req_data;
   1d7f2:	f104 0338 	add.w	r3, r4, #56	; 0x38
   1d7f6:	60a3      	str	r3, [r4, #8]
			if (!usb_handle_request(setup,
   1d7f8:	f7ff fd54 	bl	1d2a4 <usb_handle_request.constprop.0>
   1d7fc:	2800      	cmp	r0, #0
   1d7fe:	d1dc      	bne.n	1d7ba <usb_handle_control_transfer+0x7a>
   1d800:	e7b0      	b.n	1d764 <usb_handle_control_transfer+0x24>
	} else if (ep == USB_CONTROL_EP_IN) {
   1d802:	2880      	cmp	r0, #128	; 0x80
   1d804:	d1b1      	bne.n	1d76a <usb_handle_control_transfer+0x2a>
		if (usb_dev.data_buf_residue != 0 || usb_dev.zlp_flag == true) {
   1d806:	4b04      	ldr	r3, [pc, #16]	; (1d818 <usb_handle_control_transfer+0xd8>)
   1d808:	68da      	ldr	r2, [r3, #12]
   1d80a:	2a00      	cmp	r2, #0
   1d80c:	d1d5      	bne.n	1d7ba <usb_handle_control_transfer+0x7a>
   1d80e:	7d1b      	ldrb	r3, [r3, #20]
   1d810:	2b00      	cmp	r3, #0
   1d812:	d1d2      	bne.n	1d7ba <usb_handle_control_transfer+0x7a>
   1d814:	e7a9      	b.n	1d76a <usb_handle_control_transfer+0x2a>
   1d816:	bf00      	nop
   1d818:	2000a768 	.word	0x2000a768

0001d81c <usb_set_config>:
	usb_dev.descriptors = usb_descriptors;
   1d81c:	4b05      	ldr	r3, [pc, #20]	; (1d834 <usb_set_config+0x18>)
	usb_dev.req_handlers[type] = handler;
   1d81e:	4a06      	ldr	r2, [pc, #24]	; (1d838 <usb_set_config+0x1c>)
	usb_dev.descriptors = usb_descriptors;
   1d820:	6258      	str	r0, [r3, #36]	; 0x24
	usb_dev.req_handlers[type] = handler;
   1d822:	629a      	str	r2, [r3, #40]	; 0x28
   1d824:	4a05      	ldr	r2, [pc, #20]	; (1d83c <usb_set_config+0x20>)

	/* register class request handlers for each interface*/
	usb_register_custom_req_handler(custom_handler);

	return 0;
}
   1d826:	2000      	movs	r0, #0
	usb_dev.req_handlers[type] = handler;
   1d828:	62da      	str	r2, [r3, #44]	; 0x2c
   1d82a:	4a05      	ldr	r2, [pc, #20]	; (1d840 <usb_set_config+0x24>)
   1d82c:	631a      	str	r2, [r3, #48]	; 0x30
	usb_dev.custom_req_handler = handler;
   1d82e:	4a05      	ldr	r2, [pc, #20]	; (1d844 <usb_set_config+0x28>)
   1d830:	619a      	str	r2, [r3, #24]
}
   1d832:	4770      	bx	lr
   1d834:	2000a768 	.word	0x2000a768
   1d838:	0001d451 	.word	0x0001d451
   1d83c:	0001d155 	.word	0x0001d155
   1d840:	0001d1f5 	.word	0x0001d1f5
   1d844:	0001d195 	.word	0x0001d195

0001d848 <usb_enable>:

int usb_enable(usb_dc_status_callback status_cb)
{
   1d848:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1d84c:	4604      	mov	r4, r0
	 * This should only be called once.
	 */
	LOG_DBG("lock usb_enable_lock mutex");
	k_mutex_lock(&usb_enable_lock, K_FOREVER);

	if (usb_dev.enabled == true) {
   1d84e:	4d3b      	ldr	r5, [pc, #236]	; (1d93c <usb_enable+0xf4>)
		union { struct { uintptr_t lo, hi; } split; k_timeout_t val; } parm1 = { .val = timeout };
		return (int) arch_syscall_invoke3(parm0.x, parm1.split.lo, parm1.split.hi, K_SYSCALL_K_MUTEX_LOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_lock(mutex, timeout);
   1d850:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1d854:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1d858:	4839      	ldr	r0, [pc, #228]	; (1d940 <usb_enable+0xf8>)
   1d85a:	f005 fd7f 	bl	2335c <z_impl_k_mutex_lock>
   1d85e:	f895 60b8 	ldrb.w	r6, [r5, #184]	; 0xb8
   1d862:	2e00      	cmp	r6, #0
   1d864:	d167      	bne.n	1d936 <usb_enable+0xee>
	usb_dev.status_callback = cb;
   1d866:	4837      	ldr	r0, [pc, #220]	; (1d944 <usb_enable+0xfc>)
	ret = usb_vbus_set(true);
	if (ret < 0) {
		goto out;
	}

	usb_dev.user_status_callback = status_cb;
   1d868:	622c      	str	r4, [r5, #32]
	usb_dev.status_callback = cb;
   1d86a:	61e8      	str	r0, [r5, #28]
	usb_register_status_callback(forward_status_cb);
	usb_dc_set_status_callback(forward_status_cb);
   1d86c:	f001 ff58 	bl	1f720 <usb_dc_set_status_callback>

	ret = usb_dc_attach();
   1d870:	f001 fd46 	bl	1f300 <usb_dc_attach>
	if (ret < 0) {
   1d874:	1e04      	subs	r4, r0, #0
   1d876:	db42      	blt.n	1d8fe <usb_enable+0xb6>
		goto out;
	}

	ret = usb_transfer_init();
   1d878:	f000 fb18 	bl	1deac <usb_transfer_init>
	if (ret < 0) {
   1d87c:	1e04      	subs	r4, r0, #0
   1d87e:	db3e      	blt.n	1d8fe <usb_enable+0xb6>
		goto out;
	}

	/* Configure control EP */
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
   1d880:	2340      	movs	r3, #64	; 0x40
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;

	ep0_cfg.ep_addr = USB_CONTROL_EP_OUT;
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d882:	4668      	mov	r0, sp
	ep0_cfg.ep_mps = USB_MAX_CTRL_MPS;
   1d884:	f8ad 3002 	strh.w	r3, [sp, #2]
	ep0_cfg.ep_type = USB_DC_EP_CONTROL;
   1d888:	f88d 6004 	strb.w	r6, [sp, #4]
	ep0_cfg.ep_addr = USB_CONTROL_EP_OUT;
   1d88c:	f88d 6000 	strb.w	r6, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d890:	f001 fd7a 	bl	1f388 <usb_dc_ep_configure>
	if (ret < 0) {
   1d894:	1e04      	subs	r4, r0, #0
   1d896:	db32      	blt.n	1d8fe <usb_enable+0xb6>
		goto out;
	}

	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
   1d898:	2780      	movs	r7, #128	; 0x80
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d89a:	4668      	mov	r0, sp
	ep0_cfg.ep_addr = USB_CONTROL_EP_IN;
   1d89c:	f88d 7000 	strb.w	r7, [sp]
	ret = usb_dc_ep_configure(&ep0_cfg);
   1d8a0:	f001 fd72 	bl	1f388 <usb_dc_ep_configure>
	if (ret < 0) {
   1d8a4:	1e04      	subs	r4, r0, #0
   1d8a6:	db2a      	blt.n	1d8fe <usb_enable+0xb6>
		goto out;
	}

	/* Register endpoint 0 handlers*/
	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_OUT,
   1d8a8:	4630      	mov	r0, r6
   1d8aa:	4927      	ldr	r1, [pc, #156]	; (1d948 <usb_enable+0x100>)
   1d8ac:	f001 ff24 	bl	1f6f8 <usb_dc_ep_set_callback>
				     usb_handle_control_transfer);
	if (ret < 0) {
   1d8b0:	1e04      	subs	r4, r0, #0
   1d8b2:	db24      	blt.n	1d8fe <usb_enable+0xb6>
		goto out;
	}

	ret = usb_dc_ep_set_callback(USB_CONTROL_EP_IN,
   1d8b4:	4638      	mov	r0, r7
   1d8b6:	4924      	ldr	r1, [pc, #144]	; (1d948 <usb_enable+0x100>)
   1d8b8:	f001 ff1e 	bl	1f6f8 <usb_dc_ep_set_callback>
				     usb_handle_control_transfer);
	if (ret < 0) {
   1d8bc:	1e04      	subs	r4, r0, #0
   1d8be:	db1e      	blt.n	1d8fe <usb_enable+0xb6>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d8c0:	4c22      	ldr	r4, [pc, #136]	; (1d94c <usb_enable+0x104>)
   1d8c2:	f8df 808c 	ldr.w	r8, [pc, #140]	; 1d950 <usb_enable+0x108>
   1d8c6:	4544      	cmp	r4, r8
   1d8c8:	d320      	bcc.n	1d90c <usb_enable+0xc4>
	if (ret < 0) {
		goto out;
	}

	/* Enable control EP */
	ret = usb_dc_ep_enable(USB_CONTROL_EP_OUT);
   1d8ca:	2000      	movs	r0, #0
   1d8cc:	f001 fde4 	bl	1f498 <usb_dc_ep_enable>
	if (ret < 0) {
   1d8d0:	1e04      	subs	r4, r0, #0
   1d8d2:	db14      	blt.n	1d8fe <usb_enable+0xb6>
		goto out;
	}
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_OUT);
   1d8d4:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4

	ret = usb_dc_ep_enable(USB_CONTROL_EP_IN);
   1d8d8:	2080      	movs	r0, #128	; 0x80
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_OUT);
   1d8da:	f043 0301 	orr.w	r3, r3, #1
   1d8de:	f8c5 30c4 	str.w	r3, [r5, #196]	; 0xc4
	ret = usb_dc_ep_enable(USB_CONTROL_EP_IN);
   1d8e2:	f001 fdd9 	bl	1f498 <usb_dc_ep_enable>
	if (ret < 0) {
   1d8e6:	1e04      	subs	r4, r0, #0
   1d8e8:	db09      	blt.n	1d8fe <usb_enable+0xb6>
		goto out;
	}
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_IN);
   1d8ea:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4

	usb_dev.enabled = true;
	ret = 0;
   1d8ee:	2400      	movs	r4, #0
	usb_dev.ep_bm |= get_ep_bm_from_addr(USB_CONTROL_EP_IN);
   1d8f0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1d8f4:	f8c5 30c4 	str.w	r3, [r5, #196]	; 0xc4
	usb_dev.enabled = true;
   1d8f8:	2301      	movs	r3, #1
   1d8fa:	f885 30b8 	strb.w	r3, [r5, #184]	; 0xb8
		union { uintptr_t x; struct k_mutex * val; } parm0 = { .val = mutex };
		return (int) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_MUTEX_UNLOCK);
	}
#endif
	compiler_barrier();
	return z_impl_k_mutex_unlock(mutex);
   1d8fe:	4810      	ldr	r0, [pc, #64]	; (1d940 <usb_enable+0xf8>)
   1d900:	f005 fda6 	bl	23450 <z_impl_k_mutex_unlock>
out:
	LOG_DBG("unlock usb_enable_lock mutex");
	k_mutex_unlock(&usb_enable_lock);
	return ret;
}
   1d904:	4620      	mov	r0, r4
   1d906:	b002      	add	sp, #8
   1d908:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d90c:	2600      	movs	r6, #0
		ep_data = cfg_data->endpoint;
   1d90e:	6a27      	ldr	r7, [r4, #32]
		for (uint8_t n = 0; n < cfg_data->num_endpoints; n++) {
   1d910:	7f22      	ldrb	r2, [r4, #28]
   1d912:	b2f3      	uxtb	r3, r6
   1d914:	429a      	cmp	r2, r3
   1d916:	d801      	bhi.n	1d91c <usb_enable+0xd4>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1d918:	3424      	adds	r4, #36	; 0x24
   1d91a:	e7d4      	b.n	1d8c6 <usb_enable+0x7e>
			if (usb_dc_ep_set_callback(ep_data[n].ep_addr,
   1d91c:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
   1d920:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
   1d924:	7910      	ldrb	r0, [r2, #4]
   1d926:	f001 fee7 	bl	1f6f8 <usb_dc_ep_set_callback>
   1d92a:	3601      	adds	r6, #1
   1d92c:	2800      	cmp	r0, #0
   1d92e:	d0ef      	beq.n	1d910 <usb_enable+0xc8>
   1d930:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1d934:	e7e3      	b.n	1d8fe <usb_enable+0xb6>
		ret = -EALREADY;
   1d936:	f06f 0477 	mvn.w	r4, #119	; 0x77
   1d93a:	e7e0      	b.n	1d8fe <usb_enable+0xb6>
   1d93c:	2000a768 	.word	0x2000a768
   1d940:	2000a308 	.word	0x2000a308
   1d944:	0001d2d1 	.word	0x0001d2d1
   1d948:	0001d741 	.word	0x0001d741
   1d94c:	2000a3ec 	.word	0x2000a3ec
   1d950:	2000a410 	.word	0x2000a410

0001d954 <usb_device_init>:
/*
 * This function configures the USB device stack based on USB descriptor and
 * usb_cfg_data.
 */
static int usb_device_init(void)
{
   1d954:	b510      	push	{r4, lr}
	uint8_t *device_descriptor;

	if (usb_dev.enabled == true) {
   1d956:	4b0a      	ldr	r3, [pc, #40]	; (1d980 <usb_device_init+0x2c>)
   1d958:	f893 40b8 	ldrb.w	r4, [r3, #184]	; 0xb8
   1d95c:	b94c      	cbnz	r4, 1d972 <usb_device_init+0x1e>
		return -EALREADY;
	}

	/* register device descriptor */
	device_descriptor = usb_get_device_descriptor();
   1d95e:	f000 f855 	bl	1da0c <usb_get_device_descriptor>
	if (!device_descriptor) {
   1d962:	b148      	cbz	r0, 1d978 <usb_device_init+0x24>
		LOG_ERR("Failed to configure USB device stack");
		return -1;
	}

	usb_set_config(device_descriptor);
   1d964:	f7ff ff5a 	bl	1d81c <usb_set_config>

	if (IS_ENABLED(CONFIG_USB_DEVICE_INITIALIZE_AT_BOOT)) {
		return usb_enable(NULL);
   1d968:	4620      	mov	r0, r4
	}

	return 0;
}
   1d96a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return usb_enable(NULL);
   1d96e:	f7ff bf6b 	b.w	1d848 <usb_enable>
		return -EALREADY;
   1d972:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
   1d976:	bd10      	pop	{r4, pc}
		return -1;
   1d978:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1d97c:	e7fb      	b.n	1d976 <usb_device_init+0x22>
   1d97e:	bf00      	nop
   1d980:	2000a768 	.word	0x2000a768

0001d984 <usb_update_sn_string_descriptor>:
 * case the device ID returned by the HWINFO driver is bigger, the lower
 * part is used for the USB Serial Number, as that part is usually having
 * more entropy.
 */
__weak uint8_t *usb_update_sn_string_descriptor(void)
{
   1d984:	b530      	push	{r4, r5, lr}
	 * unless the user requested a longer serial number.
	 */
	const int usblen = sizeof(CONFIG_USB_DEVICE_SN) / 2;
	uint8_t hwid[MAX(16, sizeof(CONFIG_USB_DEVICE_SN) / 2)];
	static uint8_t sn[sizeof(CONFIG_USB_DEVICE_SN) + 1];
	const char hex[] = "0123456789ABCDEF";
   1d986:	4b1f      	ldr	r3, [pc, #124]	; (1da04 <usb_update_sn_string_descriptor+0x80>)
{
   1d988:	b08b      	sub	sp, #44	; 0x2c
	const char hex[] = "0123456789ABCDEF";
   1d98a:	aa05      	add	r2, sp, #20
   1d98c:	f103 0510 	add.w	r5, r3, #16
   1d990:	4614      	mov	r4, r2
   1d992:	6818      	ldr	r0, [r3, #0]
   1d994:	6859      	ldr	r1, [r3, #4]
   1d996:	3308      	adds	r3, #8
   1d998:	c403      	stmia	r4!, {r0, r1}
   1d99a:	42ab      	cmp	r3, r5
   1d99c:	4622      	mov	r2, r4
   1d99e:	d1f7      	bne.n	1d990 <usb_update_sn_string_descriptor+0xc>
   1d9a0:	781b      	ldrb	r3, [r3, #0]
	int hwlen, skip;

	memset(hwid, 0, sizeof(hwid));
   1d9a2:	2210      	movs	r2, #16
	const char hex[] = "0123456789ABCDEF";
   1d9a4:	7023      	strb	r3, [r4, #0]
	memset(hwid, 0, sizeof(hwid));
   1d9a6:	2100      	movs	r1, #0
   1d9a8:	a801      	add	r0, sp, #4
   1d9aa:	f007 fb1d 	bl	24fe8 <memset>
	memset(sn, 0, sizeof(sn));
   1d9ae:	2212      	movs	r2, #18
   1d9b0:	2100      	movs	r1, #0
   1d9b2:	4815      	ldr	r0, [pc, #84]	; (1da08 <usb_update_sn_string_descriptor+0x84>)
   1d9b4:	f007 fb18 	bl	24fe8 <memset>
		union { uintptr_t x; size_t val; } parm1 = { .val = length };
		return (ssize_t) arch_syscall_invoke2(parm0.x, parm1.x, K_SYSCALL_HWINFO_GET_DEVICE_ID);
	}
#endif
	compiler_barrier();
	return z_impl_hwinfo_get_device_id(buffer, length);
   1d9b8:	2110      	movs	r1, #16
   1d9ba:	a801      	add	r0, sp, #4
   1d9bc:	f002 f9b8 	bl	1fd30 <z_impl_hwinfo_get_device_id>

	hwlen = hwinfo_get_device_id(hwid, sizeof(hwid));
	if (hwlen > 0) {
   1d9c0:	2800      	cmp	r0, #0
   1d9c2:	dd1b      	ble.n	1d9fc <usb_update_sn_string_descriptor+0x78>
		skip = MAX(0, hwlen - usblen);
   1d9c4:	2808      	cmp	r0, #8
   1d9c6:	bfb8      	it	lt
   1d9c8:	2008      	movlt	r0, #8
   1d9ca:	ab01      	add	r3, sp, #4
   1d9cc:	3809      	subs	r0, #9
   1d9ce:	181a      	adds	r2, r3, r0
		LOG_HEXDUMP_DBG(&hwid[skip], usblen, "Serial Number");
		for (int i = 0; i < usblen; i++) {
   1d9d0:	2000      	movs	r0, #0
   1d9d2:	490d      	ldr	r1, [pc, #52]	; (1da08 <usb_update_sn_string_descriptor+0x84>)
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   1d9d4:	f812 3f01 	ldrb.w	r3, [r2, #1]!
   1d9d8:	ac0a      	add	r4, sp, #40	; 0x28
   1d9da:	eb04 1413 	add.w	r4, r4, r3, lsr #4
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   1d9de:	f003 030f 	and.w	r3, r3, #15
   1d9e2:	3328      	adds	r3, #40	; 0x28
   1d9e4:	446b      	add	r3, sp
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   1d9e6:	f814 4c14 	ldrb.w	r4, [r4, #-20]
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   1d9ea:	f813 3c14 	ldrb.w	r3, [r3, #-20]
		for (int i = 0; i < usblen; i++) {
   1d9ee:	3001      	adds	r0, #1
   1d9f0:	2808      	cmp	r0, #8
			sn[i * 2] = hex[hwid[i + skip] >> 4];
   1d9f2:	700c      	strb	r4, [r1, #0]
			sn[i * 2 + 1] = hex[hwid[i + skip] & 0xF];
   1d9f4:	704b      	strb	r3, [r1, #1]
		for (int i = 0; i < usblen; i++) {
   1d9f6:	f101 0102 	add.w	r1, r1, #2
   1d9fa:	d1eb      	bne.n	1d9d4 <usb_update_sn_string_descriptor+0x50>
		}
	}

	return sn;
}
   1d9fc:	4802      	ldr	r0, [pc, #8]	; (1da08 <usb_update_sn_string_descriptor+0x84>)
   1d9fe:	b00b      	add	sp, #44	; 0x2c
   1da00:	bd30      	pop	{r4, r5, pc}
   1da02:	bf00      	nop
   1da04:	000269d5 	.word	0x000269d5
   1da08:	2000b5f2 	.word	0x2000b5f2

0001da0c <usb_get_device_descriptor>:
	return 0;
}


uint8_t *usb_get_device_descriptor(void)
{
   1da0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1da10:	4c63      	ldr	r4, [pc, #396]	; (1dba0 <usb_get_device_descriptor+0x194>)
   1da12:	b085      	sub	sp, #20
	uint8_t str_descr_idx = 0U;
   1da14:	2600      	movs	r6, #0
	uint32_t requested_ep = BIT(16) | BIT(0);
   1da16:	f04f 1b01 	mov.w	fp, #65537	; 0x10001
	uint8_t numof_ifaces = 0U;
   1da1a:	46b1      	mov	r9, r6
	struct usb_cfg_data *cfg_data = NULL;
   1da1c:	4635      	mov	r5, r6
	struct usb_cfg_descriptor *cfg_descr = NULL;
   1da1e:	46b2      	mov	sl, r6
	while (head->bLength != 0U) {
   1da20:	7823      	ldrb	r3, [r4, #0]
   1da22:	b92b      	cbnz	r3, 1da30 <usb_get_device_descriptor+0x24>
	if ((head + 1) != __usb_descriptor_end) {
   1da24:	4b5f      	ldr	r3, [pc, #380]	; (1dba4 <usb_get_device_descriptor+0x198>)
   1da26:	3402      	adds	r4, #2
   1da28:	429c      	cmp	r4, r3
   1da2a:	d1f3      	bne.n	1da14 <usb_get_device_descriptor+0x8>
	if (usb_fix_descriptor(__usb_descriptor_start)) {
		LOG_ERR("Failed to fixup USB descriptor");
		return NULL;
	}

	return (uint8_t *) __usb_descriptor_start;
   1da2c:	485c      	ldr	r0, [pc, #368]	; (1dba0 <usb_get_device_descriptor+0x194>)
   1da2e:	e01c      	b.n	1da6a <usb_get_device_descriptor+0x5e>
		switch (head->bDescriptorType) {
   1da30:	7863      	ldrb	r3, [r4, #1]
   1da32:	2b05      	cmp	r3, #5
   1da34:	d805      	bhi.n	1da42 <usb_get_device_descriptor+0x36>
   1da36:	e8df f003 	tbb	[pc, r3]
   1da3a:	0479      	.short	0x0479
   1da3c:	25077903 	.word	0x25077903
   1da40:	46a2      	mov	sl, r4
		head = (struct usb_desc_header *)((uint8_t *)head + head->bLength);
   1da42:	7823      	ldrb	r3, [r4, #0]
   1da44:	441c      	add	r4, r3
   1da46:	e7eb      	b.n	1da20 <usb_get_device_descriptor+0x14>
			if (if_descr->bAlternateSetting) {
   1da48:	78e3      	ldrb	r3, [r4, #3]
   1da4a:	2b00      	cmp	r3, #0
   1da4c:	d1f9      	bne.n	1da42 <usb_get_device_descriptor+0x36>
			if (if_descr->bInterfaceNumber == 0U) {
   1da4e:	78a3      	ldrb	r3, [r4, #2]
   1da50:	b173      	cbz	r3, 1da70 <usb_get_device_descriptor+0x64>
			numof_ifaces++;
   1da52:	f109 0901 	add.w	r9, r9, #1
   1da56:	fa5f f989 	uxtb.w	r9, r9
			break;
   1da5a:	e7f2      	b.n	1da42 <usb_get_device_descriptor+0x36>
		if (cfg_data->interface_descriptor == iface) {
   1da5c:	686a      	ldr	r2, [r5, #4]
   1da5e:	4294      	cmp	r4, r2
   1da60:	d009      	beq.n	1da76 <usb_get_device_descriptor+0x6a>
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1da62:	3524      	adds	r5, #36	; 0x24
   1da64:	429d      	cmp	r5, r3
   1da66:	d3f9      	bcc.n	1da5c <usb_get_device_descriptor+0x50>
		return NULL;
   1da68:	2000      	movs	r0, #0
}
   1da6a:	b005      	add	sp, #20
   1da6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	STRUCT_SECTION_FOREACH(usb_cfg_data, cfg_data) {
   1da70:	4d4d      	ldr	r5, [pc, #308]	; (1dba8 <usb_get_device_descriptor+0x19c>)
   1da72:	4b4e      	ldr	r3, [pc, #312]	; (1dbac <usb_get_device_descriptor+0x1a0>)
   1da74:	e7f6      	b.n	1da64 <usb_get_device_descriptor+0x58>
				if (cfg_data->interface_config) {
   1da76:	68ab      	ldr	r3, [r5, #8]
   1da78:	2b00      	cmp	r3, #0
   1da7a:	d0ea      	beq.n	1da52 <usb_get_device_descriptor+0x46>
					cfg_data->interface_config(head,
   1da7c:	4649      	mov	r1, r9
   1da7e:	4620      	mov	r0, r4
   1da80:	4798      	blx	r3
   1da82:	e7e6      	b.n	1da52 <usb_get_device_descriptor+0x46>
			if (!cfg_data) {
   1da84:	2d00      	cmp	r5, #0
   1da86:	d0ef      	beq.n	1da68 <usb_get_device_descriptor+0x5c>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
   1da88:	2300      	movs	r3, #0
   1da8a:	2101      	movs	r1, #1
   1da8c:	7f2a      	ldrb	r2, [r5, #28]
   1da8e:	4293      	cmp	r3, r2
   1da90:	d2ea      	bcs.n	1da68 <usb_get_device_descriptor+0x5c>
		if (ep_descr->bEndpointAddress != ep_data[i].ep_addr) {
   1da92:	6a2a      	ldr	r2, [r5, #32]
   1da94:	78a7      	ldrb	r7, [r4, #2]
   1da96:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   1da9a:	7910      	ldrb	r0, [r2, #4]
   1da9c:	4287      	cmp	r7, r0
   1da9e:	d001      	beq.n	1daa4 <usb_get_device_descriptor+0x98>
	for (unsigned int i = 0; i < cfg_data->num_endpoints; i++) {
   1daa0:	3301      	adds	r3, #1
   1daa2:	e7f3      	b.n	1da8c <usb_get_device_descriptor+0x80>
   1daa4:	2701      	movs	r7, #1
			ep_cfg.ep_type = (ep_descr->bmAttributes &
   1daa6:	78e0      	ldrb	r0, [r4, #3]
   1daa8:	fa5f f887 	uxtb.w	r8, r7
   1daac:	f000 0003 	and.w	r0, r0, #3
   1dab0:	f88d 000c 	strb.w	r0, [sp, #12]
			ep_cfg.ep_mps = ep_descr->wMaxPacketSize;
   1dab4:	7920      	ldrb	r0, [r4, #4]
   1dab6:	f894 c005 	ldrb.w	ip, [r4, #5]
   1daba:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
   1dabe:	f8ad 000a 	strh.w	r0, [sp, #10]
			if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   1dac2:	f994 0002 	ldrsb.w	r0, [r4, #2]
   1dac6:	2800      	cmp	r0, #0
   1dac8:	da25      	bge.n	1db16 <usb_get_device_descriptor+0x10a>
				if ((*requested_ep & (1U << (idx + 16U)))) {
   1daca:	f107 0010 	add.w	r0, r7, #16
   1dace:	fa01 f000 	lsl.w	r0, r1, r0
   1dad2:	ea10 0f0b 	tst.w	r0, fp
   1dad6:	d125      	bne.n	1db24 <usb_get_device_descriptor+0x118>
				ep_cfg.ep_addr = (USB_EP_DIR_IN | idx);
   1dad8:	f048 0080 	orr.w	r0, r8, #128	; 0x80
   1dadc:	f88d 0008 	strb.w	r0, [sp, #8]
			if (!usb_dc_ep_check_cap(&ep_cfg)) {
   1dae0:	a802      	add	r0, sp, #8
   1dae2:	e9cd 3200 	strd	r3, r2, [sp]
   1dae6:	f007 faa5 	bl	25034 <usb_dc_ep_check_cap>
   1daea:	e9dd 3200 	ldrd	r3, r2, [sp]
   1daee:	2101      	movs	r1, #1
   1daf0:	b9c0      	cbnz	r0, 1db24 <usb_get_device_descriptor+0x118>
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
   1daf2:	f89d 3008 	ldrb.w	r3, [sp, #8]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   1daf6:	f013 0f80 	tst.w	r3, #128	; 0x80
				ep_descr->bEndpointAddress = ep_cfg.ep_addr;
   1dafa:	70a3      	strb	r3, [r4, #2]
				ep_data[i].ep_addr = ep_cfg.ep_addr;
   1dafc:	7113      	strb	r3, [r2, #4]
				if (ep_cfg.ep_addr & USB_EP_DIR_IN) {
   1dafe:	460b      	mov	r3, r1
					*requested_ep |= (1U << (idx + 16U));
   1db00:	bf1d      	ittte	ne
   1db02:	f108 0810 	addne.w	r8, r8, #16
   1db06:	fa5f f888 	uxtbne.w	r8, r8
   1db0a:	fa01 f308 	lslne.w	r3, r1, r8
					*requested_ep |= (1U << idx);
   1db0e:	40bb      	lsleq	r3, r7
   1db10:	ea4b 0b03 	orr.w	fp, fp, r3
				return 0;
   1db14:	e795      	b.n	1da42 <usb_get_device_descriptor+0x36>
				if ((*requested_ep & (1U << (idx)))) {
   1db16:	fa01 f007 	lsl.w	r0, r1, r7
   1db1a:	ea10 0f0b 	tst.w	r0, fp
   1db1e:	d101      	bne.n	1db24 <usb_get_device_descriptor+0x118>
   1db20:	4640      	mov	r0, r8
   1db22:	e7db      	b.n	1dadc <usb_get_device_descriptor+0xd0>
		for (uint8_t idx = 1; idx < 16U; idx++) {
   1db24:	3701      	adds	r7, #1
   1db26:	2f10      	cmp	r7, #16
   1db28:	d1bd      	bne.n	1daa6 <usb_get_device_descriptor+0x9a>
   1db2a:	e7b9      	b.n	1daa0 <usb_get_device_descriptor+0x94>
			if (str_descr_idx == USB_DESC_SERIAL_NUMBER_IDX) {
   1db2c:	2e03      	cmp	r6, #3
   1db2e:	d11d      	bne.n	1db6c <usb_get_device_descriptor+0x160>
	uint8_t *runtime_sn =  usb_update_sn_string_descriptor();
   1db30:	f7ff ff28 	bl	1d984 <usb_update_sn_string_descriptor>
	if (!runtime_sn) {
   1db34:	4607      	mov	r7, r0
   1db36:	b168      	cbz	r0, 1db54 <usb_get_device_descriptor+0x148>
	runtime_sn_len = strlen(runtime_sn);
   1db38:	f007 fa3b 	bl	24fb2 <strlen>
	if (!runtime_sn_len) {
   1db3c:	4680      	mov	r8, r0
   1db3e:	b148      	cbz	r0, 1db54 <usb_get_device_descriptor+0x148>
	default_sn_len = strlen(CONFIG_USB_DEVICE_SN);
   1db40:	481b      	ldr	r0, [pc, #108]	; (1dbb0 <usb_get_device_descriptor+0x1a4>)
   1db42:	f007 fa36 	bl	24fb2 <strlen>
	if (runtime_sn_len != default_sn_len) {
   1db46:	4580      	cmp	r8, r0
   1db48:	d104      	bne.n	1db54 <usb_get_device_descriptor+0x148>
	memcpy(sn->bString, runtime_sn, runtime_sn_len);
   1db4a:	4642      	mov	r2, r8
   1db4c:	4639      	mov	r1, r7
   1db4e:	1ca0      	adds	r0, r4, #2
   1db50:	f007 fa3f 	bl	24fd2 <memcpy>
	for (int i = idx_max; i >= 0; i -= 2) {
   1db54:	f06f 0102 	mvn.w	r1, #2
	int idx_max = USB_BSTRING_UTF16LE_IDX_MAX(str_descr->bLength);
   1db58:	7823      	ldrb	r3, [r4, #0]
	for (int i = idx_max; i >= 0; i -= 2) {
   1db5a:	1b09      	subs	r1, r1, r4
   1db5c:	18e2      	adds	r2, r4, r3
   1db5e:	eb04 0353 	add.w	r3, r4, r3, lsr #1
   1db62:	42d1      	cmn	r1, r2
   1db64:	d513      	bpl.n	1db8e <usb_get_device_descriptor+0x182>
			str_descr_idx += 1U;
   1db66:	3601      	adds	r6, #1
   1db68:	b2f6      	uxtb	r6, r6
			break;
   1db6a:	e76a      	b.n	1da42 <usb_get_device_descriptor+0x36>
			if (str_descr_idx) {
   1db6c:	2e00      	cmp	r6, #0
   1db6e:	d1f1      	bne.n	1db54 <usb_get_device_descriptor+0x148>
				if (!cfg_descr) {
   1db70:	f1ba 0f00 	cmp.w	sl, #0
   1db74:	f43f af78 	beq.w	1da68 <usb_get_device_descriptor+0x5c>
				sys_put_le16((uint8_t *)head - (uint8_t *)cfg_descr,
   1db78:	eba4 030a 	sub.w	r3, r4, sl
 *  @param val 16-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(uint16_t val, uint8_t dst[2])
{
	dst[0] = val;
   1db7c:	f88a 3002 	strb.w	r3, [sl, #2]
	dst[1] = val >> 8;
   1db80:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1db84:	f88a 3003 	strb.w	r3, [sl, #3]
				cfg_descr->bNumInterfaces = numof_ifaces;
   1db88:	f88a 9004 	strb.w	r9, [sl, #4]
   1db8c:	e7eb      	b.n	1db66 <usb_get_device_descriptor+0x15a>
		buf[i] = 0U;
   1db8e:	f04f 0000 	mov.w	r0, #0
   1db92:	f802 0c01 	strb.w	r0, [r2, #-1]
		buf[i - 1] = buf[ascii_idx_max--];
   1db96:	f813 0901 	ldrb.w	r0, [r3], #-1
   1db9a:	f802 0d02 	strb.w	r0, [r2, #-2]!
	for (int i = idx_max; i >= 0; i -= 2) {
   1db9e:	e7e0      	b.n	1db62 <usb_get_device_descriptor+0x156>
   1dba0:	2000a32c 	.word	0x2000a32c
   1dba4:	2000a3eb 	.word	0x2000a3eb
   1dba8:	2000a3ec 	.word	0x2000a3ec
   1dbac:	2000a410 	.word	0x2000a410
   1dbb0:	000269d5 	.word	0x000269d5

0001dbb4 <usb_ep_get_transfer>:
static struct usb_transfer_data ut_data[CONFIG_USB_MAX_NUM_TRANSFERS];

/* Transfer management */
static struct usb_transfer_data *usb_ep_get_transfer(uint8_t ep)
{
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dbb4:	4b09      	ldr	r3, [pc, #36]	; (1dbdc <usb_ep_get_transfer+0x28>)
   1dbb6:	2100      	movs	r1, #0
   1dbb8:	461a      	mov	r2, r3
{
   1dbba:	b510      	push	{r4, lr}
		if (ut_data[i].ep == ep && ut_data[i].status != 0) {
   1dbbc:	781c      	ldrb	r4, [r3, #0]
   1dbbe:	4284      	cmp	r4, r0
   1dbc0:	d104      	bne.n	1dbcc <usb_ep_get_transfer+0x18>
   1dbc2:	685c      	ldr	r4, [r3, #4]
   1dbc4:	b114      	cbz	r4, 1dbcc <usb_ep_get_transfer+0x18>
			return &ut_data[i];
   1dbc6:	eb02 1081 	add.w	r0, r2, r1, lsl #6
		}
	}

	return NULL;
}
   1dbca:	bd10      	pop	{r4, pc}
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dbcc:	3101      	adds	r1, #1
   1dbce:	2904      	cmp	r1, #4
   1dbd0:	f103 0340 	add.w	r3, r3, #64	; 0x40
   1dbd4:	d1f2      	bne.n	1dbbc <usb_ep_get_transfer+0x8>
	return NULL;
   1dbd6:	2000      	movs	r0, #0
   1dbd8:	e7f7      	b.n	1dbca <usb_ep_get_transfer+0x16>
   1dbda:	bf00      	nop
   1dbdc:	2000a830 	.word	0x2000a830

0001dbe0 <usb_transfer_work>:

	return false;
}

static void usb_transfer_work(struct k_work *item)
{
   1dbe0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	uint8_t ep;

	trans = CONTAINER_OF(item, struct usb_transfer_data, work);
	ep = trans->ep;

	if (trans->status != -EBUSY) {
   1dbe4:	f850 3c28 	ldr.w	r3, [r0, #-40]
{
   1dbe8:	4604      	mov	r4, r0
	if (trans->status != -EBUSY) {
   1dbea:	3310      	adds	r3, #16
	ep = trans->ep;
   1dbec:	f810 6c2c 	ldrb.w	r6, [r0, #-44]
	if (trans->status != -EBUSY) {
   1dbf0:	d110      	bne.n	1dc14 <usb_transfer_work+0x34>
		/* transfer cancelled or already completed */
		LOG_DBG("Transfer cancelled or completed, ep 0x%02x", ep);
		goto done;
	}

	if (trans->flags & USB_TRANS_WRITE) {
   1dbf2:	6903      	ldr	r3, [r0, #16]
		if (!trans->bsize) {
   1dbf4:	f850 2c20 	ldr.w	r2, [r0, #-32]
	if (trans->flags & USB_TRANS_WRITE) {
   1dbf8:	0799      	lsls	r1, r3, #30
   1dbfa:	d53c      	bpl.n	1dc76 <usb_transfer_work+0x96>
		if (!trans->bsize) {
   1dbfc:	bb02      	cbnz	r2, 1dc40 <usb_transfer_work+0x60>
			if (!(trans->flags & USB_TRANS_NO_ZLP)) {
   1dbfe:	f013 0304 	ands.w	r3, r3, #4
   1dc02:	d104      	bne.n	1dc0e <usb_transfer_work+0x2e>
				LOG_DBG("Transfer ZLP");
				usb_write(ep, NULL, 0, NULL);
   1dc04:	461a      	mov	r2, r3
   1dc06:	4619      	mov	r1, r3
   1dc08:	4630      	mov	r0, r6
   1dc0a:	f007 f8aa 	bl	24d62 <usb_write>
			}
			trans->status = 0;
   1dc0e:	2300      	movs	r3, #0

		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
		if (ret) {
			LOG_ERR("Transfer error %d, ep 0x%02x", ret, ep);
			/* transfer error */
			trans->status = -EINVAL;
   1dc10:	f844 3c28 	str.w	r3, [r4, #-40]
		/* we expect mote data, clear NAK */
		usb_dc_ep_read_continue(ep);
	}

done:
	if (trans->status != -EBUSY && trans->cb) { /* Transfer complete */
   1dc14:	f854 3c28 	ldr.w	r3, [r4, #-40]
   1dc18:	3310      	adds	r3, #16
   1dc1a:	d00e      	beq.n	1dc3a <usb_transfer_work+0x5a>
   1dc1c:	f854 5c18 	ldr.w	r5, [r4, #-24]
   1dc20:	b15d      	cbz	r5, 1dc3a <usb_transfer_work+0x5a>
		usb_transfer_callback cb = trans->cb;
		int tsize = trans->tsize;
   1dc22:	f854 7c1c 	ldr.w	r7, [r4, #-28]
		void *priv = trans->priv;
   1dc26:	f854 8c14 	ldr.w	r8, [r4, #-20]

		if (k_is_in_isr()) {
   1dc2a:	f007 ffb4 	bl	25b96 <k_is_in_isr>
   1dc2e:	2800      	cmp	r0, #0
   1dc30:	d04c      	beq.n	1dccc <usb_transfer_work+0xec>
			/* reschedule completion in thread context */
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dc32:	4621      	mov	r1, r4
   1dc34:	482b      	ldr	r0, [pc, #172]	; (1dce4 <usb_transfer_work+0x104>)
   1dc36:	f008 f8a2 	bl	25d7e <k_work_submit_to_queue>
		k_sem_give(&trans->sem);

		/* Transfer completion callback */
		cb(ep, tsize, priv);
	}
}
   1dc3a:	b002      	add	sp, #8
   1dc3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = usb_write(ep, trans->buffer, trans->bsize, &bytes);
   1dc40:	f850 1c24 	ldr.w	r1, [r0, #-36]
   1dc44:	ab01      	add	r3, sp, #4
   1dc46:	4630      	mov	r0, r6
   1dc48:	f007 f88b 	bl	24d62 <usb_write>
		if (ret) {
   1dc4c:	b110      	cbz	r0, 1dc54 <usb_transfer_work+0x74>
			trans->status = -EINVAL;
   1dc4e:	f06f 0315 	mvn.w	r3, #21
   1dc52:	e7dd      	b.n	1dc10 <usb_transfer_work+0x30>
		trans->buffer += bytes;
   1dc54:	9a01      	ldr	r2, [sp, #4]
   1dc56:	f854 3c24 	ldr.w	r3, [r4, #-36]
   1dc5a:	4413      	add	r3, r2
   1dc5c:	f844 3c24 	str.w	r3, [r4, #-36]
		trans->bsize -= bytes;
   1dc60:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1dc64:	1a9b      	subs	r3, r3, r2
   1dc66:	f844 3c20 	str.w	r3, [r4, #-32]
		trans->tsize += bytes;
   1dc6a:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   1dc6e:	4413      	add	r3, r2
   1dc70:	f844 3c1c 	str.w	r3, [r4, #-28]
   1dc74:	e7ce      	b.n	1dc14 <usb_transfer_work+0x34>
		ret = usb_dc_ep_read_wait(ep, trans->buffer, trans->bsize,
   1dc76:	f850 1c24 	ldr.w	r1, [r0, #-36]
   1dc7a:	ab01      	add	r3, sp, #4
   1dc7c:	4630      	mov	r0, r6
   1dc7e:	f001 fcb1 	bl	1f5e4 <usb_dc_ep_read_wait>
		if (ret) {
   1dc82:	2800      	cmp	r0, #0
   1dc84:	d1e3      	bne.n	1dc4e <usb_transfer_work+0x6e>
		trans->buffer += bytes;
   1dc86:	9d01      	ldr	r5, [sp, #4]
   1dc88:	f854 3c24 	ldr.w	r3, [r4, #-36]
   1dc8c:	442b      	add	r3, r5
   1dc8e:	f844 3c24 	str.w	r3, [r4, #-36]
		trans->bsize -= bytes;
   1dc92:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1dc96:	1b5b      	subs	r3, r3, r5
   1dc98:	f844 3c20 	str.w	r3, [r4, #-32]
		trans->tsize += bytes;
   1dc9c:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   1dca0:	442b      	add	r3, r5
   1dca2:	f844 3c1c 	str.w	r3, [r4, #-28]
		if (!bytes || (bytes % usb_dc_ep_mps(ep)) || !trans->bsize) {
   1dca6:	2d00      	cmp	r5, #0
   1dca8:	d0b1      	beq.n	1dc0e <usb_transfer_work+0x2e>
   1dcaa:	4630      	mov	r0, r6
   1dcac:	f001 fd3e 	bl	1f72c <usb_dc_ep_mps>
   1dcb0:	fbb5 f3f0 	udiv	r3, r5, r0
   1dcb4:	fb03 5510 	mls	r5, r3, r0, r5
   1dcb8:	2d00      	cmp	r5, #0
   1dcba:	d1a8      	bne.n	1dc0e <usb_transfer_work+0x2e>
   1dcbc:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1dcc0:	2b00      	cmp	r3, #0
   1dcc2:	d0a4      	beq.n	1dc0e <usb_transfer_work+0x2e>
		usb_dc_ep_read_continue(ep);
   1dcc4:	4630      	mov	r0, r6
   1dcc6:	f001 fcd5 	bl	1f674 <usb_dc_ep_read_continue>
   1dcca:	e7a3      	b.n	1dc14 <usb_transfer_work+0x34>
		trans->cb = NULL;
   1dccc:	f844 0c18 	str.w	r0, [r4, #-24]
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   1dcd0:	f1a4 0010 	sub.w	r0, r4, #16
   1dcd4:	f005 fc2c 	bl	23530 <z_impl_k_sem_give>
		cb(ep, tsize, priv);
   1dcd8:	4642      	mov	r2, r8
   1dcda:	4639      	mov	r1, r7
   1dcdc:	4630      	mov	r0, r6
   1dcde:	47a8      	blx	r5
   1dce0:	e7ab      	b.n	1dc3a <usb_transfer_work+0x5a>
   1dce2:	bf00      	nop
   1dce4:	2000a410 	.word	0x2000a410

0001dce8 <usb_transfer_ep_callback>:

void usb_transfer_ep_callback(uint8_t ep, enum usb_dc_ep_cb_status_code status)
{
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);

	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
   1dce8:	1e4b      	subs	r3, r1, #1
   1dcea:	2b01      	cmp	r3, #1
{
   1dcec:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1dcee:	4606      	mov	r6, r0
   1dcf0:	460d      	mov	r5, r1
	if (status != USB_DC_EP_DATA_IN && status != USB_DC_EP_DATA_OUT) {
   1dcf2:	d80f      	bhi.n	1dd14 <usb_transfer_ep_callback+0x2c>
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);
   1dcf4:	f7ff ff5e 	bl	1dbb4 <usb_ep_get_transfer>
		return;
	}

	if (!trans) {
   1dcf8:	4604      	mov	r4, r0
   1dcfa:	b968      	cbnz	r0, 1dd18 <usb_transfer_ep_callback+0x30>
		if (status == USB_DC_EP_DATA_OUT) {
   1dcfc:	2d01      	cmp	r5, #1
   1dcfe:	d109      	bne.n	1dd14 <usb_transfer_ep_callback+0x2c>
			 * so drain it).
			 */
			do {
				uint8_t data;

				usb_dc_ep_read_wait(ep, &data, 1, &bytes);
   1dd00:	ab01      	add	r3, sp, #4
   1dd02:	2201      	movs	r2, #1
   1dd04:	4630      	mov	r0, r6
   1dd06:	f10d 0103 	add.w	r1, sp, #3
   1dd0a:	f001 fc6b 	bl	1f5e4 <usb_dc_ep_read_wait>
			} while (bytes);
   1dd0e:	9b01      	ldr	r3, [sp, #4]
   1dd10:	2b00      	cmp	r3, #0
   1dd12:	d1f5      	bne.n	1dd00 <usb_transfer_ep_callback+0x18>
		/* Read (out) needs to be done from ep_callback */
		usb_transfer_work(&trans->work);
	} else {
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
	}
}
   1dd14:	b002      	add	sp, #8
   1dd16:	bd70      	pop	{r4, r5, r6, pc}
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
   1dd18:	f007 ff3d 	bl	25b96 <k_is_in_isr>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dd1c:	f104 012c 	add.w	r1, r4, #44	; 0x2c
	if (!k_is_in_isr() || (status == USB_DC_EP_DATA_OUT)) {
   1dd20:	b108      	cbz	r0, 1dd26 <usb_transfer_ep_callback+0x3e>
   1dd22:	2d01      	cmp	r5, #1
   1dd24:	d105      	bne.n	1dd32 <usb_transfer_ep_callback+0x4a>
		usb_transfer_work(&trans->work);
   1dd26:	4608      	mov	r0, r1
}
   1dd28:	b002      	add	sp, #8
   1dd2a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		usb_transfer_work(&trans->work);
   1dd2e:	f7ff bf57 	b.w	1dbe0 <usb_transfer_work>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dd32:	4803      	ldr	r0, [pc, #12]	; (1dd40 <usb_transfer_ep_callback+0x58>)
}
   1dd34:	b002      	add	sp, #8
   1dd36:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1dd3a:	f008 b820 	b.w	25d7e <k_work_submit_to_queue>
   1dd3e:	bf00      	nop
   1dd40:	2000a410 	.word	0x2000a410

0001dd44 <usb_transfer>:

int usb_transfer(uint8_t ep, uint8_t *data, size_t dlen, unsigned int flags,
		 usb_transfer_callback cb, void *cb_data)
{
   1dd44:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1dd48:	4606      	mov	r6, r0
   1dd4a:	4615      	mov	r5, r2
   1dd4c:	4698      	mov	r8, r3
   1dd4e:	9101      	str	r1, [sp, #4]
	struct usb_transfer_data *trans = NULL;
	int key, ret = 0;

	/* Parallel transfer to same endpoint is not supported. */
	if (usb_transfer_is_busy(ep)) {
   1dd50:	f007 f84d 	bl	24dee <usb_transfer_is_busy>
   1dd54:	4604      	mov	r4, r0
   1dd56:	2800      	cmp	r0, #0
   1dd58:	d15c      	bne.n	1de14 <usb_transfer+0xd0>
	__asm__ volatile(
   1dd5a:	f04f 0320 	mov.w	r3, #32
   1dd5e:	f3ef 8a11 	mrs	sl, BASEPRI
   1dd62:	f383 8812 	msr	BASEPRI_MAX, r3
   1dd66:	f3bf 8f6f 	isb	sy
	LOG_DBG("Transfer start, ep 0x%02x, data %p, dlen %zd",
		ep, data, dlen);

	key = irq_lock();

	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dd6a:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 1de1c <usb_transfer+0xd8>
	return z_impl_k_sem_take(sem, timeout);
   1dd6e:	2200      	movs	r2, #0
   1dd70:	2300      	movs	r3, #0
   1dd72:	4658      	mov	r0, fp
   1dd74:	f005 fbfc 	bl	23570 <z_impl_k_sem_take>
		if (!k_sem_take(&ut_data[i].sem, K_NO_WAIT)) {
   1dd78:	b970      	cbnz	r0, 1dd98 <usb_transfer+0x54>
		LOG_ERR("No transfer slot available");
		ret = -ENOMEM;
		goto done;
	}

	if (trans->status == -EBUSY) {
   1dd7a:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 1de20 <usb_transfer+0xdc>
   1dd7e:	01a7      	lsls	r7, r4, #6
   1dd80:	eb09 1484 	add.w	r4, r9, r4, lsl #6
   1dd84:	6863      	ldr	r3, [r4, #4]
   1dd86:	f113 0f10 	cmn.w	r3, #16
   1dd8a:	d114      	bne.n	1ddb6 <usb_transfer+0x72>
   1dd8c:	9301      	str	r3, [sp, #4]
	z_impl_k_sem_give(sem);
   1dd8e:	4658      	mov	r0, fp
   1dd90:	f005 fbce 	bl	23530 <z_impl_k_sem_give>
		/* A transfer is already ongoing and not completed */
		LOG_ERR("A transfer is already ongoing, ep 0x%02x", ep);
		k_sem_give(&trans->sem);
		ret = -EBUSY;
		goto done;
   1dd94:	9b01      	ldr	r3, [sp, #4]
   1dd96:	e006      	b.n	1dda6 <usb_transfer+0x62>
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dd98:	3401      	adds	r4, #1
   1dd9a:	2c04      	cmp	r4, #4
   1dd9c:	f10b 0b40 	add.w	fp, fp, #64	; 0x40
   1dda0:	d1e5      	bne.n	1dd6e <usb_transfer+0x2a>
		ret = -ENOMEM;
   1dda2:	f06f 030b 	mvn.w	r3, #11
	__asm__ volatile(
   1dda6:	f38a 8811 	msr	BASEPRI, sl
   1ddaa:	f3bf 8f6f 	isb	sy
	}

done:
	irq_unlock(key);
	return ret;
}
   1ddae:	4618      	mov	r0, r3
   1ddb0:	b003      	add	sp, #12
   1ddb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	trans->buffer = data;
   1ddb6:	9b01      	ldr	r3, [sp, #4]
	trans->tsize = 0;
   1ddb8:	6120      	str	r0, [r4, #16]
	trans->bsize = dlen;
   1ddba:	e9c4 3502 	strd	r3, r5, [r4, #8]
	trans->cb = cb;
   1ddbe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
   1ddc0:	4630      	mov	r0, r6
	trans->cb = cb;
   1ddc2:	6163      	str	r3, [r4, #20]
	trans->priv = cb_data;
   1ddc4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	trans->ep = ep;
   1ddc6:	f809 6007 	strb.w	r6, [r9, r7]
	trans->priv = cb_data;
   1ddca:	61a3      	str	r3, [r4, #24]
	trans->status = -EBUSY;
   1ddcc:	f06f 030f 	mvn.w	r3, #15
	trans->flags = flags;
   1ddd0:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
	trans->status = -EBUSY;
   1ddd4:	6063      	str	r3, [r4, #4]
	if (usb_dc_ep_mps(ep) && (dlen % usb_dc_ep_mps(ep))) {
   1ddd6:	f001 fca9 	bl	1f72c <usb_dc_ep_mps>
   1ddda:	b158      	cbz	r0, 1ddf4 <usb_transfer+0xb0>
   1dddc:	4630      	mov	r0, r6
   1ddde:	f001 fca5 	bl	1f72c <usb_dc_ep_mps>
   1dde2:	fbb5 f3f0 	udiv	r3, r5, r0
   1dde6:	fb03 5510 	mls	r5, r3, r0, r5
   1ddea:	b11d      	cbz	r5, 1ddf4 <usb_transfer+0xb0>
		trans->flags |= USB_TRANS_NO_ZLP;
   1ddec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1ddee:	f043 0304 	orr.w	r3, r3, #4
   1ddf2:	63e3      	str	r3, [r4, #60]	; 0x3c
	if (flags & USB_TRANS_WRITE) {
   1ddf4:	f018 0f02 	tst.w	r8, #2
   1ddf8:	d007      	beq.n	1de0a <usb_transfer+0xc6>
		k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1ddfa:	f107 012c 	add.w	r1, r7, #44	; 0x2c
   1ddfe:	4809      	ldr	r0, [pc, #36]	; (1de24 <usb_transfer+0xe0>)
   1de00:	4449      	add	r1, r9
   1de02:	f007 ffbc 	bl	25d7e <k_work_submit_to_queue>
	int key, ret = 0;
   1de06:	2300      	movs	r3, #0
   1de08:	e7cd      	b.n	1dda6 <usb_transfer+0x62>
		ret = usb_dc_ep_read_continue(ep);
   1de0a:	4630      	mov	r0, r6
   1de0c:	f001 fc32 	bl	1f674 <usb_dc_ep_read_continue>
   1de10:	4603      	mov	r3, r0
   1de12:	e7c8      	b.n	1dda6 <usb_transfer+0x62>
		return -EBUSY;
   1de14:	f06f 030f 	mvn.w	r3, #15
   1de18:	e7c9      	b.n	1ddae <usb_transfer+0x6a>
   1de1a:	bf00      	nop
   1de1c:	2000a84c 	.word	0x2000a84c
   1de20:	2000a830 	.word	0x2000a830
   1de24:	2000a410 	.word	0x2000a410

0001de28 <usb_cancel_transfer>:

void usb_cancel_transfer(uint8_t ep)
{
   1de28:	b510      	push	{r4, lr}
	__asm__ volatile(
   1de2a:	f04f 0320 	mov.w	r3, #32
   1de2e:	f3ef 8411 	mrs	r4, BASEPRI
   1de32:	f383 8812 	msr	BASEPRI_MAX, r3
   1de36:	f3bf 8f6f 	isb	sy
	struct usb_transfer_data *trans;
	unsigned int key;

	key = irq_lock();

	trans = usb_ep_get_transfer(ep);
   1de3a:	f7ff febb 	bl	1dbb4 <usb_ep_get_transfer>
	if (!trans) {
   1de3e:	b150      	cbz	r0, 1de56 <usb_cancel_transfer+0x2e>
		goto done;
	}

	if (trans->status != -EBUSY) {
   1de40:	6843      	ldr	r3, [r0, #4]
   1de42:	3310      	adds	r3, #16
   1de44:	d107      	bne.n	1de56 <usb_cancel_transfer+0x2e>
		goto done;
	}

	trans->status = -ECANCELED;
   1de46:	f06f 038b 	mvn.w	r3, #139	; 0x8b
	k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de4a:	f100 012c 	add.w	r1, r0, #44	; 0x2c
	trans->status = -ECANCELED;
   1de4e:	6043      	str	r3, [r0, #4]
	k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de50:	4803      	ldr	r0, [pc, #12]	; (1de60 <usb_cancel_transfer+0x38>)
   1de52:	f007 ff94 	bl	25d7e <k_work_submit_to_queue>
	__asm__ volatile(
   1de56:	f384 8811 	msr	BASEPRI, r4
   1de5a:	f3bf 8f6f 	isb	sy

done:
	irq_unlock(key);
}
   1de5e:	bd10      	pop	{r4, pc}
   1de60:	2000a410 	.word	0x2000a410

0001de64 <usb_cancel_transfers>:

void usb_cancel_transfers(void)
{
   1de64:	b570      	push	{r4, r5, r6, lr}
   1de66:	2504      	movs	r5, #4
   1de68:	4c0e      	ldr	r4, [pc, #56]	; (1dea4 <usb_cancel_transfers+0x40>)
	__asm__ volatile(
   1de6a:	f04f 0320 	mov.w	r3, #32
   1de6e:	f3ef 8611 	mrs	r6, BASEPRI
   1de72:	f383 8812 	msr	BASEPRI_MAX, r3
   1de76:	f3bf 8f6f 	isb	sy
		struct usb_transfer_data *trans = &ut_data[i];
		unsigned int key;

		key = irq_lock();

		if (trans->status == -EBUSY) {
   1de7a:	6863      	ldr	r3, [r4, #4]
   1de7c:	3310      	adds	r3, #16
   1de7e:	d107      	bne.n	1de90 <usb_cancel_transfers+0x2c>
			trans->status = -ECANCELED;
   1de80:	f06f 038b 	mvn.w	r3, #139	; 0x8b
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de84:	4808      	ldr	r0, [pc, #32]	; (1dea8 <usb_cancel_transfers+0x44>)
			trans->status = -ECANCELED;
   1de86:	6063      	str	r3, [r4, #4]
			k_work_submit_to_queue(&USB_WORK_Q, &trans->work);
   1de88:	f104 012c 	add.w	r1, r4, #44	; 0x2c
   1de8c:	f007 ff77 	bl	25d7e <k_work_submit_to_queue>
	__asm__ volatile(
   1de90:	f386 8811 	msr	BASEPRI, r6
   1de94:	f3bf 8f6f 	isb	sy
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1de98:	3d01      	subs	r5, #1
   1de9a:	f104 0440 	add.w	r4, r4, #64	; 0x40
   1de9e:	d1e4      	bne.n	1de6a <usb_cancel_transfers+0x6>
			LOG_DBG("Cancel transfer for ep: 0x%02x", trans->ep);
		}

		irq_unlock(key);
	}
}
   1dea0:	bd70      	pop	{r4, r5, r6, pc}
   1dea2:	bf00      	nop
   1dea4:	2000a830 	.word	0x2000a830
   1dea8:	2000a410 	.word	0x2000a410

0001deac <usb_transfer_init>:
	return pdata.tsize;
}

/* Init transfer slots */
int usb_transfer_init(void)
{
   1deac:	b570      	push	{r4, r5, r6, lr}
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1deae:	2500      	movs	r5, #0
   1deb0:	4c09      	ldr	r4, [pc, #36]	; (1ded8 <usb_transfer_init+0x2c>)
		k_work_init(&ut_data[i].work, usb_transfer_work);
   1deb2:	4e0a      	ldr	r6, [pc, #40]	; (1dedc <usb_transfer_init+0x30>)
   1deb4:	4631      	mov	r1, r6
   1deb6:	4620      	mov	r0, r4
   1deb8:	f007 ff44 	bl	25d44 <k_work_init>
	return z_impl_k_sem_init(sem, initial_count, limit);
   1debc:	2201      	movs	r2, #1
   1debe:	f1a4 0010 	sub.w	r0, r4, #16
   1dec2:	4611      	mov	r1, r2
	for (size_t i = 0; i < ARRAY_SIZE(ut_data); i++) {
   1dec4:	3501      	adds	r5, #1
   1dec6:	f007 ff00 	bl	25cca <z_impl_k_sem_init>
   1deca:	2d04      	cmp	r5, #4
   1decc:	f104 0440 	add.w	r4, r4, #64	; 0x40
   1ded0:	d1f0      	bne.n	1deb4 <usb_transfer_init+0x8>
		k_sem_init(&ut_data[i].sem, 1, 1);
	}

	return 0;
}
   1ded2:	2000      	movs	r0, #0
   1ded4:	bd70      	pop	{r4, r5, r6, pc}
   1ded6:	bf00      	nop
   1ded8:	2000a85c 	.word	0x2000a85c
   1dedc:	0001dbe1 	.word	0x0001dbe1

0001dee0 <cdc_acm_class_handle_req>:
 *
 * @return  0 on success, negative errno code on fail.
 */
int cdc_acm_class_handle_req(struct usb_setup_packet *setup,
			     int32_t *len, uint8_t **data)
{
   1dee0:	b570      	push	{r4, r5, r6, lr}
   1dee2:	4604      	mov	r4, r0
   1dee4:	460e      	mov	r6, r1
	struct cdc_acm_dev_data_t *dev_data;
	struct usb_dev_data *common;
	uint32_t rate;
	uint32_t new_rate;

	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
   1dee6:	7901      	ldrb	r1, [r0, #4]
   1dee8:	4812      	ldr	r0, [pc, #72]	; (1df34 <cdc_acm_class_handle_req+0x54>)
{
   1deea:	4615      	mov	r5, r2
	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
   1deec:	f006 ff5c 	bl	24da8 <usb_get_dev_data_by_iface>
					   (uint8_t)setup->wIndex);
	if (common == NULL) {
   1def0:	b1e8      	cbz	r0, 1df2e <cdc_acm_class_handle_req+0x4e>
		return -ENODEV;
	}

	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);

	if (usb_reqtype_is_to_device(setup)) {
   1def2:	f994 2000 	ldrsb.w	r2, [r4]
		switch (setup->bRequest) {
   1def6:	7863      	ldrb	r3, [r4, #1]
	if (usb_reqtype_is_to_device(setup)) {
   1def8:	2a00      	cmp	r2, #0
   1defa:	db11      	blt.n	1df20 <cdc_acm_class_handle_req+0x40>
		switch (setup->bRequest) {
   1defc:	2b20      	cmp	r3, #32
   1defe:	d004      	beq.n	1df0a <cdc_acm_class_handle_req+0x2a>
   1df00:	2b22      	cmp	r3, #34	; 0x22
   1df02:	d009      	beq.n	1df18 <cdc_acm_class_handle_req+0x38>
		}
	}

	LOG_DBG("CDC ACM bmRequestType 0x%02x bRequest 0x%02x unsupported",
		setup->bmRequestType, setup->bRequest);
	return -ENOTSUP;
   1df04:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1df08:	e005      	b.n	1df16 <cdc_acm_class_handle_req+0x36>
			memcpy(&dev_data->line_coding, *data,
   1df0a:	2207      	movs	r2, #7
   1df0c:	6829      	ldr	r1, [r5, #0]
   1df0e:	3810      	subs	r0, #16
   1df10:	f007 f85f 	bl	24fd2 <memcpy>
			return 0;
   1df14:	2000      	movs	r0, #0
}
   1df16:	bd70      	pop	{r4, r5, r6, pc}
			dev_data->line_state = (uint8_t)setup->wValue;
   1df18:	8863      	ldrh	r3, [r4, #2]
   1df1a:	f800 3c09 	strb.w	r3, [r0, #-9]
			return 0;
   1df1e:	e7f9      	b.n	1df14 <cdc_acm_class_handle_req+0x34>
		if (setup->bRequest == GET_LINE_CODING) {
   1df20:	2b21      	cmp	r3, #33	; 0x21
   1df22:	d1ef      	bne.n	1df04 <cdc_acm_class_handle_req+0x24>
			*len = sizeof(dev_data->line_coding);
   1df24:	2307      	movs	r3, #7
			*data = (uint8_t *)(&dev_data->line_coding);
   1df26:	3810      	subs	r0, #16
   1df28:	6028      	str	r0, [r5, #0]
			*len = sizeof(dev_data->line_coding);
   1df2a:	6033      	str	r3, [r6, #0]
			return 0;
   1df2c:	e7f2      	b.n	1df14 <cdc_acm_class_handle_req+0x34>
		return -ENODEV;
   1df2e:	f06f 0012 	mvn.w	r0, #18
   1df32:	e7f0      	b.n	1df16 <cdc_acm_class_handle_req+0x36>
   1df34:	2000a930 	.word	0x2000a930

0001df38 <cdc_acm_int_in>:
 *
 * @param ep        Endpoint address.
 * @param ep_status Endpoint status code.
 */
static void cdc_acm_int_in(uint8_t ep, enum usb_dc_ep_cb_status_code ep_status)
{
   1df38:	4601      	mov	r1, r0
   1df3a:	b508      	push	{r3, lr}
	struct cdc_acm_dev_data_t *dev_data;
	struct usb_dev_data *common;

	ARG_UNUSED(ep_status);

	common = usb_get_dev_data_by_ep(&cdc_acm_data_devlist, ep);
   1df3c:	4803      	ldr	r0, [pc, #12]	; (1df4c <cdc_acm_int_in+0x14>)
   1df3e:	f006 ff40 	bl	24dc2 <usb_get_dev_data_by_ep>
	if (common == NULL) {
   1df42:	b110      	cbz	r0, 1df4a <cdc_acm_int_in+0x12>
		return;
	}

	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);

	dev_data->notification_sent = 1U;
   1df44:	2301      	movs	r3, #1
   1df46:	f800 3c07 	strb.w	r3, [r0, #-7]
	LOG_DBG("CDC_IntIN EP[%x]\r", ep);
}
   1df4a:	bd08      	pop	{r3, pc}
   1df4c:	2000a930 	.word	0x2000a930

0001df50 <cdc_acm_irq_rx_enable>:
 */
static void cdc_acm_irq_rx_enable(const struct device *dev)
{
	struct cdc_acm_dev_data_t * const dev_data = dev->data;

	dev_data->rx_irq_ena = true;
   1df50:	2301      	movs	r3, #1
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1df52:	6901      	ldr	r1, [r0, #16]
	dev_data->rx_irq_ena = true;
   1df54:	f881 304b 	strb.w	r3, [r1, #75]	; 0x4b

	if (dev_data->cb && dev_data->rx_ready) {
   1df58:	680b      	ldr	r3, [r1, #0]
   1df5a:	b133      	cbz	r3, 1df6a <cdc_acm_irq_rx_enable+0x1a>
   1df5c:	f891 3049 	ldrb.w	r3, [r1, #73]	; 0x49
   1df60:	b11b      	cbz	r3, 1df6a <cdc_acm_irq_rx_enable+0x1a>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1df62:	4802      	ldr	r0, [pc, #8]	; (1df6c <cdc_acm_irq_rx_enable+0x1c>)
   1df64:	3108      	adds	r1, #8
   1df66:	f007 bf0a 	b.w	25d7e <k_work_submit_to_queue>
	}
}
   1df6a:	4770      	bx	lr
   1df6c:	2000a410 	.word	0x2000a410

0001df70 <cdc_acm_irq_tx_enable>:
	dev_data->tx_irq_ena = true;
   1df70:	2301      	movs	r3, #1
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1df72:	6901      	ldr	r1, [r0, #16]
	dev_data->tx_irq_ena = true;
   1df74:	f881 304a 	strb.w	r3, [r1, #74]	; 0x4a
	if (dev_data->cb && dev_data->tx_ready) {
   1df78:	680b      	ldr	r3, [r1, #0]
   1df7a:	b133      	cbz	r3, 1df8a <cdc_acm_irq_tx_enable+0x1a>
   1df7c:	f891 3048 	ldrb.w	r3, [r1, #72]	; 0x48
   1df80:	b11b      	cbz	r3, 1df8a <cdc_acm_irq_tx_enable+0x1a>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1df82:	4802      	ldr	r0, [pc, #8]	; (1df8c <cdc_acm_irq_tx_enable+0x1c>)
   1df84:	3108      	adds	r1, #8
   1df86:	f007 befa 	b.w	25d7e <k_work_submit_to_queue>
}
   1df8a:	4770      	bx	lr
   1df8c:	2000a410 	.word	0x2000a410

0001df90 <cdc_acm_reset_port>:
	dev_data->tx_ready = false;
   1df90:	2100      	movs	r1, #0
{
   1df92:	4603      	mov	r3, r0
	dev_data->line_coding = (struct cdc_acm_line_coding)
   1df94:	4a0c      	ldr	r2, [pc, #48]	; (1dfc8 <cdc_acm_reset_port+0x38>)
	dev_data->tx_ready = false;
   1df96:	f8a0 1048 	strh.w	r1, [r0, #72]	; 0x48
	dev_data->line_coding = (struct cdc_acm_line_coding)
   1df9a:	6810      	ldr	r0, [r2, #0]
	dev_data->serial_state = 0;
   1df9c:	f883 109c 	strb.w	r1, [r3, #156]	; 0x9c
	dev_data->line_coding = (struct cdc_acm_line_coding)
   1dfa0:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
   1dfa4:	8890      	ldrh	r0, [r2, #4]
   1dfa6:	7992      	ldrb	r2, [r2, #6]
   1dfa8:	f8a3 0098 	strh.w	r0, [r3, #152]	; 0x98
   1dfac:	f883 209a 	strb.w	r2, [r3, #154]	; 0x9a
	dev_data->line_state = 0;
   1dfb0:	f883 109b 	strb.w	r1, [r3, #155]	; 0x9b
	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
   1dfb4:	2240      	movs	r2, #64	; 0x40
	dev_data->configured = false;
   1dfb6:	f8a3 109e 	strh.w	r1, [r3, #158]	; 0x9e
	dev_data->rx_paused = false;
   1dfba:	f883 10a0 	strb.w	r1, [r3, #160]	; 0xa0
	memset(&dev_data->rx_buf, 0, CDC_ACM_BUFFER_SIZE);
   1dfbe:	f103 004c 	add.w	r0, r3, #76	; 0x4c
   1dfc2:	f007 b811 	b.w	24fe8 <memset>
   1dfc6:	bf00      	nop
   1dfc8:	00026620 	.word	0x00026620

0001dfcc <cdc_acm_fifo_fill>:
{
   1dfcc:	b538      	push	{r3, r4, r5, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1dfce:	6905      	ldr	r5, [r0, #16]
	if (!dev_data->configured || dev_data->suspended) {
   1dfd0:	f895 009e 	ldrb.w	r0, [r5, #158]	; 0x9e
   1dfd4:	b188      	cbz	r0, 1dffa <cdc_acm_fifo_fill+0x2e>
   1dfd6:	f895 309f 	ldrb.w	r3, [r5, #159]	; 0x9f
   1dfda:	b97b      	cbnz	r3, 1dffc <cdc_acm_fifo_fill+0x30>
	dev_data->tx_ready = false;
   1dfdc:	f885 3048 	strb.w	r3, [r5, #72]	; 0x48
	wrote = ring_buf_put(dev_data->tx_ringbuf, tx_data, len);
   1dfe0:	f8d5 0090 	ldr.w	r0, [r5, #144]	; 0x90
   1dfe4:	f006 fddf 	bl	24ba6 <ring_buf_put>
   1dfe8:	4604      	mov	r4, r0
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_NO_WAIT);
   1dfea:	2200      	movs	r2, #0
   1dfec:	2300      	movs	r3, #0
   1dfee:	4804      	ldr	r0, [pc, #16]	; (1e000 <cdc_acm_fifo_fill+0x34>)
   1dff0:	f105 0118 	add.w	r1, r5, #24
   1dff4:	f005 fc30 	bl	23858 <k_work_schedule_for_queue>
	return wrote;
   1dff8:	4620      	mov	r0, r4
}
   1dffa:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   1dffc:	2000      	movs	r0, #0
   1dffe:	e7fc      	b.n	1dffa <cdc_acm_fifo_fill+0x2e>
   1e000:	2000a410 	.word	0x2000a410

0001e004 <cdc_acm_poll_out>:
 * is not ready, no data is transferred to the buffer, that is, c is dropped.
 * If the USB subsystem is ready and the buffer is full, the first character
 * from the tx_ringbuf is removed to make room for the new character.
 */
static void cdc_acm_poll_out(const struct device *dev, unsigned char c)
{
   1e004:	b513      	push	{r0, r1, r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1e006:	6904      	ldr	r4, [r0, #16]
{
   1e008:	f88d 1007 	strb.w	r1, [sp, #7]

	if (!dev_data->configured || dev_data->suspended) {
   1e00c:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
   1e010:	b1a3      	cbz	r3, 1e03c <cdc_acm_poll_out+0x38>
   1e012:	f894 309f 	ldrb.w	r3, [r4, #159]	; 0x9f
   1e016:	b98b      	cbnz	r3, 1e03c <cdc_acm_poll_out+0x38>
		return;
	}

	dev_data->tx_ready = false;

	if (!ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
   1e018:	f10d 0107 	add.w	r1, sp, #7
   1e01c:	2201      	movs	r2, #1
   1e01e:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
	dev_data->tx_ready = false;
   1e022:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	if (!ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
   1e026:	f006 fdbe 	bl	24ba6 <ring_buf_put>
   1e02a:	4601      	mov	r1, r0
   1e02c:	b140      	cbz	r0, 1e040 <cdc_acm_poll_out+0x3c>

	/* Schedule with minimal timeout to make it possible to send more than
	 * one byte per USB transfer. The latency increase is negligible while
	 * the increased throughput and reduced CPU usage is easily observable.
	 */
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_MSEC(1));
   1e02e:	2221      	movs	r2, #33	; 0x21
   1e030:	2300      	movs	r3, #0
   1e032:	480c      	ldr	r0, [pc, #48]	; (1e064 <cdc_acm_poll_out+0x60>)
   1e034:	f104 0118 	add.w	r1, r4, #24
   1e038:	f005 fc0e 	bl	23858 <k_work_schedule_for_queue>
}
   1e03c:	b002      	add	sp, #8
   1e03e:	bd10      	pop	{r4, pc}
		if (!ring_buf_get(dev_data->tx_ringbuf, NULL, 1) ||
   1e040:	2201      	movs	r2, #1
   1e042:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
   1e046:	f006 fdfe 	bl	24c46 <ring_buf_get>
   1e04a:	2800      	cmp	r0, #0
   1e04c:	d0f6      	beq.n	1e03c <cdc_acm_poll_out+0x38>
		    !ring_buf_put(dev_data->tx_ringbuf, &c, 1)) {
   1e04e:	2201      	movs	r2, #1
   1e050:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
   1e054:	f10d 0107 	add.w	r1, sp, #7
   1e058:	f006 fda5 	bl	24ba6 <ring_buf_put>
		if (!ring_buf_get(dev_data->tx_ringbuf, NULL, 1) ||
   1e05c:	2800      	cmp	r0, #0
   1e05e:	d1e6      	bne.n	1e02e <cdc_acm_poll_out+0x2a>
   1e060:	e7ec      	b.n	1e03c <cdc_acm_poll_out+0x38>
   1e062:	bf00      	nop
   1e064:	2000a410 	.word	0x2000a410

0001e068 <tx_work_handler>:
{
   1e068:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct usb_cfg_data *cfg = (void *)dev->config;
   1e06a:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
{
   1e06e:	4605      	mov	r5, r0
	uint8_t ep = cfg->endpoint[ACM_IN_EP_IDX].ep_addr;
   1e070:	685b      	ldr	r3, [r3, #4]
{
   1e072:	b085      	sub	sp, #20
	uint8_t ep = cfg->endpoint[ACM_IN_EP_IDX].ep_addr;
   1e074:	6a1b      	ldr	r3, [r3, #32]
   1e076:	7d1f      	ldrb	r7, [r3, #20]
	if (usb_transfer_is_busy(ep)) {
   1e078:	4638      	mov	r0, r7
   1e07a:	f006 feb8 	bl	24dee <usb_transfer_is_busy>
   1e07e:	4606      	mov	r6, r0
   1e080:	b9e0      	cbnz	r0, 1e0bc <tx_work_handler+0x54>
	len = ring_buf_get_claim(dev_data->tx_ringbuf, &data,
   1e082:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1e086:	6fa8      	ldr	r0, [r5, #120]	; 0x78
   1e088:	a903      	add	r1, sp, #12
   1e08a:	f006 fdab 	bl	24be4 <ring_buf_get_claim>
	if (!len) {
   1e08e:	4604      	mov	r4, r0
   1e090:	b1a0      	cbz	r0, 1e0bc <tx_work_handler+0x54>
	if (!(len % CONFIG_CDC_ACM_BULK_EP_MPS)) {
   1e092:	0683      	lsls	r3, r0, #26
	struct cdc_acm_dev_data_t *dev_data =
   1e094:	f1a5 0318 	sub.w	r3, r5, #24
	dev_data->tx_ready = false;
   1e098:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
	usb_transfer(ep, data, len, USB_TRANS_WRITE,
   1e09c:	9301      	str	r3, [sp, #4]
   1e09e:	4b08      	ldr	r3, [pc, #32]	; (1e0c0 <tx_work_handler+0x58>)
		len -= 1;
   1e0a0:	bf08      	it	eq
   1e0a2:	f100 34ff 	addeq.w	r4, r0, #4294967295	; 0xffffffff
	usb_transfer(ep, data, len, USB_TRANS_WRITE,
   1e0a6:	9903      	ldr	r1, [sp, #12]
   1e0a8:	9300      	str	r3, [sp, #0]
   1e0aa:	4622      	mov	r2, r4
   1e0ac:	2302      	movs	r3, #2
   1e0ae:	4638      	mov	r0, r7
   1e0b0:	f7ff fe48 	bl	1dd44 <usb_transfer>
	ring_buf_get_finish(dev_data->tx_ringbuf, len);
   1e0b4:	4621      	mov	r1, r4
   1e0b6:	6fa8      	ldr	r0, [r5, #120]	; 0x78
   1e0b8:	f006 fdb0 	bl	24c1c <ring_buf_get_finish>
}
   1e0bc:	b005      	add	sp, #20
   1e0be:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1e0c0:	0001e0c5 	.word	0x0001e0c5

0001e0c4 <cdc_acm_write_cb>:
	dev_data->tx_ready = true;
   1e0c4:	2301      	movs	r3, #1
{
   1e0c6:	b510      	push	{r4, lr}
	dev_data->tx_ready = true;
   1e0c8:	f882 3048 	strb.w	r3, [r2, #72]	; 0x48
	if (dev_data->cb && dev_data->tx_irq_ena) {
   1e0cc:	6813      	ldr	r3, [r2, #0]
{
   1e0ce:	4614      	mov	r4, r2
	if (dev_data->cb && dev_data->tx_irq_ena) {
   1e0d0:	b13b      	cbz	r3, 1e0e2 <cdc_acm_write_cb+0x1e>
   1e0d2:	f892 304a 	ldrb.w	r3, [r2, #74]	; 0x4a
   1e0d6:	b123      	cbz	r3, 1e0e2 <cdc_acm_write_cb+0x1e>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e0d8:	480a      	ldr	r0, [pc, #40]	; (1e104 <cdc_acm_write_cb+0x40>)
   1e0da:	f102 0108 	add.w	r1, r2, #8
   1e0de:	f007 fe4e 	bl	25d7e <k_work_submit_to_queue>
	if (ring_buf_is_empty(dev_data->tx_ringbuf)) {
   1e0e2:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   1e0e6:	689a      	ldr	r2, [r3, #8]
   1e0e8:	691b      	ldr	r3, [r3, #16]
   1e0ea:	429a      	cmp	r2, r3
   1e0ec:	d008      	beq.n	1e100 <cdc_acm_write_cb+0x3c>
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_NO_WAIT);
   1e0ee:	f104 0118 	add.w	r1, r4, #24
   1e0f2:	2200      	movs	r2, #0
}
   1e0f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	k_work_schedule_for_queue(&USB_WORK_Q, &dev_data->tx_work, K_NO_WAIT);
   1e0f8:	2300      	movs	r3, #0
   1e0fa:	4802      	ldr	r0, [pc, #8]	; (1e104 <cdc_acm_write_cb+0x40>)
   1e0fc:	f005 bbac 	b.w	23858 <k_work_schedule_for_queue>
}
   1e100:	bd10      	pop	{r4, pc}
   1e102:	bf00      	nop
   1e104:	2000a410 	.word	0x2000a410

0001e108 <cdc_acm_init>:
	parent->next = child;
   1e108:	2300      	movs	r3, #0
{
   1e10a:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   1e10c:	6904      	ldr	r4, [r0, #16]
   1e10e:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
   1e112:	4b0c      	ldr	r3, [pc, #48]	; (1e144 <cdc_acm_init+0x3c>)
	dev_data->common.dev = dev;
   1e114:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
   1e118:	6859      	ldr	r1, [r3, #4]
	sys_slist_append(&cdc_acm_data_devlist, &dev_data->common.node);
   1e11a:	f104 02a8 	add.w	r2, r4, #168	; 0xa8
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   1e11e:	b969      	cbnz	r1, 1e13c <cdc_acm_init+0x34>
	list->head = node;
   1e120:	e9c3 2200 	strd	r2, r2, [r3]
	k_work_init(&dev_data->cb_work, cdc_acm_irq_callback_work_handler);
   1e124:	f104 0008 	add.w	r0, r4, #8
   1e128:	4907      	ldr	r1, [pc, #28]	; (1e148 <cdc_acm_init+0x40>)
   1e12a:	f007 fe0b 	bl	25d44 <k_work_init>
	k_work_init_delayable(&dev_data->tx_work, tx_work_handler);
   1e12e:	f104 0018 	add.w	r0, r4, #24
   1e132:	4906      	ldr	r1, [pc, #24]	; (1e14c <cdc_acm_init+0x44>)
   1e134:	f007 fe34 	bl	25da0 <k_work_init_delayable>
}
   1e138:	2000      	movs	r0, #0
   1e13a:	bd10      	pop	{r4, pc}
	parent->next = child;
   1e13c:	600a      	str	r2, [r1, #0]
	list->tail = node;
   1e13e:	605a      	str	r2, [r3, #4]
}
   1e140:	e7f0      	b.n	1e124 <cdc_acm_init+0x1c>
   1e142:	bf00      	nop
   1e144:	2000a930 	.word	0x2000a930
   1e148:	00024e19 	.word	0x00024e19
   1e14c:	0001e069 	.word	0x0001e069

0001e150 <cdc_acm_read_cb>:
{
   1e150:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1e152:	4614      	mov	r4, r2
	wrote = ring_buf_put(dev_data->rx_ringbuf, dev_data->rx_buf, size);
   1e154:	f102 064c 	add.w	r6, r2, #76	; 0x4c
	if (size <= 0) {
   1e158:	1e0a      	subs	r2, r1, #0
{
   1e15a:	4605      	mov	r5, r0
	if (size <= 0) {
   1e15c:	dd1f      	ble.n	1e19e <cdc_acm_read_cb+0x4e>
	wrote = ring_buf_put(dev_data->rx_ringbuf, dev_data->rx_buf, size);
   1e15e:	4631      	mov	r1, r6
   1e160:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   1e164:	f006 fd1f 	bl	24ba6 <ring_buf_put>
	dev_data->rx_ready = true;
   1e168:	2301      	movs	r3, #1
   1e16a:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
	if (dev_data->cb && dev_data->rx_irq_ena) {
   1e16e:	6823      	ldr	r3, [r4, #0]
   1e170:	b13b      	cbz	r3, 1e182 <cdc_acm_read_cb+0x32>
   1e172:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
   1e176:	b123      	cbz	r3, 1e182 <cdc_acm_read_cb+0x32>
		k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e178:	480e      	ldr	r0, [pc, #56]	; (1e1b4 <cdc_acm_read_cb+0x64>)
   1e17a:	f104 0108 	add.w	r1, r4, #8
   1e17e:	f007 fdfe 	bl	25d7e <k_work_submit_to_queue>
	if (ring_buf_space_get(dev_data->rx_ringbuf) < sizeof(dev_data->rx_buf)) {
   1e182:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 *
 * @return Ring buffer free space (in bytes).
 */
static inline uint32_t ring_buf_space_get(struct ring_buf *buf)
{
	return buf->size - (buf->put_head - buf->get_tail);
   1e186:	684b      	ldr	r3, [r1, #4]
   1e188:	694a      	ldr	r2, [r1, #20]
   1e18a:	1a9a      	subs	r2, r3, r2
   1e18c:	69cb      	ldr	r3, [r1, #28]
   1e18e:	1a9b      	subs	r3, r3, r2
   1e190:	2b3f      	cmp	r3, #63	; 0x3f
   1e192:	d804      	bhi.n	1e19e <cdc_acm_read_cb+0x4e>
		dev_data->rx_paused = true;
   1e194:	2301      	movs	r3, #1
   1e196:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
}
   1e19a:	b002      	add	sp, #8
   1e19c:	bd70      	pop	{r4, r5, r6, pc}
	usb_transfer(ep, dev_data->rx_buf, sizeof(dev_data->rx_buf),
   1e19e:	4b06      	ldr	r3, [pc, #24]	; (1e1b8 <cdc_acm_read_cb+0x68>)
   1e1a0:	2240      	movs	r2, #64	; 0x40
   1e1a2:	9300      	str	r3, [sp, #0]
   1e1a4:	4631      	mov	r1, r6
   1e1a6:	2301      	movs	r3, #1
   1e1a8:	4628      	mov	r0, r5
   1e1aa:	9401      	str	r4, [sp, #4]
   1e1ac:	f7ff fdca 	bl	1dd44 <usb_transfer>
   1e1b0:	e7f3      	b.n	1e19a <cdc_acm_read_cb+0x4a>
   1e1b2:	bf00      	nop
   1e1b4:	2000a410 	.word	0x2000a410
   1e1b8:	0001e151 	.word	0x0001e151

0001e1bc <cdc_acm_dev_status_cb>:
{
   1e1bc:	b538      	push	{r3, r4, r5, lr}
   1e1be:	460d      	mov	r5, r1
	common = usb_get_dev_data_by_cfg(&cdc_acm_data_devlist, cfg);
   1e1c0:	4601      	mov	r1, r0
   1e1c2:	481e      	ldr	r0, [pc, #120]	; (1e23c <cdc_acm_dev_status_cb+0x80>)
   1e1c4:	f006 fde5 	bl	24d92 <usb_get_dev_data_by_cfg>
	if (common == NULL) {
   1e1c8:	4604      	mov	r4, r0
   1e1ca:	b380      	cbz	r0, 1e22e <cdc_acm_dev_status_cb+0x72>
	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);
   1e1cc:	4602      	mov	r2, r0
	struct usb_cfg_data *cfg = (void *)dev->config;
   1e1ce:	f852 39a4 	ldr.w	r3, [r2], #-164
	switch (status) {
   1e1d2:	1e69      	subs	r1, r5, #1
	struct usb_cfg_data *cfg = (void *)dev->config;
   1e1d4:	685b      	ldr	r3, [r3, #4]
	switch (status) {
   1e1d6:	2905      	cmp	r1, #5
   1e1d8:	d829      	bhi.n	1e22e <cdc_acm_dev_status_cb+0x72>
   1e1da:	e8df f001 	tbb	[pc, r1]
   1e1de:	2820      	.short	0x2820
   1e1e0:	29252003 	.word	0x29252003
		if (!dev_data->configured) {
   1e1e4:	f814 1c06 	ldrb.w	r1, [r4, #-6]
   1e1e8:	b931      	cbnz	r1, 1e1f8 <cdc_acm_dev_status_cb+0x3c>
			cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr, 0,
   1e1ea:	6a1b      	ldr	r3, [r3, #32]
   1e1ec:	7b18      	ldrb	r0, [r3, #12]
   1e1ee:	f7ff ffaf 	bl	1e150 <cdc_acm_read_cb>
			dev_data->configured = true;
   1e1f2:	2301      	movs	r3, #1
   1e1f4:	f804 3c06 	strb.w	r3, [r4, #-6]
		if (!dev_data->tx_ready) {
   1e1f8:	f814 3c5c 	ldrb.w	r3, [r4, #-92]
   1e1fc:	b9bb      	cbnz	r3, 1e22e <cdc_acm_dev_status_cb+0x72>
			dev_data->tx_ready = true;
   1e1fe:	2301      	movs	r3, #1
   1e200:	f804 3c5c 	strb.w	r3, [r4, #-92]
			if (dev_data->cb != NULL && dev_data->tx_irq_ena) {
   1e204:	f854 3ca4 	ldr.w	r3, [r4, #-164]
   1e208:	b18b      	cbz	r3, 1e22e <cdc_acm_dev_status_cb+0x72>
   1e20a:	f814 3c5a 	ldrb.w	r3, [r4, #-90]
   1e20e:	b173      	cbz	r3, 1e22e <cdc_acm_dev_status_cb+0x72>
				k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e210:	f1a4 019c 	sub.w	r1, r4, #156	; 0x9c
   1e214:	480a      	ldr	r0, [pc, #40]	; (1e240 <cdc_acm_dev_status_cb+0x84>)
}
   1e216:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				k_work_submit_to_queue(&USB_WORK_Q, &dev_data->cb_work);
   1e21a:	f007 bdb0 	b.w	25d7e <k_work_submit_to_queue>
		cdc_acm_reset_port(dev_data);
   1e21e:	4610      	mov	r0, r2
}
   1e220:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		cdc_acm_reset_port(dev_data);
   1e224:	f7ff beb4 	b.w	1df90 <cdc_acm_reset_port>
		dev_data->suspended = true;
   1e228:	2301      	movs	r3, #1
			dev_data->suspended = false;
   1e22a:	f804 3c05 	strb.w	r3, [r4, #-5]
}
   1e22e:	bd38      	pop	{r3, r4, r5, pc}
		if (dev_data->suspended) {
   1e230:	f814 3c05 	ldrb.w	r3, [r4, #-5]
   1e234:	2b00      	cmp	r3, #0
   1e236:	d0fa      	beq.n	1e22e <cdc_acm_dev_status_cb+0x72>
			dev_data->suspended = false;
   1e238:	2300      	movs	r3, #0
   1e23a:	e7f6      	b.n	1e22a <cdc_acm_dev_status_cb+0x6e>
   1e23c:	2000a930 	.word	0x2000a930
   1e240:	2000a410 	.word	0x2000a410

0001e244 <z_usb_work_q_init>:
K_KERNEL_STACK_DEFINE(z_usb_work_q_stack, CONFIG_USB_WORKQUEUE_STACK_SIZE);

struct k_work_q z_usb_work_q;

static int z_usb_work_q_init(void)
{
   1e244:	b537      	push	{r0, r1, r2, r4, r5, lr}

	k_work_queue_start(&z_usb_work_q,
   1e246:	2400      	movs	r4, #0
   1e248:	4d08      	ldr	r5, [pc, #32]	; (1e26c <z_usb_work_q_init+0x28>)
   1e24a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1e24e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1e252:	4628      	mov	r0, r5
   1e254:	4906      	ldr	r1, [pc, #24]	; (1e270 <z_usb_work_q_init+0x2c>)
   1e256:	9400      	str	r4, [sp, #0]
   1e258:	f005 fac6 	bl	237e8 <k_work_queue_start>
	return z_impl_k_thread_name_set(thread, str);
   1e25c:	4905      	ldr	r1, [pc, #20]	; (1e274 <z_usb_work_q_init+0x30>)
   1e25e:	4628      	mov	r0, r5
   1e260:	f007 fc9f 	bl	25ba2 <z_impl_k_thread_name_set>
			   K_KERNEL_STACK_SIZEOF(z_usb_work_q_stack),
			   CONFIG_USB_WORKQUEUE_PRIORITY, NULL);
	k_thread_name_set(&z_usb_work_q.thread, "usbworkq");

	return 0;
}
   1e264:	4620      	mov	r0, r4
   1e266:	b003      	add	sp, #12
   1e268:	bd30      	pop	{r4, r5, pc}
   1e26a:	bf00      	nop
   1e26c:	2000a410 	.word	0x2000a410
   1e270:	2000b630 	.word	0x2000b630
   1e274:	00026a1b 	.word	0x00026a1b

0001e278 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   1e278:	4901      	ldr	r1, [pc, #4]	; (1e280 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   1e27a:	2210      	movs	r2, #16
	str	r2, [r1]
   1e27c:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   1e27e:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   1e280:	e000ed10 	.word	0xe000ed10

0001e284 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   1e284:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   1e286:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   1e288:	f380 8811 	msr	BASEPRI, r0
	isb
   1e28c:	f3bf 8f6f 	isb	sy
	 * (i.e. if the caller sets _kernel.idle).
	 */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */

	/* Enter low power state */
	_sleep_if_allowed wfi
   1e290:	b501      	push	{r0, lr}
   1e292:	f7fe fde9 	bl	1ce68 <z_arm_on_enter_cpu_idle>
   1e296:	2800      	cmp	r0, #0
   1e298:	d002      	beq.n	1e2a0 <_skip_0>
   1e29a:	f3bf 8f4f 	dsb	sy
   1e29e:	bf30      	wfi

0001e2a0 <_skip_0>:
   1e2a0:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   1e2a4:	b662      	cpsie	i
	isb
   1e2a6:	f3bf 8f6f 	isb	sy

	bx	lr
   1e2aa:	4770      	bx	lr

0001e2ac <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
   1e2ac:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
   1e2ae:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
   1e2b0:	f381 8811 	msr	BASEPRI, r1

	_sleep_if_allowed wfe
   1e2b4:	b501      	push	{r0, lr}
   1e2b6:	f7fe fdd7 	bl	1ce68 <z_arm_on_enter_cpu_idle>
   1e2ba:	2800      	cmp	r0, #0
   1e2bc:	d002      	beq.n	1e2c4 <_skip_1>
   1e2be:	f3bf 8f4f 	dsb	sy
   1e2c2:	bf20      	wfe

0001e2c4 <_skip_1>:
   1e2c4:	e8bd 4001 	ldmia.w	sp!, {r0, lr}

	msr	BASEPRI, r0
   1e2c8:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
   1e2cc:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
   1e2ce:	4770      	bx	lr

0001e2d0 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   1e2d0:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   1e2d2:	2800      	cmp	r0, #0
   1e2d4:	db07      	blt.n	1e2e6 <arch_irq_enable+0x16>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1e2d6:	2301      	movs	r3, #1
   1e2d8:	0941      	lsrs	r1, r0, #5
   1e2da:	4a03      	ldr	r2, [pc, #12]	; (1e2e8 <arch_irq_enable+0x18>)
   1e2dc:	f000 001f 	and.w	r0, r0, #31
   1e2e0:	4083      	lsls	r3, r0
   1e2e2:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
   1e2e6:	4770      	bx	lr
   1e2e8:	e000e100 	.word	0xe000e100

0001e2ec <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
   1e2ec:	b240      	sxtb	r0, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   1e2ee:	2800      	cmp	r0, #0
   1e2f0:	db0c      	blt.n	1e30c <arch_irq_disable+0x20>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1e2f2:	2201      	movs	r2, #1
   1e2f4:	4906      	ldr	r1, [pc, #24]	; (1e310 <arch_irq_disable+0x24>)
   1e2f6:	0943      	lsrs	r3, r0, #5
   1e2f8:	f000 001f 	and.w	r0, r0, #31
   1e2fc:	4082      	lsls	r2, r0
   1e2fe:	3320      	adds	r3, #32
   1e300:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   1e304:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e308:	f3bf 8f6f 	isb	sy
}
   1e30c:	4770      	bx	lr
   1e30e:	bf00      	nop
   1e310:	e000e100 	.word	0xe000e100

0001e314 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
   1e314:	4b05      	ldr	r3, [pc, #20]	; (1e32c <arch_irq_is_enabled+0x18>)
   1e316:	0942      	lsrs	r2, r0, #5
   1e318:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   1e31c:	2301      	movs	r3, #1
   1e31e:	f000 001f 	and.w	r0, r0, #31
   1e322:	fa03 f000 	lsl.w	r0, r3, r0
}
   1e326:	4010      	ands	r0, r2
   1e328:	4770      	bx	lr
   1e32a:	bf00      	nop
   1e32c:	e000e100 	.word	0xe000e100

0001e330 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   1e330:	b240      	sxtb	r0, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   1e332:	2800      	cmp	r0, #0
		prio += _IRQ_PRIO_OFFSET;
   1e334:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e338:	bfac      	ite	ge
   1e33a:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e33e:	4b06      	ldrlt	r3, [pc, #24]	; (1e358 <z_arm_irq_priority_set+0x28>)
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e340:	ea4f 1141 	mov.w	r1, r1, lsl #5
   1e344:	b2c9      	uxtb	r1, r1
   1e346:	bfab      	itete	ge
   1e348:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e34c:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e350:	f880 1300 	strbge.w	r1, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e354:	5419      	strblt	r1, [r3, r0]
}
   1e356:	4770      	bx	lr
   1e358:	e000ed14 	.word	0xe000ed14

0001e35c <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   1e35c:	bf30      	wfi
    b z_SysNmiOnReset
   1e35e:	f7ff bffd 	b.w	1e35c <z_SysNmiOnReset>
   1e362:	bf00      	nop

0001e364 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   1e364:	4a0b      	ldr	r2, [pc, #44]	; (1e394 <z_arm_prep_c+0x30>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
   1e366:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   1e368:	4b0b      	ldr	r3, [pc, #44]	; (1e398 <z_arm_prep_c+0x34>)
   1e36a:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   1e36e:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
   1e370:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e374:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   1e378:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1e37c:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   1e380:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   1e384:	f004 fe28 	bl	22fd8 <z_bss_zero>
	z_data_copy();
   1e388:	f005 fdfe 	bl	23f88 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   1e38c:	f000 fa08 	bl	1e7a0 <z_arm_interrupt_init>
	z_cstart();
   1e390:	f004 fe62 	bl	23058 <z_cstart>
   1e394:	0001c000 	.word	0x0001c000
   1e398:	e000ed00 	.word	0xe000ed00

0001e39c <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
   1e39c:	4a09      	ldr	r2, [pc, #36]	; (1e3c4 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   1e39e:	490a      	ldr	r1, [pc, #40]	; (1e3c8 <arch_swap+0x2c>)
	_current->arch.basepri = key;
   1e3a0:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   1e3a2:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   1e3a4:	6758      	str	r0, [r3, #116]	; 0x74
	_current->arch.swap_return_value = _k_neg_eagain;
   1e3a6:	6799      	str	r1, [r3, #120]	; 0x78

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1e3a8:	4908      	ldr	r1, [pc, #32]	; (1e3cc <arch_swap+0x30>)
   1e3aa:	684b      	ldr	r3, [r1, #4]
   1e3ac:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   1e3b0:	604b      	str	r3, [r1, #4]
   1e3b2:	2300      	movs	r3, #0
   1e3b4:	f383 8811 	msr	BASEPRI, r3
   1e3b8:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   1e3bc:	6893      	ldr	r3, [r2, #8]
}
   1e3be:	6f98      	ldr	r0, [r3, #120]	; 0x78
   1e3c0:	4770      	bx	lr
   1e3c2:	bf00      	nop
   1e3c4:	2000b5b4 	.word	0x2000b5b4
   1e3c8:	0002696c 	.word	0x0002696c
   1e3cc:	e000ed00 	.word	0xe000ed00

0001e3d0 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   1e3d0:	4915      	ldr	r1, [pc, #84]	; (1e428 <z_arm_pendsv+0x58>)
    ldr r2, [r1, #_kernel_offset_to_current]
   1e3d2:	688a      	ldr	r2, [r1, #8]

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
   1e3d4:	f882 e07d 	strb.w	lr, [r2, #125]	; 0x7d
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   1e3d8:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   1e3dc:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   1e3de:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   1e3e2:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   1e3e6:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
   1e3e8:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   1e3ec:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   1e3f0:	4f0e      	ldr	r7, [pc, #56]	; (1e42c <z_arm_pendsv+0x5c>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   1e3f2:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   1e3f6:	698a      	ldr	r2, [r1, #24]

    str r2, [r1, #_kernel_offset_to_current]
   1e3f8:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   1e3fa:	603e      	str	r6, [r7, #0]

#endif

#if defined(CONFIG_ARM_STORE_EXC_RETURN)
    /* Restore EXC_RETURN value. */
    ldrsb lr, [r2, #_thread_offset_to_mode_exc_return]
   1e3fc:	f992 e07d 	ldrsb.w	lr, [r2, #125]	; 0x7d

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   1e400:	6f50      	ldr	r0, [r2, #116]	; 0x74
    movs r3, #0
   1e402:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   1e404:	6753      	str	r3, [r2, #116]	; 0x74
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   1e406:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   1e40a:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   1e40e:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   1e412:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   1e416:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   1e41a:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   1e41c:	f006 fd9d 	bl	24f5a <configure_builtin_stack_guard>
    pop {r2, lr}
   1e420:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
   1e424:	4770      	bx	lr
   1e426:	0000      	.short	0x0000
    ldr r1, =_kernel
   1e428:	2000b5b4 	.word	0x2000b5b4
    ldr v4, =_SCS_ICSR
   1e42c:	e000ed04 	.word	0xe000ed04

0001e430 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
   1e430:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   1e434:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   1e436:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   1e43a:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   1e43e:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   1e440:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   1e444:	2902      	cmp	r1, #2
    beq _oops
   1e446:	d0ff      	beq.n	1e448 <_oops>

0001e448 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   1e448:	b501      	push	{r0, lr}
    push {r1, r2}
    push {r4-r11}
    mov  r1, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    bl z_do_kernel_oops
   1e44a:	f006 fd77 	bl	24f3c <z_do_kernel_oops>
     * the MSP to its value prior to entering the function
     */
    add sp, #40
#endif /* CONFIG_ARMV7_M_ARMV8_M_MAINLINE */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
    pop {r0, pc}
   1e44e:	bd01      	pop	{r0, pc}

0001e450 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
   1e450:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
   1e454:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
   1e456:	490c      	ldr	r1, [pc, #48]	; (1e488 <arch_new_thread+0x38>)
	iframe->a2 = (uint32_t)p1;
   1e458:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
   1e45c:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
   1e45e:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
   1e462:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
   1e466:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
   1e468:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
   1e46c:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
   1e470:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   1e474:	f842 3c04 	str.w	r3, [r2, #-4]
		((uintptr_t)iframe - sizeof(struct __fpu_sf));
	memset(iframe, 0, sizeof(struct __fpu_sf));
#endif

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
   1e478:	2300      	movs	r3, #0
   1e47a:	6743      	str	r3, [r0, #116]	; 0x74

#if defined(CONFIG_ARM_STORE_EXC_RETURN) || defined(CONFIG_USERSPACE)
	thread->arch.mode = 0;
   1e47c:	f44f 433c 	mov.w	r3, #48128	; 0xbc00
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
   1e480:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
   1e482:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.mode = 0;
   1e484:	67c3      	str	r3, [r0, #124]	; 0x7c
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   1e486:	4770      	bx	lr
   1e488:	00024481 	.word	0x00024481

0001e48c <arch_switch_to_main_thread>:
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
	z_arm_prepare_switch_to_main();

	_current = main_thread;
   1e48c:	4b08      	ldr	r3, [pc, #32]	; (1e4b0 <arch_switch_to_main_thread+0x24>)
   1e48e:	6098      	str	r0, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   1e490:	6e43      	ldr	r3, [r0, #100]	; 0x64
   1e492:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   1e496:	4610      	mov	r0, r2
   1e498:	f381 8809 	msr	PSP, r1
   1e49c:	2100      	movs	r1, #0
   1e49e:	b663      	cpsie	if
   1e4a0:	f381 8811 	msr	BASEPRI, r1
   1e4a4:	f3bf 8f6f 	isb	sy
   1e4a8:	2200      	movs	r2, #0
   1e4aa:	2300      	movs	r3, #0
   1e4ac:	f005 ffe8 	bl	24480 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   1e4b0:	2000b5b4 	.word	0x2000b5b4

0001e4b4 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   1e4b4:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   1e4b6:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   1e4b8:	4a0b      	ldr	r2, [pc, #44]	; (1e4e8 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   1e4ba:	6950      	ldr	r0, [r2, #20]
	cmp r0, #0
   1e4bc:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   1e4be:	bf1e      	ittt	ne
	movne	r1, #0
   1e4c0:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   1e4c2:	6151      	strne	r1, [r2, #20]
		blne	z_pm_save_idle_exit
   1e4c4:	f007 fb72 	blne	25bac <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   1e4c8:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   1e4ca:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   1e4ce:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   1e4d2:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   1e4d6:	4905      	ldr	r1, [pc, #20]	; (1e4ec <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   1e4d8:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   1e4da:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
   1e4dc:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   1e4de:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   1e4e2:	4903      	ldr	r1, [pc, #12]	; (1e4f0 <_isr_wrapper+0x3c>)
	bx r1
   1e4e4:	4708      	bx	r1
   1e4e6:	0000      	.short	0x0000
	ldr r2, =_kernel
   1e4e8:	2000b5b4 	.word	0x2000b5b4
	ldr r1, =_sw_isr_table
   1e4ec:	000262f0 	.word	0x000262f0
	ldr r1, =z_arm_int_exit
   1e4f0:	0001e4f5 	.word	0x0001e4f5

0001e4f4 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   1e4f4:	4b04      	ldr	r3, [pc, #16]	; (1e508 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   1e4f6:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   1e4f8:	6998      	ldr	r0, [r3, #24]
	cmp r0, r1
   1e4fa:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   1e4fc:	d003      	beq.n	1e506 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   1e4fe:	4903      	ldr	r1, [pc, #12]	; (1e50c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   1e500:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   1e504:	600a      	str	r2, [r1, #0]

0001e506 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   1e506:	4770      	bx	lr
	ldr r3, =_kernel
   1e508:	2000b5b4 	.word	0x2000b5b4
	ldr r1, =_SCS_ICSR
   1e50c:	e000ed04 	.word	0xe000ed04

0001e510 <usage_fault.constprop.0>:
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   1e510:	4b15      	ldr	r3, [pc, #84]	; (1e568 <usage_fault.constprop.0+0x58>)
   1e512:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
   1e514:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
		reason = K_ERR_ARM_USAGE_DIV_0;
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   1e518:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
   1e51a:	bf14      	ite	ne
   1e51c:	201e      	movne	r0, #30
   1e51e:	201d      	moveq	r0, #29
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
   1e520:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
		PR_FAULT_INFO("  Unaligned memory access");
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   1e524:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
   1e526:	bf18      	it	ne
   1e528:	201f      	movne	r0, #31
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   1e52a:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   1e52e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_STACK_CHK_FAIL;
   1e530:	bf18      	it	ne
   1e532:	2002      	movne	r0, #2
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
   1e534:	f412 2f00 	tst.w	r2, #524288	; 0x80000
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   1e538:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
   1e53a:	bf18      	it	ne
   1e53c:	2021      	movne	r0, #33	; 0x21
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
   1e53e:	f412 2f80 	tst.w	r2, #262144	; 0x40000
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   1e542:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
   1e544:	bf18      	it	ne
   1e546:	2022      	movne	r0, #34	; 0x22
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
   1e548:	f412 3f00 	tst.w	r2, #131072	; 0x20000
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   1e54c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
   1e54e:	bf18      	it	ne
   1e550:	2023      	movne	r0, #35	; 0x23
		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
   1e552:	f412 3f80 	tst.w	r2, #65536	; 0x10000
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   1e556:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	return reason;
}
   1e558:	bf18      	it	ne
   1e55a:	2024      	movne	r0, #36	; 0x24
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   1e55c:	ea6f 4202 	mvn.w	r2, r2, lsl #16
   1e560:	ea6f 4212 	mvn.w	r2, r2, lsr #16
   1e564:	629a      	str	r2, [r3, #40]	; 0x28
}
   1e566:	4770      	bx	lr
   1e568:	e000ed00 	.word	0xe000ed00

0001e56c <bus_fault.constprop.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1e56c:	b510      	push	{r4, lr}
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   1e56e:	4b19      	ldr	r3, [pc, #100]	; (1e5d4 <bus_fault.constprop.0+0x68>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1e570:	4602      	mov	r2, r0
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   1e572:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   1e574:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
   1e576:	f410 5f80 	tst.w	r0, #4096	; 0x1000
   1e57a:	bf14      	ite	ne
   1e57c:	2017      	movne	r0, #23
   1e57e:	2016      	moveq	r0, #22
		reason = K_ERR_ARM_BUS_UNSTACKING;
   1e580:	f414 6f00 	tst.w	r4, #2048	; 0x800
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   1e584:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_UNSTACKING;
   1e586:	bf18      	it	ne
   1e588:	2018      	movne	r0, #24
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   1e58a:	05a4      	lsls	r4, r4, #22
   1e58c:	d509      	bpl.n	1e5a2 <bus_fault.constprop.0+0x36>
		STORE_xFAR(bfar, SCB->BFAR);
   1e58e:	6b98      	ldr	r0, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   1e590:	6a98      	ldr	r0, [r3, #40]	; 0x28
   1e592:	0400      	lsls	r0, r0, #16
   1e594:	d504      	bpl.n	1e5a0 <bus_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
   1e596:	b11a      	cbz	r2, 1e5a0 <bus_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   1e598:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e59a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   1e59e:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
   1e5a0:	2019      	movs	r0, #25
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   1e5a2:	4b0c      	ldr	r3, [pc, #48]	; (1e5d4 <bus_fault.constprop.0+0x68>)
   1e5a4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
   1e5a6:	f412 6f80 	tst.w	r2, #1024	; 0x400
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   1e5aa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
   1e5ac:	bf18      	it	ne
   1e5ae:	201a      	movne	r0, #26
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   1e5b0:	05d2      	lsls	r2, r2, #23
   1e5b2:	d40c      	bmi.n	1e5ce <bus_fault.constprop.0+0x62>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   1e5b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
   1e5b6:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   1e5ba:	bf18      	it	ne
   1e5bc:	201c      	movne	r0, #28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   1e5be:	4a05      	ldr	r2, [pc, #20]	; (1e5d4 <bus_fault.constprop.0+0x68>)
   1e5c0:	6a93      	ldr	r3, [r2, #40]	; 0x28
   1e5c2:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   1e5c6:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   1e5c8:	2300      	movs	r3, #0
   1e5ca:	700b      	strb	r3, [r1, #0]
}
   1e5cc:	bd10      	pop	{r4, pc}
		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
   1e5ce:	201b      	movs	r0, #27
   1e5d0:	e7f5      	b.n	1e5be <bus_fault.constprop.0+0x52>
   1e5d2:	bf00      	nop
   1e5d4:	e000ed00 	.word	0xe000ed00

0001e5d8 <mem_manage_fault.constprop.0>:
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   1e5d8:	b510      	push	{r4, lr}
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   1e5da:	4b1c      	ldr	r3, [pc, #112]	; (1e64c <mem_manage_fault.constprop.0+0x74>)
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   1e5dc:	4602      	mov	r2, r0
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   1e5de:	6a98      	ldr	r0, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   1e5e0:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
   1e5e2:	f010 0f10 	tst.w	r0, #16
   1e5e6:	bf14      	ite	ne
   1e5e8:	2011      	movne	r0, #17
   1e5ea:	2010      	moveq	r0, #16
		reason = K_ERR_ARM_MEM_UNSTACKING;
   1e5ec:	f014 0f08 	tst.w	r4, #8
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   1e5f0:	6a9c      	ldr	r4, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_UNSTACKING;
   1e5f2:	bf18      	it	ne
   1e5f4:	2012      	movne	r0, #18
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   1e5f6:	07a4      	lsls	r4, r4, #30
   1e5f8:	d509      	bpl.n	1e60e <mem_manage_fault.constprop.0+0x36>
		uint32_t temp = SCB->MMFAR;
   1e5fa:	6b58      	ldr	r0, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   1e5fc:	6a98      	ldr	r0, [r3, #40]	; 0x28
   1e5fe:	0600      	lsls	r0, r0, #24
   1e600:	d504      	bpl.n	1e60c <mem_manage_fault.constprop.0+0x34>
			if (from_hard_fault != 0) {
   1e602:	b11a      	cbz	r2, 1e60c <mem_manage_fault.constprop.0+0x34>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   1e604:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e606:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   1e60a:	629a      	str	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_DATA_ACCESS;
   1e60c:	2013      	movs	r0, #19
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   1e60e:	4b0f      	ldr	r3, [pc, #60]	; (1e64c <mem_manage_fault.constprop.0+0x74>)
   1e610:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
   1e612:	f012 0f01 	tst.w	r2, #1
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   1e616:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
   1e618:	bf18      	it	ne
   1e61a:	2014      	movne	r0, #20
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
   1e61c:	f012 0f20 	tst.w	r2, #32
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   1e620:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
   1e622:	bf18      	it	ne
   1e624:	2015      	movne	r0, #21
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
   1e626:	06d4      	lsls	r4, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
   1e628:	bf58      	it	pl
   1e62a:	6a9b      	ldrpl	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   1e62c:	4b07      	ldr	r3, [pc, #28]	; (1e64c <mem_manage_fault.constprop.0+0x74>)
   1e62e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e630:	0692      	lsls	r2, r2, #26
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
   1e632:	bf42      	ittt	mi
   1e634:	6a5a      	ldrmi	r2, [r3, #36]	; 0x24
   1e636:	f422 5200 	bicmi.w	r2, r2, #8192	; 0x2000
   1e63a:	625a      	strmi	r2, [r3, #36]	; 0x24
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   1e63c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e63e:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
   1e642:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
   1e644:	2300      	movs	r3, #0
   1e646:	700b      	strb	r3, [r1, #0]
}
   1e648:	bd10      	pop	{r4, pc}
   1e64a:	bf00      	nop
   1e64c:	e000ed00 	.word	0xe000ed00

0001e650 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
   1e650:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   1e652:	4b47      	ldr	r3, [pc, #284]	; (1e770 <z_arm_fault+0x120>)
{
   1e654:	4605      	mov	r5, r0
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   1e656:	685b      	ldr	r3, [r3, #4]
   1e658:	2600      	movs	r6, #0
{
   1e65a:	b08a      	sub	sp, #40	; 0x28
   1e65c:	f3c3 0308 	ubfx	r3, r3, #0, #9
   1e660:	f386 8811 	msr	BASEPRI, r6
   1e664:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   1e668:	f002 407f 	and.w	r0, r2, #4278190080	; 0xff000000
   1e66c:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
   1e670:	d116      	bne.n	1e6a0 <z_arm_fault+0x50>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   1e672:	07d0      	lsls	r0, r2, #31
   1e674:	d414      	bmi.n	1e6a0 <z_arm_fault+0x50>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   1e676:	0654      	lsls	r4, r2, #25
   1e678:	d403      	bmi.n	1e682 <z_arm_fault+0x32>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   1e67a:	0710      	lsls	r0, r2, #28
   1e67c:	d404      	bmi.n	1e688 <z_arm_fault+0x38>
			*nested_exc = true;
   1e67e:	2601      	movs	r6, #1
   1e680:	e004      	b.n	1e68c <z_arm_fault+0x3c>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   1e682:	f012 0204 	ands.w	r2, r2, #4
   1e686:	d000      	beq.n	1e68a <z_arm_fault+0x3a>
			ptr_esf = (z_arch_esf_t *)psp;
   1e688:	460d      	mov	r5, r1
	*nested_exc = false;
   1e68a:	2600      	movs	r6, #0
	*recoverable = false;
   1e68c:	2200      	movs	r2, #0
	switch (fault) {
   1e68e:	3b03      	subs	r3, #3
	*recoverable = false;
   1e690:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
   1e694:	2b03      	cmp	r3, #3
   1e696:	d805      	bhi.n	1e6a4 <z_arm_fault+0x54>
   1e698:	e8df f003 	tbb	[pc, r3]
   1e69c:	59605c1e 	.word	0x59605c1e
		return NULL;
   1e6a0:	4635      	mov	r5, r6
   1e6a2:	e7f3      	b.n	1e68c <z_arm_fault+0x3c>
   1e6a4:	2400      	movs	r4, #0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   1e6a6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1e6aa:	b99b      	cbnz	r3, 1e6d4 <z_arm_fault+0x84>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   1e6ac:	2220      	movs	r2, #32
   1e6ae:	4629      	mov	r1, r5
   1e6b0:	a802      	add	r0, sp, #8
   1e6b2:	f006 fc8e 	bl	24fd2 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   1e6b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1e6b8:	2e00      	cmp	r6, #0
   1e6ba:	d053      	beq.n	1e764 <z_arm_fault+0x114>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   1e6bc:	f3c3 0208 	ubfx	r2, r3, #0, #9
   1e6c0:	b922      	cbnz	r2, 1e6cc <z_arm_fault+0x7c>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   1e6c2:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   1e6c6:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1e6ca:	9309      	str	r3, [sp, #36]	; 0x24

	if (IS_ENABLED(CONFIG_SIMPLIFIED_EXCEPTION_CODES) && (reason >= K_ERR_ARCH_START)) {
		reason = K_ERR_CPU_EXCEPTION;
	}

	z_arm_fatal_error(reason, &esf_copy);
   1e6cc:	4620      	mov	r0, r4
   1e6ce:	a902      	add	r1, sp, #8
   1e6d0:	f006 fc32 	bl	24f38 <z_arm_fatal_error>
}
   1e6d4:	b00a      	add	sp, #40	; 0x28
   1e6d6:	bd70      	pop	{r4, r5, r6, pc}
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   1e6d8:	4b25      	ldr	r3, [pc, #148]	; (1e770 <z_arm_fault+0x120>)
   1e6da:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1e6dc:	0791      	lsls	r1, r2, #30
   1e6de:	d4e1      	bmi.n	1e6a4 <z_arm_fault+0x54>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
   1e6e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1e6e2:	2a00      	cmp	r2, #0
   1e6e4:	dbde      	blt.n	1e6a4 <z_arm_fault+0x54>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   1e6e6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1e6e8:	0052      	lsls	r2, r2, #1
   1e6ea:	d5db      	bpl.n	1e6a4 <z_arm_fault+0x54>
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
   1e6ec:	695a      	ldr	r2, [r3, #20]
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
   1e6ee:	69a9      	ldr	r1, [r5, #24]
	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
   1e6f0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   1e6f4:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
   1e6f6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e6fa:	f3bf 8f6f 	isb	sy
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
   1e6fe:	695a      	ldr	r2, [r3, #20]
	uint16_t fault_insn = *(ret_addr - 1);
   1e700:	f831 1c02 	ldrh.w	r1, [r1, #-2]
	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
   1e704:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   1e708:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
   1e70a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e70e:	f3bf 8f6f 	isb	sy
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
   1e712:	f64d 7202 	movw	r2, #57090	; 0xdf02
   1e716:	4291      	cmp	r1, r2
   1e718:	d101      	bne.n	1e71e <z_arm_fault+0xce>
			reason = esf->basic.r0;
   1e71a:	682c      	ldr	r4, [r5, #0]
   1e71c:	e7c3      	b.n	1e6a6 <z_arm_fault+0x56>
		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
   1e71e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e720:	b2d2      	uxtb	r2, r2
   1e722:	b132      	cbz	r2, 1e732 <z_arm_fault+0xe2>
			reason = mem_manage_fault(esf, 1, recoverable);
   1e724:	2001      	movs	r0, #1
   1e726:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   1e72a:	f7ff ff55 	bl	1e5d8 <mem_manage_fault.constprop.0>
		reason = usage_fault(esf);
   1e72e:	4604      	mov	r4, r0
		break;
   1e730:	e7b9      	b.n	1e6a6 <z_arm_fault+0x56>
		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
   1e732:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1e734:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
   1e738:	d005      	beq.n	1e746 <z_arm_fault+0xf6>
			reason = bus_fault(esf, 1, recoverable);
   1e73a:	2001      	movs	r0, #1
   1e73c:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   1e740:	f7ff ff14 	bl	1e56c <bus_fault.constprop.0>
   1e744:	e7f3      	b.n	1e72e <z_arm_fault+0xde>
		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
   1e746:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1e748:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   1e74c:	d3aa      	bcc.n	1e6a4 <z_arm_fault+0x54>
		reason = usage_fault(esf);
   1e74e:	f7ff fedf 	bl	1e510 <usage_fault.constprop.0>
   1e752:	e7ec      	b.n	1e72e <z_arm_fault+0xde>
		reason = mem_manage_fault(esf, 0, recoverable);
   1e754:	2000      	movs	r0, #0
   1e756:	f10d 0107 	add.w	r1, sp, #7
   1e75a:	e7e6      	b.n	1e72a <z_arm_fault+0xda>
		reason = bus_fault(esf, 0, recoverable);
   1e75c:	2000      	movs	r0, #0
   1e75e:	f10d 0107 	add.w	r1, sp, #7
   1e762:	e7ed      	b.n	1e740 <z_arm_fault+0xf0>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1e764:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   1e768:	f023 0301 	bic.w	r3, r3, #1
   1e76c:	e7ad      	b.n	1e6ca <z_arm_fault+0x7a>
   1e76e:	bf00      	nop
   1e770:	e000ed00 	.word	0xe000ed00

0001e774 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   1e774:	4b04      	ldr	r3, [pc, #16]	; (1e788 <z_arm_fault_init+0x14>)
   1e776:	695a      	ldr	r2, [r3, #20]
   1e778:	f042 0210 	orr.w	r2, r2, #16
   1e77c:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   1e77e:	695a      	ldr	r2, [r3, #20]
   1e780:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   1e784:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
   1e786:	4770      	bx	lr
   1e788:	e000ed00 	.word	0xe000ed00

0001e78c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   1e78c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   1e790:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
   1e794:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
   1e796:	4672      	mov	r2, lr
	bl z_arm_fault
   1e798:	f7ff ff5a 	bl	1e650 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
   1e79c:	bd01      	pop	{r0, pc}
   1e79e:	bf00      	nop

0001e7a0 <z_arm_interrupt_init>:
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   1e7a0:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1e7a2:	2120      	movs	r1, #32
   1e7a4:	4803      	ldr	r0, [pc, #12]	; (1e7b4 <z_arm_interrupt_init+0x14>)
   1e7a6:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   1e7a8:	3301      	adds	r3, #1
   1e7aa:	2b45      	cmp	r3, #69	; 0x45
   1e7ac:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   1e7b0:	d1f9      	bne.n	1e7a6 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   1e7b2:	4770      	bx	lr
   1e7b4:	e000e100 	.word	0xe000e100

0001e7b8 <__start>:
    strb r0, [r1]
#endif /* CONFIG_DEBUG_THREAD_INFO */

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
   1e7b8:	2000      	movs	r0, #0
    msr CONTROL, r0
   1e7ba:	f380 8814 	msr	CONTROL, r0
    isb
   1e7be:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
   1e7c2:	2000      	movs	r0, #0
    msr MSPLIM, r0
   1e7c4:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
   1e7c8:	f380 880b 	msr	PSPLIM, r0
#if defined(CONFIG_PM_S2RAM)
    bl arch_pm_s2ram_resume
#endif /* CONFIG_PM_S2RAM */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
   1e7cc:	f7fe fb92 	bl	1cef4 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
   1e7d0:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
   1e7d2:	490e      	ldr	r1, [pc, #56]	; (1e80c <__start+0x54>)
    str r0, [r1]
   1e7d4:	6008      	str	r0, [r1, #0]
    dsb
   1e7d6:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   1e7da:	480d      	ldr	r0, [pc, #52]	; (1e810 <__start+0x58>)
    msr msp, r0
   1e7dc:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
   1e7e0:	f000 f83e 	bl	1e860 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   1e7e4:	2020      	movs	r0, #32
    msr BASEPRI, r0
   1e7e6:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   1e7ea:	480a      	ldr	r0, [pc, #40]	; (1e814 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
   1e7ec:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   1e7f0:	1840      	adds	r0, r0, r1
    msr PSP, r0
   1e7f2:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   1e7f6:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   1e7fa:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   1e7fc:	4308      	orrs	r0, r1
    msr CONTROL, r0
   1e7fe:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   1e802:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   1e806:	f7ff fdad 	bl	1e364 <z_arm_prep_c>
   1e80a:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
   1e80c:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
   1e810:	2000cb70 	.word	0x2000cb70
    ldr r0, =z_interrupt_stacks
   1e814:	2000be30 	.word	0x2000be30

0001e818 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
   1e818:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   1e81c:	4905      	ldr	r1, [pc, #20]	; (1e834 <sys_arch_reboot+0x1c>)
   1e81e:	4b06      	ldr	r3, [pc, #24]	; (1e838 <sys_arch_reboot+0x20>)
   1e820:	68ca      	ldr	r2, [r1, #12]
   1e822:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   1e826:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   1e828:	60cb      	str	r3, [r1, #12]
   1e82a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   1e82e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
   1e830:	e7fd      	b.n	1e82e <sys_arch_reboot+0x16>
   1e832:	bf00      	nop
   1e834:	e000ed00 	.word	0xe000ed00
   1e838:	05fa0004 	.word	0x05fa0004

0001e83c <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
   1e83c:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
   1e83e:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
   1e840:	4906      	ldr	r1, [pc, #24]	; (1e85c <z_arm_clear_arm_mpu_config+0x20>)
   1e842:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90
	int num_regions =
   1e846:	f3c2 2207 	ubfx	r2, r2, #8, #8
	for (i = 0; i < num_regions; i++) {
   1e84a:	4293      	cmp	r3, r2
   1e84c:	db00      	blt.n	1e850 <z_arm_clear_arm_mpu_config+0x14>
		ARM_MPU_ClrRegion(i);
	}
}
   1e84e:	4770      	bx	lr
  mpu->RNR = rnr;
   1e850:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
  mpu->RLAR = 0U;
   1e854:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0
	for (i = 0; i < num_regions; i++) {
   1e858:	3301      	adds	r3, #1
   1e85a:	e7f6      	b.n	1e84a <z_arm_clear_arm_mpu_config+0xe>
   1e85c:	e000ed00 	.word	0xe000ed00

0001e860 <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
   1e860:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
   1e862:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
   1e864:	2400      	movs	r4, #0
   1e866:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
   1e86a:	f7ff ffe7 	bl	1e83c <z_arm_clear_arm_mpu_config>
   1e86e:	4623      	mov	r3, r4
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
   1e870:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1e874:	4a0c      	ldr	r2, [pc, #48]	; (1e8a8 <z_arm_init_arch_hw_at_boot+0x48>)
   1e876:	f103 0120 	add.w	r1, r3, #32
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   1e87a:	3301      	adds	r3, #1
   1e87c:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
   1e87e:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
   1e882:	d1f8      	bne.n	1e876 <z_arm_init_arch_hw_at_boot+0x16>
   1e884:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
   1e886:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1e88a:	4a07      	ldr	r2, [pc, #28]	; (1e8a8 <z_arm_init_arch_hw_at_boot+0x48>)
   1e88c:	f103 0160 	add.w	r1, r3, #96	; 0x60
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   1e890:	3301      	adds	r3, #1
   1e892:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
   1e894:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
   1e898:	d1f8      	bne.n	1e88c <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
   1e89a:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
   1e89c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1e8a0:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
   1e8a4:	bd10      	pop	{r4, pc}
   1e8a6:	bf00      	nop
   1e8a8:	e000e100 	.word	0xe000e100

0001e8ac <z_impl_k_thread_abort>:
#include <zephyr/wait_q.h>
#include <zephyr/sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
	if (_current == thread) {
   1e8ac:	4b08      	ldr	r3, [pc, #32]	; (1e8d0 <z_impl_k_thread_abort+0x24>)
   1e8ae:	689b      	ldr	r3, [r3, #8]
   1e8b0:	4283      	cmp	r3, r0
   1e8b2:	d10b      	bne.n	1e8cc <z_impl_k_thread_abort+0x20>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1e8b4:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
   1e8b8:	b143      	cbz	r3, 1e8cc <z_impl_k_thread_abort+0x20>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1e8ba:	4b06      	ldr	r3, [pc, #24]	; (1e8d4 <z_impl_k_thread_abort+0x28>)
   1e8bc:	685a      	ldr	r2, [r3, #4]
   1e8be:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   1e8c2:	605a      	str	r2, [r3, #4]
			/* Clear any system calls that may be pending
			 * as they have a higher priority than the PendSV
			 * handler and will check the stack of the thread
			 * being aborted.
			 */
			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
   1e8c4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   1e8c6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
   1e8ca:	625a      	str	r2, [r3, #36]	; 0x24
		}
	}

	z_thread_abort(thread);
   1e8cc:	f005 baea 	b.w	23ea4 <z_thread_abort>
   1e8d0:	2000b5b4 	.word	0x2000b5b4
   1e8d4:	e000ed00 	.word	0xe000ed00

0001e8d8 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   1e8d8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	 * into account the unused SRAM area, as well.
	 */
#ifdef CONFIG_AARCH32_ARMV8_R
	arm_core_mpu_disable();
#endif
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   1e8da:	4c09      	ldr	r4, [pc, #36]	; (1e900 <z_arm_configure_static_mpu_regions+0x28>)
   1e8dc:	4a09      	ldr	r2, [pc, #36]	; (1e904 <z_arm_configure_static_mpu_regions+0x2c>)
   1e8de:	4623      	mov	r3, r4
   1e8e0:	2101      	movs	r1, #1
   1e8e2:	4809      	ldr	r0, [pc, #36]	; (1e908 <z_arm_configure_static_mpu_regions+0x30>)
   1e8e4:	f000 f8ea 	bl	1eabc <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   1e8e8:	2300      	movs	r3, #0
   1e8ea:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   1e8ec:	4b07      	ldr	r3, [pc, #28]	; (1e90c <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1e8ee:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   1e8f0:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1e8f2:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
   1e8f4:	9301      	str	r3, [sp, #4]
   1e8f6:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1e8f8:	f000 f8ea 	bl	1ead0 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   1e8fc:	b004      	add	sp, #16
   1e8fe:	bd10      	pop	{r4, pc}
   1e900:	20080000 	.word	0x20080000
   1e904:	2000a000 	.word	0x2000a000
   1e908:	00026694 	.word	0x00026694
   1e90c:	2000a410 	.word	0x2000a410

0001e910 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
   1e910:	b510      	push	{r4, lr}
	mpu_set_region(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
		| (region_conf->attr.rbar &
   1e912:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   1e914:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   1e916:	f004 021f 	and.w	r2, r4, #31
		(region_conf->base & MPU_RBAR_BASE_Msk)
   1e91a:	f023 031f 	bic.w	r3, r3, #31
		| (region_conf->attr.rbar &
   1e91e:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   1e920:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   1e922:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   1e924:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = rnr;
   1e928:	4905      	ldr	r1, [pc, #20]	; (1e940 <region_init+0x30>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   1e92a:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   1e92e:	f043 0301 	orr.w	r3, r3, #1
	MPU->RNR = rnr;
   1e932:	f8c1 0098 	str.w	r0, [r1, #152]	; 0x98
	MPU->RBAR = rbar;
   1e936:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
	MPU->RLAR = rlar;
   1e93a:	f8c1 30a0 	str.w	r3, [r1, #160]	; 0xa0
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   1e93e:	bd10      	pop	{r4, pc}
   1e940:	e000ed00 	.word	0xe000ed00

0001e944 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   1e944:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e948:	460f      	mov	r7, r1
   1e94a:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   1e94c:	4606      	mov	r6, r0
   1e94e:	f04f 0800 	mov.w	r8, #0
	MPU->RNR = rnr;
   1e952:	4d4e      	ldr	r5, [pc, #312]	; (1ea8c <mpu_configure_regions_and_partition.constprop.0+0x148>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
   1e954:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   1e956:	45b8      	cmp	r8, r7
   1e958:	f280 8094 	bge.w	1ea84 <mpu_configure_regions_and_partition.constprop.0+0x140>
		if (regions[i].size == 0U) {
   1e95c:	f8d6 9004 	ldr.w	r9, [r6, #4]
   1e960:	f1b9 0f00 	cmp.w	r9, #0
   1e964:	d036      	beq.n	1e9d4 <mpu_configure_regions_and_partition.constprop.0+0x90>
		&&
   1e966:	f1b9 0f1f 	cmp.w	r9, #31
   1e96a:	f240 8089 	bls.w	1ea80 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		&&
   1e96e:	f019 0f1f 	tst.w	r9, #31
   1e972:	f040 8085 	bne.w	1ea80 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		((part->start &
   1e976:	f8d6 a000 	ldr.w	sl, [r6]
		&&
   1e97a:	f01a 0f1f 	tst.w	sl, #31
   1e97e:	d17f      	bne.n	1ea80 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1e980:	4650      	mov	r0, sl
   1e982:	f006 faf0 	bl	24f66 <arm_cmse_mpu_region_get>
   1e986:	4683      	mov	fp, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1e988:	eb09 000a 	add.w	r0, r9, sl
   1e98c:	3801      	subs	r0, #1
   1e98e:	f006 faea 	bl	24f66 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   1e992:	4583      	cmp	fp, r0
   1e994:	d174      	bne.n	1ea80 <mpu_configure_regions_and_partition.constprop.0+0x13c>
		 * inside which the new region will be configured.
		 */
		int u_reg_index =
			get_region_index(regions[i].start, regions[i].size);

		if ((u_reg_index == -EINVAL) ||
   1e996:	f11b 0f16 	cmn.w	fp, #22
   1e99a:	d071      	beq.n	1ea80 <mpu_configure_regions_and_partition.constprop.0+0x13c>
   1e99c:	455c      	cmp	r4, fp
   1e99e:	dd6f      	ble.n	1ea80 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	MPU->RNR = rnr;
   1e9a0:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
   1e9a4:	f8d5 109c 	ldr.w	r1, [r5, #156]	; 0x9c
	MPU->RNR = rnr;
   1e9a8:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RLAR;
   1e9ac:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	return mpu_get_rbar() & MPU_RBAR_BASE_Msk;
   1e9b0:	f021 011f 	bic.w	r1, r1, #31
	return (mpu_get_rlar() & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   1e9b4:	f043 0a1f 	orr.w	sl, r3, #31
		 * The new memory region is to be placed inside the underlying
		 * region, possibly splitting the underlying region into two.
		 */
		uint32_t u_reg_base = mpu_region_get_base(u_reg_index);
		uint32_t u_reg_last = mpu_region_get_last_addr(u_reg_index);
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   1e9b8:	e9d6 3200 	ldrd	r3, r2, [r6]
   1e9bc:	441a      	add	r2, r3

		if ((regions[i].start == u_reg_base) &&
   1e9be:	4299      	cmp	r1, r3
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
   1e9c0:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
		if ((regions[i].start == u_reg_base) &&
   1e9c4:	d11e      	bne.n	1ea04 <mpu_configure_regions_and_partition.constprop.0+0xc0>
   1e9c6:	45ca      	cmp	sl, r9
   1e9c8:	d108      	bne.n	1e9dc <mpu_configure_regions_and_partition.constprop.0+0x98>
			 * underlying region. In this case we simply
			 * update the partition attributes of the
			 * underlying region with those of the new
			 * region.
			 */
			mpu_configure_region(u_reg_index, &regions[i]);
   1e9ca:	4631      	mov	r1, r6
   1e9cc:	fa5f f08b 	uxtb.w	r0, fp
   1e9d0:	f006 fad2 	bl	24f78 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   1e9d4:	f108 0801 	add.w	r8, r8, #1
   1e9d8:	360c      	adds	r6, #12
   1e9da:	e7bc      	b.n	1e956 <mpu_configure_regions_and_partition.constprop.0+0x12>
			 */
			mpu_region_set_base(u_reg_index,
				regions[i].start + regions[i].size);

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);
   1e9dc:	4631      	mov	r1, r6
	MPU->RNR = rnr;
   1e9de:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
   1e9e2:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
		     | (base & MPU_RBAR_BASE_Msk));
   1e9e6:	f022 021f 	bic.w	r2, r2, #31
	mpu_set_rbar((mpu_get_rbar() & (~MPU_RBAR_BASE_Msk))
   1e9ea:	f003 031f 	and.w	r3, r3, #31
		     | (base & MPU_RBAR_BASE_Msk));
   1e9ee:	4313      	orrs	r3, r2
	MPU->RBAR = rbar;
   1e9f0:	f8c5 309c 	str.w	r3, [r5, #156]	; 0x9c
				mpu_configure_region(reg_index, &regions[i]);
   1e9f4:	b2e0      	uxtb	r0, r4
			 */
			mpu_region_set_limit(u_reg_index,
				regions[i].start - 1);

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);
   1e9f6:	f006 fabf 	bl	24f78 <mpu_configure_region>

			if (reg_index == -EINVAL) {
   1e9fa:	f110 0f16 	cmn.w	r0, #22
   1e9fe:	d03f      	beq.n	1ea80 <mpu_configure_regions_and_partition.constprop.0+0x13c>

			if (reg_index == -EINVAL) {
				return reg_index;
			}

			reg_index++;
   1ea00:	1c44      	adds	r4, r0, #1
   1ea02:	e7e7      	b.n	1e9d4 <mpu_configure_regions_and_partition.constprop.0+0x90>
	MPU->RNR = rnr;
   1ea04:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RLAR;
   1ea08:	f8d5 20a0 	ldr.w	r2, [r5, #160]	; 0xa0
				regions[i].start - 1);
   1ea0c:	3b01      	subs	r3, #1
		     | (limit & MPU_RLAR_LIMIT_Msk));
   1ea0e:	f023 031f 	bic.w	r3, r3, #31
	mpu_set_rlar((mpu_get_rlar() & (~MPU_RLAR_LIMIT_Msk))
   1ea12:	f002 021f 	and.w	r2, r2, #31
		     | (limit & MPU_RLAR_LIMIT_Msk));
   1ea16:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
   1ea18:	45ca      	cmp	sl, r9
				mpu_configure_region(reg_index, &regions[i]);
   1ea1a:	4631      	mov	r1, r6
				mpu_configure_region(reg_index, &regions[i]);
   1ea1c:	b2e0      	uxtb	r0, r4
	MPU->RLAR = rlar;
   1ea1e:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
		} else if (reg_last == u_reg_last) {
   1ea22:	d0e8      	beq.n	1e9f6 <mpu_configure_regions_and_partition.constprop.0+0xb2>
				mpu_configure_region(reg_index, &regions[i]);
   1ea24:	f006 faa8 	bl	24f78 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   1ea28:	f110 0f16 	cmn.w	r0, #22
   1ea2c:	d028      	beq.n	1ea80 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	MPU->RNR = rnr;
   1ea2e:	f8c5 b098 	str.w	fp, [r5, #152]	; 0x98
	return MPU->RBAR;
   1ea32:	f8d5 209c 	ldr.w	r2, [r5, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
   1ea36:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
   1ea3a:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
	attr->rbar = mpu_get_rbar() &
   1ea3e:	f362 0304 	bfi	r3, r2, #0, #5
   1ea42:	f88d 3008 	strb.w	r3, [sp, #8]
	return MPU->RLAR;
   1ea46:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
   1ea4a:	f89d 2008 	ldrb.w	r2, [sp, #8]
   1ea4e:	085b      	lsrs	r3, r3, #1
   1ea50:	f363 1247 	bfi	r2, r3, #5, #3
   1ea54:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
   1ea58:	e9d6 3200 	ldrd	r3, r2, [r6]
   1ea5c:	4413      	add	r3, r2
   1ea5e:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
   1ea60:	f023 031f 	bic.w	r3, r3, #31
			reg_index++;
   1ea64:	1c41      	adds	r1, r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
   1ea66:	4453      	add	r3, sl
   1ea68:	eba3 0309 	sub.w	r3, r3, r9
   1ea6c:	b2c8      	uxtb	r0, r1
   1ea6e:	f023 031f 	bic.w	r3, r3, #31

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
   1ea72:	2807      	cmp	r0, #7
			fill_region.attr.r_limit =
   1ea74:	9303      	str	r3, [sp, #12]
   1ea76:	d803      	bhi.n	1ea80 <mpu_configure_regions_and_partition.constprop.0+0x13c>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
   1ea78:	4669      	mov	r1, sp
   1ea7a:	f7ff ff49 	bl	1e910 <region_init>
   1ea7e:	e7bf      	b.n	1ea00 <mpu_configure_regions_and_partition.constprop.0+0xbc>
			return -EINVAL;
   1ea80:	f06f 0415 	mvn.w	r4, #21
		}
	}

	return reg_index;
}
   1ea84:	4620      	mov	r0, r4
   1ea86:	b005      	add	sp, #20
   1ea88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1ea8c:	e000ed00 	.word	0xe000ed00

0001ea90 <arm_core_mpu_enable>:
	 * background region for privileged software access if desired.
	 */
#if defined(CONFIG_MPU_DISABLE_BACKGROUND_MAP)
	MPU->CTRL = MPU_CTRL_ENABLE_Msk;
#else
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   1ea90:	2205      	movs	r2, #5
   1ea92:	4b04      	ldr	r3, [pc, #16]	; (1eaa4 <arm_core_mpu_enable+0x14>)
   1ea94:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
   1ea98:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1ea9c:	f3bf 8f6f 	isb	sy
#endif

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   1eaa0:	4770      	bx	lr
   1eaa2:	bf00      	nop
   1eaa4:	e000ed00 	.word	0xe000ed00

0001eaa8 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
   1eaa8:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   1eaac:	2200      	movs	r2, #0
   1eaae:	4b02      	ldr	r3, [pc, #8]	; (1eab8 <arm_core_mpu_disable+0x10>)
   1eab0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
   1eab4:	4770      	bx	lr
   1eab6:	bf00      	nop
   1eab8:	e000ed00 	.word	0xe000ed00

0001eabc <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	*static_regions, const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
   1eabc:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   1eabe:	4c03      	ldr	r4, [pc, #12]	; (1eacc <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   1eac0:	7822      	ldrb	r2, [r4, #0]
   1eac2:	f7ff ff3f 	bl	1e944 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   1eac6:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
   1eac8:	bd10      	pop	{r4, pc}
   1eaca:	bf00      	nop
   1eacc:	2000b604 	.word	0x2000b604

0001ead0 <arm_core_mpu_mark_areas_for_dynamic_regions>:
 * @brief mark memory areas for dynamic region configuration
 */
void arm_core_mpu_mark_areas_for_dynamic_regions(
	const struct z_arm_mpu_partition dyn_region_areas[],
	const uint8_t dyn_region_areas_num)
{
   1ead0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ead4:	4d29      	ldr	r5, [pc, #164]	; (1eb7c <arm_core_mpu_mark_areas_for_dynamic_regions+0xac>)
   1ead6:	468a      	mov	sl, r1

/* This internal function marks and stores the configuration of memory areas
 * where dynamic region programming is allowed. Return zero on success, or
 * -EINVAL on error.
 */
static int mpu_mark_areas_for_dynamic_regions(
   1ead8:	4606      	mov	r6, r0
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1eada:	f04f 0800 	mov.w	r8, #0
   1eade:	46ab      	mov	fp, r5
	MPU->RNR = rnr;
   1eae0:	4f27      	ldr	r7, [pc, #156]	; (1eb80 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb0>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1eae2:	45d0      	cmp	r8, sl
   1eae4:	da1b      	bge.n	1eb1e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
   1eae6:	f8d6 9004 	ldr.w	r9, [r6, #4]
   1eaea:	f1b9 0f00 	cmp.w	r9, #0
   1eaee:	d03f      	beq.n	1eb70 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   1eaf0:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1eaf2:	4608      	mov	r0, r1
   1eaf4:	9101      	str	r1, [sp, #4]
   1eaf6:	f006 fa36 	bl	24f66 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1eafa:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1eafc:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1eafe:	eb09 0001 	add.w	r0, r9, r1
   1eb02:	3801      	subs	r0, #1
   1eb04:	f006 fa2f 	bl	24f66 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   1eb08:	4284      	cmp	r4, r0
   1eb0a:	f04f 0214 	mov.w	r2, #20
   1eb0e:	4b1d      	ldr	r3, [pc, #116]	; (1eb84 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb4>)
   1eb10:	d008      	beq.n	1eb24 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
   1eb12:	fb02 f308 	mul.w	r3, r2, r8
   1eb16:	f06f 0215 	mvn.w	r2, #21
   1eb1a:	f84b 2003 	str.w	r2, [fp, r3]
						 dyn_region_areas_num) == -EINVAL) {

		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
			dyn_region_areas_num);
	}
}
   1eb1e:	b003      	add	sp, #12
   1eb20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   1eb24:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
   1eb28:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   1eb2a:	d0f8      	beq.n	1eb1e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   1eb2c:	7819      	ldrb	r1, [r3, #0]
   1eb2e:	42a1      	cmp	r1, r4
   1eb30:	ddf5      	ble.n	1eb1e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = mpu_get_rbar() &
   1eb32:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = rnr;
   1eb36:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
   1eb3a:	f8c7 4098 	str.w	r4, [r7, #152]	; 0x98
	return MPU->RBAR;
   1eb3e:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
	attr->rbar = mpu_get_rbar() &
   1eb42:	f100 0108 	add.w	r1, r0, #8
   1eb46:	7b00      	ldrb	r0, [r0, #12]
   1eb48:	f364 0004 	bfi	r0, r4, #0, #5
   1eb4c:	7108      	strb	r0, [r1, #4]
	return MPU->RLAR;
   1eb4e:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
	attr->mair_idx = (mpu_get_rlar() & MPU_RLAR_AttrIndx_Msk) >>
   1eb52:	790c      	ldrb	r4, [r1, #4]
   1eb54:	0840      	lsrs	r0, r0, #1
   1eb56:	f360 1447 	bfi	r4, r0, #5, #3
   1eb5a:	710c      	strb	r4, [r1, #4]
	return MPU->RBAR;
   1eb5c:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
	region_conf->base = mpu_get_rbar() & MPU_RBAR_BASE_Msk;
   1eb60:	f021 011f 	bic.w	r1, r1, #31
   1eb64:	6069      	str	r1, [r5, #4]
	return MPU->RLAR;
   1eb66:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
	region_conf->attr.r_limit = mpu_get_rlar() & MPU_RLAR_LIMIT_Msk;
   1eb6a:	f021 011f 	bic.w	r1, r1, #31
   1eb6e:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1eb70:	f108 0801 	add.w	r8, r8, #1
   1eb74:	3514      	adds	r5, #20
   1eb76:	360c      	adds	r6, #12
   1eb78:	e7b3      	b.n	1eae2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
   1eb7a:	bf00      	nop
   1eb7c:	2000a938 	.word	0x2000a938
   1eb80:	e000ed00 	.word	0xe000ed00
   1eb84:	2000b604 	.word	0x2000b604

0001eb88 <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
   1eb88:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   1eb8a:	4d0e      	ldr	r5, [pc, #56]	; (1ebc4 <z_arm_mpu_init+0x3c>)
   1eb8c:	682c      	ldr	r4, [r5, #0]
   1eb8e:	2c08      	cmp	r4, #8
   1eb90:	d815      	bhi.n	1ebbe <z_arm_mpu_init+0x36>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1eb92:	2000      	movs	r0, #0
	arm_core_mpu_disable();
   1eb94:	f7ff ff88 	bl	1eaa8 <arm_core_mpu_disable>
	MPU->MAIR0 = mair0;
   1eb98:	4b0b      	ldr	r3, [pc, #44]	; (1ebc8 <z_arm_mpu_init+0x40>)
   1eb9a:	4a0c      	ldr	r2, [pc, #48]	; (1ebcc <z_arm_mpu_init+0x44>)
   1eb9c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1eba0:	4284      	cmp	r4, r0
   1eba2:	d105      	bne.n	1ebb0 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
   1eba4:	4b0a      	ldr	r3, [pc, #40]	; (1ebd0 <z_arm_mpu_init+0x48>)
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
   1eba6:	2000      	movs	r0, #0
	static_regions_num = mpu_config.num_regions;
   1eba8:	701c      	strb	r4, [r3, #0]
	arm_core_mpu_enable();
   1ebaa:	f7ff ff71 	bl	1ea90 <arm_core_mpu_enable>
}
   1ebae:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   1ebb0:	6869      	ldr	r1, [r5, #4]
   1ebb2:	eb01 1100 	add.w	r1, r1, r0, lsl #4
   1ebb6:	f7ff feab 	bl	1e910 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1ebba:	3001      	adds	r0, #1
   1ebbc:	e7f0      	b.n	1eba0 <z_arm_mpu_init+0x18>
		return -1;
   1ebbe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1ebc2:	e7f4      	b.n	1ebae <z_arm_mpu_init+0x26>
   1ebc4:	000266a0 	.word	0x000266a0
   1ebc8:	e000ed00 	.word	0xe000ed00
   1ebcc:	0044ffaa 	.word	0x0044ffaa
   1ebd0:	2000b604 	.word	0x2000b604

0001ebd4 <__stdout_hook_install>:

static int (*_stdout_hook)(int c) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int c))
{
	_stdout_hook = hook;
   1ebd4:	4b01      	ldr	r3, [pc, #4]	; (1ebdc <__stdout_hook_install+0x8>)
   1ebd6:	6018      	str	r0, [r3, #0]
}
   1ebd8:	4770      	bx	lr
   1ebda:	bf00      	nop
   1ebdc:	2000a110 	.word	0x2000a110

0001ebe0 <setup>:
	 * this case do the remainder of actions to properly configure and
	 * boot the Network MCU.
	 */

	/* Release the Network MCU, 'Release force off signal' */
	NRF_RESET->NETWORK.FORCEOFF = RESET_NETWORK_FORCEOFF_FORCEOFF_Release;
   1ebe0:	2000      	movs	r0, #0
   1ebe2:	4b02      	ldr	r3, [pc, #8]	; (1ebec <setup+0xc>)
   1ebe4:	f8c3 0614 	str.w	r0, [r3, #1556]	; 0x614
	if (IS_ENABLED(CONFIG_BOARD_ENABLE_CPUNET)) {
		enable_cpunet();
	}

	return 0;
}
   1ebe8:	4770      	bx	lr
   1ebea:	bf00      	nop
   1ebec:	40005000 	.word	0x40005000

0001ebf0 <usbd_evt_put>:
 * @brief Enqueue USBD event.
 *
 * @param Pointer to the previously allocated and filled event structure.
 */
static inline void usbd_evt_put(struct usbd_event *ev)
{
   1ebf0:	4601      	mov	r1, r0
	k_fifo_put(&usbd_evt_fifo, ev);
   1ebf2:	4801      	ldr	r0, [pc, #4]	; (1ebf8 <usbd_evt_put+0x8>)
   1ebf4:	f007 b85e 	b.w	25cb4 <k_queue_append>
   1ebf8:	2000a31c 	.word	0x2000a31c

0001ebfc <usbd_work_schedule>:
	k_work_submit_to_queue(&usbd_work_queue, &get_usbd_ctx()->usb_work);
   1ebfc:	4901      	ldr	r1, [pc, #4]	; (1ec04 <usbd_work_schedule+0x8>)
   1ebfe:	4802      	ldr	r0, [pc, #8]	; (1ec08 <usbd_work_schedule+0xc>)
   1ec00:	f007 b8bd 	b.w	25d7e <k_work_submit_to_queue>
   1ec04:	2000a974 	.word	0x2000a974
   1ec08:	2000a4b0 	.word	0x2000a4b0

0001ec0c <endpoint_ctx>:
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1ec0c:	0602      	lsls	r2, r0, #24
	uint8_t ep_num = USB_EP_GET_IDX(ep);
   1ec0e:	f000 037f 	and.w	r3, r0, #127	; 0x7f
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1ec12:	d512      	bpl.n	1ec3a <endpoint_ctx+0x2e>
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
   1ec14:	2b08      	cmp	r3, #8
   1ec16:	d105      	bne.n	1ec24 <endpoint_ctx+0x18>
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec18:	0701      	lsls	r1, r0, #28
	ep_num = NRF_USBD_EP_NR_GET(ep);
   1ec1a:	f000 030f 	and.w	r3, r0, #15
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec1e:	d506      	bpl.n	1ec2e <endpoint_ctx+0x22>
			return &ctx->ep_ctx[EP_ISOIN_INDEX];
   1ec20:	480e      	ldr	r0, [pc, #56]	; (1ec5c <endpoint_ctx+0x50>)
   1ec22:	4770      	bx	lr
			if (ep_num >= CFG_EPIN_CNT) {
   1ec24:	f010 0f78 	tst.w	r0, #120	; 0x78
   1ec28:	d112      	bne.n	1ec50 <endpoint_ctx+0x44>
	ep_num = NRF_USBD_EP_NR_GET(ep);
   1ec2a:	f000 030f 	and.w	r3, r0, #15
			return &ctx->ep_ctx[ep_num];
   1ec2e:	204c      	movs	r0, #76	; 0x4c
   1ec30:	eb00 1043 	add.w	r0, r0, r3, lsl #5
   1ec34:	4b0a      	ldr	r3, [pc, #40]	; (1ec60 <endpoint_ctx+0x54>)
   1ec36:	4418      	add	r0, r3
   1ec38:	4770      	bx	lr
		if (unlikely(ep_num == NRF_USBD_EPISO_FIRST)) {
   1ec3a:	2b08      	cmp	r3, #8
   1ec3c:	d105      	bne.n	1ec4a <endpoint_ctx+0x3e>
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec3e:	0702      	lsls	r2, r0, #28
	ep_num = NRF_USBD_EP_NR_GET(ep);
   1ec40:	f000 030f 	and.w	r3, r0, #15
		if (unlikely(NRF_USBD_EPISO_CHECK(ep))) {
   1ec44:	d506      	bpl.n	1ec54 <endpoint_ctx+0x48>
			return &ctx->ep_ctx[EP_ISOOUT_INDEX];
   1ec46:	4807      	ldr	r0, [pc, #28]	; (1ec64 <endpoint_ctx+0x58>)
   1ec48:	4770      	bx	lr
			if (ep_num >= CFG_EPOUT_CNT) {
   1ec4a:	f010 0f78 	tst.w	r0, #120	; 0x78
   1ec4e:	d0f6      	beq.n	1ec3e <endpoint_ctx+0x32>
		return NULL;
   1ec50:	2000      	movs	r0, #0
}
   1ec52:	4770      	bx	lr
			return &ctx->ep_ctx[CFG_EPIN_CNT +
   1ec54:	4804      	ldr	r0, [pc, #16]	; (1ec68 <endpoint_ctx+0x5c>)
   1ec56:	eb00 1043 	add.w	r0, r0, r3, lsl #5
   1ec5a:	4770      	bx	lr
   1ec5c:	2000aa98 	.word	0x2000aa98
   1ec60:	2000a94c 	.word	0x2000a94c
   1ec64:	2000abb8 	.word	0x2000abb8
   1ec68:	2000aab8 	.word	0x2000aab8

0001ec6c <usbd_evt_get>:
	return z_impl_k_queue_get(queue, timeout);
   1ec6c:	2200      	movs	r2, #0
   1ec6e:	2300      	movs	r3, #0
   1ec70:	4801      	ldr	r0, [pc, #4]	; (1ec78 <usbd_evt_get+0xc>)
   1ec72:	f004 bc29 	b.w	234c8 <z_impl_k_queue_get>
   1ec76:	bf00      	nop
   1ec78:	2000a31c 	.word	0x2000a31c

0001ec7c <usbd_evt_flush>:

/**
 * @brief Drop all enqueued events.
 */
static inline void usbd_evt_flush(void)
{
   1ec7c:	b510      	push	{r4, lr}
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1ec7e:	4c05      	ldr	r4, [pc, #20]	; (1ec94 <usbd_evt_flush+0x18>)
	struct usbd_event *ev;

	do {
		ev = usbd_evt_get();
   1ec80:	f7ff fff4 	bl	1ec6c <usbd_evt_get>
		if (ev) {
   1ec84:	b120      	cbz	r0, 1ec90 <usbd_evt_flush+0x14>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1ec86:	1d01      	adds	r1, r0, #4
   1ec88:	4620      	mov	r0, r4
   1ec8a:	f006 ff5b 	bl	25b44 <k_mem_slab_free>
			usbd_evt_free(ev);
		}
	} while (ev != NULL);
   1ec8e:	e7f7      	b.n	1ec80 <usbd_evt_flush+0x4>
}
   1ec90:	bd10      	pop	{r4, pc}
   1ec92:	bf00      	nop
   1ec94:	2000a2d8 	.word	0x2000a2d8

0001ec98 <usbd_evt_alloc>:
 * This function should be called prior to usbd_evt_put().
 *
 * @returns Pointer to the allocated event or NULL if there was no space left.
 */
static inline struct usbd_event *usbd_evt_alloc(void)
{
   1ec98:	b507      	push	{r0, r1, r2, lr}
	struct usbd_event *ev;
	struct usbd_mem_block block;

	if (k_mem_slab_alloc(&fifo_elem_slab,
   1ec9a:	2300      	movs	r3, #0
   1ec9c:	2200      	movs	r2, #0
   1ec9e:	480e      	ldr	r0, [pc, #56]	; (1ecd8 <usbd_evt_alloc+0x40>)
   1eca0:	a901      	add	r1, sp, #4
   1eca2:	f004 fa59 	bl	23158 <k_mem_slab_alloc>
   1eca6:	b190      	cbz	r0, 1ecce <usbd_evt_alloc+0x36>
		 * Allocation may fail if workqueue thread is starved or event
		 * queue size is too small (CONFIG_USB_NRFX_EVT_QUEUE_SIZE).
		 * Wipe all events, free the space and schedule
		 * reinitialization.
		 */
		usbd_evt_flush();
   1eca8:	f7ff ffe8 	bl	1ec7c <usbd_evt_flush>

		if (k_mem_slab_alloc(&fifo_elem_slab, (void **)&block.data, K_NO_WAIT)) {
   1ecac:	2200      	movs	r2, #0
   1ecae:	2300      	movs	r3, #0
   1ecb0:	4809      	ldr	r0, [pc, #36]	; (1ecd8 <usbd_evt_alloc+0x40>)
   1ecb2:	a901      	add	r1, sp, #4
   1ecb4:	f004 fa50 	bl	23158 <k_mem_slab_alloc>
   1ecb8:	b938      	cbnz	r0, 1ecca <usbd_evt_alloc+0x32>
			return NULL;
		}

		ev = (struct usbd_event *)block.data;
		ev->block = block;
		ev->evt_type = USBD_EVT_REINIT;
   1ecba:	2304      	movs	r3, #4
		ev = (struct usbd_event *)block.data;
   1ecbc:	9801      	ldr	r0, [sp, #4]
		ev->block = block;
   1ecbe:	6040      	str	r0, [r0, #4]
		ev->evt_type = USBD_EVT_REINIT;
   1ecc0:	7403      	strb	r3, [r0, #16]
		usbd_evt_put(ev);
   1ecc2:	f7ff ff95 	bl	1ebf0 <usbd_evt_put>
		usbd_work_schedule();
   1ecc6:	f7ff ff99 	bl	1ebfc <usbd_work_schedule>

		return NULL;
   1ecca:	2000      	movs	r0, #0
   1eccc:	e001      	b.n	1ecd2 <usbd_evt_alloc+0x3a>
	}

	ev = (struct usbd_event *)block.data;
   1ecce:	9801      	ldr	r0, [sp, #4]
	ev->block = block;
   1ecd0:	6040      	str	r0, [r0, #4]

	return ev;
}
   1ecd2:	b003      	add	sp, #12
   1ecd4:	f85d fb04 	ldr.w	pc, [sp], #4
   1ecd8:	2000a2d8 	.word	0x2000a2d8

0001ecdc <submit_dc_power_event>:

static void submit_dc_power_event(enum usbd_periph_state state)
{
   1ecdc:	b510      	push	{r4, lr}
   1ecde:	4604      	mov	r4, r0
	struct usbd_event *ev = usbd_evt_alloc();
   1ece0:	f7ff ffda 	bl	1ec98 <usbd_evt_alloc>

	if (!ev) {
   1ece4:	b160      	cbz	r0, 1ed00 <submit_dc_power_event+0x24>
		return;
	}

	ev->evt_type = USBD_EVT_POWER;
   1ece6:	2200      	movs	r2, #0
	ev->evt.pwr_evt.state = state;
   1ece8:	7204      	strb	r4, [r0, #8]
	ev->evt_type = USBD_EVT_POWER;
   1ecea:	7402      	strb	r2, [r0, #16]

	usbd_evt_put(ev);
   1ecec:	f7ff ff80 	bl	1ebf0 <usbd_evt_put>

	if (usbd_ctx.attached) {
   1ecf0:	4b04      	ldr	r3, [pc, #16]	; (1ed04 <submit_dc_power_event+0x28>)
   1ecf2:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1ecf6:	b11b      	cbz	r3, 1ed00 <submit_dc_power_event+0x24>
		usbd_work_schedule();
	}
}
   1ecf8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		usbd_work_schedule();
   1ecfc:	f7ff bf7e 	b.w	1ebfc <usbd_work_schedule>
}
   1ed00:	bd10      	pop	{r4, pc}
   1ed02:	bf00      	nop
   1ed04:	2000a94c 	.word	0x2000a94c

0001ed08 <usbd_event_transfer_data>:
		}
	}
}

static void usbd_event_transfer_data(nrfx_usbd_evt_t const *const p_event)
{
   1ed08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct nrf_usbd_ep_ctx *ep_ctx =
		endpoint_ctx(p_event->data.eptransfer.ep);
   1ed0a:	7887      	ldrb	r7, [r0, #2]
{
   1ed0c:	4606      	mov	r6, r0
		endpoint_ctx(p_event->data.eptransfer.ep);
   1ed0e:	4638      	mov	r0, r7
   1ed10:	f7ff ff7c 	bl	1ec0c <endpoint_ctx>

	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ed14:	063b      	lsls	r3, r7, #24
		endpoint_ctx(p_event->data.eptransfer.ep);
   1ed16:	4604      	mov	r4, r0
		switch (p_event->data.eptransfer.status) {
   1ed18:	78f5      	ldrb	r5, [r6, #3]
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ed1a:	d512      	bpl.n	1ed42 <usbd_event_transfer_data+0x3a>
		switch (p_event->data.eptransfer.status) {
   1ed1c:	2d00      	cmp	r5, #0
   1ed1e:	d143      	bne.n	1eda8 <usbd_event_transfer_data+0xa0>
		case NRFX_USBD_EP_OK: {
			struct usbd_event *ev = usbd_evt_alloc();
   1ed20:	f7ff ffba 	bl	1ec98 <usbd_evt_alloc>

			if (!ev) {
   1ed24:	4603      	mov	r3, r0
   1ed26:	2800      	cmp	r0, #0
   1ed28:	d03e      	beq.n	1eda8 <usbd_event_transfer_data+0xa0>

			LOG_DBG("write complete, ep 0x%02x",
				(uint32_t)p_event->data.eptransfer.ep);

			ep_ctx->write_in_progress = false;
			ev->evt_type = USBD_EVT_EP;
   1ed2a:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
   1ed2c:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
   1ed2e:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
   1ed30:	2203      	movs	r2, #3
   1ed32:	7302      	strb	r2, [r0, #12]
				(uint32_t)p_event->data.eptransfer.ep);

			ep_ctx->read_pending = true;
			ev->evt_type = USBD_EVT_EP;
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
			ev->evt.ep_evt.ep = ep_ctx;
   1ed34:	609c      	str	r4, [r3, #8]

			ev->evt_type = USBD_EVT_EP;
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
			ev->evt.ep_evt.ep = ep_ctx;

			usbd_evt_put(ev);
   1ed36:	f7ff ff5b 	bl	1ebf0 <usbd_evt_put>
				p_event->data.eptransfer.ep);
		}
		break;
		}
	}
}
   1ed3a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			usbd_work_schedule();
   1ed3e:	f7ff bf5d 	b.w	1ebfc <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
   1ed42:	b14d      	cbz	r5, 1ed58 <usbd_event_transfer_data+0x50>
   1ed44:	2d01      	cmp	r5, #1
   1ed46:	d12f      	bne.n	1eda8 <usbd_event_transfer_data+0xa0>
			struct usbd_event *ev = usbd_evt_alloc();
   1ed48:	f7ff ffa6 	bl	1ec98 <usbd_evt_alloc>
			if (!ev) {
   1ed4c:	4603      	mov	r3, r0
   1ed4e:	b358      	cbz	r0, 1eda8 <usbd_event_transfer_data+0xa0>
			ep_ctx->read_pending = true;
   1ed50:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
   1ed52:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1ed54:	7305      	strb	r5, [r0, #12]
   1ed56:	e7ed      	b.n	1ed34 <usbd_event_transfer_data+0x2c>
			struct usbd_event *ev = usbd_evt_alloc();
   1ed58:	f7ff ff9e 	bl	1ec98 <usbd_evt_alloc>
			if (!ev) {
   1ed5c:	b320      	cbz	r0, 1eda8 <usbd_event_transfer_data+0xa0>
				p_event->data.eptransfer.ep);
   1ed5e:	78b2      	ldrb	r2, [r6, #2]

NRF_STATIC_INLINE uint32_t nrf_usbd_ep_amount_get(NRF_USBD_Type const * p_reg, uint8_t ep)
{
    uint32_t ret;

    if (NRF_USBD_EPIN_CHECK(ep))
   1ed60:	4b12      	ldr	r3, [pc, #72]	; (1edac <usbd_event_transfer_data+0xa4>)
   1ed62:	f012 0f80 	tst.w	r2, #128	; 0x80
   1ed66:	f002 0108 	and.w	r1, r2, #8
   1ed6a:	d011      	beq.n	1ed90 <usbd_event_transfer_data+0x88>
    {
        if (NRF_USBD_EPISO_CHECK(ep))
   1ed6c:	b141      	cbz	r1, 1ed80 <usbd_event_transfer_data+0x78>
        {
            ret = p_reg->ISOIN.AMOUNT;
   1ed6e:	f8d3 36a8 	ldr.w	r3, [r3, #1704]	; 0x6a8
			ep_ctx->buf.len = nrf_usbd_ep_amount_get(NRF_USBD,
   1ed72:	60e3      	str	r3, [r4, #12]
			ev->evt_type = USBD_EVT_EP;
   1ed74:	2301      	movs	r3, #1
   1ed76:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ed78:	2302      	movs	r3, #2
			ev->evt.ep_evt.ep = ep_ctx;
   1ed7a:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ed7c:	7303      	strb	r3, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   1ed7e:	e7da      	b.n	1ed36 <usbd_event_transfer_data+0x2e>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPIN[epnr].AMOUNT;
   1ed80:	2114      	movs	r1, #20
   1ed82:	f002 020f 	and.w	r2, r2, #15
   1ed86:	fb01 3302 	mla	r3, r1, r2, r3
   1ed8a:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
   1ed8e:	e7f0      	b.n	1ed72 <usbd_event_transfer_data+0x6a>
        }
    }
    else
    {
        if (NRF_USBD_EPISO_CHECK(ep))
   1ed90:	b111      	cbz	r1, 1ed98 <usbd_event_transfer_data+0x90>
        {
            ret = p_reg->ISOOUT.AMOUNT;
   1ed92:	f8d3 37a8 	ldr.w	r3, [r3, #1960]	; 0x7a8
   1ed96:	e7ec      	b.n	1ed72 <usbd_event_transfer_data+0x6a>
        }
        else
        {
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
            ret = p_reg->EPOUT[epnr].AMOUNT;
   1ed98:	2114      	movs	r1, #20
   1ed9a:	f002 020f 	and.w	r2, r2, #15
   1ed9e:	fb01 3302 	mla	r3, r1, r2, r3
   1eda2:	f8d3 3708 	ldr.w	r3, [r3, #1800]	; 0x708
   1eda6:	e7e4      	b.n	1ed72 <usbd_event_transfer_data+0x6a>
}
   1eda8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1edaa:	bf00      	nop
   1edac:	40036000 	.word	0x40036000

0001edb0 <usb_dc_power_event_handler>:
	switch (event) {
   1edb0:	2801      	cmp	r0, #1
{
   1edb2:	b507      	push	{r0, r1, r2, lr}
	switch (event) {
   1edb4:	d00f      	beq.n	1edd6 <usb_dc_power_event_handler+0x26>
   1edb6:	2802      	cmp	r0, #2
   1edb8:	d00e      	beq.n	1edd8 <usb_dc_power_event_handler+0x28>
   1edba:	b948      	cbnz	r0, 1edd0 <usb_dc_power_event_handler+0x20>
	z_impl_k_timer_start(timer, duration, period);
   1edbc:	2200      	movs	r2, #0
   1edbe:	2300      	movs	r3, #0
   1edc0:	4808      	ldr	r0, [pc, #32]	; (1ede4 <usb_dc_power_event_handler+0x34>)
   1edc2:	e9cd 2300 	strd	r2, r3, [sp]
   1edc6:	f645 129a 	movw	r2, #22938	; 0x599a
   1edca:	2300      	movs	r3, #0
   1edcc:	f005 faa8 	bl	24320 <z_impl_k_timer_start>
}
   1edd0:	b003      	add	sp, #12
   1edd2:	f85d fb04 	ldr.w	pc, [sp], #4
	switch (event) {
   1edd6:	2000      	movs	r0, #0
}
   1edd8:	b003      	add	sp, #12
   1edda:	f85d eb04 	ldr.w	lr, [sp], #4
	submit_dc_power_event(new_state);
   1edde:	f7ff bf7d 	b.w	1ecdc <submit_dc_power_event>
   1ede2:	bf00      	nop
   1ede4:	2000a2a0 	.word	0x2000a2a0

0001ede8 <usb_init>:
	}
	return 0;
}

static int usb_init(void)
{
   1ede8:	b513      	push	{r0, r1, r4, lr}

#ifdef CONFIG_HAS_HW_NRF_USBREG
	/* Use CLOCK/POWER priority for compatibility with other series where
	 * USB events are handled by CLOCK interrupt handler.
	 */
	IRQ_CONNECT(USBREGULATOR_IRQn,
   1edea:	2200      	movs	r2, #0
   1edec:	2101      	movs	r1, #1
   1edee:	2037      	movs	r0, #55	; 0x37
   1edf0:	f7ff fa9e 	bl	1e330 <z_arm_irq_priority_set>
		    DT_IRQ(DT_INST(0, nordic_nrf_clock), priority),
		    nrfx_isr, nrfx_usbreg_irq_handler, 0);
	irq_enable(USBREGULATOR_IRQn);
   1edf4:	2037      	movs	r0, #55	; 0x37
   1edf6:	f7ff fa6b 	bl	1e2d0 <arch_irq_enable>

	static const nrfx_power_usbevt_config_t usbevt_config = {
		.handler = usb_dc_power_event_handler
	};

	err = nrfx_usbd_init(usbd_event_handler);
   1edfa:	4812      	ldr	r0, [pc, #72]	; (1ee44 <usb_init+0x5c>)
   1edfc:	f003 fb58 	bl	224b0 <nrfx_usbd_init>
	if (err != NRFX_SUCCESS) {
   1ee00:	4b11      	ldr	r3, [pc, #68]	; (1ee48 <usb_init+0x60>)
   1ee02:	4298      	cmp	r0, r3
   1ee04:	d11a      	bne.n	1ee3c <usb_init+0x54>
	 * a problem here.
	 */
	(void)nrfx_power_init(&power_config);
	nrfx_power_usbevt_init(&usbevt_config);

	k_work_queue_start(&usbd_work_queue,
   1ee06:	2400      	movs	r4, #0
	(void)nrfx_power_init(&power_config);
   1ee08:	4810      	ldr	r0, [pc, #64]	; (1ee4c <usb_init+0x64>)
   1ee0a:	f002 fb41 	bl	21490 <nrfx_power_init>
	nrfx_power_usbevt_init(&usbevt_config);
   1ee0e:	4810      	ldr	r0, [pc, #64]	; (1ee50 <usb_init+0x68>)
   1ee10:	f003 ffea 	bl	22de8 <nrfx_usbreg_init>
	k_work_queue_start(&usbd_work_queue,
   1ee14:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1ee18:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1ee1c:	490d      	ldr	r1, [pc, #52]	; (1ee54 <usb_init+0x6c>)
   1ee1e:	480e      	ldr	r0, [pc, #56]	; (1ee58 <usb_init+0x70>)
   1ee20:	9400      	str	r4, [sp, #0]
   1ee22:	f004 fce1 	bl	237e8 <k_work_queue_start>
	return z_impl_k_thread_name_set(thread, str);
   1ee26:	490d      	ldr	r1, [pc, #52]	; (1ee5c <usb_init+0x74>)
   1ee28:	480b      	ldr	r0, [pc, #44]	; (1ee58 <usb_init+0x70>)
   1ee2a:	f006 feba 	bl	25ba2 <z_impl_k_thread_name_set>
			   usbd_work_queue_stack,
			   K_KERNEL_STACK_SIZEOF(usbd_work_queue_stack),
			   CONFIG_SYSTEM_WORKQUEUE_PRIORITY, NULL);

	k_thread_name_set(&usbd_work_queue.thread, "usbd_workq");
	k_work_init(&ctx->usb_work, usbd_work_handler);
   1ee2e:	480c      	ldr	r0, [pc, #48]	; (1ee60 <usb_init+0x78>)
   1ee30:	490c      	ldr	r1, [pc, #48]	; (1ee64 <usb_init+0x7c>)
   1ee32:	f006 ff87 	bl	25d44 <k_work_init>

	return 0;
   1ee36:	4620      	mov	r0, r4
}
   1ee38:	b002      	add	sp, #8
   1ee3a:	bd10      	pop	{r4, pc}
		return -EIO;
   1ee3c:	f06f 0004 	mvn.w	r0, #4
   1ee40:	e7fa      	b.n	1ee38 <usb_init+0x50>
   1ee42:	bf00      	nop
   1ee44:	0001eea1 	.word	0x0001eea1
   1ee48:	0bad0000 	.word	0x0bad0000
   1ee4c:	00026a56 	.word	0x00026a56
   1ee50:	000266c8 	.word	0x000266c8
   1ee54:	2000ba30 	.word	0x2000ba30
   1ee58:	2000a4b0 	.word	0x2000a4b0
   1ee5c:	00026a4b 	.word	0x00026a4b
   1ee60:	2000a974 	.word	0x2000a974
   1ee64:	0001f025 	.word	0x0001f025

0001ee68 <hfxo_stop.constprop.0.isra.0>:
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1ee68:	2300      	movs	r3, #0
static int hfxo_stop(struct nrf_usbd_ctx *ctx)
   1ee6a:	b510      	push	{r4, lr}
   1ee6c:	490b      	ldr	r1, [pc, #44]	; (1ee9c <hfxo_stop.constprop.0.isra.0+0x34>)
   1ee6e:	e8d1 2fef 	ldaex	r2, [r1]
   1ee72:	2a01      	cmp	r2, #1
   1ee74:	d103      	bne.n	1ee7e <hfxo_stop.constprop.0.isra.0+0x16>
   1ee76:	e8c1 3fe0 	stlex	r0, r3, [r1]
   1ee7a:	2800      	cmp	r0, #0
   1ee7c:	d1f7      	bne.n	1ee6e <hfxo_stop.constprop.0.isra.0+0x6>
	if (atomic_cas(&ctx->clk_requested, 1, 0)) {
   1ee7e:	d10c      	bne.n	1ee9a <hfxo_stop.constprop.0.isra.0+0x32>
		return onoff_cancel_or_release(ctx->hfxo_mgr, &ctx->hfxo_cli);
   1ee80:	f851 4c04 	ldr.w	r4, [r1, #-4]
 * @retval negative other errors produced by onoff_release().
 */
static inline int onoff_cancel_or_release(struct onoff_manager *mgr,
					  struct onoff_client *cli)
{
	int rv = onoff_cancel(mgr, cli);
   1ee84:	3914      	subs	r1, #20
   1ee86:	4620      	mov	r0, r4
   1ee88:	f005 fdc4 	bl	24a14 <onoff_cancel>

	if (rv == -EALREADY) {
   1ee8c:	3078      	adds	r0, #120	; 0x78
   1ee8e:	d104      	bne.n	1ee9a <hfxo_stop.constprop.0.isra.0+0x32>
		rv = onoff_release(mgr);
   1ee90:	4620      	mov	r0, r4
}
   1ee92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1ee96:	f005 bd98 	b.w	249ca <onoff_release>
   1ee9a:	bd10      	pop	{r4, pc}
   1ee9c:	2000a96c 	.word	0x2000a96c

0001eea0 <usbd_event_handler>:
{
   1eea0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1eea2:	4606      	mov	r6, r0
   1eea4:	b089      	sub	sp, #36	; 0x24
	struct usbd_event evt = {0};
   1eea6:	2214      	movs	r2, #20
   1eea8:	2100      	movs	r1, #0
   1eeaa:	a803      	add	r0, sp, #12
   1eeac:	f006 f89c 	bl	24fe8 <memset>
	switch (p_event->type) {
   1eeb0:	7833      	ldrb	r3, [r6, #0]
   1eeb2:	3b01      	subs	r3, #1
   1eeb4:	2b05      	cmp	r3, #5
   1eeb6:	d821      	bhi.n	1eefc <usbd_event_handler+0x5c>
   1eeb8:	e8df f003 	tbb	[pc, r3]
   1eebc:	1414037a 	.word	0x1414037a
   1eec0:	166a      	.short	0x166a
   1eec2:	2303      	movs	r3, #3
		evt.evt_type = USBD_EVT_POWER;
   1eec4:	2400      	movs	r4, #0
		evt.evt.pwr_evt.state = USBD_SUSPENDED;
   1eec6:	f88d 3014 	strb.w	r3, [sp, #20]
		ev = usbd_evt_alloc();
   1eeca:	f7ff fee5 	bl	1ec98 <usbd_evt_alloc>
		if (!ev) {
   1eece:	4603      	mov	r3, r0
   1eed0:	b1a0      	cbz	r0, 1eefc <usbd_event_handler+0x5c>
		ev->evt = evt.evt;
   1eed2:	f100 0208 	add.w	r2, r0, #8
		ev->evt_type = evt.evt_type;
   1eed6:	7404      	strb	r4, [r0, #16]
		ev->evt = evt.evt;
   1eed8:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
   1eedc:	e882 0003 	stmia.w	r2, {r0, r1}
		usbd_evt_put(ev);
   1eee0:	4618      	mov	r0, r3
   1eee2:	e01d      	b.n	1ef20 <usbd_event_handler+0x80>
	switch (p_event->type) {
   1eee4:	2304      	movs	r3, #4
   1eee6:	e7ed      	b.n	1eec4 <usbd_event_handler+0x24>
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
   1eee8:	78b7      	ldrb	r7, [r6, #2]
   1eeea:	4638      	mov	r0, r7
   1eeec:	f7ff fe8e 	bl	1ec0c <endpoint_ctx>
		switch (ep_ctx->cfg.type) {
   1eef0:	7a83      	ldrb	r3, [r0, #10]
		ep_ctx = endpoint_ctx(p_event->data.eptransfer.ep);
   1eef2:	4604      	mov	r4, r0
		switch (ep_ctx->cfg.type) {
   1eef4:	b123      	cbz	r3, 1ef00 <usbd_event_handler+0x60>
   1eef6:	3b01      	subs	r3, #1
   1eef8:	2b02      	cmp	r3, #2
   1eefa:	d943      	bls.n	1ef84 <usbd_event_handler+0xe4>
}
   1eefc:	b009      	add	sp, #36	; 0x24
   1eefe:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ef00:	063b      	lsls	r3, r7, #24
		switch (p_event->data.eptransfer.status) {
   1ef02:	78f5      	ldrb	r5, [r6, #3]
	if (NRF_USBD_EPIN_CHECK(p_event->data.eptransfer.ep)) {
   1ef04:	d513      	bpl.n	1ef2e <usbd_event_handler+0x8e>
		switch (p_event->data.eptransfer.status) {
   1ef06:	2d00      	cmp	r5, #0
   1ef08:	d1f8      	bne.n	1eefc <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
   1ef0a:	f7ff fec5 	bl	1ec98 <usbd_evt_alloc>
			if (!ev) {
   1ef0e:	4603      	mov	r3, r0
   1ef10:	2800      	cmp	r0, #0
   1ef12:	d0f3      	beq.n	1eefc <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
   1ef14:	2201      	movs	r2, #1
			ep_ctx->write_in_progress = false;
   1ef16:	77a5      	strb	r5, [r4, #30]
			ev->evt_type = USBD_EVT_EP;
   1ef18:	7402      	strb	r2, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_WRITE_COMPLETE;
   1ef1a:	2203      	movs	r2, #3
   1ef1c:	7302      	strb	r2, [r0, #12]
			ev->evt.ep_evt.ep = ep_ctx;
   1ef1e:	609c      	str	r4, [r3, #8]
		usbd_evt_put(ev);
   1ef20:	f7ff fe66 	bl	1ebf0 <usbd_evt_put>
}
   1ef24:	b009      	add	sp, #36	; 0x24
   1ef26:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		usbd_work_schedule();
   1ef2a:	f7ff be67 	b.w	1ebfc <usbd_work_schedule>
		switch (p_event->data.eptransfer.status) {
   1ef2e:	b155      	cbz	r5, 1ef46 <usbd_event_handler+0xa6>
   1ef30:	2d01      	cmp	r5, #1
   1ef32:	d1e3      	bne.n	1eefc <usbd_event_handler+0x5c>
			struct usbd_event *ev = usbd_evt_alloc();
   1ef34:	f7ff feb0 	bl	1ec98 <usbd_evt_alloc>
			if (!ev) {
   1ef38:	4603      	mov	r3, r0
   1ef3a:	2800      	cmp	r0, #0
   1ef3c:	d0de      	beq.n	1eefc <usbd_event_handler+0x5c>
			ep_ctx->read_pending = true;
   1ef3e:	7765      	strb	r5, [r4, #29]
			ev->evt_type = USBD_EVT_EP;
   1ef40:	7405      	strb	r5, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1ef42:	7305      	strb	r5, [r0, #12]
   1ef44:	e7eb      	b.n	1ef1e <usbd_event_handler+0x7e>
			struct usbd_event *ev = usbd_evt_alloc();
   1ef46:	f7ff fea7 	bl	1ec98 <usbd_evt_alloc>
			if (!ev) {
   1ef4a:	4607      	mov	r7, r0
   1ef4c:	2800      	cmp	r0, #0
   1ef4e:	d0d5      	beq.n	1eefc <usbd_event_handler+0x5c>
			ev->evt_type = USBD_EVT_EP;
   1ef50:	2301      	movs	r3, #1
   1ef52:	7403      	strb	r3, [r0, #16]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ef54:	2302      	movs	r3, #2
			ev->evt.ep_evt.ep = ep_ctx;
   1ef56:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_COMPLETE;
   1ef58:	7303      	strb	r3, [r0, #12]
			err_code = nrfx_usbd_ep_status_get(
   1ef5a:	f104 010c 	add.w	r1, r4, #12
   1ef5e:	78b0      	ldrb	r0, [r6, #2]
   1ef60:	f006 fd75 	bl	25a4e <nrfx_usbd_ep_status_get>
			if (ctx->ctrl_read_len > ep_ctx->buf.len) {
   1ef64:	4a13      	ldr	r2, [pc, #76]	; (1efb4 <usbd_event_handler+0x114>)
   1ef66:	68e1      	ldr	r1, [r4, #12]
   1ef68:	f8b2 328c 	ldrh.w	r3, [r2, #652]	; 0x28c
   1ef6c:	428b      	cmp	r3, r1
   1ef6e:	d906      	bls.n	1ef7e <usbd_event_handler+0xde>
				ctx->ctrl_read_len -= ep_ctx->buf.len;
   1ef70:	1a5b      	subs	r3, r3, r1
   1ef72:	f8a2 328c 	strh.w	r3, [r2, #652]	; 0x28c
				nrfx_usbd_setup_data_clear();
   1ef76:	f003 fcd1 	bl	2291c <nrfx_usbd_setup_data_clear>
			usbd_evt_put(ev);
   1ef7a:	4638      	mov	r0, r7
   1ef7c:	e7d0      	b.n	1ef20 <usbd_event_handler+0x80>
				ctx->ctrl_read_len = 0U;
   1ef7e:	f8a2 528c 	strh.w	r5, [r2, #652]	; 0x28c
   1ef82:	e7fa      	b.n	1ef7a <usbd_event_handler+0xda>
			usbd_event_transfer_data(p_event);
   1ef84:	4630      	mov	r0, r6
}
   1ef86:	b009      	add	sp, #36	; 0x24
   1ef88:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
			usbd_event_transfer_data(p_event);
   1ef8c:	f7ff bebc 	b.w	1ed08 <usbd_event_transfer_data>
		nrfx_usbd_setup_get(&drv_setup);
   1ef90:	a801      	add	r0, sp, #4
   1ef92:	f003 fc9d 	bl	228d0 <nrfx_usbd_setup_get>
		if ((drv_setup.bRequest != USB_SREQ_SET_ADDRESS)
   1ef96:	f89d 3005 	ldrb.w	r3, [sp, #5]
   1ef9a:	2b05      	cmp	r3, #5
   1ef9c:	d104      	bne.n	1efa8 <usbd_event_handler+0x108>
		    || (USB_REQTYPE_GET_TYPE(drv_setup.bmRequestType)
   1ef9e:	f89d 3004 	ldrb.w	r3, [sp, #4]
   1efa2:	f013 0f60 	tst.w	r3, #96	; 0x60
   1efa6:	d0a9      	beq.n	1eefc <usbd_event_handler+0x5c>
			evt.evt.ep_evt.ep = ep_ctx;
   1efa8:	4b03      	ldr	r3, [pc, #12]	; (1efb8 <usbd_event_handler+0x118>)
			evt.evt_type = USBD_EVT_EP;
   1efaa:	2401      	movs	r4, #1
			evt.evt.ep_evt.ep = ep_ctx;
   1efac:	9305      	str	r3, [sp, #20]
	if (put_evt) {
   1efae:	e78c      	b.n	1eeca <usbd_event_handler+0x2a>
	switch (p_event->type) {
   1efb0:	2402      	movs	r4, #2
   1efb2:	e78a      	b.n	1eeca <usbd_event_handler+0x2a>
   1efb4:	2000a94c 	.word	0x2000a94c
   1efb8:	2000aab8 	.word	0x2000aab8

0001efbc <eps_ctx_init>:
{
   1efbc:	b538      	push	{r3, r4, r5, lr}
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   1efbe:	2400      	movs	r4, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
   1efc0:	f064 007f 	orn	r0, r4, #127	; 0x7f
   1efc4:	b2c0      	uxtb	r0, r0
   1efc6:	f7ff fe21 	bl	1ec0c <endpoint_ctx>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   1efca:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
   1efcc:	f006 f818 	bl	25000 <ep_ctx_reset>
	for (i = 0U; i < CFG_EPIN_CNT; i++) {
   1efd0:	2c08      	cmp	r4, #8
   1efd2:	d1f5      	bne.n	1efc0 <eps_ctx_init+0x4>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   1efd4:	2400      	movs	r4, #0
   1efd6:	4d0e      	ldr	r5, [pc, #56]	; (1f010 <eps_ctx_init+0x54>)
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
   1efd8:	b2e0      	uxtb	r0, r4
   1efda:	f7ff fe17 	bl	1ec0c <endpoint_ctx>
		if (!ep_ctx->buf.block.data) {
   1efde:	6903      	ldr	r3, [r0, #16]
   1efe0:	b903      	cbnz	r3, 1efe4 <eps_ctx_init+0x28>
			ep_ctx->buf.block.data = ep_out_bufs[i];
   1efe2:	6105      	str	r5, [r0, #16]
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   1efe4:	3401      	adds	r4, #1
		ep_ctx_reset(ep_ctx);
   1efe6:	f006 f80b 	bl	25000 <ep_ctx_reset>
	for (i = 0U; i < CFG_EPOUT_CNT; i++) {
   1efea:	2c08      	cmp	r4, #8
   1efec:	f105 0540 	add.w	r5, r5, #64	; 0x40
   1eff0:	d1f2      	bne.n	1efd8 <eps_ctx_init+0x1c>
		ep_ctx_reset(ep_ctx);
   1eff2:	4808      	ldr	r0, [pc, #32]	; (1f014 <eps_ctx_init+0x58>)
   1eff4:	f006 f804 	bl	25000 <ep_ctx_reset>
		if (!ep_ctx->buf.block.data) {
   1eff8:	4b07      	ldr	r3, [pc, #28]	; (1f018 <eps_ctx_init+0x5c>)
   1effa:	f8d3 227c 	ldr.w	r2, [r3, #636]	; 0x27c
   1effe:	b912      	cbnz	r2, 1f006 <eps_ctx_init+0x4a>
			ep_ctx->buf.block.data = ep_isoout_bufs[0];
   1f000:	4a06      	ldr	r2, [pc, #24]	; (1f01c <eps_ctx_init+0x60>)
   1f002:	f8c3 227c 	str.w	r2, [r3, #636]	; 0x27c
		ep_ctx_reset(ep_ctx);
   1f006:	4806      	ldr	r0, [pc, #24]	; (1f020 <eps_ctx_init+0x64>)
   1f008:	f005 fffa 	bl	25000 <ep_ctx_reset>
}
   1f00c:	2000      	movs	r0, #0
   1f00e:	bd38      	pop	{r3, r4, r5, pc}
   1f010:	2000afdc 	.word	0x2000afdc
   1f014:	2000aa98 	.word	0x2000aa98
   1f018:	2000a94c 	.word	0x2000a94c
   1f01c:	2000abdc 	.word	0x2000abdc
   1f020:	2000abb8 	.word	0x2000abb8

0001f024 <usbd_work_handler>:
{
   1f024:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1f028:	4607      	mov	r7, r0
	return get_usbd_ctx()->ready;
   1f02a:	4cad      	ldr	r4, [pc, #692]	; (1f2e0 <usbd_work_handler+0x2bc>)
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f02c:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 1f2e4 <usbd_work_handler+0x2c0>
{
   1f030:	b085      	sub	sp, #20
	while ((ev = usbd_evt_get()) != NULL) {
   1f032:	f7ff fe1b 	bl	1ec6c <usbd_evt_get>
   1f036:	b910      	cbnz	r0, 1f03e <usbd_work_handler+0x1a>
}
   1f038:	b005      	add	sp, #20
   1f03a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	return get_usbd_ctx()->ready;
   1f03e:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
   1f042:	7c02      	ldrb	r2, [r0, #16]
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f044:	f100 0904 	add.w	r9, r0, #4
		if (!dev_ready() && ev->evt_type != USBD_EVT_POWER) {
   1f048:	b93b      	cbnz	r3, 1f05a <usbd_work_handler+0x36>
   1f04a:	2a00      	cmp	r2, #0
   1f04c:	f000 8088 	beq.w	1f160 <usbd_work_handler+0x13c>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f050:	4649      	mov	r1, r9
   1f052:	48a4      	ldr	r0, [pc, #656]	; (1f2e4 <usbd_work_handler+0x2c0>)
   1f054:	f006 fd76 	bl	25b44 <k_mem_slab_free>
}
   1f058:	e7eb      	b.n	1f032 <usbd_work_handler+0xe>
		switch (ev->evt_type) {
   1f05a:	2a04      	cmp	r2, #4
   1f05c:	d844      	bhi.n	1f0e8 <usbd_work_handler+0xc4>
   1f05e:	e8df f012 	tbh	[pc, r2, lsl #1]
   1f062:	007f      	.short	0x007f
   1f064:	00fe0005 	.word	0x00fe0005
   1f068:	012f0114 	.word	0x012f0114
	switch (ep_evt->evt_type) {
   1f06c:	7b03      	ldrb	r3, [r0, #12]
	struct nrf_usbd_ep_ctx *ep_ctx = ep_evt->ep;
   1f06e:	6885      	ldr	r5, [r0, #8]
	switch (ep_evt->evt_type) {
   1f070:	2b03      	cmp	r3, #3
   1f072:	d839      	bhi.n	1f0e8 <usbd_work_handler+0xc4>
   1f074:	e8df f003 	tbb	[pc, r3]
   1f078:	615c3f02 	.word	0x615c3f02
	usbd_setup = (struct usb_setup_packet *)ep_ctx->buf.data;
   1f07c:	696e      	ldr	r6, [r5, #20]
	memset(usbd_setup, 0, sizeof(struct usb_setup_packet));
   1f07e:	2208      	movs	r2, #8
   1f080:	2100      	movs	r1, #0
   1f082:	4630      	mov	r0, r6
   1f084:	f005 ffb0 	bl	24fe8 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   1f088:	4b97      	ldr	r3, [pc, #604]	; (1f2e8 <usbd_work_handler+0x2c4>)
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   1f08a:	4898      	ldr	r0, [pc, #608]	; (1f2ec <usbd_work_handler+0x2c8>)
   1f08c:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
   1f090:	7032      	strb	r2, [r6, #0]
    return (uint8_t)(p_reg->BREQUEST);
   1f092:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
   1f096:	7072      	strb	r2, [r6, #1]
    const uint16_t val = p_reg->WVALUEL;
   1f098:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
   1f09c:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
   1f0a0:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wValue = nrf_usbd_setup_wvalue_get(NRF_USBD);
   1f0a4:	8072      	strh	r2, [r6, #2]
    const uint16_t val = p_reg->WINDEXL;
   1f0a6:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
   1f0aa:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
   1f0ae:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	usbd_setup->wIndex = nrf_usbd_setup_windex_get(NRF_USBD);
   1f0b2:	80b2      	strh	r2, [r6, #4]
    const uint16_t val = p_reg->WLENGTHL;
   1f0b4:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
   1f0b8:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   1f0bc:	4631      	mov	r1, r6
   1f0be:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
   1f0c2:	2208      	movs	r2, #8
	usbd_setup->wLength = nrf_usbd_setup_wlength_get(NRF_USBD);
   1f0c4:	80f3      	strh	r3, [r6, #6]
	ep_ctx->buf.len = sizeof(struct usb_setup_packet);
   1f0c6:	60ea      	str	r2, [r5, #12]
	memcpy(&usbd_ctx.setup, usbd_setup, sizeof(struct usb_setup_packet));
   1f0c8:	f005 ff83 	bl	24fd2 <memcpy>
	ep_ctx->cfg.cb(ep_ctx->cfg.addr, USB_DC_EP_SETUP);
   1f0cc:	682b      	ldr	r3, [r5, #0]
   1f0ce:	2100      	movs	r1, #0
   1f0d0:	7a68      	ldrb	r0, [r5, #9]
   1f0d2:	4798      	blx	r3
	if (usb_reqtype_is_to_device(usbd_setup) && usbd_setup->wLength) {
   1f0d4:	f996 3000 	ldrsb.w	r3, [r6]
   1f0d8:	2b00      	cmp	r3, #0
   1f0da:	db08      	blt.n	1f0ee <usbd_work_handler+0xca>
   1f0dc:	88f3      	ldrh	r3, [r6, #6]
   1f0de:	b133      	cbz	r3, 1f0ee <usbd_work_handler+0xca>
		ctx->ctrl_read_len = usbd_setup->wLength;
   1f0e0:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
		nrfx_usbd_setup_data_clear();
   1f0e4:	f003 fc1a 	bl	2291c <nrfx_usbd_setup_data_clear>
	k_mem_slab_free(&fifo_elem_slab, (void **)&ev->block.data);
   1f0e8:	4649      	mov	r1, r9
   1f0ea:	4640      	mov	r0, r8
   1f0ec:	e7b2      	b.n	1f054 <usbd_work_handler+0x30>
		ctx->ctrl_read_len = 0U;
   1f0ee:	2300      	movs	r3, #0
   1f0f0:	f8a4 328c 	strh.w	r3, [r4, #652]	; 0x28c
   1f0f4:	e7f8      	b.n	1f0e8 <usbd_work_handler+0xc4>
	if (!ep_ctx->read_pending) {
   1f0f6:	7f6b      	ldrb	r3, [r5, #29]
   1f0f8:	2b00      	cmp	r3, #0
   1f0fa:	d0f5      	beq.n	1f0e8 <usbd_work_handler+0xc4>
	if (!ep_ctx->read_complete) {
   1f0fc:	7f2b      	ldrb	r3, [r5, #28]
   1f0fe:	2b00      	cmp	r3, #0
   1f100:	d0f2      	beq.n	1f0e8 <usbd_work_handler+0xc4>
	ep_ctx->read_pending = false;
   1f102:	2600      	movs	r6, #0
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f104:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
	ep_ctx->read_pending = false;
   1f108:	776e      	strb	r6, [r5, #29]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f10a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f10e:	4878      	ldr	r0, [pc, #480]	; (1f2f0 <usbd_work_handler+0x2cc>)
	ep_ctx->read_complete = false;
   1f110:	772e      	strb	r6, [r5, #28]
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f112:	f005 ff8b 	bl	2502c <k_mutex_lock.constprop.0.isra.0>
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
   1f116:	696b      	ldr	r3, [r5, #20]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
   1f118:	a901      	add	r1, sp, #4
	NRFX_USBD_TRANSFER_OUT(transfer, ep_ctx->buf.data,
   1f11a:	9301      	str	r3, [sp, #4]
   1f11c:	686b      	ldr	r3, [r5, #4]
   1f11e:	e9cd 3602 	strd	r3, r6, [sp, #8]
	nrfx_err_t err = nrfx_usbd_ep_transfer(
   1f122:	7a68      	ldrb	r0, [r5, #9]
   1f124:	f003 fa06 	bl	22534 <nrfx_usbd_ep_transfer>
	k_mutex_unlock(&ctx->drv_lock);
   1f128:	4871      	ldr	r0, [pc, #452]	; (1f2f0 <usbd_work_handler+0x2cc>)
   1f12a:	f005 ff81 	bl	25030 <k_mutex_unlock.isra.0>
   1f12e:	e7db      	b.n	1f0e8 <usbd_work_handler+0xc4>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   1f130:	2101      	movs	r1, #1
   1f132:	682b      	ldr	r3, [r5, #0]
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   1f134:	7a68      	ldrb	r0, [r5, #9]
   1f136:	4798      	blx	r3
		break;
   1f138:	e7d6      	b.n	1f0e8 <usbd_work_handler+0xc4>
		if (ep_ctx->cfg.type == USB_DC_EP_CONTROL &&
   1f13a:	7aab      	ldrb	r3, [r5, #10]
   1f13c:	b96b      	cbnz	r3, 1f15a <usbd_work_handler+0x136>
   1f13e:	7feb      	ldrb	r3, [r5, #31]
   1f140:	b95b      	cbnz	r3, 1f15a <usbd_work_handler+0x136>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f142:	486b      	ldr	r0, [pc, #428]	; (1f2f0 <usbd_work_handler+0x2cc>)
   1f144:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f148:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f14c:	f005 ff6e 	bl	2502c <k_mutex_lock.constprop.0.isra.0>
			nrfx_usbd_setup_clear();
   1f150:	f003 fc18 	bl	22984 <nrfx_usbd_setup_clear>
			k_mutex_unlock(&ctx->drv_lock);
   1f154:	4866      	ldr	r0, [pc, #408]	; (1f2f0 <usbd_work_handler+0x2cc>)
   1f156:	f005 ff6b 	bl	25030 <k_mutex_unlock.isra.0>
		ep_ctx->cfg.cb(ep_ctx->cfg.addr,
   1f15a:	2102      	movs	r1, #2
   1f15c:	682b      	ldr	r3, [r5, #0]
   1f15e:	e7e9      	b.n	1f134 <usbd_work_handler+0x110>
	switch (pwr_evt->state) {
   1f160:	7a02      	ldrb	r2, [r0, #8]
   1f162:	2a04      	cmp	r2, #4
   1f164:	d8c0      	bhi.n	1f0e8 <usbd_work_handler+0xc4>
   1f166:	e8df f002 	tbb	[pc, r2]
   1f16a:	0355      	.short	0x0355
   1f16c:	631f      	.short	0x631f
   1f16e:	6f          	.byte	0x6f
   1f16f:	00          	.byte	0x00
		if (!nrfx_usbd_is_enabled()) {
   1f170:	f003 f968 	bl	22444 <nrfx_usbd_is_enabled>
   1f174:	4605      	mov	r5, r0
   1f176:	2800      	cmp	r0, #0
   1f178:	d1b6      	bne.n	1f0e8 <usbd_work_handler+0xc4>
			nrfx_usbd_enable();
   1f17a:	f003 f90f 	bl	2239c <nrfx_usbd_enable>
   1f17e:	2301      	movs	r3, #1
   1f180:	495c      	ldr	r1, [pc, #368]	; (1f2f4 <usbd_work_handler+0x2d0>)
   1f182:	e8d1 2fef 	ldaex	r2, [r1]
   1f186:	2a00      	cmp	r2, #0
   1f188:	d103      	bne.n	1f192 <usbd_work_handler+0x16e>
   1f18a:	e8c1 3fe0 	stlex	r0, r3, [r1]
   1f18e:	2800      	cmp	r0, #0
   1f190:	d1f7      	bne.n	1f182 <usbd_work_handler+0x15e>
	if (atomic_cas(&ctx->clk_requested, 0, 1)) {
   1f192:	d1a9      	bne.n	1f0e8 <usbd_work_handler+0xc4>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
   1f194:	f841 5c08 	str.w	r5, [r1, #-8]
   1f198:	f841 5c10 	str.w	r5, [r1, #-16]
		return onoff_request(ctx->hfxo_mgr, &ctx->hfxo_cli);
   1f19c:	69e0      	ldr	r0, [r4, #28]
   1f19e:	3914      	subs	r1, #20
   1f1a0:	6163      	str	r3, [r4, #20]
   1f1a2:	f005 fbba 	bl	2491a <onoff_request>
   1f1a6:	e79f      	b.n	1f0e8 <usbd_work_handler+0xc4>
	switch (pwr_evt->state) {
   1f1a8:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPIN(ep));
   1f1aa:	f065 007f 	orn	r0, r5, #127	; 0x7f
   1f1ae:	b2c0      	uxtb	r0, r0
   1f1b0:	f7ff fd2c 	bl	1ec0c <endpoint_ctx>
		if (ep_ctx->cfg.en) {
   1f1b4:	7a03      	ldrb	r3, [r0, #8]
   1f1b6:	b113      	cbz	r3, 1f1be <usbd_work_handler+0x19a>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f1b8:	7a40      	ldrb	r0, [r0, #9]
   1f1ba:	f003 fd91 	bl	22ce0 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPIN_CNT; i++) {
   1f1be:	3501      	adds	r5, #1
   1f1c0:	2d08      	cmp	r5, #8
   1f1c2:	d1f2      	bne.n	1f1aa <usbd_work_handler+0x186>
		if (ep_ctx->cfg.en) {
   1f1c4:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
   1f1c8:	b11b      	cbz	r3, 1f1d2 <usbd_work_handler+0x1ae>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f1ca:	f894 0155 	ldrb.w	r0, [r4, #341]	; 0x155
   1f1ce:	f003 fd87 	bl	22ce0 <nrfx_usbd_ep_enable>
	switch (pwr_evt->state) {
   1f1d2:	2500      	movs	r5, #0
	return endpoint_ctx(NRF_USBD_EPOUT(ep));
   1f1d4:	b2e8      	uxtb	r0, r5
   1f1d6:	f7ff fd19 	bl	1ec0c <endpoint_ctx>
		if (ep_ctx->cfg.en) {
   1f1da:	7a03      	ldrb	r3, [r0, #8]
   1f1dc:	b113      	cbz	r3, 1f1e4 <usbd_work_handler+0x1c0>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f1de:	7a40      	ldrb	r0, [r0, #9]
   1f1e0:	f003 fd7e 	bl	22ce0 <nrfx_usbd_ep_enable>
	for (i = 0; i < CFG_EPOUT_CNT; i++) {
   1f1e4:	3501      	adds	r5, #1
   1f1e6:	2d08      	cmp	r5, #8
   1f1e8:	d1f4      	bne.n	1f1d4 <usbd_work_handler+0x1b0>
		if (ep_ctx->cfg.en) {
   1f1ea:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
   1f1ee:	b11b      	cbz	r3, 1f1f8 <usbd_work_handler+0x1d4>
			nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   1f1f0:	f894 0275 	ldrb.w	r0, [r4, #629]	; 0x275
   1f1f4:	f003 fd74 	bl	22ce0 <nrfx_usbd_ep_enable>
		nrfx_usbd_start(true);
   1f1f8:	2001      	movs	r0, #1
   1f1fa:	f003 f905 	bl	22408 <nrfx_usbd_start>
		ctx->ready = true;
   1f1fe:	2301      	movs	r3, #1
   1f200:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
		if (ctx->status_cb) {
   1f204:	6823      	ldr	r3, [r4, #0]
   1f206:	2b00      	cmp	r3, #0
   1f208:	f43f af6e 	beq.w	1f0e8 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_CONNECTED, NULL);
   1f20c:	2100      	movs	r1, #0
   1f20e:	2002      	movs	r0, #2
				ctx->status_cb(USB_DC_SOF, NULL);
   1f210:	4798      	blx	r3
   1f212:	e769      	b.n	1f0e8 <usbd_work_handler+0xc4>
		ctx->ready = false;
   1f214:	2500      	movs	r5, #0
   1f216:	f884 5025 	strb.w	r5, [r4, #37]	; 0x25
		nrfx_usbd_disable();
   1f21a:	f003 fd1f 	bl	22c5c <nrfx_usbd_disable>
		err = hfxo_stop(ctx);
   1f21e:	f7ff fe23 	bl	1ee68 <hfxo_stop.constprop.0.isra.0>
		if (ctx->status_cb) {
   1f222:	6823      	ldr	r3, [r4, #0]
   1f224:	2b00      	cmp	r3, #0
   1f226:	f43f af5f 	beq.w	1f0e8 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_DISCONNECTED, NULL);
   1f22a:	4629      	mov	r1, r5
   1f22c:	2004      	movs	r0, #4
   1f22e:	e7ef      	b.n	1f210 <usbd_work_handler+0x1ec>
		if (dev_ready()) {
   1f230:	2b00      	cmp	r3, #0
   1f232:	f43f af59 	beq.w	1f0e8 <usbd_work_handler+0xc4>
			nrfx_usbd_suspend();
   1f236:	f003 f90f 	bl	22458 <nrfx_usbd_suspend>
			if (ctx->status_cb) {
   1f23a:	6823      	ldr	r3, [r4, #0]
   1f23c:	2b00      	cmp	r3, #0
   1f23e:	f43f af53 	beq.w	1f0e8 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_SUSPEND, NULL);
   1f242:	2100      	movs	r1, #0
   1f244:	2005      	movs	r0, #5
   1f246:	e7e3      	b.n	1f210 <usbd_work_handler+0x1ec>
		if (ctx->status_cb && dev_ready()) {
   1f248:	6822      	ldr	r2, [r4, #0]
   1f24a:	2a00      	cmp	r2, #0
   1f24c:	f43f af4c 	beq.w	1f0e8 <usbd_work_handler+0xc4>
   1f250:	2b00      	cmp	r3, #0
   1f252:	f43f af49 	beq.w	1f0e8 <usbd_work_handler+0xc4>
			ctx->status_cb(USB_DC_RESUME, NULL);
   1f256:	2100      	movs	r1, #0
   1f258:	2006      	movs	r0, #6
   1f25a:	4790      	blx	r2
   1f25c:	e744      	b.n	1f0e8 <usbd_work_handler+0xc4>
			k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f25e:	f107 0510 	add.w	r5, r7, #16
   1f262:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f266:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f26a:	4628      	mov	r0, r5
   1f26c:	f005 fede 	bl	2502c <k_mutex_lock.constprop.0.isra.0>
			eps_ctx_init();
   1f270:	f7ff fea4 	bl	1efbc <eps_ctx_init>
			k_mutex_unlock(&ctx->drv_lock);
   1f274:	4628      	mov	r0, r5
   1f276:	f005 fedb 	bl	25030 <k_mutex_unlock.isra.0>
			if (ctx->status_cb) {
   1f27a:	f857 3c28 	ldr.w	r3, [r7, #-40]
   1f27e:	2b00      	cmp	r3, #0
   1f280:	f43f af32 	beq.w	1f0e8 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_RESET, NULL);
   1f284:	2100      	movs	r1, #0
   1f286:	2001      	movs	r0, #1
   1f288:	e7c2      	b.n	1f210 <usbd_work_handler+0x1ec>
	if (ep_ctx->cfg.en) {
   1f28a:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
   1f28e:	b17b      	cbz	r3, 1f2b0 <usbd_work_handler+0x28c>
		ep_ctx->read_pending = true;
   1f290:	2501      	movs	r5, #1
   1f292:	f884 5289 	strb.w	r5, [r4, #649]	; 0x289
		ep_ctx->read_complete = true;
   1f296:	f884 5288 	strb.w	r5, [r4, #648]	; 0x288
		ev = usbd_evt_alloc();
   1f29a:	f7ff fcfd 	bl	1ec98 <usbd_evt_alloc>
		if (!ev) {
   1f29e:	b138      	cbz	r0, 1f2b0 <usbd_work_handler+0x28c>
		ev->evt.ep_evt.ep = ep_ctx;
   1f2a0:	4a15      	ldr	r2, [pc, #84]	; (1f2f8 <usbd_work_handler+0x2d4>)
		ev->evt_type = USBD_EVT_EP;
   1f2a2:	7405      	strb	r5, [r0, #16]
		ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1f2a4:	7305      	strb	r5, [r0, #12]
		ev->evt.ep_evt.ep = ep_ctx;
   1f2a6:	6082      	str	r2, [r0, #8]
		usbd_evt_put(ev);
   1f2a8:	f7ff fca2 	bl	1ebf0 <usbd_evt_put>
		usbd_work_schedule();
   1f2ac:	f7ff fca6 	bl	1ebfc <usbd_work_schedule>
			if (ctx->status_cb) {
   1f2b0:	f857 3c28 	ldr.w	r3, [r7, #-40]
   1f2b4:	2b00      	cmp	r3, #0
   1f2b6:	f43f af17 	beq.w	1f0e8 <usbd_work_handler+0xc4>
				ctx->status_cb(USB_DC_SOF, NULL);
   1f2ba:	2100      	movs	r1, #0
   1f2bc:	200a      	movs	r0, #10
   1f2be:	e7a7      	b.n	1f210 <usbd_work_handler+0x1ec>
	nrfx_power_usbevt_disable();
   1f2c0:	f003 fd7a 	bl	22db8 <nrfx_usbreg_disable>
	nrfx_usbd_disable();
   1f2c4:	f003 fcca 	bl	22c5c <nrfx_usbd_disable>
	nrfx_usbd_uninit();
   1f2c8:	f003 f85e 	bl	22388 <nrfx_usbd_uninit>
	usbd_evt_flush();
   1f2cc:	f7ff fcd6 	bl	1ec7c <usbd_evt_flush>
	ret = eps_ctx_init();
   1f2d0:	f7ff fe74 	bl	1efbc <eps_ctx_init>
	nrfx_power_usbevt_enable();
   1f2d4:	f003 fd68 	bl	22da8 <nrfx_usbreg_enable>
	err = nrfx_usbd_init(usbd_event_handler);
   1f2d8:	4808      	ldr	r0, [pc, #32]	; (1f2fc <usbd_work_handler+0x2d8>)
   1f2da:	f003 f8e9 	bl	224b0 <nrfx_usbd_init>
}
   1f2de:	e703      	b.n	1f0e8 <usbd_work_handler+0xc4>
   1f2e0:	2000a94c 	.word	0x2000a94c
   1f2e4:	2000a2d8 	.word	0x2000a2d8
   1f2e8:	40036000 	.word	0x40036000
   1f2ec:	2000a950 	.word	0x2000a950
   1f2f0:	2000a984 	.word	0x2000a984
   1f2f4:	2000a96c 	.word	0x2000a96c
   1f2f8:	2000abb8 	.word	0x2000abb8
   1f2fc:	0001eea1 	.word	0x0001eea1

0001f300 <usb_dc_attach>:
{
   1f300:	b538      	push	{r3, r4, r5, lr}
	if (ctx->attached) {
   1f302:	4d15      	ldr	r5, [pc, #84]	; (1f358 <usb_dc_attach+0x58>)
   1f304:	f895 4024 	ldrb.w	r4, [r5, #36]	; 0x24
   1f308:	bb24      	cbnz	r4, 1f354 <usb_dc_attach+0x54>
	return z_impl_k_mutex_init(mutex);
   1f30a:	f105 0038 	add.w	r0, r5, #56	; 0x38
   1f30e:	f006 fc5c 	bl	25bca <z_impl_k_mutex_init>
		z_nrf_clock_control_get_onoff(
   1f312:	2002      	movs	r0, #2
   1f314:	f000 fb20 	bl	1f958 <z_nrf_clock_control_get_onoff>
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f318:	4622      	mov	r2, r4
   1f31a:	2101      	movs	r1, #1
	ctx->hfxo_mgr =
   1f31c:	61e8      	str	r0, [r5, #28]
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f31e:	2036      	movs	r0, #54	; 0x36
   1f320:	f7ff f806 	bl	1e330 <z_arm_irq_priority_set>
	nrfx_power_usbevt_enable();
   1f324:	f003 fd40 	bl	22da8 <nrfx_usbreg_enable>
	ret = eps_ctx_init();
   1f328:	f7ff fe48 	bl	1efbc <eps_ctx_init>
	if (ret == 0) {
   1f32c:	4604      	mov	r4, r0
   1f32e:	b910      	cbnz	r0, 1f336 <usb_dc_attach+0x36>
		ctx->attached = true;
   1f330:	2301      	movs	r3, #1
   1f332:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_sfnode_t *sys_sflist_peek_head(sys_sflist_t *list)
{
	return list->head;
   1f336:	4b09      	ldr	r3, [pc, #36]	; (1f35c <usb_dc_attach+0x5c>)
	if (!k_fifo_is_empty(&usbd_evt_fifo)) {
   1f338:	681b      	ldr	r3, [r3, #0]
   1f33a:	b10b      	cbz	r3, 1f340 <usb_dc_attach+0x40>
		usbd_work_schedule();
   1f33c:	f7ff fc5e 	bl	1ebfc <usbd_work_schedule>
    return p_reg->INTENSET & mask;
}

NRF_STATIC_INLINE uint32_t nrf_usbreg_status_get(NRF_USBREG_Type const * p_reg)
{
    return p_reg->USBREGSTATUS;
   1f340:	4b07      	ldr	r3, [pc, #28]	; (1f360 <usb_dc_attach+0x60>)
   1f342:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_usbreg_state_t nrfx_usbreg_usbstatus_get(void)
{
    uint32_t status = nrf_usbreg_status_get(NRF_USBREGULATOR);
    if (0 == (status & NRF_USBREG_STATUS_VBUSDETECT_MASK))
   1f346:	07db      	lsls	r3, r3, #31
   1f348:	d502      	bpl.n	1f350 <usb_dc_attach+0x50>
		usb_dc_power_event_handler(NRFX_POWER_USB_EVT_DETECTED);
   1f34a:	2000      	movs	r0, #0
   1f34c:	f7ff fd30 	bl	1edb0 <usb_dc_power_event_handler>
}
   1f350:	4620      	mov	r0, r4
   1f352:	bd38      	pop	{r3, r4, r5, pc}
		return 0;
   1f354:	2400      	movs	r4, #0
   1f356:	e7fb      	b.n	1f350 <usb_dc_attach+0x50>
   1f358:	2000a94c 	.word	0x2000a94c
   1f35c:	2000a31c 	.word	0x2000a31c
   1f360:	40037000 	.word	0x40037000

0001f364 <usb_dc_set_address>:
	return get_usbd_ctx()->attached;
   1f364:	4b07      	ldr	r3, [pc, #28]	; (1f384 <usb_dc_set_address+0x20>)
	if (!dev_attached() || !dev_ready()) {
   1f366:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   1f36a:	b13a      	cbz	r2, 1f37c <usb_dc_set_address+0x18>
   1f36c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
		return -ENODEV;
   1f370:	2b00      	cmp	r3, #0
   1f372:	bf14      	ite	ne
   1f374:	2000      	movne	r0, #0
   1f376:	f06f 0012 	mvneq.w	r0, #18
   1f37a:	4770      	bx	lr
   1f37c:	f06f 0012 	mvn.w	r0, #18
}
   1f380:	4770      	bx	lr
   1f382:	bf00      	nop
   1f384:	2000a94c 	.word	0x2000a94c

0001f388 <usb_dc_ep_configure>:
{
   1f388:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f38a:	4b10      	ldr	r3, [pc, #64]	; (1f3cc <usb_dc_ep_configure+0x44>)
{
   1f38c:	4604      	mov	r4, r0
	if (!dev_attached()) {
   1f38e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1f392:	b1c3      	cbz	r3, 1f3c6 <usb_dc_ep_configure+0x3e>
	ep_ctx = endpoint_ctx(ep_cfg->ep_addr);
   1f394:	7805      	ldrb	r5, [r0, #0]
   1f396:	4628      	mov	r0, r5
   1f398:	f7ff fc38 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f39c:	b910      	cbnz	r0, 1f3a4 <usb_dc_ep_configure+0x1c>
		return -EINVAL;
   1f39e:	f06f 0015 	mvn.w	r0, #21
}
   1f3a2:	bd38      	pop	{r3, r4, r5, pc}
	ep_ctx->cfg.addr = ep_cfg->ep_addr;
   1f3a4:	7245      	strb	r5, [r0, #9]
	ep_ctx->cfg.type = ep_cfg->ep_type;
   1f3a6:	7923      	ldrb	r3, [r4, #4]
   1f3a8:	7283      	strb	r3, [r0, #10]
	ep_ctx->cfg.max_sz = ep_cfg->ep_mps;
   1f3aa:	8863      	ldrh	r3, [r4, #2]
   1f3ac:	6043      	str	r3, [r0, #4]
	if (!NRF_USBD_EPISO_CHECK(ep_cfg->ep_addr)) {
   1f3ae:	7820      	ldrb	r0, [r4, #0]
   1f3b0:	8861      	ldrh	r1, [r4, #2]
   1f3b2:	f010 0f08 	tst.w	r0, #8
   1f3b6:	d102      	bne.n	1f3be <usb_dc_ep_configure+0x36>
		if ((ep_cfg->ep_mps & (ep_cfg->ep_mps - 1)) != 0U) {
   1f3b8:	1e4b      	subs	r3, r1, #1
   1f3ba:	420b      	tst	r3, r1
   1f3bc:	d1ef      	bne.n	1f39e <usb_dc_ep_configure+0x16>
	nrfx_usbd_ep_max_packet_size_set(ep_addr_to_nrfx(ep_cfg->ep_addr),
   1f3be:	f006 fb41 	bl	25a44 <nrfx_usbd_ep_max_packet_size_set>
	return 0;
   1f3c2:	2000      	movs	r0, #0
   1f3c4:	e7ed      	b.n	1f3a2 <usb_dc_ep_configure+0x1a>
		return -ENODEV;
   1f3c6:	f06f 0012 	mvn.w	r0, #18
   1f3ca:	e7ea      	b.n	1f3a2 <usb_dc_ep_configure+0x1a>
   1f3cc:	2000a94c 	.word	0x2000a94c

0001f3d0 <usb_dc_ep_set_stall>:
{
   1f3d0:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f3d2:	4b12      	ldr	r3, [pc, #72]	; (1f41c <usb_dc_ep_set_stall+0x4c>)
{
   1f3d4:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   1f3d6:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   1f3da:	b1ca      	cbz	r2, 1f410 <usb_dc_ep_set_stall+0x40>
   1f3dc:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f3e0:	b1b3      	cbz	r3, 1f410 <usb_dc_ep_set_stall+0x40>
	ep_ctx = endpoint_ctx(ep);
   1f3e2:	f7ff fc13 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f3e6:	4604      	mov	r4, r0
   1f3e8:	b1a8      	cbz	r0, 1f416 <usb_dc_ep_set_stall+0x46>
	switch (ep_ctx->cfg.type) {
   1f3ea:	7a83      	ldrb	r3, [r0, #10]
   1f3ec:	2b01      	cmp	r3, #1
   1f3ee:	d012      	beq.n	1f416 <usb_dc_ep_set_stall+0x46>
   1f3f0:	d907      	bls.n	1f402 <usb_dc_ep_set_stall+0x32>
   1f3f2:	3b02      	subs	r3, #2
   1f3f4:	2b01      	cmp	r3, #1
   1f3f6:	d907      	bls.n	1f408 <usb_dc_ep_set_stall+0x38>
	ep_ctx->buf.len = 0U;
   1f3f8:	2000      	movs	r0, #0
	ep_ctx->buf.curr = ep_ctx->buf.data;
   1f3fa:	6963      	ldr	r3, [r4, #20]
	ep_ctx->buf.len = 0U;
   1f3fc:	60e0      	str	r0, [r4, #12]
	ep_ctx->buf.curr = ep_ctx->buf.data;
   1f3fe:	61a3      	str	r3, [r4, #24]
}
   1f400:	bd38      	pop	{r3, r4, r5, pc}
		nrfx_usbd_setup_stall();
   1f402:	f003 fac7 	bl	22994 <nrfx_usbd_setup_stall>
		break;
   1f406:	e7f7      	b.n	1f3f8 <usb_dc_ep_set_stall+0x28>
		nrfx_usbd_ep_stall(ep_addr_to_nrfx(ep));
   1f408:	4628      	mov	r0, r5
   1f40a:	f003 fa33 	bl	22874 <nrfx_usbd_ep_stall>
		break;
   1f40e:	e7f3      	b.n	1f3f8 <usb_dc_ep_set_stall+0x28>
		return -ENODEV;
   1f410:	f06f 0012 	mvn.w	r0, #18
   1f414:	e7f4      	b.n	1f400 <usb_dc_ep_set_stall+0x30>
	switch (ep_ctx->cfg.type) {
   1f416:	f06f 0015 	mvn.w	r0, #21
   1f41a:	e7f1      	b.n	1f400 <usb_dc_ep_set_stall+0x30>
   1f41c:	2000a94c 	.word	0x2000a94c

0001f420 <usb_dc_ep_clear_stall>:
{
   1f420:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f422:	4b0e      	ldr	r3, [pc, #56]	; (1f45c <usb_dc_ep_clear_stall+0x3c>)
{
   1f424:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   1f426:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
   1f42a:	b182      	cbz	r2, 1f44e <usb_dc_ep_clear_stall+0x2e>
   1f42c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f430:	b16b      	cbz	r3, 1f44e <usb_dc_ep_clear_stall+0x2e>
	ep_ctx = endpoint_ctx(ep);
   1f432:	f7ff fbeb 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f436:	b168      	cbz	r0, 1f454 <usb_dc_ep_clear_stall+0x34>
	if (NRF_USBD_EPISO_CHECK(ep)) {
   1f438:	f015 0408 	ands.w	r4, r5, #8
   1f43c:	d10a      	bne.n	1f454 <usb_dc_ep_clear_stall+0x34>
	nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
   1f43e:	4628      	mov	r0, r5
   1f440:	f003 fa3a 	bl	228b8 <nrfx_usbd_ep_dtoggle_clear>
	nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
   1f444:	4628      	mov	r0, r5
   1f446:	f003 fc9f 	bl	22d88 <nrfx_usbd_ep_stall_clear>
	return 0;
   1f44a:	4620      	mov	r0, r4
}
   1f44c:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
   1f44e:	f06f 0012 	mvn.w	r0, #18
   1f452:	e7fb      	b.n	1f44c <usb_dc_ep_clear_stall+0x2c>
		return -EINVAL;
   1f454:	f06f 0015 	mvn.w	r0, #21
   1f458:	e7f8      	b.n	1f44c <usb_dc_ep_clear_stall+0x2c>
   1f45a:	bf00      	nop
   1f45c:	2000a94c 	.word	0x2000a94c

0001f460 <usb_dc_ep_is_stalled>:
{
   1f460:	b538      	push	{r3, r4, r5, lr}
	return get_usbd_ctx()->attached;
   1f462:	4b0c      	ldr	r3, [pc, #48]	; (1f494 <usb_dc_ep_is_stalled+0x34>)
{
   1f464:	4605      	mov	r5, r0
	if (!dev_attached() || !dev_ready()) {
   1f466:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   1f46a:	460c      	mov	r4, r1
	if (!dev_attached() || !dev_ready()) {
   1f46c:	b162      	cbz	r2, 1f488 <usb_dc_ep_is_stalled+0x28>
   1f46e:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f472:	b14b      	cbz	r3, 1f488 <usb_dc_ep_is_stalled+0x28>
	ep_ctx = endpoint_ctx(ep);
   1f474:	f7ff fbca 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f478:	b148      	cbz	r0, 1f48e <usb_dc_ep_is_stalled+0x2e>
	if (!stalled) {
   1f47a:	b144      	cbz	r4, 1f48e <usb_dc_ep_is_stalled+0x2e>
	*stalled = (uint8_t) nrfx_usbd_ep_stall_check(ep_addr_to_nrfx(ep));
   1f47c:	4628      	mov	r0, r5
   1f47e:	f003 fa01 	bl	22884 <nrfx_usbd_ep_stall_check>
   1f482:	7020      	strb	r0, [r4, #0]
	return 0;
   1f484:	2000      	movs	r0, #0
}
   1f486:	bd38      	pop	{r3, r4, r5, pc}
		return -ENODEV;
   1f488:	f06f 0012 	mvn.w	r0, #18
   1f48c:	e7fb      	b.n	1f486 <usb_dc_ep_is_stalled+0x26>
		return -EINVAL;
   1f48e:	f06f 0015 	mvn.w	r0, #21
   1f492:	e7f8      	b.n	1f486 <usb_dc_ep_is_stalled+0x26>
   1f494:	2000a94c 	.word	0x2000a94c

0001f498 <usb_dc_ep_enable>:
{
   1f498:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
   1f49a:	4e13      	ldr	r6, [pc, #76]	; (1f4e8 <usb_dc_ep_enable+0x50>)
{
   1f49c:	4604      	mov	r4, r0
	if (!dev_attached()) {
   1f49e:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
   1f4a2:	b1c3      	cbz	r3, 1f4d6 <usb_dc_ep_enable+0x3e>
	ep_ctx = endpoint_ctx(ep);
   1f4a4:	f7ff fbb2 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f4a8:	4605      	mov	r5, r0
   1f4aa:	b1b8      	cbz	r0, 1f4dc <usb_dc_ep_enable+0x44>
	if (!NRF_USBD_EPISO_CHECK(ep)) {
   1f4ac:	0723      	lsls	r3, r4, #28
   1f4ae:	d405      	bmi.n	1f4bc <usb_dc_ep_enable+0x24>
		nrfx_usbd_ep_dtoggle_clear(ep_addr_to_nrfx(ep));
   1f4b0:	4620      	mov	r0, r4
   1f4b2:	f003 fa01 	bl	228b8 <nrfx_usbd_ep_dtoggle_clear>
		nrfx_usbd_ep_stall_clear(ep_addr_to_nrfx(ep));
   1f4b6:	4620      	mov	r0, r4
   1f4b8:	f003 fc66 	bl	22d88 <nrfx_usbd_ep_stall_clear>
	if (ep_ctx->cfg.en) {
   1f4bc:	7a2b      	ldrb	r3, [r5, #8]
   1f4be:	b983      	cbnz	r3, 1f4e2 <usb_dc_ep_enable+0x4a>
	ep_ctx->cfg.en = true;
   1f4c0:	2301      	movs	r3, #1
   1f4c2:	722b      	strb	r3, [r5, #8]
	if (dev_ready()) {
   1f4c4:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
   1f4c8:	b90b      	cbnz	r3, 1f4ce <usb_dc_ep_enable+0x36>
	return 0;
   1f4ca:	2000      	movs	r0, #0
}
   1f4cc:	bd70      	pop	{r4, r5, r6, pc}
		nrfx_usbd_ep_enable(ep_addr_to_nrfx(ep));
   1f4ce:	4620      	mov	r0, r4
   1f4d0:	f003 fc06 	bl	22ce0 <nrfx_usbd_ep_enable>
   1f4d4:	e7f9      	b.n	1f4ca <usb_dc_ep_enable+0x32>
		return -ENODEV;
   1f4d6:	f06f 0012 	mvn.w	r0, #18
   1f4da:	e7f7      	b.n	1f4cc <usb_dc_ep_enable+0x34>
		return -EINVAL;
   1f4dc:	f06f 0015 	mvn.w	r0, #21
   1f4e0:	e7f4      	b.n	1f4cc <usb_dc_ep_enable+0x34>
		return -EALREADY;
   1f4e2:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1f4e6:	e7f1      	b.n	1f4cc <usb_dc_ep_enable+0x34>
   1f4e8:	2000a94c 	.word	0x2000a94c

0001f4ec <usb_dc_ep_write>:
{
   1f4ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	return get_usbd_ctx()->attached;
   1f4f0:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 1f5d8 <usb_dc_ep_write+0xec>
{
   1f4f4:	461e      	mov	r6, r3
	if (!dev_attached() || !dev_ready()) {
   1f4f6:	f898 3024 	ldrb.w	r3, [r8, #36]	; 0x24
{
   1f4fa:	4607      	mov	r7, r0
   1f4fc:	4689      	mov	r9, r1
   1f4fe:	4615      	mov	r5, r2
   1f500:	b085      	sub	sp, #20
	if (!dev_attached() || !dev_ready()) {
   1f502:	2b00      	cmp	r3, #0
   1f504:	d061      	beq.n	1f5ca <usb_dc_ep_write+0xde>
   1f506:	f898 3025 	ldrb.w	r3, [r8, #37]	; 0x25
   1f50a:	2b00      	cmp	r3, #0
   1f50c:	d05d      	beq.n	1f5ca <usb_dc_ep_write+0xde>
	if (NRF_USBD_EPOUT_CHECK(ep)) {
   1f50e:	0603      	lsls	r3, r0, #24
   1f510:	d55e      	bpl.n	1f5d0 <usb_dc_ep_write+0xe4>
	ep_ctx = endpoint_ctx(ep);
   1f512:	f7ff fb7b 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f516:	4604      	mov	r4, r0
   1f518:	2800      	cmp	r0, #0
   1f51a:	d059      	beq.n	1f5d0 <usb_dc_ep_write+0xe4>
	if (!ep_ctx->cfg.en) {
   1f51c:	7a03      	ldrb	r3, [r0, #8]
   1f51e:	2b00      	cmp	r3, #0
   1f520:	d056      	beq.n	1f5d0 <usb_dc_ep_write+0xe4>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f522:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f526:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f52a:	f108 0038 	add.w	r0, r8, #56	; 0x38
   1f52e:	f005 fd7d 	bl	2502c <k_mutex_lock.constprop.0.isra.0>
	if (ep_ctx->write_in_progress) {
   1f532:	7fa3      	ldrb	r3, [r4, #30]
   1f534:	b14b      	cbz	r3, 1f54a <usb_dc_ep_write+0x5e>
		k_mutex_unlock(&ctx->drv_lock);
   1f536:	f108 0038 	add.w	r0, r8, #56	; 0x38
   1f53a:	f005 fd79 	bl	25030 <k_mutex_unlock.isra.0>
		return -EAGAIN;
   1f53e:	f06f 040a 	mvn.w	r4, #10
}
   1f542:	4620      	mov	r0, r4
   1f544:	b005      	add	sp, #20
   1f546:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   1f54a:	7aa3      	ldrb	r3, [r4, #10]
	if (!data_len && ep_ctx->trans_zlp) {
   1f54c:	b1c5      	cbz	r5, 1f580 <usb_dc_ep_write+0x94>
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   1f54e:	b33b      	cbz	r3, 1f5a0 <usb_dc_ep_write+0xb4>
	ep_ctx->write_in_progress = true;
   1f550:	2301      	movs	r3, #1
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
   1f552:	f04f 0800 	mov.w	r8, #0
	ep_ctx->write_in_progress = true;
   1f556:	77a3      	strb	r3, [r4, #30]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
   1f558:	4638      	mov	r0, r7
   1f55a:	a901      	add	r1, sp, #4
	NRFX_USBD_TRANSFER_IN(transfer, data, data_len, 0);
   1f55c:	e9cd 9501 	strd	r9, r5, [sp, #4]
   1f560:	f8cd 800c 	str.w	r8, [sp, #12]
	nrfx_err_t err = nrfx_usbd_ep_transfer(ep_addr_to_nrfx(ep), &transfer);
   1f564:	f002 ffe6 	bl	22534 <nrfx_usbd_ep_transfer>
	if (err != NRFX_SUCCESS) {
   1f568:	4b1c      	ldr	r3, [pc, #112]	; (1f5dc <usb_dc_ep_write+0xf0>)
   1f56a:	4298      	cmp	r0, r3
   1f56c:	d029      	beq.n	1f5c2 <usb_dc_ep_write+0xd6>
		ep_ctx->write_in_progress = false;
   1f56e:	f884 801e 	strb.w	r8, [r4, #30]
		if (ret_bytes) {
   1f572:	bb1e      	cbnz	r6, 1f5bc <usb_dc_ep_write+0xd0>
		result = -EIO;
   1f574:	f06f 0404 	mvn.w	r4, #4
	k_mutex_unlock(&ctx->drv_lock);
   1f578:	4819      	ldr	r0, [pc, #100]	; (1f5e0 <usb_dc_ep_write+0xf4>)
   1f57a:	f005 fd59 	bl	25030 <k_mutex_unlock.isra.0>
	return result;
   1f57e:	e7e0      	b.n	1f542 <usb_dc_ep_write+0x56>
	if (!data_len && ep_ctx->trans_zlp) {
   1f580:	7fe2      	ldrb	r2, [r4, #31]
   1f582:	b102      	cbz	r2, 1f586 <usb_dc_ep_write+0x9a>
		ep_ctx->trans_zlp = false;
   1f584:	77e5      	strb	r5, [r4, #31]
	if (ep_ctx->cfg.type == USB_DC_EP_CONTROL) {
   1f586:	2b00      	cmp	r3, #0
   1f588:	d1e2      	bne.n	1f550 <usb_dc_ep_write+0x64>
	    && (nrfx_usbd_last_setup_dir_get() != ep)) {
   1f58a:	f003 fa0b 	bl	229a4 <nrfx_usbd_last_setup_dir_get>
   1f58e:	42b8      	cmp	r0, r7
   1f590:	d0de      	beq.n	1f550 <usb_dc_ep_write+0x64>
		nrfx_usbd_setup_clear();
   1f592:	f003 f9f7 	bl	22984 <nrfx_usbd_setup_clear>
		k_mutex_unlock(&ctx->drv_lock);
   1f596:	4812      	ldr	r0, [pc, #72]	; (1f5e0 <usb_dc_ep_write+0xf4>)
   1f598:	f005 fd4a 	bl	25030 <k_mutex_unlock.isra.0>
		return 0;
   1f59c:	2400      	movs	r4, #0
   1f59e:	e7d0      	b.n	1f542 <usb_dc_ep_write+0x56>
		if (data_len && usbd_ctx.setup.wLength > data_len &&
   1f5a0:	f8b8 300a 	ldrh.w	r3, [r8, #10]
   1f5a4:	42ab      	cmp	r3, r5
   1f5a6:	d9f0      	bls.n	1f58a <usb_dc_ep_write+0x9e>
		    !(data_len % ep_ctx->cfg.max_sz)) {
   1f5a8:	6862      	ldr	r2, [r4, #4]
   1f5aa:	fbb5 f3f2 	udiv	r3, r5, r2
   1f5ae:	fb02 5313 	mls	r3, r2, r3, r5
		if (data_len && usbd_ctx.setup.wLength > data_len &&
   1f5b2:	2b00      	cmp	r3, #0
   1f5b4:	d1e9      	bne.n	1f58a <usb_dc_ep_write+0x9e>
			ep_ctx->trans_zlp = true;
   1f5b6:	2301      	movs	r3, #1
   1f5b8:	77e3      	strb	r3, [r4, #31]
	if ((ep_ctx->cfg.type == USB_DC_EP_CONTROL)
   1f5ba:	e7e6      	b.n	1f58a <usb_dc_ep_write+0x9e>
			*ret_bytes = 0;
   1f5bc:	f8c6 8000 	str.w	r8, [r6]
   1f5c0:	e7d8      	b.n	1f574 <usb_dc_ep_write+0x88>
		if (ret_bytes) {
   1f5c2:	b106      	cbz	r6, 1f5c6 <usb_dc_ep_write+0xda>
			*ret_bytes = data_len;
   1f5c4:	6035      	str	r5, [r6, #0]
	int result = 0;
   1f5c6:	2400      	movs	r4, #0
   1f5c8:	e7d6      	b.n	1f578 <usb_dc_ep_write+0x8c>
		return -ENODEV;
   1f5ca:	f06f 0412 	mvn.w	r4, #18
   1f5ce:	e7b8      	b.n	1f542 <usb_dc_ep_write+0x56>
		return -EINVAL;
   1f5d0:	f06f 0415 	mvn.w	r4, #21
   1f5d4:	e7b5      	b.n	1f542 <usb_dc_ep_write+0x56>
   1f5d6:	bf00      	nop
   1f5d8:	2000a94c 	.word	0x2000a94c
   1f5dc:	0bad0000 	.word	0x0bad0000
   1f5e0:	2000a984 	.word	0x2000a984

0001f5e4 <usb_dc_ep_read_wait>:
{
   1f5e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1f5e8:	461d      	mov	r5, r3
	return get_usbd_ctx()->attached;
   1f5ea:	4b20      	ldr	r3, [pc, #128]	; (1f66c <usb_dc_ep_read_wait+0x88>)
{
   1f5ec:	4617      	mov	r7, r2
	if (!dev_attached() || !dev_ready()) {
   1f5ee:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
{
   1f5f2:	460e      	mov	r6, r1
	if (!dev_attached() || !dev_ready()) {
   1f5f4:	2a00      	cmp	r2, #0
   1f5f6:	d033      	beq.n	1f660 <usb_dc_ep_read_wait+0x7c>
   1f5f8:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
   1f5fc:	b383      	cbz	r3, 1f660 <usb_dc_ep_read_wait+0x7c>
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1f5fe:	0603      	lsls	r3, r0, #24
   1f600:	d431      	bmi.n	1f666 <usb_dc_ep_read_wait+0x82>
	if (!data && max_data_len) {
   1f602:	b901      	cbnz	r1, 1f606 <usb_dc_ep_read_wait+0x22>
   1f604:	bb7f      	cbnz	r7, 1f666 <usb_dc_ep_read_wait+0x82>
	ep_ctx = endpoint_ctx(ep);
   1f606:	f7ff fb01 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f60a:	4604      	mov	r4, r0
   1f60c:	b358      	cbz	r0, 1f666 <usb_dc_ep_read_wait+0x82>
	if (!ep_ctx->cfg.en) {
   1f60e:	7a03      	ldrb	r3, [r0, #8]
   1f610:	b34b      	cbz	r3, 1f666 <usb_dc_ep_read_wait+0x82>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f612:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f616:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f61a:	4815      	ldr	r0, [pc, #84]	; (1f670 <usb_dc_ep_read_wait+0x8c>)
   1f61c:	f005 fd06 	bl	2502c <k_mutex_lock.constprop.0.isra.0>
	bytes_to_copy = MIN(max_data_len, ep_ctx->buf.len);
   1f620:	68e3      	ldr	r3, [r4, #12]
   1f622:	46b8      	mov	r8, r7
   1f624:	429f      	cmp	r7, r3
   1f626:	bf28      	it	cs
   1f628:	4698      	movcs	r8, r3
	if (!data && !max_data_len) {
   1f62a:	b946      	cbnz	r6, 1f63e <usb_dc_ep_read_wait+0x5a>
   1f62c:	b93f      	cbnz	r7, 1f63e <usb_dc_ep_read_wait+0x5a>
		if (read_bytes) {
   1f62e:	b105      	cbz	r5, 1f632 <usb_dc_ep_read_wait+0x4e>
			*read_bytes = ep_ctx->buf.len;
   1f630:	602b      	str	r3, [r5, #0]
		k_mutex_unlock(&ctx->drv_lock);
   1f632:	480f      	ldr	r0, [pc, #60]	; (1f670 <usb_dc_ep_read_wait+0x8c>)
   1f634:	f005 fcfc 	bl	25030 <k_mutex_unlock.isra.0>
		return 0;
   1f638:	2000      	movs	r0, #0
}
   1f63a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	memcpy(data, ep_ctx->buf.curr, bytes_to_copy);
   1f63e:	4642      	mov	r2, r8
   1f640:	4630      	mov	r0, r6
   1f642:	69a1      	ldr	r1, [r4, #24]
   1f644:	f005 fcc5 	bl	24fd2 <memcpy>
	ep_ctx->buf.curr += bytes_to_copy;
   1f648:	69a3      	ldr	r3, [r4, #24]
   1f64a:	4443      	add	r3, r8
   1f64c:	61a3      	str	r3, [r4, #24]
	ep_ctx->buf.len -= bytes_to_copy;
   1f64e:	68e3      	ldr	r3, [r4, #12]
   1f650:	eba3 0308 	sub.w	r3, r3, r8
   1f654:	60e3      	str	r3, [r4, #12]
	if (read_bytes) {
   1f656:	2d00      	cmp	r5, #0
   1f658:	d0eb      	beq.n	1f632 <usb_dc_ep_read_wait+0x4e>
		*read_bytes = bytes_to_copy;
   1f65a:	f8c5 8000 	str.w	r8, [r5]
   1f65e:	e7e8      	b.n	1f632 <usb_dc_ep_read_wait+0x4e>
		return -ENODEV;
   1f660:	f06f 0012 	mvn.w	r0, #18
   1f664:	e7e9      	b.n	1f63a <usb_dc_ep_read_wait+0x56>
		return -EINVAL;
   1f666:	f06f 0015 	mvn.w	r0, #21
   1f66a:	e7e6      	b.n	1f63a <usb_dc_ep_read_wait+0x56>
   1f66c:	2000a94c 	.word	0x2000a94c
   1f670:	2000a984 	.word	0x2000a984

0001f674 <usb_dc_ep_read_continue>:
{
   1f674:	b570      	push	{r4, r5, r6, lr}
	return get_usbd_ctx()->attached;
   1f676:	4d1e      	ldr	r5, [pc, #120]	; (1f6f0 <usb_dc_ep_read_continue+0x7c>)
{
   1f678:	4603      	mov	r3, r0
	if (!dev_attached() || !dev_ready()) {
   1f67a:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
   1f67e:	b382      	cbz	r2, 1f6e2 <usb_dc_ep_read_continue+0x6e>
   1f680:	f895 2025 	ldrb.w	r2, [r5, #37]	; 0x25
   1f684:	b36a      	cbz	r2, 1f6e2 <usb_dc_ep_read_continue+0x6e>
	if (NRF_USBD_EPIN_CHECK(ep)) {
   1f686:	061b      	lsls	r3, r3, #24
   1f688:	d42e      	bmi.n	1f6e8 <usb_dc_ep_read_continue+0x74>
	ep_ctx = endpoint_ctx(ep);
   1f68a:	f7ff fabf 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f68e:	4604      	mov	r4, r0
   1f690:	b350      	cbz	r0, 1f6e8 <usb_dc_ep_read_continue+0x74>
	if (!ep_ctx->cfg.en) {
   1f692:	7a03      	ldrb	r3, [r0, #8]
   1f694:	b343      	cbz	r3, 1f6e8 <usb_dc_ep_read_continue+0x74>
	k_mutex_lock(&ctx->drv_lock, K_FOREVER);
   1f696:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1f69a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1f69e:	f105 0038 	add.w	r0, r5, #56	; 0x38
   1f6a2:	f005 fcc3 	bl	2502c <k_mutex_lock.constprop.0.isra.0>
	if (!ep_ctx->buf.len) {
   1f6a6:	68e3      	ldr	r3, [r4, #12]
   1f6a8:	b9b3      	cbnz	r3, 1f6d8 <usb_dc_ep_read_continue+0x64>
		ep_ctx->read_complete = true;
   1f6aa:	2601      	movs	r6, #1
		ep_ctx->buf.curr = ep_ctx->buf.data;
   1f6ac:	6963      	ldr	r3, [r4, #20]
		ep_ctx->read_complete = true;
   1f6ae:	7726      	strb	r6, [r4, #28]
		ep_ctx->buf.curr = ep_ctx->buf.data;
   1f6b0:	61a3      	str	r3, [r4, #24]
		if (ep_ctx->read_pending) {
   1f6b2:	7f63      	ldrb	r3, [r4, #29]
   1f6b4:	b183      	cbz	r3, 1f6d8 <usb_dc_ep_read_continue+0x64>
			struct usbd_event *ev = usbd_evt_alloc();
   1f6b6:	f7ff faef 	bl	1ec98 <usbd_evt_alloc>
			if (!ev) {
   1f6ba:	b930      	cbnz	r0, 1f6ca <usb_dc_ep_read_continue+0x56>
				k_mutex_unlock(&ctx->drv_lock);
   1f6bc:	f105 0038 	add.w	r0, r5, #56	; 0x38
   1f6c0:	f005 fcb6 	bl	25030 <k_mutex_unlock.isra.0>
				return -ENOMEM;
   1f6c4:	f06f 000b 	mvn.w	r0, #11
}
   1f6c8:	bd70      	pop	{r4, r5, r6, pc}
			ev->evt_type = USBD_EVT_EP;
   1f6ca:	7406      	strb	r6, [r0, #16]
			ev->evt.ep_evt.ep = ep_ctx;
   1f6cc:	6084      	str	r4, [r0, #8]
			ev->evt.ep_evt.evt_type = EP_EVT_RECV_REQ;
   1f6ce:	7306      	strb	r6, [r0, #12]
			usbd_evt_put(ev);
   1f6d0:	f7ff fa8e 	bl	1ebf0 <usbd_evt_put>
			usbd_work_schedule();
   1f6d4:	f7ff fa92 	bl	1ebfc <usbd_work_schedule>
	k_mutex_unlock(&ctx->drv_lock);
   1f6d8:	4806      	ldr	r0, [pc, #24]	; (1f6f4 <usb_dc_ep_read_continue+0x80>)
   1f6da:	f005 fca9 	bl	25030 <k_mutex_unlock.isra.0>
	return 0;
   1f6de:	2000      	movs	r0, #0
   1f6e0:	e7f2      	b.n	1f6c8 <usb_dc_ep_read_continue+0x54>
		return -ENODEV;
   1f6e2:	f06f 0012 	mvn.w	r0, #18
   1f6e6:	e7ef      	b.n	1f6c8 <usb_dc_ep_read_continue+0x54>
		return -EINVAL;
   1f6e8:	f06f 0015 	mvn.w	r0, #21
   1f6ec:	e7ec      	b.n	1f6c8 <usb_dc_ep_read_continue+0x54>
   1f6ee:	bf00      	nop
   1f6f0:	2000a94c 	.word	0x2000a94c
   1f6f4:	2000a984 	.word	0x2000a984

0001f6f8 <usb_dc_ep_set_callback>:
{
   1f6f8:	b510      	push	{r4, lr}
	return get_usbd_ctx()->attached;
   1f6fa:	4b08      	ldr	r3, [pc, #32]	; (1f71c <usb_dc_ep_set_callback+0x24>)
{
   1f6fc:	460c      	mov	r4, r1
	if (!dev_attached()) {
   1f6fe:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1f702:	b12b      	cbz	r3, 1f710 <usb_dc_ep_set_callback+0x18>
	ep_ctx = endpoint_ctx(ep);
   1f704:	f7ff fa82 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f708:	b128      	cbz	r0, 1f716 <usb_dc_ep_set_callback+0x1e>
	ep_ctx->cfg.cb = cb;
   1f70a:	6004      	str	r4, [r0, #0]
	return 0;
   1f70c:	2000      	movs	r0, #0
}
   1f70e:	bd10      	pop	{r4, pc}
		return -ENODEV;
   1f710:	f06f 0012 	mvn.w	r0, #18
   1f714:	e7fb      	b.n	1f70e <usb_dc_ep_set_callback+0x16>
		return -EINVAL;
   1f716:	f06f 0015 	mvn.w	r0, #21
   1f71a:	e7f8      	b.n	1f70e <usb_dc_ep_set_callback+0x16>
   1f71c:	2000a94c 	.word	0x2000a94c

0001f720 <usb_dc_set_status_callback>:
	get_usbd_ctx()->status_cb = cb;
   1f720:	4b01      	ldr	r3, [pc, #4]	; (1f728 <usb_dc_set_status_callback+0x8>)
   1f722:	6018      	str	r0, [r3, #0]
}
   1f724:	4770      	bx	lr
   1f726:	bf00      	nop
   1f728:	2000a94c 	.word	0x2000a94c

0001f72c <usb_dc_ep_mps>:
{
   1f72c:	b508      	push	{r3, lr}
	return get_usbd_ctx()->attached;
   1f72e:	4b07      	ldr	r3, [pc, #28]	; (1f74c <usb_dc_ep_mps+0x20>)
	if (!dev_attached()) {
   1f730:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   1f734:	b123      	cbz	r3, 1f740 <usb_dc_ep_mps+0x14>
	ep_ctx = endpoint_ctx(ep);
   1f736:	f7ff fa69 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   1f73a:	b120      	cbz	r0, 1f746 <usb_dc_ep_mps+0x1a>
	return ep_ctx->cfg.max_sz;
   1f73c:	6840      	ldr	r0, [r0, #4]
}
   1f73e:	bd08      	pop	{r3, pc}
		return -ENODEV;
   1f740:	f06f 0012 	mvn.w	r0, #18
   1f744:	e7fb      	b.n	1f73e <usb_dc_ep_mps+0x12>
		return -EINVAL;
   1f746:	f06f 0015 	mvn.w	r0, #21
   1f74a:	e7f8      	b.n	1f73e <usb_dc_ep_mps+0x12>
   1f74c:	2000a94c 	.word	0x2000a94c

0001f750 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
   1f750:	4b08      	ldr	r3, [pc, #32]	; (1f774 <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
   1f752:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   1f754:	1ac3      	subs	r3, r0, r3
{
   1f756:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f758:	4907      	ldr	r1, [pc, #28]	; (1f778 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
   1f75a:	109b      	asrs	r3, r3, #2
{
   1f75c:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f75e:	4359      	muls	r1, r3
   1f760:	2240      	movs	r2, #64	; 0x40
   1f762:	4806      	ldr	r0, [pc, #24]	; (1f77c <onoff_stop+0x2c>)
   1f764:	f005 fcc2 	bl	250ec <stop>
	notify(mgr, res);
   1f768:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
   1f76a:	4601      	mov	r1, r0
	notify(mgr, res);
   1f76c:	4620      	mov	r0, r4
}
   1f76e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
   1f772:	4718      	bx	r3
   1f774:	2000b1f0 	.word	0x2000b1f0
   1f778:	b6db6db7 	.word	0xb6db6db7
   1f77c:	00026200 	.word	0x00026200

0001f780 <onoff_start>:
static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f780:	2340      	movs	r3, #64	; 0x40
{
   1f782:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
   1f784:	4c0b      	ldr	r4, [pc, #44]	; (1f7b4 <onoff_start+0x34>)
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f786:	9300      	str	r3, [sp, #0]
	size_t offset = (size_t)(mgr - data->mgr);
   1f788:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f78a:	460b      	mov	r3, r1
{
   1f78c:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f78e:	490a      	ldr	r1, [pc, #40]	; (1f7b8 <onoff_start+0x38>)
	size_t offset = (size_t)(mgr - data->mgr);
   1f790:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f792:	4361      	muls	r1, r4
{
   1f794:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
   1f796:	4a09      	ldr	r2, [pc, #36]	; (1f7bc <onoff_start+0x3c>)
   1f798:	4809      	ldr	r0, [pc, #36]	; (1f7c0 <onoff_start+0x40>)
   1f79a:	f005 fcd4 	bl	25146 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
   1f79e:	1e01      	subs	r1, r0, #0
   1f7a0:	da05      	bge.n	1f7ae <onoff_start+0x2e>
		notify(mgr, err);
   1f7a2:	4630      	mov	r0, r6
   1f7a4:	462b      	mov	r3, r5
	}
}
   1f7a6:	b002      	add	sp, #8
   1f7a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
   1f7ac:	4718      	bx	r3
}
   1f7ae:	b002      	add	sp, #8
   1f7b0:	bd70      	pop	{r4, r5, r6, pc}
   1f7b2:	bf00      	nop
   1f7b4:	2000b1f0 	.word	0x2000b1f0
   1f7b8:	b6db6db7 	.word	0xb6db6db7
   1f7bc:	000251b3 	.word	0x000251b3
   1f7c0:	00026200 	.word	0x00026200

0001f7c4 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
   1f7c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f7c8:	2200      	movs	r2, #0
   1f7ca:	2101      	movs	r1, #1
{
   1f7cc:	4606      	mov	r6, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1f7ce:	2005      	movs	r0, #5
   1f7d0:	f7fe fdae 	bl	1e330 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
   1f7d4:	4811      	ldr	r0, [pc, #68]	; (1f81c <clk_init+0x58>)
   1f7d6:	f001 fa17 	bl	20c08 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
   1f7da:	4b11      	ldr	r3, [pc, #68]	; (1f820 <clk_init+0x5c>)
   1f7dc:	4298      	cmp	r0, r3
   1f7de:	d119      	bne.n	1f814 <clk_init+0x50>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
   1f7e0:	f001 fa22 	bl	20c28 <nrfx_clock_enable>
   1f7e4:	2400      	movs	r4, #0
	return &data->mgr[type];
   1f7e6:	f04f 091c 	mov.w	r9, #28
					 &transitions);
		if (err < 0) {
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f7ea:	270c      	movs	r7, #12
		err = onoff_manager_init(get_onoff_manager(dev, i),
   1f7ec:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1f824 <clk_init+0x60>
	struct nrf_clock_control_data *data = dev->data;
   1f7f0:	6935      	ldr	r5, [r6, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
   1f7f2:	4641      	mov	r1, r8
   1f7f4:	fb09 5004 	mla	r0, r9, r4, r5
   1f7f8:	f005 f87c 	bl	248f4 <onoff_manager_init>
		if (err < 0) {
   1f7fc:	2800      	cmp	r0, #0
   1f7fe:	db07      	blt.n	1f810 <clk_init+0x4c>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f800:	2301      	movs	r3, #1
   1f802:	fb07 5504 	mla	r5, r7, r4, r5
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
   1f806:	441c      	add	r4, r3
   1f808:	2c04      	cmp	r4, #4
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
   1f80a:	67ab      	str	r3, [r5, #120]	; 0x78
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
   1f80c:	d1f0      	bne.n	1f7f0 <clk_init+0x2c>
	}

	return 0;
   1f80e:	2000      	movs	r0, #0
}
   1f810:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EIO;
   1f814:	f06f 0004 	mvn.w	r0, #4
   1f818:	e7fa      	b.n	1f810 <clk_init+0x4c>
   1f81a:	bf00      	nop
   1f81c:	0001f85d 	.word	0x0001f85d
   1f820:	0bad0000 	.word	0x0bad0000
   1f824:	000266d0 	.word	0x000266d0

0001f828 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
   1f828:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
   1f82a:	230c      	movs	r3, #12
	sub_data->cb = NULL;
   1f82c:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
   1f82e:	434b      	muls	r3, r1
static void clkstarted_handle(const struct device *dev,
   1f830:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
   1f832:	4808      	ldr	r0, [pc, #32]	; (1f854 <clkstarted_handle.constprop.0+0x2c>)
   1f834:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
   1f836:	3378      	adds	r3, #120	; 0x78
   1f838:	4418      	add	r0, r3
	void *user_data = sub_data->user_data;
   1f83a:	e9d4 561c 	ldrd	r5, r6, [r4, #112]	; 0x70
	sub_data->cb = NULL;
   1f83e:	6722      	str	r2, [r4, #112]	; 0x70
	set_on_state(&sub_data->flags);
   1f840:	f005 fc41 	bl	250c6 <set_on_state>
	if (callback) {
   1f844:	b12d      	cbz	r5, 1f852 <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
   1f846:	4632      	mov	r2, r6
   1f848:	462b      	mov	r3, r5
}
   1f84a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
   1f84e:	4802      	ldr	r0, [pc, #8]	; (1f858 <clkstarted_handle.constprop.0+0x30>)
   1f850:	4718      	bx	r3
}
   1f852:	bd70      	pop	{r4, r5, r6, pc}
   1f854:	2000b1f0 	.word	0x2000b1f0
   1f858:	00026200 	.word	0x00026200

0001f85c <clock_event_handler>:
	switch (event) {
   1f85c:	2805      	cmp	r0, #5
   1f85e:	d811      	bhi.n	1f884 <clock_event_handler+0x28>
   1f860:	e8df f000 	tbb	[pc, r0]
   1f864:	10100e03 	.word	0x10100e03
   1f868:	0a0c      	.short	0x0a0c
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
   1f86a:	4b07      	ldr	r3, [pc, #28]	; (1f888 <clock_event_handler+0x2c>)
   1f86c:	6f98      	ldr	r0, [r3, #120]	; 0x78
   1f86e:	f010 0007 	ands.w	r0, r0, #7
   1f872:	d107      	bne.n	1f884 <clock_event_handler+0x28>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1f874:	f7ff bfd8 	b.w	1f828 <clkstarted_handle.constprop.0>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK192M);
   1f878:	2002      	movs	r0, #2
   1f87a:	e7fb      	b.n	1f874 <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLKAUDIO);
   1f87c:	2003      	movs	r0, #3
   1f87e:	e7f9      	b.n	1f874 <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1f880:	2001      	movs	r0, #1
   1f882:	e7f7      	b.n	1f874 <clock_event_handler+0x18>
}
   1f884:	4770      	bx	lr
   1f886:	bf00      	nop
   1f888:	2000b1f0 	.word	0x2000b1f0

0001f88c <generic_hfclk_start>:
{
   1f88c:	b508      	push	{r3, lr}
	__asm__ volatile(
   1f88e:	f04f 0320 	mov.w	r3, #32
   1f892:	f3ef 8111 	mrs	r1, BASEPRI
   1f896:	f383 8812 	msr	BASEPRI_MAX, r3
   1f89a:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
   1f89e:	4a11      	ldr	r2, [pc, #68]	; (1f8e4 <generic_hfclk_start+0x58>)
   1f8a0:	6813      	ldr	r3, [r2, #0]
   1f8a2:	f043 0002 	orr.w	r0, r3, #2
   1f8a6:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
   1f8a8:	07da      	lsls	r2, r3, #31
   1f8aa:	d408      	bmi.n	1f8be <generic_hfclk_start+0x32>
	__asm__ volatile(
   1f8ac:	f381 8811 	msr	BASEPRI, r1
   1f8b0:	f3bf 8f6f 	isb	sy
}
   1f8b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
   1f8b8:	2001      	movs	r0, #1
   1f8ba:	f001 b9cd 	b.w	20c58 <nrfx_clock_start>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   1f8be:	4b0a      	ldr	r3, [pc, #40]	; (1f8e8 <generic_hfclk_start+0x5c>)
   1f8c0:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   1f8c4:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
   1f8c8:	07d3      	lsls	r3, r2, #31
   1f8ca:	d5ef      	bpl.n	1f8ac <generic_hfclk_start+0x20>
			set_on_state(get_hf_flags());
   1f8cc:	4807      	ldr	r0, [pc, #28]	; (1f8ec <generic_hfclk_start+0x60>)
   1f8ce:	f005 fbfa 	bl	250c6 <set_on_state>
   1f8d2:	f381 8811 	msr	BASEPRI, r1
   1f8d6:	f3bf 8f6f 	isb	sy
}
   1f8da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
   1f8de:	2000      	movs	r0, #0
   1f8e0:	f7ff bfa2 	b.w	1f828 <clkstarted_handle.constprop.0>
   1f8e4:	2000b290 	.word	0x2000b290
   1f8e8:	40005000 	.word	0x40005000
   1f8ec:	2000b268 	.word	0x2000b268

0001f8f0 <api_blocking_start>:
{
   1f8f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   1f8f2:	2200      	movs	r2, #0
   1f8f4:	2301      	movs	r3, #1
   1f8f6:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   1f8fa:	466b      	mov	r3, sp
   1f8fc:	4a08      	ldr	r2, [pc, #32]	; (1f920 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
   1f8fe:	f8cd d000 	str.w	sp, [sp]
   1f902:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
   1f906:	f005 fc4d 	bl	251a4 <api_start>
	if (err < 0) {
   1f90a:	2800      	cmp	r0, #0
   1f90c:	db05      	blt.n	1f91a <api_blocking_start+0x2a>
	return z_impl_k_sem_take(sem, timeout);
   1f90e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1f912:	2300      	movs	r3, #0
   1f914:	4668      	mov	r0, sp
   1f916:	f003 fe2b 	bl	23570 <z_impl_k_sem_take>
}
   1f91a:	b005      	add	sp, #20
   1f91c:	f85d fb04 	ldr.w	pc, [sp], #4
   1f920:	000251e9 	.word	0x000251e9

0001f924 <generic_hfclk_stop>:
{
   1f924:	b510      	push	{r4, lr}
	__asm__ volatile(
   1f926:	f04f 0320 	mov.w	r3, #32
   1f92a:	f3ef 8411 	mrs	r4, BASEPRI
   1f92e:	f383 8812 	msr	BASEPRI_MAX, r3
   1f932:	f3bf 8f6f 	isb	sy
	hfclk_users &= ~HF_USER_GENERIC;
   1f936:	4a07      	ldr	r2, [pc, #28]	; (1f954 <generic_hfclk_stop+0x30>)
   1f938:	6813      	ldr	r3, [r2, #0]
   1f93a:	f023 0102 	bic.w	r1, r3, #2
	if (!(hfclk_users & HF_USER_BT)) {
   1f93e:	07db      	lsls	r3, r3, #31
	hfclk_users &= ~HF_USER_GENERIC;
   1f940:	6011      	str	r1, [r2, #0]
	if (!(hfclk_users & HF_USER_BT)) {
   1f942:	d402      	bmi.n	1f94a <generic_hfclk_stop+0x26>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
   1f944:	2001      	movs	r0, #1
   1f946:	f005 ff62 	bl	2580e <nrfx_clock_stop>
	__asm__ volatile(
   1f94a:	f384 8811 	msr	BASEPRI, r4
   1f94e:	f3bf 8f6f 	isb	sy
}
   1f952:	bd10      	pop	{r4, pc}
   1f954:	2000b290 	.word	0x2000b290

0001f958 <z_nrf_clock_control_get_onoff>:
	return &data->mgr[type];
   1f958:	b2c3      	uxtb	r3, r0
}
   1f95a:	201c      	movs	r0, #28
   1f95c:	4a01      	ldr	r2, [pc, #4]	; (1f964 <z_nrf_clock_control_get_onoff+0xc>)
   1f95e:	fb03 2000 	mla	r0, r3, r0, r2
   1f962:	4770      	bx	lr
   1f964:	2000b1f0 	.word	0x2000b1f0

0001f968 <z_nrf_clock_control_lf_on>:
{
   1f968:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1f96c:	2201      	movs	r2, #1
   1f96e:	4607      	mov	r7, r0
   1f970:	4935      	ldr	r1, [pc, #212]	; (1fa48 <z_nrf_clock_control_lf_on+0xe0>)
   1f972:	e8d1 3fef 	ldaex	r3, [r1]
   1f976:	e8c1 2fe0 	stlex	r0, r2, [r1]
   1f97a:	2800      	cmp	r0, #0
   1f97c:	d1f9      	bne.n	1f972 <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
   1f97e:	b933      	cbnz	r3, 1f98e <z_nrf_clock_control_lf_on+0x26>
   1f980:	4932      	ldr	r1, [pc, #200]	; (1fa4c <z_nrf_clock_control_lf_on+0xe4>)
		err = onoff_request(mgr, &cli);
   1f982:	4833      	ldr	r0, [pc, #204]	; (1fa50 <z_nrf_clock_control_lf_on+0xe8>)
   1f984:	604b      	str	r3, [r1, #4]
   1f986:	60cb      	str	r3, [r1, #12]
   1f988:	608a      	str	r2, [r1, #8]
   1f98a:	f004 ffc6 	bl	2491a <onoff_request>
	switch (start_mode) {
   1f98e:	1e7b      	subs	r3, r7, #1
   1f990:	2b01      	cmp	r3, #1
   1f992:	d828      	bhi.n	1f9e6 <z_nrf_clock_control_lf_on+0x7e>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
   1f994:	2f01      	cmp	r7, #1
   1f996:	d106      	bne.n	1f9a6 <z_nrf_clock_control_lf_on+0x3e>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   1f998:	4b2e      	ldr	r3, [pc, #184]	; (1fa54 <z_nrf_clock_control_lf_on+0xec>)
   1f99a:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
   1f99e:	f003 0303 	and.w	r3, r3, #3
   1f9a2:	2b02      	cmp	r3, #2
   1f9a4:	d01f      	beq.n	1f9e6 <z_nrf_clock_control_lf_on+0x7e>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   1f9a6:	f006 f8f6 	bl	25b96 <k_is_in_isr>
   1f9aa:	4605      	mov	r5, r0
   1f9ac:	b9e8      	cbnz	r0, 1f9ea <z_nrf_clock_control_lf_on+0x82>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
   1f9ae:	4b2a      	ldr	r3, [pc, #168]	; (1fa58 <z_nrf_clock_control_lf_on+0xf0>)
   1f9b0:	781b      	ldrb	r3, [r3, #0]
   1f9b2:	b1d3      	cbz	r3, 1f9ea <z_nrf_clock_control_lf_on+0x82>
    p_reg->INTENCLR = mask;
   1f9b4:	2202      	movs	r2, #2
	int key = isr_mode ? irq_lock() : 0;
   1f9b6:	4606      	mov	r6, r0
   1f9b8:	4b26      	ldr	r3, [pc, #152]	; (1fa54 <z_nrf_clock_control_lf_on+0xec>)
   1f9ba:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   1f9be:	4c25      	ldr	r4, [pc, #148]	; (1fa54 <z_nrf_clock_control_lf_on+0xec>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1f9c0:	f8df 8098 	ldr.w	r8, [pc, #152]	; 1fa5c <z_nrf_clock_control_lf_on+0xf4>
   1f9c4:	f8d4 3418 	ldr.w	r3, [r4, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   1f9c8:	f8d4 2418 	ldr.w	r2, [r4, #1048]	; 0x418
   1f9cc:	03d2      	lsls	r2, r2, #15
   1f9ce:	d516      	bpl.n	1f9fe <z_nrf_clock_control_lf_on+0x96>
	while (!(nrfx_clock_is_running(d, (void *)&type)
   1f9d0:	f003 0303 	and.w	r3, r3, #3
   1f9d4:	2b02      	cmp	r3, #2
   1f9d6:	d001      	beq.n	1f9dc <z_nrf_clock_control_lf_on+0x74>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
   1f9d8:	2f01      	cmp	r7, #1
   1f9da:	d110      	bne.n	1f9fe <z_nrf_clock_control_lf_on+0x96>
	if (isr_mode) {
   1f9dc:	b375      	cbz	r5, 1fa3c <z_nrf_clock_control_lf_on+0xd4>
   1f9de:	f386 8811 	msr	BASEPRI, r6
   1f9e2:	f3bf 8f6f 	isb	sy
}
   1f9e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__asm__ volatile(
   1f9ea:	f04f 0320 	mov.w	r3, #32
   1f9ee:	f3ef 8611 	mrs	r6, BASEPRI
   1f9f2:	f383 8812 	msr	BASEPRI_MAX, r3
   1f9f6:	f3bf 8f6f 	isb	sy
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
   1f9fa:	2501      	movs	r5, #1
   1f9fc:	e7df      	b.n	1f9be <z_nrf_clock_control_lf_on+0x56>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
   1f9fe:	b1c5      	cbz	r5, 1fa32 <z_nrf_clock_control_lf_on+0xca>
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
   1fa00:	4630      	mov	r0, r6
   1fa02:	f7fe fc53 	bl	1e2ac <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
   1fa06:	f8d4 3518 	ldr.w	r3, [r4, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
   1fa0a:	b2db      	uxtb	r3, r3
   1fa0c:	2b01      	cmp	r3, #1
   1fa0e:	d1d9      	bne.n	1f9c4 <z_nrf_clock_control_lf_on+0x5c>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1fa10:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
   1fa14:	2a00      	cmp	r2, #0
   1fa16:	d0d5      	beq.n	1f9c4 <z_nrf_clock_control_lf_on+0x5c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1fa18:	2200      	movs	r2, #0
   1fa1a:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
   1fa1e:	f8d4 2104 	ldr.w	r2, [r4, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
   1fa22:	2202      	movs	r2, #2
   1fa24:	f8c4 2518 	str.w	r2, [r4, #1304]	; 0x518
   1fa28:	2220      	movs	r2, #32
   1fa2a:	f8c8 2180 	str.w	r2, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fa2e:	60a3      	str	r3, [r4, #8]
}
   1fa30:	e7c8      	b.n	1f9c4 <z_nrf_clock_control_lf_on+0x5c>
	return z_impl_k_sleep(timeout);
   1fa32:	2100      	movs	r1, #0
   1fa34:	2021      	movs	r0, #33	; 0x21
   1fa36:	f004 f9fb 	bl	23e30 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
   1fa3a:	e7e4      	b.n	1fa06 <z_nrf_clock_control_lf_on+0x9e>
    p_reg->INTENSET = mask;
   1fa3c:	2202      	movs	r2, #2
   1fa3e:	4b05      	ldr	r3, [pc, #20]	; (1fa54 <z_nrf_clock_control_lf_on+0xec>)
   1fa40:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   1fa44:	e7cf      	b.n	1f9e6 <z_nrf_clock_control_lf_on+0x7e>
   1fa46:	bf00      	nop
   1fa48:	2000b1ec 	.word	0x2000b1ec
   1fa4c:	2000b1dc 	.word	0x2000b1dc
   1fa50:	2000b20c 	.word	0x2000b20c
   1fa54:	40005000 	.word	0x40005000
   1fa58:	2000b62b 	.word	0x2000b62b
   1fa5c:	e000e100 	.word	0xe000e100

0001fa60 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(void)
{
   1fa60:	b508      	push	{r3, lr}
   1fa62:	4807      	ldr	r0, [pc, #28]	; (1fa80 <uart_console_init+0x20>)
   1fa64:	f006 f82e 	bl	25ac4 <z_device_is_ready>
	if (!device_is_ready(uart_console_dev)) {
   1fa68:	b138      	cbz	r0, 1fa7a <uart_console_init+0x1a>
	__stdout_hook_install(console_out);
   1fa6a:	4806      	ldr	r0, [pc, #24]	; (1fa84 <uart_console_init+0x24>)
   1fa6c:	f7ff f8b2 	bl	1ebd4 <__stdout_hook_install>
	__printk_hook_install(console_out);
   1fa70:	4804      	ldr	r0, [pc, #16]	; (1fa84 <uart_console_init+0x24>)
   1fa72:	f7fc fd25 	bl	1c4c0 <__printk_hook_install>
		return -ENODEV;
	}

	uart_console_hook_install();

	return 0;
   1fa76:	2000      	movs	r0, #0
}
   1fa78:	bd08      	pop	{r3, pc}
		return -ENODEV;
   1fa7a:	f06f 0012 	mvn.w	r0, #18
   1fa7e:	e7fb      	b.n	1fa78 <uart_console_init+0x18>
   1fa80:	00026260 	.word	0x00026260
   1fa84:	0001fa89 	.word	0x0001fa89

0001fa88 <console_out>:
	if ('\n' == c) {
   1fa88:	280a      	cmp	r0, #10
{
   1fa8a:	b538      	push	{r3, r4, r5, lr}
   1fa8c:	4604      	mov	r4, r0
   1fa8e:	4d07      	ldr	r5, [pc, #28]	; (1faac <console_out+0x24>)
	if ('\n' == c) {
   1fa90:	d104      	bne.n	1fa9c <console_out+0x14>
					unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
   1fa92:	68ab      	ldr	r3, [r5, #8]
   1fa94:	210d      	movs	r1, #13
   1fa96:	4628      	mov	r0, r5
   1fa98:	685b      	ldr	r3, [r3, #4]
   1fa9a:	4798      	blx	r3
   1fa9c:	68ab      	ldr	r3, [r5, #8]
   1fa9e:	4803      	ldr	r0, [pc, #12]	; (1faac <console_out+0x24>)
   1faa0:	685b      	ldr	r3, [r3, #4]
   1faa2:	b2e1      	uxtb	r1, r4
   1faa4:	4798      	blx	r3
}
   1faa6:	4620      	mov	r0, r4
   1faa8:	bd38      	pop	{r3, r4, r5, pc}
   1faaa:	bf00      	nop
   1faac:	00026260 	.word	0x00026260

0001fab0 <gpio_nrfx_pin_interrupt_configure>:

static int gpio_nrfx_pin_interrupt_configure(const struct device *port,
					     gpio_pin_t pin,
					     enum gpio_int_mode mode,
					     enum gpio_int_trig trig)
{
   1fab0:	b530      	push	{r4, r5, lr}
	return port->config;
   1fab2:	6840      	ldr	r0, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   1fab4:	f001 041f 	and.w	r4, r1, #31
   1fab8:	7b05      	ldrb	r5, [r0, #12]
	nrfx_err_t err;
	uint8_t ch;

	if (mode == GPIO_INT_MODE_DISABLED) {
   1faba:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
{
   1fabe:	b085      	sub	sp, #20
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   1fac0:	ea44 1445 	orr.w	r4, r4, r5, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
   1fac4:	d105      	bne.n	1fad2 <gpio_nrfx_pin_interrupt_configure+0x22>
		nrfx_gpiote_trigger_disable(abs_pin);
   1fac6:	4620      	mov	r0, r4
   1fac8:	f001 fbba 	bl	21240 <nrfx_gpiote_trigger_disable>

		return 0;
   1facc:	2000      	movs	r0, #0
	}

	nrfx_gpiote_trigger_enable(abs_pin, true);

	return 0;
}
   1face:	b005      	add	sp, #20
   1fad0:	bd30      	pop	{r4, r5, pc}
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fad2:	2500      	movs	r5, #0
	if (mode == GPIO_INT_MODE_LEVEL) {
   1fad4:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fad8:	e9cd 5502 	strd	r5, r5, [sp, #8]
	if (mode == GPIO_INT_MODE_LEVEL) {
   1fadc:	d114      	bne.n	1fb08 <gpio_nrfx_pin_interrupt_configure+0x58>
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
   1fade:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fae2:	bf0c      	ite	eq
   1fae4:	2304      	moveq	r3, #4
   1fae6:	2305      	movne	r3, #5
   1fae8:	f88d 3008 	strb.w	r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1faec:	2300      	movs	r3, #0
   1faee:	4620      	mov	r0, r4
   1faf0:	4619      	mov	r1, r3
   1faf2:	aa02      	add	r2, sp, #8
   1faf4:	f001 f9e2 	bl	20ebc <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   1faf8:	4b1f      	ldr	r3, [pc, #124]	; (1fb78 <gpio_nrfx_pin_interrupt_configure+0xc8>)
   1fafa:	4298      	cmp	r0, r3
   1fafc:	d138      	bne.n	1fb70 <gpio_nrfx_pin_interrupt_configure+0xc0>
	nrfx_gpiote_trigger_enable(abs_pin, true);
   1fafe:	2101      	movs	r1, #1
   1fb00:	4620      	mov	r0, r4
   1fb02:	f001 fb57 	bl	211b4 <nrfx_gpiote_trigger_enable>
	return 0;
   1fb06:	e7e1      	b.n	1facc <gpio_nrfx_pin_interrupt_configure+0x1c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   1fb08:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
   1fb0c:	d025      	beq.n	1fb5a <gpio_nrfx_pin_interrupt_configure+0xaa>
   1fb0e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
   1fb12:	bf14      	ite	ne
   1fb14:	2301      	movne	r3, #1
   1fb16:	2302      	moveq	r3, #2
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fb18:	f88d 3008 	strb.w	r3, [sp, #8]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
   1fb1c:	6883      	ldr	r3, [r0, #8]
   1fb1e:	40cb      	lsrs	r3, r1
   1fb20:	07d9      	lsls	r1, r3, #31
   1fb22:	d4e3      	bmi.n	1faec <gpio_nrfx_pin_interrupt_configure+0x3c>
   1fb24:	f1b2 7fa0 	cmp.w	r2, #20971520	; 0x1400000
   1fb28:	d1e0      	bne.n	1faec <gpio_nrfx_pin_interrupt_configure+0x3c>
        /* FALLTHROUGH */
        case 0: return NRF_P0;
#endif
#if defined(P1_FEATURE_PINS_PRESENT)
        /* FALLTHROUGH */
        case 1: return NRF_P1;
   1fb2a:	4a14      	ldr	r2, [pc, #80]	; (1fb7c <gpio_nrfx_pin_interrupt_configure+0xcc>)
   1fb2c:	4814      	ldr	r0, [pc, #80]	; (1fb80 <gpio_nrfx_pin_interrupt_configure+0xd0>)
NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;

    return pin_number >> 5;
   1fb2e:	0961      	lsrs	r1, r4, #5
        case 1: return NRF_P1;
   1fb30:	2901      	cmp	r1, #1
   1fb32:	bf08      	it	eq
   1fb34:	4602      	moveq	r2, r0
    *p_pin = pin_number & 0x1F;
   1fb36:	f004 031f 	and.w	r3, r4, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   1fb3a:	3380      	adds	r3, #128	; 0x80
   1fb3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
   1fb40:	07db      	lsls	r3, r3, #31
   1fb42:	d4d3      	bmi.n	1faec <gpio_nrfx_pin_interrupt_configure+0x3c>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fb44:	f10d 0507 	add.w	r5, sp, #7
   1fb48:	4629      	mov	r1, r5
   1fb4a:	4620      	mov	r0, r4
   1fb4c:	f001 fade 	bl	2110c <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
   1fb50:	4b0c      	ldr	r3, [pc, #48]	; (1fb84 <gpio_nrfx_pin_interrupt_configure+0xd4>)
   1fb52:	4298      	cmp	r0, r3
   1fb54:	d003      	beq.n	1fb5e <gpio_nrfx_pin_interrupt_configure+0xae>
		trigger_config.p_in_channel = &ch;
   1fb56:	9503      	str	r5, [sp, #12]
   1fb58:	e7c8      	b.n	1faec <gpio_nrfx_pin_interrupt_configure+0x3c>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
   1fb5a:	2303      	movs	r3, #3
   1fb5c:	e7dc      	b.n	1fb18 <gpio_nrfx_pin_interrupt_configure+0x68>
			err = nrfx_gpiote_channel_alloc(&ch);
   1fb5e:	4628      	mov	r0, r5
   1fb60:	f001 fb22 	bl	211a8 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
   1fb64:	4b04      	ldr	r3, [pc, #16]	; (1fb78 <gpio_nrfx_pin_interrupt_configure+0xc8>)
   1fb66:	4298      	cmp	r0, r3
   1fb68:	d0f5      	beq.n	1fb56 <gpio_nrfx_pin_interrupt_configure+0xa6>
				return -ENOMEM;
   1fb6a:	f06f 000b 	mvn.w	r0, #11
   1fb6e:	e7ae      	b.n	1face <gpio_nrfx_pin_interrupt_configure+0x1e>
		return -EINVAL;
   1fb70:	f06f 0015 	mvn.w	r0, #21
   1fb74:	e7ab      	b.n	1face <gpio_nrfx_pin_interrupt_configure+0x1e>
   1fb76:	bf00      	nop
   1fb78:	0bad0000 	.word	0x0bad0000
   1fb7c:	40842500 	.word	0x40842500
   1fb80:	40842800 	.word	0x40842800
   1fb84:	0bad0004 	.word	0x0bad0004

0001fb88 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
   1fb88:	b510      	push	{r4, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
   1fb8a:	f001 fafd 	bl	21188 <nrfx_gpiote_is_init>
   1fb8e:	4604      	mov	r4, r0
   1fb90:	b968      	cbnz	r0, 1fbae <gpio_nrfx_init+0x26>
		return 0;
	}

	err = nrfx_gpiote_init(0/*not used*/);
   1fb92:	f001 fad1 	bl	21138 <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
   1fb96:	4b08      	ldr	r3, [pc, #32]	; (1fbb8 <gpio_nrfx_init+0x30>)
   1fb98:	4298      	cmp	r0, r3
   1fb9a:	d10a      	bne.n	1fbb2 <gpio_nrfx_init+0x2a>
		return -EIO;
	}

	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
   1fb9c:	4621      	mov	r1, r4
   1fb9e:	4807      	ldr	r0, [pc, #28]	; (1fbbc <gpio_nrfx_init+0x34>)
   1fba0:	f001 faae 	bl	21100 <nrfx_gpiote_global_callback_set>

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   1fba4:	4622      	mov	r2, r4
   1fba6:	2105      	movs	r1, #5
   1fba8:	202f      	movs	r0, #47	; 0x2f
   1fbaa:	f7fe fbc1 	bl	1e330 <z_arm_irq_priority_set>
		return 0;
   1fbae:	2000      	movs	r0, #0
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
   1fbb0:	bd10      	pop	{r4, pc}
		return -EIO;
   1fbb2:	f06f 0004 	mvn.w	r0, #4
   1fbb6:	e7fb      	b.n	1fbb0 <gpio_nrfx_init+0x28>
   1fbb8:	0bad0000 	.word	0x0bad0000
   1fbbc:	0001fbc1 	.word	0x0001fbc1

0001fbc0 <nrfx_gpio_handler>:
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbc0:	0942      	lsrs	r2, r0, #5
{
   1fbc2:	4603      	mov	r3, r0
   1fbc4:	b570      	push	{r4, r5, r6, lr}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbc6:	d002      	beq.n	1fbce <nrfx_gpio_handler+0xe>
   1fbc8:	2a01      	cmp	r2, #1
   1fbca:	d017      	beq.n	1fbfc <nrfx_gpio_handler+0x3c>
}
   1fbcc:	bd70      	pop	{r4, r5, r6, pc}
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbce:	4e0d      	ldr	r6, [pc, #52]	; (1fc04 <nrfx_gpio_handler+0x44>)
	gpio_fire_callbacks(list, port, BIT(pin));
   1fbd0:	6932      	ldr	r2, [r6, #16]
   1fbd2:	6851      	ldr	r1, [r2, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1fbd4:	2900      	cmp	r1, #0
   1fbd6:	d0f9      	beq.n	1fbcc <nrfx_gpio_handler+0xc>
   1fbd8:	2501      	movs	r5, #1
    *p_pin = pin_number & 0x1F;
   1fbda:	f003 031f 	and.w	r3, r3, #31
	return node->next;
   1fbde:	680c      	ldr	r4, [r1, #0]
   1fbe0:	409d      	lsls	r5, r3
   1fbe2:	2900      	cmp	r1, #0
   1fbe4:	d0f2      	beq.n	1fbcc <nrfx_gpio_handler+0xc>
		if (cb->pin_mask & pins) {
   1fbe6:	688a      	ldr	r2, [r1, #8]
   1fbe8:	402a      	ands	r2, r5
   1fbea:	d002      	beq.n	1fbf2 <nrfx_gpio_handler+0x32>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   1fbec:	4630      	mov	r0, r6
   1fbee:	684b      	ldr	r3, [r1, #4]
   1fbf0:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1fbf2:	b12c      	cbz	r4, 1fc00 <nrfx_gpio_handler+0x40>
   1fbf4:	6823      	ldr	r3, [r4, #0]
   1fbf6:	4621      	mov	r1, r4
   1fbf8:	461c      	mov	r4, r3
   1fbfa:	e7f2      	b.n	1fbe2 <nrfx_gpio_handler+0x22>
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
   1fbfc:	4e02      	ldr	r6, [pc, #8]	; (1fc08 <nrfx_gpio_handler+0x48>)
   1fbfe:	e7e7      	b.n	1fbd0 <nrfx_gpio_handler+0x10>
   1fc00:	4623      	mov	r3, r4
   1fc02:	e7f8      	b.n	1fbf6 <nrfx_gpio_handler+0x36>
   1fc04:	00026230 	.word	0x00026230
   1fc08:	00026218 	.word	0x00026218

0001fc0c <gpio_nrfx_pin_configure>:
{
   1fc0c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	return port->config;
   1fc10:	6847      	ldr	r7, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1fc12:	f001 051f 	and.w	r5, r1, #31
   1fc16:	7b3b      	ldrb	r3, [r7, #12]
{
   1fc18:	4614      	mov	r4, r2
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1fc1a:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
{
   1fc1e:	460e      	mov	r6, r1
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fc20:	4628      	mov	r0, r5
   1fc22:	f10d 0103 	add.w	r1, sp, #3
   1fc26:	f001 fa71 	bl	2110c <nrfx_gpiote_channel_get>
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
   1fc2a:	f414 3f40 	tst.w	r4, #196608	; 0x30000
	err = nrfx_gpiote_channel_get(abs_pin, &ch);
   1fc2e:	4680      	mov	r8, r0
	if ((flags & (GPIO_INPUT | GPIO_OUTPUT)) == GPIO_DISCONNECTED) {
   1fc30:	d10b      	bne.n	1fc4a <gpio_nrfx_pin_configure+0x3e>
		(void)nrfx_gpiote_pin_uninit(abs_pin);
   1fc32:	4628      	mov	r0, r5
   1fc34:	f001 fb2c 	bl	21290 <nrfx_gpiote_pin_uninit>
		if (free_ch) {
   1fc38:	4b3c      	ldr	r3, [pc, #240]	; (1fd2c <gpio_nrfx_pin_configure+0x120>)
   1fc3a:	4598      	cmp	r8, r3
   1fc3c:	d103      	bne.n	1fc46 <gpio_nrfx_pin_configure+0x3a>
			err = nrfx_gpiote_channel_free(ch);
   1fc3e:	f89d 0003 	ldrb.w	r0, [sp, #3]
   1fc42:	f001 faab 	bl	2119c <nrfx_gpiote_channel_free>
		return 0;
   1fc46:	2000      	movs	r0, #0
   1fc48:	e00c      	b.n	1fc64 <gpio_nrfx_pin_configure+0x58>
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fc4a:	2300      	movs	r3, #0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fc4c:	4628      	mov	r0, r5
   1fc4e:	4619      	mov	r1, r3
   1fc50:	aa02      	add	r2, sp, #8
	nrfx_gpiote_trigger_config_t trigger_config = {
   1fc52:	e9cd 3302 	strd	r3, r3, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
   1fc56:	f001 f931 	bl	20ebc <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
   1fc5a:	4b34      	ldr	r3, [pc, #208]	; (1fd2c <gpio_nrfx_pin_configure+0x120>)
   1fc5c:	4298      	cmp	r0, r3
   1fc5e:	d004      	beq.n	1fc6a <gpio_nrfx_pin_configure+0x5e>
		return NRF_GPIO_PIN_PULLUP;
   1fc60:	f06f 0015 	mvn.w	r0, #21
}
   1fc64:	b004      	add	sp, #16
   1fc66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (free_ch) {
   1fc6a:	4580      	cmp	r8, r0
   1fc6c:	d103      	bne.n	1fc76 <gpio_nrfx_pin_configure+0x6a>
		err = nrfx_gpiote_channel_free(ch);
   1fc6e:	f89d 0003 	ldrb.w	r0, [sp, #3]
   1fc72:	f001 fa93 	bl	2119c <nrfx_gpiote_channel_free>
	if (flags & GPIO_OUTPUT) {
   1fc76:	03a3      	lsls	r3, r4, #14
   1fc78:	d549      	bpl.n	1fd0e <gpio_nrfx_pin_configure+0x102>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fc7a:	f240 3306 	movw	r3, #774	; 0x306
   1fc7e:	4023      	ands	r3, r4
   1fc80:	f5b3 7f83 	cmp.w	r3, #262	; 0x106
   1fc84:	d019      	beq.n	1fcba <gpio_nrfx_pin_configure+0xae>
   1fc86:	d80c      	bhi.n	1fca2 <gpio_nrfx_pin_configure+0x96>
   1fc88:	2b06      	cmp	r3, #6
   1fc8a:	d017      	beq.n	1fcbc <gpio_nrfx_pin_configure+0xb0>
   1fc8c:	d804      	bhi.n	1fc98 <gpio_nrfx_pin_configure+0x8c>
   1fc8e:	b1ab      	cbz	r3, 1fcbc <gpio_nrfx_pin_configure+0xb0>
   1fc90:	2b02      	cmp	r3, #2
   1fc92:	d1e5      	bne.n	1fc60 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0S1;
   1fc94:	2304      	movs	r3, #4
   1fc96:	e011      	b.n	1fcbc <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fc98:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
   1fc9c:	d1e0      	bne.n	1fc60 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_H0S1;
   1fc9e:	2301      	movs	r3, #1
   1fca0:	e00c      	b.n	1fcbc <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fca2:	f240 2202 	movw	r2, #514	; 0x202
   1fca6:	4293      	cmp	r3, r2
   1fca8:	d026      	beq.n	1fcf8 <gpio_nrfx_pin_configure+0xec>
   1fcaa:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
   1fcae:	d025      	beq.n	1fcfc <gpio_nrfx_pin_configure+0xf0>
   1fcb0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1fcb4:	d1d4      	bne.n	1fc60 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_S0H1;
   1fcb6:	2302      	movs	r3, #2
   1fcb8:	e000      	b.n	1fcbc <gpio_nrfx_pin_configure+0xb0>
		*drive = NRF_GPIO_PIN_H0D1;
   1fcba:	2307      	movs	r3, #7
		nrfx_gpiote_output_config_t output_config = {
   1fcbc:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
   1fcc0:	f484 3380 	eor.w	r3, r4, #65536	; 0x10000
   1fcc4:	f3c3 4300 	ubfx	r3, r3, #16, #1
	if (flags & GPIO_PULL_UP) {
   1fcc8:	06e0      	lsls	r0, r4, #27
		nrfx_gpiote_output_config_t output_config = {
   1fcca:	f88d 3005 	strb.w	r3, [sp, #5]
		return NRF_GPIO_PIN_PULLUP;
   1fcce:	bf4c      	ite	mi
   1fcd0:	2303      	movmi	r3, #3
	} else if (flags & GPIO_PULL_DOWN) {
   1fcd2:	f3c4 1340 	ubfxpl	r3, r4, #5, #1
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   1fcd6:	0321      	lsls	r1, r4, #12
		nrfx_gpiote_output_config_t output_config = {
   1fcd8:	f88d 3006 	strb.w	r3, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
   1fcdc:	d510      	bpl.n	1fd00 <gpio_nrfx_pin_configure+0xf4>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
   1fcde:	2301      	movs	r3, #1
   1fce0:	687a      	ldr	r2, [r7, #4]
   1fce2:	40b3      	lsls	r3, r6
    p_reg->OUTSET = set_mask;
   1fce4:	6093      	str	r3, [r2, #8]
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
   1fce6:	2200      	movs	r2, #0
   1fce8:	4628      	mov	r0, r5
   1fcea:	a901      	add	r1, sp, #4
   1fcec:	f001 f994 	bl	21018 <nrfx_gpiote_output_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
   1fcf0:	4b0e      	ldr	r3, [pc, #56]	; (1fd2c <gpio_nrfx_pin_configure+0x120>)
   1fcf2:	4298      	cmp	r0, r3
   1fcf4:	d0a7      	beq.n	1fc46 <gpio_nrfx_pin_configure+0x3a>
   1fcf6:	e7b3      	b.n	1fc60 <gpio_nrfx_pin_configure+0x54>
		*drive = NRF_GPIO_PIN_D0H1;
   1fcf8:	2305      	movs	r3, #5
   1fcfa:	e7df      	b.n	1fcbc <gpio_nrfx_pin_configure+0xb0>
	switch (flags & (NRF_GPIO_DRIVE_MSK | GPIO_OPEN_DRAIN)) {
   1fcfc:	2303      	movs	r3, #3
   1fcfe:	e7dd      	b.n	1fcbc <gpio_nrfx_pin_configure+0xb0>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
   1fd00:	0362      	lsls	r2, r4, #13
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
   1fd02:	bf41      	itttt	mi
   1fd04:	2301      	movmi	r3, #1
   1fd06:	687a      	ldrmi	r2, [r7, #4]
   1fd08:	40b3      	lslmi	r3, r6
    p_reg->OUTCLR = clr_mask;
   1fd0a:	60d3      	strmi	r3, [r2, #12]
}
   1fd0c:	e7eb      	b.n	1fce6 <gpio_nrfx_pin_configure+0xda>
	if (flags & GPIO_PULL_UP) {
   1fd0e:	06e3      	lsls	r3, r4, #27
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1fd10:	f04f 0300 	mov.w	r3, #0
		return NRF_GPIO_PIN_PULLUP;
   1fd14:	bf4c      	ite	mi
   1fd16:	2403      	movmi	r4, #3
	} else if (flags & GPIO_PULL_DOWN) {
   1fd18:	f3c4 1440 	ubfxpl	r4, r4, #5, #1
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1fd1c:	461a      	mov	r2, r3
   1fd1e:	4628      	mov	r0, r5
   1fd20:	a901      	add	r1, sp, #4
	nrfx_gpiote_input_config_t input_config = {
   1fd22:	f88d 4004 	strb.w	r4, [sp, #4]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
   1fd26:	f001 f8c9 	bl	20ebc <nrfx_gpiote_input_configure>
   1fd2a:	e7e1      	b.n	1fcf0 <gpio_nrfx_pin_configure+0xe4>
   1fd2c:	0bad0000 	.word	0x0bad0000

0001fd30 <z_impl_hwinfo_get_device_id>:

static inline void soc_secure_read_deviceid(uint32_t deviceid[2])
{
	int err;

	err = soc_secure_mem_read(deviceid,
   1fd30:	2208      	movs	r2, #8
struct nrf_uid {
	uint32_t id[2];
};

ssize_t z_impl_hwinfo_get_device_id(uint8_t *buffer, size_t length)
{
   1fd32:	b530      	push	{r4, r5, lr}
   1fd34:	460c      	mov	r4, r1
   1fd36:	b085      	sub	sp, #20
   1fd38:	4605      	mov	r5, r0
   1fd3a:	490b      	ldr	r1, [pc, #44]	; (1fd68 <z_impl_hwinfo_get_device_id+0x38>)
   1fd3c:	eb0d 0002 	add.w	r0, sp, r2
   1fd40:	f004 ffe6 	bl	24d10 <soc_secure_mem_read>
	soc_secure_read_deviceid(deviceid);

	dev_id.id[0] = sys_cpu_to_be32(deviceid[1]);
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);

	if (length > sizeof(dev_id.id)) {
   1fd44:	2c08      	cmp	r4, #8
   1fd46:	bf28      	it	cs
   1fd48:	2408      	movcs	r4, #8
   1fd4a:	9b03      	ldr	r3, [sp, #12]
		length = sizeof(dev_id.id);
	}

	memcpy(buffer, dev_id.id, length);
   1fd4c:	4622      	mov	r2, r4
   1fd4e:	ba1b      	rev	r3, r3
	dev_id.id[0] = sys_cpu_to_be32(deviceid[1]);
   1fd50:	9300      	str	r3, [sp, #0]
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);
   1fd52:	9b02      	ldr	r3, [sp, #8]
	memcpy(buffer, dev_id.id, length);
   1fd54:	4669      	mov	r1, sp
   1fd56:	ba1b      	rev	r3, r3
   1fd58:	4628      	mov	r0, r5
	dev_id.id[1] = sys_cpu_to_be32(deviceid[0]);
   1fd5a:	9301      	str	r3, [sp, #4]
	memcpy(buffer, dev_id.id, length);
   1fd5c:	f005 f939 	bl	24fd2 <memcpy>

	return length;
}
   1fd60:	4620      	mov	r0, r4
   1fd62:	b005      	add	sp, #20
   1fd64:	bd30      	pop	{r4, r5, pc}
   1fd66:	bf00      	nop
   1fd68:	00ff0204 	.word	0x00ff0204

0001fd6c <i2c_nrfx_twim_init>:
	return ret;
}
#endif /* CONFIG_PM_DEVICE */

static int i2c_nrfx_twim_init(const struct device *dev)
{
   1fd6c:	b538      	push	{r3, r4, r5, lr}
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   1fd6e:	6844      	ldr	r4, [r0, #4]
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   1fd70:	6905      	ldr	r5, [r0, #16]

	dev_config->irq_connect();
   1fd72:	69e3      	ldr	r3, [r4, #28]
   1fd74:	4798      	blx	r3

	int err = pinctrl_apply_state(dev_config->pcfg,
   1fd76:	6a20      	ldr	r0, [r4, #32]
   1fd78:	f005 faba 	bl	252f0 <pinctrl_apply_state.constprop.0>
				      COND_CODE_1(CONFIG_PM_DEVICE_RUNTIME,
						  (PINCTRL_STATE_SLEEP),
						  (PINCTRL_STATE_DEFAULT)));
	if (err < 0) {
   1fd7c:	2800      	cmp	r0, #0
   1fd7e:	db0d      	blt.n	1fd9c <i2c_nrfx_twim_init+0x30>
		return err;
	}

	if (nrfx_twim_init(&dev_config->twim, &dev_config->twim_config,
   1fd80:	462b      	mov	r3, r5
   1fd82:	4620      	mov	r0, r4
   1fd84:	4a07      	ldr	r2, [pc, #28]	; (1fda4 <i2c_nrfx_twim_init+0x38>)
   1fd86:	f104 0108 	add.w	r1, r4, #8
   1fd8a:	f001 fe49 	bl	21a20 <nrfx_twim_init>
   1fd8e:	4b06      	ldr	r3, [pc, #24]	; (1fda8 <i2c_nrfx_twim_init+0x3c>)
   1fd90:	4298      	cmp	r0, r3
   1fd92:	d104      	bne.n	1fd9e <i2c_nrfx_twim_init+0x32>

#ifdef CONFIG_PM_DEVICE_RUNTIME
	pm_device_init_suspended(dev);
	pm_device_runtime_enable(dev);
#else
	nrfx_twim_enable(&dev_config->twim);
   1fd94:	4620      	mov	r0, r4
   1fd96:	f001 fee1 	bl	21b5c <nrfx_twim_enable>
#endif

	return 0;
   1fd9a:	2000      	movs	r0, #0
}
   1fd9c:	bd38      	pop	{r3, r4, r5, pc}
		return -EIO;
   1fd9e:	f06f 0004 	mvn.w	r0, #4
   1fda2:	e7fb      	b.n	1fd9c <i2c_nrfx_twim_init+0x30>
   1fda4:	0001fde9 	.word	0x0001fde9
   1fda8:	0bad0000 	.word	0x0bad0000

0001fdac <i2c_nrfx_twim_recover_bus>:
{
   1fdac:	b570      	push	{r4, r5, r6, lr}
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   1fdae:	6844      	ldr	r4, [r0, #4]
	scl_pin = nrf_twim_scl_pin_get(dev_config->twim.p_twim);
   1fdb0:	6823      	ldr	r3, [r4, #0]
		nrfx_twim_disable(&dev_config->twim);
   1fdb2:	4620      	mov	r0, r4
    p_reg->PSEL.SDA = sda_pin;
}

NRF_STATIC_INLINE uint32_t nrf_twim_scl_pin_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->PSEL.SCL;
   1fdb4:	f8d3 5508 	ldr.w	r5, [r3, #1288]	; 0x508
}

NRF_STATIC_INLINE uint32_t nrf_twim_sda_pin_get(NRF_TWIM_Type const * p_reg)
{
    return p_reg->PSEL.SDA;
   1fdb8:	f8d3 650c 	ldr.w	r6, [r3, #1292]	; 0x50c
   1fdbc:	f001 fede 	bl	21b7c <nrfx_twim_disable>
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin);

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE nrfx_err_t nrfx_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
    return nrfx_twi_twim_bus_recover(scl_pin, sda_pin);
   1fdc0:	4631      	mov	r1, r6
   1fdc2:	4628      	mov	r0, r5
   1fdc4:	f003 f860 	bl	22e88 <nrfx_twi_twim_bus_recover>
   1fdc8:	4605      	mov	r5, r0
		(void)pinctrl_apply_state(dev_config->pcfg,
   1fdca:	6a20      	ldr	r0, [r4, #32]
   1fdcc:	f005 fa90 	bl	252f0 <pinctrl_apply_state.constprop.0>
		nrfx_twim_enable(&dev_config->twim);
   1fdd0:	4620      	mov	r0, r4
   1fdd2:	f001 fec3 	bl	21b5c <nrfx_twim_enable>
	return (err == NRFX_SUCCESS ? 0 : -EBUSY);
   1fdd6:	4b03      	ldr	r3, [pc, #12]	; (1fde4 <i2c_nrfx_twim_recover_bus+0x38>)
   1fdd8:	429d      	cmp	r5, r3
}
   1fdda:	bf14      	ite	ne
   1fddc:	f06f 000f 	mvnne.w	r0, #15
   1fde0:	2000      	moveq	r0, #0
   1fde2:	bd70      	pop	{r4, r5, r6, pc}
   1fde4:	0bad0000 	.word	0x0bad0000

0001fde8 <event_handler>:
	switch (p_event->type) {
   1fde8:	7803      	ldrb	r3, [r0, #0]
   1fdea:	2b01      	cmp	r3, #1
   1fdec:	d008      	beq.n	1fe00 <event_handler+0x18>
   1fdee:	2b02      	cmp	r3, #2
   1fdf0:	d008      	beq.n	1fe04 <event_handler+0x1c>
   1fdf2:	b94b      	cbnz	r3, 1fe08 <event_handler+0x20>
		dev_data->res = NRFX_SUCCESS;
   1fdf4:	4b05      	ldr	r3, [pc, #20]	; (1fe0c <event_handler+0x24>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   1fdf6:	620b      	str	r3, [r1, #32]
	z_impl_k_sem_give(sem);
   1fdf8:	f101 0010 	add.w	r0, r1, #16
   1fdfc:	f003 bb98 	b.w	23530 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   1fe00:	4b03      	ldr	r3, [pc, #12]	; (1fe10 <event_handler+0x28>)
   1fe02:	e7f8      	b.n	1fdf6 <event_handler+0xe>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   1fe04:	4b03      	ldr	r3, [pc, #12]	; (1fe14 <event_handler+0x2c>)
   1fe06:	e7f6      	b.n	1fdf6 <event_handler+0xe>
		dev_data->res = NRFX_ERROR_INTERNAL;
   1fe08:	4b03      	ldr	r3, [pc, #12]	; (1fe18 <event_handler+0x30>)
   1fe0a:	e7f4      	b.n	1fdf6 <event_handler+0xe>
   1fe0c:	0bad0000 	.word	0x0bad0000
   1fe10:	0bae0001 	.word	0x0bae0001
   1fe14:	0bae0002 	.word	0x0bae0002
   1fe18:	0bad0001 	.word	0x0bad0001

0001fe1c <i2c_nrfx_twim_transfer>:
{
   1fe1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1fe20:	4693      	mov	fp, r2
	nrfx_twim_xfer_desc_t cur_xfer = {
   1fe22:	2214      	movs	r2, #20
{
   1fe24:	461d      	mov	r5, r3
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   1fe26:	f8d0 a004 	ldr.w	sl, [r0, #4]
{
   1fe2a:	b08b      	sub	sp, #44	; 0x2c
	struct i2c_nrfx_twim_data *dev_data = dev->data;
   1fe2c:	6906      	ldr	r6, [r0, #16]
	uint16_t concat_buf_size = dev_config->concat_buf_size;
   1fe2e:	f8ba 3018 	ldrh.w	r3, [sl, #24]
{
   1fe32:	4681      	mov	r9, r0
   1fe34:	460c      	mov	r4, r1
	nrfx_twim_xfer_desc_t cur_xfer = {
   1fe36:	eb0d 0002 	add.w	r0, sp, r2
   1fe3a:	2100      	movs	r1, #0
	uint8_t *msg_buf = dev_data->msg_buf;
   1fe3c:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
	uint16_t concat_buf_size = dev_config->concat_buf_size;
   1fe40:	9302      	str	r3, [sp, #8]
	nrfx_twim_xfer_desc_t cur_xfer = {
   1fe42:	f005 f8d1 	bl	24fe8 <memset>
   1fe46:	f88d 5015 	strb.w	r5, [sp, #21]
	return z_impl_k_sem_take(sem, timeout);
   1fe4a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1fe4e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1fe52:	4630      	mov	r0, r6
   1fe54:	f003 fb8c 	bl	23570 <z_impl_k_sem_take>
	k_sem_take(&dev_data->completion_sync, K_NO_WAIT);
   1fe58:	f106 0310 	add.w	r3, r6, #16
   1fe5c:	9301      	str	r3, [sp, #4]
	for (size_t i = 0; i < num_msgs; i++) {
   1fe5e:	2700      	movs	r7, #0
   1fe60:	2200      	movs	r2, #0
   1fe62:	2300      	movs	r3, #0
   1fe64:	f106 0010 	add.w	r0, r6, #16
   1fe68:	f003 fb82 	bl	23570 <z_impl_k_sem_take>
	uint16_t msg_buf_used = 0;
   1fe6c:	463d      	mov	r5, r7
	for (size_t i = 0; i < num_msgs; i++) {
   1fe6e:	455f      	cmp	r7, fp
   1fe70:	d301      	bcc.n	1fe76 <i2c_nrfx_twim_transfer+0x5a>
   1fe72:	2400      	movs	r4, #0
   1fe74:	e068      	b.n	1ff48 <i2c_nrfx_twim_transfer+0x12c>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   1fe76:	7a20      	ldrb	r0, [r4, #8]
   1fe78:	0702      	lsls	r2, r0, #28
   1fe7a:	f100 8089 	bmi.w	1ff90 <i2c_nrfx_twim_transfer+0x174>
		bool concat_next = ((i + 1) < num_msgs)
   1fe7e:	3701      	adds	r7, #1
				&& ((msgs[i].flags & I2C_MSG_READ)
   1fe80:	455f      	cmp	r7, fp
   1fe82:	d20a      	bcs.n	1fe9a <i2c_nrfx_twim_transfer+0x7e>
				&& !(msgs[i].flags & I2C_MSG_STOP)
   1fe84:	0783      	lsls	r3, r0, #30
   1fe86:	d408      	bmi.n	1fe9a <i2c_nrfx_twim_transfer+0x7e>
				&& !(msgs[i + 1].flags & I2C_MSG_RESTART)
   1fe88:	7d23      	ldrb	r3, [r4, #20]
				    == (msgs[i + 1].flags & I2C_MSG_READ));
   1fe8a:	ea80 0203 	eor.w	r2, r0, r3
				&& ((msgs[i].flags & I2C_MSG_READ)
   1fe8e:	f002 0201 	and.w	r2, r2, #1
   1fe92:	f003 0304 	and.w	r3, r3, #4
   1fe96:	431a      	orrs	r2, r3
   1fe98:	d01a      	beq.n	1fed0 <i2c_nrfx_twim_transfer+0xb4>
		if (concat_next || (msg_buf_used != 0)) {
   1fe9a:	b1dd      	cbz	r5, 1fed4 <i2c_nrfx_twim_transfer+0xb8>
		bool concat_next = ((i + 1) < num_msgs)
   1fe9c:	2300      	movs	r3, #0
			if ((msg_buf_used + msgs[i].len) > concat_buf_size) {
   1fe9e:	6862      	ldr	r2, [r4, #4]
   1fea0:	f8dd c008 	ldr.w	ip, [sp, #8]
   1fea4:	18a9      	adds	r1, r5, r2
   1fea6:	4561      	cmp	r1, ip
   1fea8:	d875      	bhi.n	1ff96 <i2c_nrfx_twim_transfer+0x17a>
			if (!(msgs[i].flags & I2C_MSG_READ)) {
   1feaa:	07c1      	lsls	r1, r0, #31
   1feac:	d406      	bmi.n	1febc <i2c_nrfx_twim_transfer+0xa0>
				memcpy(msg_buf + msg_buf_used,
   1feae:	6821      	ldr	r1, [r4, #0]
   1feb0:	eb08 0005 	add.w	r0, r8, r5
   1feb4:	9303      	str	r3, [sp, #12]
   1feb6:	f005 f88c 	bl	24fd2 <memcpy>
   1feba:	9b03      	ldr	r3, [sp, #12]
			msg_buf_used += msgs[i].len;
   1febc:	6862      	ldr	r2, [r4, #4]
   1febe:	442a      	add	r2, r5
   1fec0:	b295      	uxth	r5, r2
		if (concat_next) {
   1fec2:	2b00      	cmp	r3, #0
   1fec4:	d14f      	bne.n	1ff66 <i2c_nrfx_twim_transfer+0x14a>
		if (msg_buf_used == 0) {
   1fec6:	b14d      	cbz	r5, 1fedc <i2c_nrfx_twim_transfer+0xc0>
			cur_xfer.primary_length = msg_buf_used;
   1fec8:	462b      	mov	r3, r5
			cur_xfer.p_primary_buf = msg_buf;
   1feca:	f8cd 8020 	str.w	r8, [sp, #32]
			cur_xfer.primary_length = msg_buf_used;
   1fece:	e009      	b.n	1fee4 <i2c_nrfx_twim_transfer+0xc8>
		bool concat_next = ((i + 1) < num_msgs)
   1fed0:	2301      	movs	r3, #1
   1fed2:	e7e4      	b.n	1fe9e <i2c_nrfx_twim_transfer+0x82>
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   1fed4:	07c0      	lsls	r0, r0, #31
			   !nrfx_is_in_ram(msgs[i].buf)) {
   1fed6:	e9d4 1200 	ldrd	r1, r2, [r4]
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   1feda:	d51b      	bpl.n	1ff14 <i2c_nrfx_twim_transfer+0xf8>
			cur_xfer.p_primary_buf = msgs[i].buf;
   1fedc:	2500      	movs	r5, #0
   1fede:	6823      	ldr	r3, [r4, #0]
   1fee0:	9308      	str	r3, [sp, #32]
			cur_xfer.primary_length = msgs[i].len;
   1fee2:	6863      	ldr	r3, [r4, #4]
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   1fee4:	7a22      	ldrb	r2, [r4, #8]
			cur_xfer.primary_length = msgs[i].len;
   1fee6:	9306      	str	r3, [sp, #24]
			NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX;
   1fee8:	f002 0301 	and.w	r3, r2, #1
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   1feec:	f082 0202 	eor.w	r2, r2, #2
   1fef0:	f3c2 0240 	ubfx	r2, r2, #1, #1
   1fef4:	4650      	mov	r0, sl
   1fef6:	0152      	lsls	r2, r2, #5
   1fef8:	a905      	add	r1, sp, #20
		cur_xfer.type = (msgs[i].flags & I2C_MSG_READ) ?
   1fefa:	f88d 3014 	strb.w	r3, [sp, #20]
		nrfx_err_t res = nrfx_twim_xfer(&dev_config->twim,
   1fefe:	f001 fe5b 	bl	21bb8 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
   1ff02:	4b28      	ldr	r3, [pc, #160]	; (1ffa4 <i2c_nrfx_twim_transfer+0x188>)
   1ff04:	4298      	cmp	r0, r3
   1ff06:	d013      	beq.n	1ff30 <i2c_nrfx_twim_transfer+0x114>
			if (res == NRFX_ERROR_BUSY) {
   1ff08:	330b      	adds	r3, #11
   1ff0a:	4298      	cmp	r0, r3
   1ff0c:	d11a      	bne.n	1ff44 <i2c_nrfx_twim_transfer+0x128>
				ret = -EBUSY;
   1ff0e:	f06f 040f 	mvn.w	r4, #15
   1ff12:	e019      	b.n	1ff48 <i2c_nrfx_twim_transfer+0x12c>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   1ff14:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		} else if (!(msgs[i].flags & I2C_MSG_READ) &&
   1ff18:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   1ff1c:	d0de      	beq.n	1fedc <i2c_nrfx_twim_transfer+0xc0>
			if (msgs[i].len > dev_config->flash_buf_max_size) {
   1ff1e:	f8ba 301a 	ldrh.w	r3, [sl, #26]
   1ff22:	4293      	cmp	r3, r2
   1ff24:	d33a      	bcc.n	1ff9c <i2c_nrfx_twim_transfer+0x180>
			memcpy(msg_buf, msgs[i].buf, msgs[i].len);
   1ff26:	4640      	mov	r0, r8
   1ff28:	f005 f853 	bl	24fd2 <memcpy>
			msg_buf_used = msgs[i].len;
   1ff2c:	88a5      	ldrh	r5, [r4, #4]
		if (concat_next) {
   1ff2e:	e7ca      	b.n	1fec6 <i2c_nrfx_twim_transfer+0xaa>
   1ff30:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   1ff34:	2300      	movs	r3, #0
   1ff36:	9801      	ldr	r0, [sp, #4]
   1ff38:	f003 fb1a 	bl	23570 <z_impl_k_sem_take>
		if (ret != 0) {
   1ff3c:	b158      	cbz	r0, 1ff56 <i2c_nrfx_twim_transfer+0x13a>
			(void)i2c_nrfx_twim_recover_bus(dev);
   1ff3e:	4648      	mov	r0, r9
   1ff40:	f7ff ff34 	bl	1fdac <i2c_nrfx_twim_recover_bus>
				ret = -EIO;
   1ff44:	f06f 0404 	mvn.w	r4, #4
	z_impl_k_sem_give(sem);
   1ff48:	4630      	mov	r0, r6
   1ff4a:	f003 faf1 	bl	23530 <z_impl_k_sem_give>
}
   1ff4e:	4620      	mov	r0, r4
   1ff50:	b00b      	add	sp, #44	; 0x2c
   1ff52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		res = dev_data->res;
   1ff56:	6a33      	ldr	r3, [r6, #32]
		if (res != NRFX_SUCCESS) {
   1ff58:	4a12      	ldr	r2, [pc, #72]	; (1ffa4 <i2c_nrfx_twim_transfer+0x188>)
   1ff5a:	4293      	cmp	r3, r2
   1ff5c:	d1f2      	bne.n	1ff44 <i2c_nrfx_twim_transfer+0x128>
		if ((msgs[i].flags & I2C_MSG_READ)
   1ff5e:	7a23      	ldrb	r3, [r4, #8]
   1ff60:	07db      	lsls	r3, r3, #31
   1ff62:	d402      	bmi.n	1ff6a <i2c_nrfx_twim_transfer+0x14e>
		msg_buf_used = 0;
   1ff64:	2500      	movs	r5, #0
   1ff66:	340c      	adds	r4, #12
   1ff68:	e781      	b.n	1fe6e <i2c_nrfx_twim_transfer+0x52>
		    && cur_xfer.p_primary_buf == msg_buf) {
   1ff6a:	9b08      	ldr	r3, [sp, #32]
   1ff6c:	4598      	cmp	r8, r3
   1ff6e:	d1f9      	bne.n	1ff64 <i2c_nrfx_twim_transfer+0x148>
   1ff70:	4623      	mov	r3, r4
   1ff72:	e008      	b.n	1ff86 <i2c_nrfx_twim_transfer+0x16a>
				msg_buf_used -= msgs[j].len;
   1ff74:	1aa9      	subs	r1, r5, r2
				memcpy(msgs[j].buf,
   1ff76:	68d8      	ldr	r0, [r3, #12]
				msg_buf_used -= msgs[j].len;
   1ff78:	b28d      	uxth	r5, r1
				memcpy(msgs[j].buf,
   1ff7a:	fa18 f181 	uxtah	r1, r8, r1
   1ff7e:	9303      	str	r3, [sp, #12]
   1ff80:	f005 f827 	bl	24fd2 <memcpy>
				j--;
   1ff84:	9b03      	ldr	r3, [sp, #12]
			while (msg_buf_used >= msgs[j].len) {
   1ff86:	685a      	ldr	r2, [r3, #4]
   1ff88:	3b0c      	subs	r3, #12
   1ff8a:	4295      	cmp	r5, r2
   1ff8c:	d2f2      	bcs.n	1ff74 <i2c_nrfx_twim_transfer+0x158>
   1ff8e:	e7e9      	b.n	1ff64 <i2c_nrfx_twim_transfer+0x148>
			ret = -ENOTSUP;
   1ff90:	f06f 0485 	mvn.w	r4, #133	; 0x85
   1ff94:	e7d8      	b.n	1ff48 <i2c_nrfx_twim_transfer+0x12c>
				ret = -ENOSPC;
   1ff96:	f06f 041b 	mvn.w	r4, #27
   1ff9a:	e7d5      	b.n	1ff48 <i2c_nrfx_twim_transfer+0x12c>
				ret = -EINVAL;
   1ff9c:	f06f 0415 	mvn.w	r4, #21
   1ffa0:	e7d2      	b.n	1ff48 <i2c_nrfx_twim_transfer+0x12c>
   1ffa2:	bf00      	nop
   1ffa4:	0bad0000 	.word	0x0bad0000

0001ffa8 <pinctrl_configure_pins>:
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1ffa8:	f04f 0c01 	mov.w	ip, #1
#define NRF_PSEL_QSPI(reg, line) ((NRF_QSPI_Type *)reg)->PSEL.line
#endif

int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
			   uintptr_t reg)
{
   1ffac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        case 1: return NRF_P1;
   1ffb0:	4e56      	ldr	r6, [pc, #344]	; (2010c <pinctrl_configure_pins+0x164>)
   1ffb2:	4f57      	ldr	r7, [pc, #348]	; (20110 <pinctrl_configure_pins+0x168>)
   1ffb4:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   1ffb8:	4281      	cmp	r1, r0
   1ffba:	d102      	bne.n	1ffc2 <pinctrl_configure_pins+0x1a>
			nrf_gpio_cfg(pin, dir, input, NRF_GET_PULL(pins[i]),
				     drive, NRF_GPIO_PIN_NOSENSE);
		}
	}

	return 0;
   1ffbc:	2000      	movs	r0, #0
}
   1ffbe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
   1ffc2:	6804      	ldr	r4, [r0, #0]
		uint32_t pin = NRF_GET_PIN(pins[i]);
   1ffc4:	f004 037f 	and.w	r3, r4, #127	; 0x7f
		nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
   1ffc8:	f3c4 2543 	ubfx	r5, r4, #9, #4
		switch (NRF_GET_FUN(pins[i])) {
   1ffcc:	0c24      	lsrs	r4, r4, #16
			pin = 0xFFFFFFFFU;
   1ffce:	2b7f      	cmp	r3, #127	; 0x7f
		switch (NRF_GET_FUN(pins[i])) {
   1ffd0:	f1a4 0404 	sub.w	r4, r4, #4
			pin = 0xFFFFFFFFU;
   1ffd4:	bf08      	it	eq
   1ffd6:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
		switch (NRF_GET_FUN(pins[i])) {
   1ffda:	2c1e      	cmp	r4, #30
   1ffdc:	f200 8092 	bhi.w	20104 <pinctrl_configure_pins+0x15c>
   1ffe0:	e8df f004 	tbb	[pc, r4]
   1ffe4:	90272310 	.word	0x90272310
   1ffe8:	2b909090 	.word	0x2b909090
   1ffec:	90909058 	.word	0x90909058
   1fff0:	90909090 	.word	0x90909090
   1fff4:	725b9090 	.word	0x725b9090
   1fff8:	90907875 	.word	0x90907875
   1fffc:	84817b90 	.word	0x84817b90
   20000:	8a87      	.short	0x8a87
   20002:	8d          	.byte	0x8d
   20003:	00          	.byte	0x00
			input = NRF_GPIO_PIN_INPUT_CONNECT;
   20004:	2400      	movs	r4, #0
			NRF_PSEL_SPIM(reg, SCK) = pin;
   20006:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    return pin_number >> 5;
   2000a:	ea4f 1953 	mov.w	r9, r3, lsr #5
        case 1: return NRF_P1;
   2000e:	f1b9 0f01 	cmp.w	r9, #1
   20012:	bf14      	ite	ne
   20014:	46b0      	movne	r8, r6
   20016:	46b8      	moveq	r8, r7
    *p_pin = pin_number & 0x1F;
   20018:	f003 0e1f 	and.w	lr, r3, #31
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   2001c:	fa0c fe0e 	lsl.w	lr, ip, lr
    p_reg->OUTCLR = clr_mask;
   20020:	f8c8 e00c 	str.w	lr, [r8, #12]
   20024:	f04f 0e01 	mov.w	lr, #1
   20028:	e00e      	b.n	20048 <pinctrl_configure_pins+0xa0>
			NRF_PSEL_SPIM(reg, MOSI) = pin;
   2002a:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
			pin = 0xFFFFFFFFU;
   2002e:	2401      	movs	r4, #1
   20030:	e7eb      	b.n	2000a <pinctrl_configure_pins+0x62>
			NRF_PSEL_SPIM(reg, MISO) = pin;
   20032:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
			input = NRF_GPIO_PIN_INPUT_CONNECT;
   20036:	2400      	movs	r4, #0
   20038:	e044      	b.n	200c4 <pinctrl_configure_pins+0x11c>
			NRF_PSEL_TWIM(reg, SCL) = pin;
   2003a:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
			if (drive == NRF_DRIVE_S0S1) {
   2003e:	2d00      	cmp	r5, #0
   20040:	d1f9      	bne.n	20036 <pinctrl_configure_pins+0x8e>
			input = NRF_GPIO_PIN_INPUT_CONNECT;
   20042:	2400      	movs	r4, #0
				drive = NRF_DRIVE_S0D1;
   20044:	2506      	movs	r5, #6
			dir = NRF_GPIO_PIN_DIR_INPUT;
   20046:	46a6      	mov	lr, r4
			if (NRF_GET_LP(pins[i]) == NRF_LP_ENABLE) {
   20048:	f850 ab04 	ldr.w	sl, [r0], #4
    *p_pin = pin_number & 0x1F;
   2004c:	f003 091f 	and.w	r9, r3, #31
   20050:	f40a 5800 	and.w	r8, sl, #8192	; 0x2000
				input = NRF_GPIO_PIN_INPUT_DISCONNECT;
   20054:	f1b8 0f00 	cmp.w	r8, #0
    return pin_number >> 5;
   20058:	ea4f 1353 	mov.w	r3, r3, lsr #5
   2005c:	bf1c      	itt	ne
   2005e:	2401      	movne	r4, #1
   20060:	f04f 0e00 	movne.w	lr, #0
        case 0: return NRF_P0;
   20064:	2b01      	cmp	r3, #1
   20066:	bf0c      	ite	eq
   20068:	46b8      	moveq	r8, r7
   2006a:	46b0      	movne	r8, r6
   2006c:	eb08 0889 	add.w	r8, r8, r9, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   20070:	f8d8 3200 	ldr.w	r3, [r8, #512]	; 0x200
			nrf_gpio_cfg(pin, dir, input, NRF_GET_PULL(pins[i]),
   20074:	f3ca 1ac1 	ubfx	sl, sl, #7, #2
   20078:	f003 49e0 	and.w	r9, r3, #1879048192	; 0x70000000
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   2007c:	022b      	lsls	r3, r5, #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   2007e:	ea43 038a 	orr.w	r3, r3, sl, lsl #2
   20082:	ea43 030e 	orr.w	r3, r3, lr
   20086:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   2008a:	ea43 0309 	orr.w	r3, r3, r9
    reg->PIN_CNF[pin_number] = cnf;
   2008e:	f8c8 3200 	str.w	r3, [r8, #512]	; 0x200
	for (uint8_t i = 0U; i < pin_cnt; i++) {
   20092:	e791      	b.n	1ffb8 <pinctrl_configure_pins+0x10>
			NRF_PSEL_TWIM(reg, SDA) = pin;
   20094:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
			if (drive == NRF_DRIVE_S0S1) {
   20098:	e7d1      	b.n	2003e <pinctrl_configure_pins+0x96>
			NRF_PSEL_PWM(reg, OUT[0]) = pin;
   2009a:	f8c2 3560 	str.w	r3, [r2, #1376]	; 0x560
			write = NRF_GET_INVERT(pins[i]);
   2009e:	6804      	ldr	r4, [r0, #0]
   200a0:	f3c4 3480 	ubfx	r4, r4, #14, #1
    if (value == 0)
   200a4:	2c00      	cmp	r4, #0
   200a6:	d0c2      	beq.n	2002e <pinctrl_configure_pins+0x86>
    return pin_number >> 5;
   200a8:	ea4f 1853 	mov.w	r8, r3, lsr #5
        case 1: return NRF_P1;
   200ac:	f1b8 0f01 	cmp.w	r8, #1
   200b0:	bf14      	ite	ne
   200b2:	46b6      	movne	lr, r6
   200b4:	46be      	moveq	lr, r7
    *p_pin = pin_number & 0x1F;
   200b6:	f003 041f 	and.w	r4, r3, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   200ba:	fa0c f404 	lsl.w	r4, ip, r4
    p_reg->OUTSET = set_mask;
   200be:	f8ce 4008 	str.w	r4, [lr, #8]
   200c2:	2401      	movs	r4, #1
			dir = NRF_GPIO_PIN_DIR_INPUT;
   200c4:	46a6      	mov	lr, r4
   200c6:	e7bf      	b.n	20048 <pinctrl_configure_pins+0xa0>
			NRF_PSEL_PWM(reg, OUT[1]) = pin;
   200c8:	f8c2 3564 	str.w	r3, [r2, #1380]	; 0x564
			write = NRF_GET_INVERT(pins[i]);
   200cc:	e7e7      	b.n	2009e <pinctrl_configure_pins+0xf6>
			NRF_PSEL_PWM(reg, OUT[2]) = pin;
   200ce:	f8c2 3568 	str.w	r3, [r2, #1384]	; 0x568
			write = NRF_GET_INVERT(pins[i]);
   200d2:	e7e4      	b.n	2009e <pinctrl_configure_pins+0xf6>
			NRF_PSEL_PWM(reg, OUT[3]) = pin;
   200d4:	f8c2 356c 	str.w	r3, [r2, #1388]	; 0x56c
   200d8:	e7e1      	b.n	2009e <pinctrl_configure_pins+0xf6>
			NRF_PSEL_QSPI(reg, SCK) = pin;
   200da:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
			input = NRF_GPIO_PIN_INPUT_DISCONNECT;
   200de:	2401      	movs	r4, #1
			dir = NRF_GPIO_PIN_DIR_INPUT;
   200e0:	f04f 0e00 	mov.w	lr, #0
   200e4:	e7b0      	b.n	20048 <pinctrl_configure_pins+0xa0>
			NRF_PSEL_QSPI(reg, CSN) = pin;
   200e6:	f8c2 3528 	str.w	r3, [r2, #1320]	; 0x528
    if (value == 0)
   200ea:	e7dd      	b.n	200a8 <pinctrl_configure_pins+0x100>
			NRF_PSEL_QSPI(reg, IO0) = pin;
   200ec:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
			if (write != NO_WRITE) {
   200f0:	e7f5      	b.n	200de <pinctrl_configure_pins+0x136>
			NRF_PSEL_QSPI(reg, IO1) = pin;
   200f2:	f8c2 3534 	str.w	r3, [r2, #1332]	; 0x534
			if (write != NO_WRITE) {
   200f6:	e7f2      	b.n	200de <pinctrl_configure_pins+0x136>
			NRF_PSEL_QSPI(reg, IO2) = pin;
   200f8:	f8c2 3538 	str.w	r3, [r2, #1336]	; 0x538
			if (write != NO_WRITE) {
   200fc:	e7ef      	b.n	200de <pinctrl_configure_pins+0x136>
			NRF_PSEL_QSPI(reg, IO3) = pin;
   200fe:	f8c2 353c 	str.w	r3, [r2, #1340]	; 0x53c
			if (write != NO_WRITE) {
   20102:	e7ec      	b.n	200de <pinctrl_configure_pins+0x136>
		switch (NRF_GET_FUN(pins[i])) {
   20104:	f06f 0085 	mvn.w	r0, #133	; 0x85
   20108:	e759      	b.n	1ffbe <pinctrl_configure_pins+0x16>
   2010a:	bf00      	nop
   2010c:	40842500 	.word	0x40842500
   20110:	40842800 	.word	0x40842800

00020114 <regulator_fixed_enable>:
struct regulator_fixed_data {
	struct regulator_common_data common;
};

static int regulator_fixed_enable(const struct device *dev)
{
   20114:	b538      	push	{r3, r4, r5, lr}
	const struct regulator_fixed_config *cfg = dev->config;
   20116:	6844      	ldr	r4, [r0, #4]
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
{
	return gpio_pin_set(spec->port, spec->pin, value);
   20118:	2201      	movs	r2, #1
   2011a:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
   2011e:	6a60      	ldr	r0, [r4, #36]	; 0x24
   20120:	f005 f9ae 	bl	25480 <gpio_pin_set>
	int ret;

	ret = gpio_pin_set_dt(&cfg->enable, 1);
	if (ret < 0) {
   20124:	2800      	cmp	r0, #0
   20126:	db02      	blt.n	2012e <regulator_fixed_enable+0x1a>
		return ret;
	}

	if (cfg->off_on_delay_us > 0U) {
   20128:	6a24      	ldr	r4, [r4, #32]
   2012a:	b90c      	cbnz	r4, 20130 <regulator_fixed_enable+0x1c>
		k_sleep(K_USEC(cfg->off_on_delay_us));
	}

	return 0;
   2012c:	2000      	movs	r0, #0
}
   2012e:	bd38      	pop	{r3, r4, r5, pc}
			/* Faster algorithm but source is first multiplied by target frequency
			 * and it can overflow even though final result would not overflow.
			 * Kconfig option shall prevent use of this algorithm when there is a
			 * risk of overflow.
			 */
			return ((t * to_hz + off) / from_hz);
   20130:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   20134:	2100      	movs	r1, #0
   20136:	4805      	ldr	r0, [pc, #20]	; (2014c <regulator_fixed_enable+0x38>)
   20138:	2300      	movs	r3, #0
   2013a:	fbe4 0105 	umlal	r0, r1, r4, r5
   2013e:	4a04      	ldr	r2, [pc, #16]	; (20150 <regulator_fixed_enable+0x3c>)
   20140:	f7fc f808 	bl	1c154 <__aeabi_uldivmod>
	return z_impl_k_sleep(timeout);
   20144:	f003 fe74 	bl	23e30 <z_impl_k_sleep>
   20148:	e7f0      	b.n	2012c <regulator_fixed_enable+0x18>
   2014a:	bf00      	nop
   2014c:	000f423f 	.word	0x000f423f
   20150:	000f4240 	.word	0x000f4240

00020154 <transfer_next_chunk>:
	spi_context_complete(ctx, dev, error);
	dev_data->busy = false;
}

static void transfer_next_chunk(const struct device *dev)
{
   20154:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct spi_nrfx_data *dev_data = dev->data;
   20156:	6904      	ldr	r4, [r0, #16]
{
   20158:	4606      	mov	r6, r0
 * directions have a continuous buffer, i.e. the maximum SPI transfer that
 * can be done with DMA that handles only non-scattered buffers.
 */
static inline size_t spi_context_max_continuous_chunk(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
   2015a:	6ca5      	ldr	r5, [r4, #72]	; 0x48
	const struct spi_nrfx_config *dev_config = dev->config;
   2015c:	6847      	ldr	r7, [r0, #4]
		return ctx->rx_len;
   2015e:	6d23      	ldr	r3, [r4, #80]	; 0x50
{
   20160:	b085      	sub	sp, #20
	if (!ctx->tx_len) {
   20162:	b93d      	cbnz	r5, 20174 <transfer_next_chunk+0x20>
	struct spi_context *ctx = &dev_data->ctx;
	int error = 0;

	size_t chunk_len = spi_context_max_continuous_chunk(ctx);

	if (chunk_len > 0) {
   20164:	bb6b      	cbnz	r3, 201c2 <transfer_next_chunk+0x6e>
	int error = 0;
   20166:	4619      	mov	r1, r3
			anomaly_58_workaround_clear(dev_data);
#endif
		}
	}

	finish_transaction(dev, error);
   20168:	6930      	ldr	r0, [r6, #16]
}
   2016a:	b005      	add	sp, #20
   2016c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	finish_transaction(dev, error);
   20170:	f005 baa3 	b.w	256ba <finish_transaction.isra.0>
		const uint8_t *tx_buf = ctx->tx_buf;
   20174:	6c61      	ldr	r1, [r4, #68]	; 0x44
	} else if (!ctx->rx_len) {
   20176:	bb03      	cbnz	r3, 201ba <transfer_next_chunk+0x66>
	return !!(ctx->tx_buf && ctx->tx_len);
   20178:	bb31      	cbnz	r1, 201c8 <transfer_next_chunk+0x74>
		if (chunk_len > dev_config->max_chunk_len) {
   2017a:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   2017c:	6c63      	ldr	r3, [r4, #68]	; 0x44
   2017e:	42aa      	cmp	r2, r5
   20180:	bf28      	it	cs
   20182:	462a      	movcs	r2, r5
		xfer.p_tx_buffer = tx_buf;
   20184:	9100      	str	r1, [sp, #0]
		dev_data->chunk_len = chunk_len;
   20186:	65a2      	str	r2, [r4, #88]	; 0x58
   20188:	b11b      	cbz	r3, 20192 <transfer_next_chunk+0x3e>
   2018a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   2018c:	2b00      	cmp	r3, #0
   2018e:	bf18      	it	ne
   20190:	4613      	movne	r3, r2
   20192:	9301      	str	r3, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
   20194:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   20196:	9302      	str	r3, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
   20198:	b11b      	cbz	r3, 201a2 <transfer_next_chunk+0x4e>
   2019a:	6d23      	ldr	r3, [r4, #80]	; 0x50
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   2019c:	2b00      	cmp	r3, #0
   2019e:	bf18      	it	ne
   201a0:	4613      	movne	r3, r2
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   201a2:	2200      	movs	r2, #0
   201a4:	4669      	mov	r1, sp
   201a6:	4638      	mov	r0, r7
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   201a8:	9303      	str	r3, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   201aa:	f001 fb99 	bl	218e0 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
   201ae:	4b0e      	ldr	r3, [pc, #56]	; (201e8 <transfer_next_chunk+0x94>)
   201b0:	4298      	cmp	r0, r3
   201b2:	d017      	beq.n	201e4 <transfer_next_chunk+0x90>
			error = -EIO;
   201b4:	f06f 0104 	mvn.w	r1, #4
   201b8:	e7d6      	b.n	20168 <transfer_next_chunk+0x14>
		return ctx->tx_len;
	}

	return MIN(ctx->tx_len, ctx->rx_len);
   201ba:	429d      	cmp	r5, r3
   201bc:	bf28      	it	cs
   201be:	461d      	movcs	r5, r3
   201c0:	e7da      	b.n	20178 <transfer_next_chunk+0x24>
		const uint8_t *tx_buf = ctx->tx_buf;
   201c2:	461d      	mov	r5, r3
   201c4:	6c61      	ldr	r1, [r4, #68]	; 0x44
	return !!(ctx->tx_buf && ctx->tx_len);
   201c6:	e7d8      	b.n	2017a <transfer_next_chunk+0x26>
   201c8:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
		if (spi_context_tx_buf_on(ctx) && !nrfx_is_in_ram(tx_buf)) {
   201cc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   201d0:	d0d3      	beq.n	2017a <transfer_next_chunk+0x26>
			if (chunk_len > CONFIG_SPI_NRFX_RAM_BUFFER_SIZE) {
   201d2:	2d08      	cmp	r5, #8
   201d4:	bf28      	it	cs
   201d6:	2508      	movcs	r5, #8
			memcpy(dev_data->buffer, tx_buf, chunk_len);
   201d8:	6e20      	ldr	r0, [r4, #96]	; 0x60
   201da:	462a      	mov	r2, r5
   201dc:	f004 fef9 	bl	24fd2 <memcpy>
			tx_buf = dev_data->buffer;
   201e0:	6e21      	ldr	r1, [r4, #96]	; 0x60
   201e2:	e7ca      	b.n	2017a <transfer_next_chunk+0x26>
}
   201e4:	b005      	add	sp, #20
   201e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   201e8:	0bad0000 	.word	0x0bad0000

000201ec <spi_nrfx_transceive>:

static int spi_nrfx_transceive(const struct device *dev,
			       const struct spi_config *spi_cfg,
			       const struct spi_buf_set *tx_bufs,
			       const struct spi_buf_set *rx_bufs)
{
   201ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   201f0:	469a      	mov	sl, r3
	const struct spi_nrfx_config *dev_config = dev->config;
   201f2:	6843      	ldr	r3, [r0, #4]
{
   201f4:	b08b      	sub	sp, #44	; 0x2c
	const struct spi_nrfx_config *dev_config = dev->config;
   201f6:	9303      	str	r3, [sp, #12]
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
   201f8:	888b      	ldrh	r3, [r1, #4]
{
   201fa:	4607      	mov	r7, r0
   201fc:	049b      	lsls	r3, r3, #18
   201fe:	460e      	mov	r6, r1
   20200:	4690      	mov	r8, r2
	struct spi_nrfx_data *dev_data = dev->data;
   20202:	6904      	ldr	r4, [r0, #16]
   20204:	f100 8106 	bmi.w	20414 <spi_nrfx_transceive+0x228>
	return z_impl_k_sem_take(sem, timeout);
   20208:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2020c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   20210:	f104 0010 	add.w	r0, r4, #16
   20214:	f003 f9ac 	bl	23570 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
   20218:	6066      	str	r6, [r4, #4]
	const struct spi_nrfx_config *dev_config = dev->config;
   2021a:	687b      	ldr	r3, [r7, #4]
	struct spi_nrfx_data *dev_data = dev->data;
   2021c:	f8d7 9010 	ldr.w	r9, [r7, #16]
	uint32_t max_freq = dev_config->max_freq;
   20220:	689d      	ldr	r5, [r3, #8]
	const struct spi_nrfx_config *dev_config = dev->config;
   20222:	9300      	str	r3, [sp, #0]
	if (dev_data->initialized && spi_context_configured(ctx, spi_cfg)) {
   20224:	f899 305d 	ldrb.w	r3, [r9, #93]	; 0x5d
   20228:	9301      	str	r3, [sp, #4]
   2022a:	b11b      	cbz	r3, 20234 <spi_nrfx_transceive+0x48>
   2022c:	f8d9 3000 	ldr.w	r3, [r9]
   20230:	429e      	cmp	r6, r3
   20232:	d07c      	beq.n	2032e <spi_nrfx_transceive+0x142>
	if (spi_cfg->operation & SPI_HALF_DUPLEX) {
   20234:	f8b6 c004 	ldrh.w	ip, [r6, #4]
   20238:	f41c 6f00 	tst.w	ip, #2048	; 0x800
   2023c:	f040 811f 	bne.w	2047e <spi_nrfx_transceive+0x292>
	if (spi_cfg->operation & SPI_MODE_LOOP) {
   20240:	f01c 0f09 	tst.w	ip, #9
   20244:	f040 8118 	bne.w	20478 <spi_nrfx_transceive+0x28c>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
   20248:	f3cc 1345 	ubfx	r3, ip, #5, #6
   2024c:	2b08      	cmp	r3, #8
   2024e:	f040 8113 	bne.w	20478 <spi_nrfx_transceive+0x28c>
	if (spi_cfg->frequency < 125000) {
   20252:	6833      	ldr	r3, [r6, #0]
   20254:	9302      	str	r3, [sp, #8]
   20256:	9a02      	ldr	r2, [sp, #8]
   20258:	4b9a      	ldr	r3, [pc, #616]	; (204c4 <spi_nrfx_transceive+0x2d8>)
   2025a:	429a      	cmp	r2, r3
   2025c:	f240 810c 	bls.w	20478 <spi_nrfx_transceive+0x28c>
	if (max_freq > 16000000 &&
   20260:	4b99      	ldr	r3, [pc, #612]	; (204c8 <spi_nrfx_transceive+0x2dc>)
   20262:	429d      	cmp	r5, r3
   20264:	d906      	bls.n	20274 <spi_nrfx_transceive+0x88>
                        CLOCK_HFCLKCTRL_HCLK_Msk);
}

NRF_STATIC_INLINE nrf_clock_hfclk_div_t nrf_clock_hfclk_div_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_hfclk_div_t)((p_reg->HFCLKCTRL & CLOCK_HFCLKCTRL_HCLK_Msk)
   20266:	4a99      	ldr	r2, [pc, #612]	; (204cc <spi_nrfx_transceive+0x2e0>)
   20268:	f8d2 2558 	ldr.w	r2, [r2, #1368]	; 0x558
		max_freq = 16000000;
   2026c:	f012 0f03 	tst.w	r2, #3
   20270:	bf18      	it	ne
   20272:	461d      	movne	r5, r3
	config = dev_config->def_config;
   20274:	9b00      	ldr	r3, [sp, #0]
   20276:	f10d 0e10 	add.w	lr, sp, #16
   2027a:	f103 0b0c 	add.w	fp, r3, #12
   2027e:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
   20282:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
   20286:	9b02      	ldr	r3, [sp, #8]
	config = dev_config->def_config;
   20288:	e89b 0003 	ldmia.w	fp, {r0, r1}
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
   2028c:	42ab      	cmp	r3, r5
   2028e:	bf28      	it	cs
   20290:	462b      	movcs	r3, r5
   20292:	461d      	mov	r5, r3
	if (frequency < 250000) {
   20294:	4b8e      	ldr	r3, [pc, #568]	; (204d0 <spi_nrfx_transceive+0x2e4>)
	config = dev_config->def_config;
   20296:	e88e 0003 	stmia.w	lr, {r0, r1}
	if (frequency < 250000) {
   2029a:	429d      	cmp	r5, r3
   2029c:	f240 80c3 	bls.w	20426 <spi_nrfx_transceive+0x23a>
	} else if (frequency < 500000) {
   202a0:	4b8c      	ldr	r3, [pc, #560]	; (204d4 <spi_nrfx_transceive+0x2e8>)
   202a2:	429d      	cmp	r5, r3
   202a4:	f240 80c2 	bls.w	2042c <spi_nrfx_transceive+0x240>
	} else if (frequency < 1000000) {
   202a8:	4b8b      	ldr	r3, [pc, #556]	; (204d8 <spi_nrfx_transceive+0x2ec>)
   202aa:	429d      	cmp	r5, r3
   202ac:	f240 80c1 	bls.w	20432 <spi_nrfx_transceive+0x246>
	} else if (frequency < 2000000) {
   202b0:	4b8a      	ldr	r3, [pc, #552]	; (204dc <spi_nrfx_transceive+0x2f0>)
   202b2:	429d      	cmp	r5, r3
   202b4:	f240 80c0 	bls.w	20438 <spi_nrfx_transceive+0x24c>
	} else if (frequency < 4000000) {
   202b8:	4b89      	ldr	r3, [pc, #548]	; (204e0 <spi_nrfx_transceive+0x2f4>)
   202ba:	429d      	cmp	r5, r3
   202bc:	f240 80bf 	bls.w	2043e <spi_nrfx_transceive+0x252>
	} else if (frequency < 8000000) {
   202c0:	4b88      	ldr	r3, [pc, #544]	; (204e4 <spi_nrfx_transceive+0x2f8>)
   202c2:	429d      	cmp	r5, r3
   202c4:	f0c0 80be 	bcc.w	20444 <spi_nrfx_transceive+0x258>
	} else if (frequency < 16000000) {
   202c8:	4b7f      	ldr	r3, [pc, #508]	; (204c8 <spi_nrfx_transceive+0x2dc>)
   202ca:	429d      	cmp	r5, r3
   202cc:	f0c0 80bd 	bcc.w	2044a <spi_nrfx_transceive+0x25e>
		return NRF_SPIM_FREQ_16M;
   202d0:	4b85      	ldr	r3, [pc, #532]	; (204e8 <spi_nrfx_transceive+0x2fc>)
   202d2:	429d      	cmp	r5, r3
   202d4:	bf2c      	ite	cs
   202d6:	f04f 55a0 	movcs.w	r5, #335544320	; 0x14000000
   202da:	f04f 6520 	movcc.w	r5, #167772160	; 0xa000000
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   202de:	f01c 0f02 	tst.w	ip, #2
	config.frequency = get_nrf_spim_frequency(MIN(spi_cfg->frequency,
   202e2:	9506      	str	r5, [sp, #24]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   202e4:	f00c 0304 	and.w	r3, ip, #4
   202e8:	f000 80b2 	beq.w	20450 <spi_nrfx_transceive+0x264>
			return NRF_SPIM_MODE_2;
   202ec:	2b00      	cmp	r3, #0
   202ee:	bf14      	ite	ne
   202f0:	2303      	movne	r3, #3
   202f2:	2302      	moveq	r3, #2
	config.mode      = get_nrf_spim_mode(spi_cfg->operation);
   202f4:	f88d 301c 	strb.w	r3, [sp, #28]
	if (dev_data->initialized) {
   202f8:	9b01      	ldr	r3, [sp, #4]
	if (operation & SPI_TRANSFER_LSB) {
   202fa:	f3cc 1c00 	ubfx	ip, ip, #4, #1
	config.bit_order = get_nrf_spim_bit_order(spi_cfg->operation);
   202fe:	f88d c01d 	strb.w	ip, [sp, #29]
	if (dev_data->initialized) {
   20302:	b12b      	cbz	r3, 20310 <spi_nrfx_transceive+0x124>
		nrfx_spim_uninit(&dev_config->spim);
   20304:	9800      	ldr	r0, [sp, #0]
   20306:	f001 fa97 	bl	21838 <nrfx_spim_uninit>
		dev_data->initialized = false;
   2030a:	2300      	movs	r3, #0
   2030c:	f889 305d 	strb.w	r3, [r9, #93]	; 0x5d
	result = nrfx_spim_init(&dev_config->spim, &config,
   20310:	464b      	mov	r3, r9
   20312:	4a76      	ldr	r2, [pc, #472]	; (204ec <spi_nrfx_transceive+0x300>)
   20314:	9800      	ldr	r0, [sp, #0]
   20316:	a904      	add	r1, sp, #16
   20318:	f001 f956 	bl	215c8 <nrfx_spim_init>
	if (result != NRFX_SUCCESS) {
   2031c:	4b74      	ldr	r3, [pc, #464]	; (204f0 <spi_nrfx_transceive+0x304>)
   2031e:	4298      	cmp	r0, r3
   20320:	f040 809a 	bne.w	20458 <spi_nrfx_transceive+0x26c>
	dev_data->initialized = true;
   20324:	2301      	movs	r3, #1
	ctx->config = spi_cfg;
   20326:	f8c9 6000 	str.w	r6, [r9]
	dev_data->initialized = true;
   2032a:	f889 305d 	strb.w	r3, [r9, #93]	; 0x5d
		dev_data->busy = true;
   2032e:	2301      	movs	r3, #1
   20330:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
   20334:	f1b8 0f00 	cmp.w	r8, #0
   20338:	f040 80a4 	bne.w	20484 <spi_nrfx_transceive+0x298>
   2033c:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
   20340:	2300      	movs	r3, #0
   20342:	63a3      	str	r3, [r4, #56]	; 0x38
		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
   20344:	f104 0248 	add.w	r2, r4, #72	; 0x48
   20348:	f104 0138 	add.w	r1, r4, #56	; 0x38
   2034c:	f104 0034 	add.w	r0, r4, #52	; 0x34
   20350:	f005 f8f2 	bl	25538 <spi_context_get_next_buf.constprop.0>
	ctx->tx_buf = (const uint8_t *)
   20354:	6460      	str	r0, [r4, #68]	; 0x44
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
   20356:	f1ba 0f00 	cmp.w	sl, #0
   2035a:	f040 809c 	bne.w	20496 <spi_nrfx_transceive+0x2aa>
   2035e:	f8c4 a03c 	str.w	sl, [r4, #60]	; 0x3c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
   20362:	2300      	movs	r3, #0
   20364:	6423      	str	r3, [r4, #64]	; 0x40
		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
   20366:	f104 0250 	add.w	r2, r4, #80	; 0x50
   2036a:	f104 0140 	add.w	r1, r4, #64	; 0x40
   2036e:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   20372:	f005 f8e1 	bl	25538 <spi_context_get_next_buf.constprop.0>
	ctx->sync_status = 0;
   20376:	2500      	movs	r5, #0
	_spi_context_cs_control(ctx, on, false);
   20378:	2101      	movs	r1, #1
   2037a:	462a      	mov	r2, r5
	ctx->rx_buf = (uint8_t *)
   2037c:	64e0      	str	r0, [r4, #76]	; 0x4c
	ctx->sync_status = 0;
   2037e:	6325      	str	r5, [r4, #48]	; 0x30
	_spi_context_cs_control(ctx, on, false);
   20380:	4620      	mov	r0, r4
   20382:	f005 f900 	bl	25586 <_spi_context_cs_control>
		transfer_next_chunk(dev);
   20386:	4638      	mov	r0, r7
   20388:	f7ff fee4 	bl	20154 <transfer_next_chunk>
}

static inline size_t spi_context_total_tx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
   2038c:	462a      	mov	r2, r5

	for (n = 0; n < ctx->tx_count; ++n) {
   2038e:	462b      	mov	r3, r5
   20390:	6ba0      	ldr	r0, [r4, #56]	; 0x38
   20392:	4283      	cmp	r3, r0
   20394:	f040 8088 	bne.w	204a8 <spi_nrfx_transceive+0x2bc>
}

static inline size_t spi_context_total_rx_len(struct spi_context *ctx)
{
	size_t n;
	size_t total_len = 0;
   20398:	2300      	movs	r3, #0

	for (n = 0; n < ctx->rx_count; ++n) {
   2039a:	4619      	mov	r1, r3
   2039c:	6c25      	ldr	r5, [r4, #64]	; 0x40
   2039e:	42a9      	cmp	r1, r5
   203a0:	f040 8089 	bne.w	204b6 <spi_nrfx_transceive+0x2ca>
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
   203a4:	4293      	cmp	r3, r2
   203a6:	bf38      	it	cc
   203a8:	4613      	movcc	r3, r2
				     ctx->config->frequency;
   203aa:	4626      	mov	r6, r4
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
   203ac:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
   203b0:	f04f 0800 	mov.w	r8, #0
   203b4:	fb02 f503 	mul.w	r5, r2, r3
				     ctx->config->frequency;
   203b8:	f856 3b20 	ldr.w	r3, [r6], #32
   203bc:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
			timeout_ms = MAX(tx_len, rx_len) * 8 * 1000 /
   203c0:	681b      	ldr	r3, [r3, #0]
   203c2:	4641      	mov	r1, r8
   203c4:	fbb5 f5f3 	udiv	r5, r5, r3
   203c8:	f240 30e7 	movw	r0, #999	; 0x3e7
			timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
   203cc:	35c8      	adds	r5, #200	; 0xc8
   203ce:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   203d2:	2300      	movs	r3, #0
   203d4:	fbe5 010c 	umlal	r0, r1, r5, ip
   203d8:	f7fb febc 	bl	1c154 <__aeabi_uldivmod>
   203dc:	4602      	mov	r2, r0
   203de:	460b      	mov	r3, r1
   203e0:	4630      	mov	r0, r6
   203e2:	f003 f8c5 	bl	23570 <z_impl_k_sem_take>
		if (k_sem_take(&ctx->sync, timeout)) {
   203e6:	b918      	cbnz	r0, 203f0 <spi_nrfx_transceive+0x204>
		status = ctx->sync_status;
   203e8:	6b25      	ldr	r5, [r4, #48]	; 0x30
		if (error == -ETIMEDOUT) {
   203ea:	f115 0f74 	cmn.w	r5, #116	; 0x74
   203ee:	d135      	bne.n	2045c <spi_nrfx_transceive+0x270>
			nrfx_spim_uninit(&dev_config->spim);
   203f0:	9803      	ldr	r0, [sp, #12]
			dev_data->chunk_len = 0;
   203f2:	f8c4 8058 	str.w	r8, [r4, #88]	; 0x58
			nrfx_spim_uninit(&dev_config->spim);
   203f6:	f001 fa1f 	bl	21838 <nrfx_spim_uninit>
			dev_data->initialized = false;
   203fa:	f884 805d 	strb.w	r8, [r4, #93]	; 0x5d
			finish_transaction(dev, -ETIMEDOUT);
   203fe:	f06f 0173 	mvn.w	r1, #115	; 0x73
   20402:	6938      	ldr	r0, [r7, #16]
   20404:	f005 f959 	bl	256ba <finish_transaction.isra.0>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_SEM_RESET);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_reset(sem);
   20408:	4630      	mov	r0, r6
   2040a:	f003 f8d9 	bl	235c0 <z_impl_k_sem_reset>
		error = spi_context_wait_for_completion(&dev_data->ctx);
   2040e:	f06f 0573 	mvn.w	r5, #115	; 0x73
}
   20412:	e023      	b.n	2045c <spi_nrfx_transceive+0x270>
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
   20414:	69a3      	ldr	r3, [r4, #24]
   20416:	2b00      	cmp	r3, #0
   20418:	f47f aef6 	bne.w	20208 <spi_nrfx_transceive+0x1c>
		(k_sem_count_get(&ctx->lock) == 0) &&
   2041c:	6863      	ldr	r3, [r4, #4]
   2041e:	4299      	cmp	r1, r3
   20420:	f47f aef2 	bne.w	20208 <spi_nrfx_transceive+0x1c>
   20424:	e6f9      	b.n	2021a <spi_nrfx_transceive+0x2e>
		return NRF_SPIM_FREQ_125K;
   20426:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
   2042a:	e758      	b.n	202de <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_250K;
   2042c:	f04f 6580 	mov.w	r5, #67108864	; 0x4000000
   20430:	e755      	b.n	202de <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_500K;
   20432:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   20436:	e752      	b.n	202de <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_1M;
   20438:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   2043c:	e74f      	b.n	202de <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_2M;
   2043e:	f04f 5500 	mov.w	r5, #536870912	; 0x20000000
   20442:	e74c      	b.n	202de <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_4M;
   20444:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
   20448:	e749      	b.n	202de <spi_nrfx_transceive+0xf2>
		return NRF_SPIM_FREQ_8M;
   2044a:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
   2044e:	e746      	b.n	202de <spi_nrfx_transceive+0xf2>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
   20450:	3b00      	subs	r3, #0
   20452:	bf18      	it	ne
   20454:	2301      	movne	r3, #1
   20456:	e74d      	b.n	202f4 <spi_nrfx_transceive+0x108>
		return -EIO;
   20458:	f06f 0504 	mvn.w	r5, #4
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
   2045c:	6823      	ldr	r3, [r4, #0]
   2045e:	889b      	ldrh	r3, [r3, #4]
   20460:	f413 5300 	ands.w	r3, r3, #8192	; 0x2000
   20464:	d104      	bne.n	20470 <spi_nrfx_transceive+0x284>
		ctx->owner = NULL;
   20466:	6063      	str	r3, [r4, #4]
	z_impl_k_sem_give(sem);
   20468:	f104 0010 	add.w	r0, r4, #16
   2046c:	f003 f860 	bl	23530 <z_impl_k_sem_give>
	return transceive(dev, spi_cfg, tx_bufs, rx_bufs, false, NULL, NULL);
}
   20470:	4628      	mov	r0, r5
   20472:	b00b      	add	sp, #44	; 0x2c
   20474:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return -EINVAL;
   20478:	f06f 0515 	mvn.w	r5, #21
   2047c:	e7ee      	b.n	2045c <spi_nrfx_transceive+0x270>
		return -ENOTSUP;
   2047e:	f06f 0585 	mvn.w	r5, #133	; 0x85
   20482:	e7eb      	b.n	2045c <spi_nrfx_transceive+0x270>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
   20484:	f8d8 3000 	ldr.w	r3, [r8]
   20488:	6363      	str	r3, [r4, #52]	; 0x34
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
   2048a:	2b00      	cmp	r3, #0
   2048c:	f43f af58 	beq.w	20340 <spi_nrfx_transceive+0x154>
   20490:	f8d8 3004 	ldr.w	r3, [r8, #4]
   20494:	e755      	b.n	20342 <spi_nrfx_transceive+0x156>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
   20496:	f8da 3000 	ldr.w	r3, [sl]
   2049a:	63e3      	str	r3, [r4, #60]	; 0x3c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
   2049c:	2b00      	cmp	r3, #0
   2049e:	f43f af60 	beq.w	20362 <spi_nrfx_transceive+0x176>
   204a2:	f8da 3004 	ldr.w	r3, [sl, #4]
   204a6:	e75d      	b.n	20364 <spi_nrfx_transceive+0x178>
		total_len += ctx->current_tx[n].len;
   204a8:	6b61      	ldr	r1, [r4, #52]	; 0x34
   204aa:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   204ae:	6849      	ldr	r1, [r1, #4]
	for (n = 0; n < ctx->tx_count; ++n) {
   204b0:	3301      	adds	r3, #1
		total_len += ctx->current_tx[n].len;
   204b2:	440a      	add	r2, r1
	for (n = 0; n < ctx->tx_count; ++n) {
   204b4:	e76d      	b.n	20392 <spi_nrfx_transceive+0x1a6>
		total_len += ctx->current_rx[n].len;
   204b6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   204b8:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   204bc:	6840      	ldr	r0, [r0, #4]
	for (n = 0; n < ctx->rx_count; ++n) {
   204be:	3101      	adds	r1, #1
		total_len += ctx->current_rx[n].len;
   204c0:	4403      	add	r3, r0
	for (n = 0; n < ctx->rx_count; ++n) {
   204c2:	e76c      	b.n	2039e <spi_nrfx_transceive+0x1b2>
   204c4:	0001e847 	.word	0x0001e847
   204c8:	00f42400 	.word	0x00f42400
   204cc:	40005000 	.word	0x40005000
   204d0:	0003d08f 	.word	0x0003d08f
   204d4:	0007a11f 	.word	0x0007a11f
   204d8:	000f423f 	.word	0x000f423f
   204dc:	001e847f 	.word	0x001e847f
   204e0:	003d08ff 	.word	0x003d08ff
   204e4:	007a1200 	.word	0x007a1200
   204e8:	01e84800 	.word	0x01e84800
   204ec:	000256db 	.word	0x000256db
   204f0:	0bad0000 	.word	0x0bad0000

000204f4 <compare_int_lock>:
#endif
}

static bool compare_int_lock(int32_t chan)
{
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   204f4:	2301      	movs	r3, #1
   204f6:	4083      	lsls	r3, r0
{
   204f8:	b570      	push	{r4, r5, r6, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
   204fa:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   204fc:	4a0b      	ldr	r2, [pc, #44]	; (2052c <compare_int_lock+0x38>)
   204fe:	e8d2 1fef 	ldaex	r1, [r2]
   20502:	ea01 0504 	and.w	r5, r1, r4
   20506:	e8c2 5fe6 	stlex	r6, r5, [r2]
   2050a:	2e00      	cmp	r6, #0
   2050c:	d1f7      	bne.n	204fe <compare_int_lock+0xa>

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   2050e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   20512:	4082      	lsls	r2, r0
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_int_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
   20514:	4806      	ldr	r0, [pc, #24]	; (20530 <compare_int_lock+0x3c>)
   20516:	f8c0 2308 	str.w	r2, [r0, #776]	; 0x308
   2051a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
   2051e:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
   20522:	420b      	tst	r3, r1
}
   20524:	bf14      	ite	ne
   20526:	2001      	movne	r0, #1
   20528:	2000      	moveq	r0, #0
   2052a:	bd70      	pop	{r4, r5, r6, pc}
   2052c:	2000b2e0 	.word	0x2000b2e0
   20530:	40015000 	.word	0x40015000

00020534 <sys_clock_timeout_handler>:
}

static void sys_clock_timeout_handler(int32_t chan,
				      uint64_t expire_time,
				      void *user_data)
{
   20534:	b470      	push	{r4, r5, r6}
	uint32_t cc_value = absolute_time_to_cc(expire_time);
	uint32_t dticks = (uint32_t)(expire_time - last_count) / CYC_PER_TICK;
   20536:	490e      	ldr	r1, [pc, #56]	; (20570 <sys_clock_timeout_handler+0x3c>)
	return absolute_time & COUNTER_MAX;
   20538:	f022 467f 	bic.w	r6, r2, #4278190080	; 0xff000000
	uint32_t dticks = (uint32_t)(expire_time - last_count) / CYC_PER_TICK;
   2053c:	e9d1 3400 	ldrd	r3, r4, [r1]
   20540:	1ad0      	subs	r0, r2, r3

	last_count += dticks * CYC_PER_TICK;
   20542:	18c3      	adds	r3, r0, r3
   20544:	f144 0400 	adc.w	r4, r4, #0
   20548:	e9c1 3400 	strd	r3, r4, [r1]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
   2054c:	f5a6 1300 	sub.w	r3, r6, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
   20550:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
   20554:	d209      	bcs.n	2056a <sys_clock_timeout_handler+0x36>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
   20556:	4b07      	ldr	r3, [pc, #28]	; (20574 <sys_clock_timeout_handler+0x40>)
   20558:	681b      	ldr	r3, [r3, #0]
   2055a:	0a1a      	lsrs	r2, r3, #8
   2055c:	061b      	lsls	r3, r3, #24
   2055e:	199c      	adds	r4, r3, r6
   20560:	4b05      	ldr	r3, [pc, #20]	; (20578 <sys_clock_timeout_handler+0x44>)
   20562:	f142 0500 	adc.w	r5, r2, #0
   20566:	e9c3 4500 	strd	r4, r5, [r3]
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	sys_clock_announce(dticks);
}
   2056a:	bc70      	pop	{r4, r5, r6}
	sys_clock_announce(dticks);
   2056c:	f003 bde2 	b.w	24134 <sys_clock_announce>
   20570:	2000a560 	.word	0x2000a560
   20574:	2000b2e4 	.word	0x2000b2e4
   20578:	2000a568 	.word	0x2000a568

0002057c <compare_int_unlock>:
	if (key) {
   2057c:	b1d9      	cbz	r1, 205b6 <compare_int_unlock+0x3a>
		atomic_or(&int_mask, BIT(chan));
   2057e:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   20580:	4a0d      	ldr	r2, [pc, #52]	; (205b8 <compare_int_unlock+0x3c>)
   20582:	4083      	lsls	r3, r0
   20584:	e8d2 cfef 	ldaex	ip, [r2]
   20588:	ea4c 0c03 	orr.w	ip, ip, r3
   2058c:	e8c2 cfe1 	stlex	r1, ip, [r2]
   20590:	2900      	cmp	r1, #0
   20592:	d1f7      	bne.n	20584 <compare_int_unlock+0x8>
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
   20594:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    p_reg->INTENSET = mask;
   20598:	4a08      	ldr	r2, [pc, #32]	; (205bc <compare_int_unlock+0x40>)
   2059a:	4083      	lsls	r3, r0
   2059c:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   205a0:	4b07      	ldr	r3, [pc, #28]	; (205c0 <compare_int_unlock+0x44>)
   205a2:	e8d3 3faf 	lda	r3, [r3]
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
   205a6:	40c3      	lsrs	r3, r0
   205a8:	07db      	lsls	r3, r3, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   205aa:	bf42      	ittt	mi
   205ac:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   205b0:	4b04      	ldrmi	r3, [pc, #16]	; (205c4 <compare_int_unlock+0x48>)
   205b2:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
}
   205b6:	4770      	bx	lr
   205b8:	2000b2e0 	.word	0x2000b2e0
   205bc:	40015000 	.word	0x40015000
   205c0:	2000b2dc 	.word	0x2000b2dc
   205c4:	e000e100 	.word	0xe000e100

000205c8 <z_nrf_rtc_timer_read>:
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
   205c8:	4b0d      	ldr	r3, [pc, #52]	; (20600 <z_nrf_rtc_timer_read+0x38>)
   205ca:	6818      	ldr	r0, [r3, #0]
   205cc:	0a01      	lsrs	r1, r0, #8
   205ce:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
   205d0:	f3bf 8f5f 	dmb	sy
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
   205d4:	4b0b      	ldr	r3, [pc, #44]	; (20604 <z_nrf_rtc_timer_read+0x3c>)
   205d6:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	val += cntr;
   205da:	1818      	adds	r0, r3, r0
   205dc:	f141 0100 	adc.w	r1, r1, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
   205e0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   205e4:	d20a      	bcs.n	205fc <z_nrf_rtc_timer_read+0x34>
		if (val < anchor) {
   205e6:	4b08      	ldr	r3, [pc, #32]	; (20608 <z_nrf_rtc_timer_read+0x40>)
   205e8:	e9d3 2300 	ldrd	r2, r3, [r3]
   205ec:	4290      	cmp	r0, r2
   205ee:	eb71 0303 	sbcs.w	r3, r1, r3
   205f2:	d203      	bcs.n	205fc <z_nrf_rtc_timer_read+0x34>
			val += COUNTER_SPAN;
   205f4:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
   205f8:	f141 0100 	adc.w	r1, r1, #0
}
   205fc:	4770      	bx	lr
   205fe:	bf00      	nop
   20600:	2000b2e4 	.word	0x2000b2e4
   20604:	40015000 	.word	0x40015000
   20608:	2000a568 	.word	0x2000a568

0002060c <compare_set>:
{
   2060c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20610:	4616      	mov	r6, r2
   20612:	461f      	mov	r7, r3
   20614:	4604      	mov	r4, r0
	key = compare_int_lock(chan);
   20616:	f7ff ff6d 	bl	204f4 <compare_int_lock>
   2061a:	9000      	str	r0, [sp, #0]
	uint64_t curr_time = z_nrf_rtc_timer_read();
   2061c:	f7ff ffd4 	bl	205c8 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
   20620:	42b0      	cmp	r0, r6
   20622:	eb71 0307 	sbcs.w	r3, r1, r7
   20626:	d250      	bcs.n	206ca <compare_set+0xbe>
		if (target_time - curr_time > COUNTER_HALF_SPAN) {
   20628:	4b38      	ldr	r3, [pc, #224]	; (2070c <compare_set+0x100>)
   2062a:	1a30      	subs	r0, r6, r0
   2062c:	eb67 0101 	sbc.w	r1, r7, r1
   20630:	4298      	cmp	r0, r3
   20632:	f171 0100 	sbcs.w	r1, r1, #0
   20636:	d265      	bcs.n	20704 <compare_set+0xf8>
		if (target_time != cc_data[chan].target_time) {
   20638:	4b35      	ldr	r3, [pc, #212]	; (20710 <compare_set+0x104>)
   2063a:	eb03 1304 	add.w	r3, r3, r4, lsl #4
   2063e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
   20642:	429f      	cmp	r7, r3
   20644:	bf08      	it	eq
   20646:	4296      	cmpeq	r6, r2
   20648:	d049      	beq.n	206de <compare_set+0xd2>
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
   2064a:	f44f 3980 	mov.w	r9, #65536	; 0x10000
    p_reg->EVTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
   2064e:	4931      	ldr	r1, [pc, #196]	; (20714 <compare_set+0x108>)
   20650:	fa09 f904 	lsl.w	r9, r9, r4
	event_clear(chan);
   20654:	4620      	mov	r0, r4
	return absolute_time & COUNTER_MAX;
   20656:	f026 4b7f 	bic.w	fp, r6, #4278190080	; 0xff000000
   2065a:	f8c1 9348 	str.w	r9, [r1, #840]	; 0x348
	event_clear(chan);
   2065e:	f005 f889 	bl	25774 <event_clear>
	uint32_t cc_inc = MIN_CYCLES_FROM_NOW;
   20662:	f04f 0a03 	mov.w	sl, #3
	uint32_t cc_val = req_cc;
   20666:	4658      	mov	r0, fp
	return nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   20668:	f104 0550 	add.w	r5, r4, #80	; 0x50
   2066c:	00ad      	lsls	r5, r5, #2
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2066e:	b2ad      	uxth	r5, r5
   20670:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
    p_reg->CC[ch] = cc_val;
   20674:	f504 73a8 	add.w	r3, r4, #336	; 0x150
		if (counter_sub(cc_val, now + MIN_CYCLES_FROM_NOW) >
   20678:	4a27      	ldr	r2, [pc, #156]	; (20718 <compare_set+0x10c>)
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2067a:	f505 35a8 	add.w	r5, r5, #86016	; 0x15000
    p_reg->CC[ch] = cc_val;
   2067e:	9301      	str	r3, [sp, #4]
   20680:	f8dd c004 	ldr.w	ip, [sp, #4]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
   20684:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
   20688:	f841 302c 	str.w	r3, [r1, ip, lsl #2]
    p_reg->EVTENSET = mask;
   2068c:	f8c1 9344 	str.w	r9, [r1, #836]	; 0x344
     return p_reg->COUNTER;
   20690:	f8d1 8504 	ldr.w	r8, [r1, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   20694:	eba0 0008 	sub.w	r0, r0, r8
   20698:	3803      	subs	r0, #3
   2069a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		if (counter_sub(cc_val, now + MIN_CYCLES_FROM_NOW) >
   2069e:	4290      	cmp	r0, r2
   206a0:	d91d      	bls.n	206de <compare_set+0xd2>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   206a2:	6828      	ldr	r0, [r5, #0]
			if (event_check(chan)) {
   206a4:	b160      	cbz	r0, 206c0 <compare_set+0xb4>
     return p_reg->COUNTER;
   206a6:	f8d1 8504 	ldr.w	r8, [r1, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   206aa:	eba8 000b 	sub.w	r0, r8, fp
   206ae:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
				if (counter_sub(now, req_cc) > COUNTER_HALF_SPAN) {
   206b2:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   206b6:	d912      	bls.n	206de <compare_set+0xd2>
					event_clear(chan);
   206b8:	4620      	mov	r0, r4
   206ba:	f005 f85b 	bl	25774 <event_clear>
   206be:	4a16      	ldr	r2, [pc, #88]	; (20718 <compare_set+0x10c>)
			cc_val = now + cc_inc;
   206c0:	eb0a 0008 	add.w	r0, sl, r8
			cc_inc++;
   206c4:	f10a 0a01 	add.w	sl, sl, #1
	for (;;) {
   206c8:	e7da      	b.n	20680 <compare_set+0x74>
		atomic_or(&force_isr_mask, BIT(chan));
   206ca:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   206cc:	4a13      	ldr	r2, [pc, #76]	; (2071c <compare_set+0x110>)
   206ce:	40a3      	lsls	r3, r4
   206d0:	e8d2 0fef 	ldaex	r0, [r2]
   206d4:	4318      	orrs	r0, r3
   206d6:	e8c2 0fe1 	stlex	r1, r0, [r2]
   206da:	2900      	cmp	r1, #0
   206dc:	d1f8      	bne.n	206d0 <compare_set+0xc4>
	return ret;
   206de:	2500      	movs	r5, #0
	cc_data[chan].target_time = target_time;
   206e0:	490b      	ldr	r1, [pc, #44]	; (20710 <compare_set+0x104>)
	cc_data[chan].callback = handler;
   206e2:	980c      	ldr	r0, [sp, #48]	; 0x30
	cc_data[chan].target_time = target_time;
   206e4:	0123      	lsls	r3, r4, #4
   206e6:	eb01 1204 	add.w	r2, r1, r4, lsl #4
	cc_data[chan].callback = handler;
   206ea:	50c8      	str	r0, [r1, r3]
	cc_data[chan].target_time = target_time;
   206ec:	e9c2 6702 	strd	r6, r7, [r2, #8]
	cc_data[chan].user_context = user_data;
   206f0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   206f2:	6053      	str	r3, [r2, #4]
	compare_int_unlock(chan, key);
   206f4:	4620      	mov	r0, r4
   206f6:	9900      	ldr	r1, [sp, #0]
   206f8:	f7ff ff40 	bl	2057c <compare_int_unlock>
}
   206fc:	4628      	mov	r0, r5
   206fe:	b003      	add	sp, #12
   20700:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return -EINVAL;
   20704:	f06f 0515 	mvn.w	r5, #21
   20708:	e7f4      	b.n	206f4 <compare_set+0xe8>
   2070a:	bf00      	nop
   2070c:	00800001 	.word	0x00800001
   20710:	2000a550 	.word	0x2000a550
   20714:	40015000 	.word	0x40015000
   20718:	007ffffd 	.word	0x007ffffd
   2071c:	2000b2dc 	.word	0x2000b2dc

00020720 <sys_clock_driver_init>:
	int_event_disable_rtc();
	NVIC_ClearPendingIRQ(RTC_IRQn);
}

static int sys_clock_driver_init(void)
{
   20720:	b573      	push	{r0, r1, r4, r5, r6, lr}
    p_reg->PRESCALER = val;
   20722:	2500      	movs	r5, #0
	int_event_disable_rtc();

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
   20724:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   20728:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    p_reg->INTENCLR = mask;
   2072c:	4c18      	ldr	r4, [pc, #96]	; (20790 <sys_clock_driver_init+0x70>)
   2072e:	4b19      	ldr	r3, [pc, #100]	; (20794 <sys_clock_driver_init+0x74>)
    p_reg->INTENSET = mask;
   20730:	2602      	movs	r6, #2
    p_reg->INTENCLR = mask;
   20732:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    p_reg->EVTENCLR = mask;
   20736:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
   2073a:	4b17      	ldr	r3, [pc, #92]	; (20798 <sys_clock_driver_init+0x78>)
    p_reg->PRESCALER = val;
   2073c:	f8c4 5508 	str.w	r5, [r4, #1288]	; 0x508
   20740:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
   20744:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20748:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   2074c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   20750:	4b12      	ldr	r3, [pc, #72]	; (2079c <sys_clock_driver_init+0x7c>)

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
   20752:	2101      	movs	r1, #1
   20754:	f8c4 6304 	str.w	r6, [r4, #772]	; 0x304
   20758:	2015      	movs	r0, #21
   2075a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
   2075e:	462a      	mov	r2, r5
   20760:	f7fd fde6 	bl	1e330 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
   20764:	2015      	movs	r0, #21
   20766:	f7fd fdb3 	bl	1e2d0 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   2076a:	2301      	movs	r3, #1

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
   2076c:	4a0c      	ldr	r2, [pc, #48]	; (207a0 <sys_clock_driver_init+0x80>)
   2076e:	60a3      	str	r3, [r4, #8]
   20770:	6023      	str	r3, [r4, #0]
   20772:	6013      	str	r3, [r2, #0]
	}

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		MAX_CYCLES : CYC_PER_TICK;

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
   20774:	4b0b      	ldr	r3, [pc, #44]	; (207a4 <sys_clock_driver_init+0x84>)
   20776:	4a0c      	ldr	r2, [pc, #48]	; (207a8 <sys_clock_driver_init+0x88>)
   20778:	9300      	str	r3, [sp, #0]
   2077a:	4628      	mov	r0, r5
   2077c:	2300      	movs	r3, #0
   2077e:	9501      	str	r5, [sp, #4]
   20780:	f7ff ff44 	bl	2060c <compare_set>

	z_nrf_clock_control_lf_on(mode);
   20784:	4630      	mov	r0, r6
   20786:	f7ff f8ef 	bl	1f968 <z_nrf_clock_control_lf_on>

	return 0;
}
   2078a:	4628      	mov	r0, r5
   2078c:	b002      	add	sp, #8
   2078e:	bd70      	pop	{r4, r5, r6, pc}
   20790:	40015000 	.word	0x40015000
   20794:	000f0003 	.word	0x000f0003
   20798:	2000a550 	.word	0x2000a550
   2079c:	e000e100 	.word	0xe000e100
   207a0:	2000b2e0 	.word	0x2000b2e0
   207a4:	00020535 	.word	0x00020535
   207a8:	007fffff 	.word	0x007fffff

000207ac <rtc_nrf_isr>:
{
   207ac:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    return p_reg->INTENSET & mask;
   207b0:	4b2e      	ldr	r3, [pc, #184]	; (2086c <rtc_nrf_isr+0xc0>)
   207b2:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
   207b6:	0790      	lsls	r0, r2, #30
   207b8:	d50b      	bpl.n	207d2 <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   207ba:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
   207be:	b142      	cbz	r2, 207d2 <rtc_nrf_isr+0x26>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   207c0:	2200      	movs	r2, #0
   207c2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
		overflow_cnt++;
   207c6:	4a2a      	ldr	r2, [pc, #168]	; (20870 <rtc_nrf_isr+0xc4>)
   207c8:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
   207cc:	6813      	ldr	r3, [r2, #0]
   207ce:	3301      	adds	r3, #1
   207d0:	6013      	str	r3, [r2, #0]
    return p_reg->INTENSET & mask;
   207d2:	4a26      	ldr	r2, [pc, #152]	; (2086c <rtc_nrf_isr+0xc0>)
   207d4:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
   207d8:	03d9      	lsls	r1, r3, #15
   207da:	d527      	bpl.n	2082c <rtc_nrf_isr+0x80>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   207dc:	4b25      	ldr	r3, [pc, #148]	; (20874 <rtc_nrf_isr+0xc8>)
   207de:	e8d3 1fef 	ldaex	r1, [r3]
   207e2:	f021 0001 	bic.w	r0, r1, #1
   207e6:	e8c3 0fe4 	stlex	r4, r0, [r3]
   207ea:	2c00      	cmp	r4, #0
   207ec:	d1f7      	bne.n	207de <rtc_nrf_isr+0x32>
		if ((atomic_and(&force_isr_mask, ~BIT(chan)) & BIT(chan)) ||
   207ee:	07cb      	lsls	r3, r1, #31
   207f0:	d402      	bmi.n	207f8 <rtc_nrf_isr+0x4c>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   207f2:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
   207f6:	b1cb      	cbz	r3, 2082c <rtc_nrf_isr+0x80>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   207f8:	2500      	movs	r5, #0
   207fa:	4c1c      	ldr	r4, [pc, #112]	; (2086c <rtc_nrf_isr+0xc0>)
   207fc:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
   20800:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		curr_time = z_nrf_rtc_timer_read();
   20804:	f7ff fee0 	bl	205c8 <z_nrf_rtc_timer_read>
   20808:	f04f 0320 	mov.w	r3, #32
   2080c:	f3ef 8211 	mrs	r2, BASEPRI
   20810:	f383 8812 	msr	BASEPRI_MAX, r3
   20814:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
   20818:	4b17      	ldr	r3, [pc, #92]	; (20878 <rtc_nrf_isr+0xcc>)
   2081a:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
		if (curr_time >= expire_time) {
   2081e:	42b0      	cmp	r0, r6
   20820:	41b9      	sbcs	r1, r7
   20822:	d206      	bcs.n	20832 <rtc_nrf_isr+0x86>
	__asm__ volatile(
   20824:	f382 8811 	msr	BASEPRI, r2
   20828:	f3bf 8f6f 	isb	sy
}
   2082c:	b003      	add	sp, #12
   2082e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   20832:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
			user_context = cc_data[chan].user_context;
   20836:	e9d3 1000 	ldrd	r1, r0, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   2083a:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			cc_data[chan].callback = NULL;
   2083e:	601d      	str	r5, [r3, #0]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
   20840:	e9c3 8902 	strd	r8, r9, [r3, #8]
    p_reg->EVTENCLR = mask;
   20844:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   20848:	f8c4 3348 	str.w	r3, [r4, #840]	; 0x348
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   2084c:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
   20850:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
   20854:	f382 8811 	msr	BASEPRI, r2
   20858:	f3bf 8f6f 	isb	sy
		if (handler) {
   2085c:	2900      	cmp	r1, #0
   2085e:	d0e5      	beq.n	2082c <rtc_nrf_isr+0x80>
			handler(chan, expire_time, user_context);
   20860:	9000      	str	r0, [sp, #0]
   20862:	4632      	mov	r2, r6
   20864:	463b      	mov	r3, r7
   20866:	4628      	mov	r0, r5
   20868:	4788      	blx	r1
   2086a:	e7df      	b.n	2082c <rtc_nrf_isr+0x80>
   2086c:	40015000 	.word	0x40015000
   20870:	2000b2e4 	.word	0x2000b2e4
   20874:	2000b2dc 	.word	0x2000b2dc
   20878:	2000a550 	.word	0x2000a550

0002087c <sys_clock_set_timeout>:
	if (ticks == K_TICKS_FOREVER) {
   2087c:	1c43      	adds	r3, r0, #1
{
   2087e:	b513      	push	{r0, r1, r4, lr}
	if (ticks == K_TICKS_FOREVER) {
   20880:	d021      	beq.n	208c6 <sys_clock_set_timeout+0x4a>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
   20882:	2801      	cmp	r0, #1
   20884:	dd21      	ble.n	208ca <sys_clock_set_timeout+0x4e>
   20886:	4a12      	ldr	r2, [pc, #72]	; (208d0 <sys_clock_set_timeout+0x54>)
   20888:	4b12      	ldr	r3, [pc, #72]	; (208d4 <sys_clock_set_timeout+0x58>)
   2088a:	4290      	cmp	r0, r2
   2088c:	bfd4      	ite	le
   2088e:	4604      	movle	r4, r0
   20890:	461c      	movgt	r4, r3
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   20892:	f7ff fe99 	bl	205c8 <z_nrf_rtc_timer_read>
   20896:	4b10      	ldr	r3, [pc, #64]	; (208d8 <sys_clock_set_timeout+0x5c>)
	if (cyc > MAX_CYCLES) {
   20898:	490e      	ldr	r1, [pc, #56]	; (208d4 <sys_clock_set_timeout+0x58>)
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
   2089a:	e9d3 2300 	ldrd	r2, r3, [r3]
   2089e:	1a80      	subs	r0, r0, r2
		cyc = 0;
   208a0:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   208a4:	bf28      	it	cs
   208a6:	2400      	movcs	r4, #0
	cyc += unannounced;
   208a8:	4404      	add	r4, r0
	if (cyc > MAX_CYCLES) {
   208aa:	428c      	cmp	r4, r1
   208ac:	bf28      	it	cs
   208ae:	460c      	movcs	r4, r1
	uint64_t target_time = cyc + last_count;
   208b0:	2000      	movs	r0, #0
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   208b2:	490a      	ldr	r1, [pc, #40]	; (208dc <sys_clock_set_timeout+0x60>)
	uint64_t target_time = cyc + last_count;
   208b4:	18a2      	adds	r2, r4, r2
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
   208b6:	9001      	str	r0, [sp, #4]
   208b8:	9100      	str	r1, [sp, #0]
   208ba:	f143 0300 	adc.w	r3, r3, #0
   208be:	f7ff fea5 	bl	2060c <compare_set>
}
   208c2:	b002      	add	sp, #8
   208c4:	bd10      	pop	{r4, pc}
		cyc = MAX_TICKS * CYC_PER_TICK;
   208c6:	4c03      	ldr	r4, [pc, #12]	; (208d4 <sys_clock_set_timeout+0x58>)
   208c8:	e7e3      	b.n	20892 <sys_clock_set_timeout+0x16>
		cyc = CLAMP(ticks, 1, (int32_t)MAX_TICKS);
   208ca:	2401      	movs	r4, #1
   208cc:	e7e1      	b.n	20892 <sys_clock_set_timeout+0x16>
   208ce:	bf00      	nop
   208d0:	007ffffe 	.word	0x007ffffe
   208d4:	007fffff 	.word	0x007fffff
   208d8:	2000a560 	.word	0x2000a560
   208dc:	00020535 	.word	0x00020535

000208e0 <sys_clock_elapsed>:
{
   208e0:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
   208e2:	f7ff fe71 	bl	205c8 <z_nrf_rtc_timer_read>
   208e6:	4b02      	ldr	r3, [pc, #8]	; (208f0 <sys_clock_elapsed+0x10>)
   208e8:	681b      	ldr	r3, [r3, #0]
}
   208ea:	1ac0      	subs	r0, r0, r3
   208ec:	bd08      	pop	{r3, pc}
   208ee:	bf00      	nop
   208f0:	2000a560 	.word	0x2000a560

000208f4 <tfm_ns_interface_dispatch>:
K_MUTEX_DEFINE(tfm_mutex);

int32_t tfm_ns_interface_dispatch(veneer_fn fn,
				  uint32_t arg0, uint32_t arg1,
				  uint32_t arg2, uint32_t arg3)
{
   208f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   208f8:	461f      	mov	r7, r3
	return !z_sys_post_kernel;
   208fa:	4b15      	ldr	r3, [pc, #84]	; (20950 <tfm_ns_interface_dispatch+0x5c>)
   208fc:	4604      	mov	r4, r0
   208fe:	f893 8000 	ldrb.w	r8, [r3]
   20902:	460d      	mov	r5, r1
   20904:	4616      	mov	r6, r2
   20906:	b0a2      	sub	sp, #136	; 0x88
	int32_t result;
	bool is_pre_kernel = k_is_pre_kernel();
	int tfm_ns_saved_prio;

	if (!is_pre_kernel) {
   20908:	f1b8 0f00 	cmp.w	r8, #0
   2090c:	d115      	bne.n	2093a <tfm_ns_interface_dispatch+0x46>
#endif
	}

	struct fpu_ctx_full context_buffer;

	z_arm_save_fp_context(&context_buffer);
   2090e:	4668      	mov	r0, sp
   20910:	f004 fb27 	bl	24f62 <z_arm_save_fp_context>

	result = fn(arg0, arg1, arg2, arg3);
   20914:	463a      	mov	r2, r7
   20916:	4631      	mov	r1, r6
   20918:	4628      	mov	r0, r5
   2091a:	9b28      	ldr	r3, [sp, #160]	; 0xa0
   2091c:	47a0      	blx	r4
   2091e:	4604      	mov	r4, r0

	z_arm_restore_fp_context(&context_buffer);
   20920:	4668      	mov	r0, sp
   20922:	f004 fb1f 	bl	24f64 <z_arm_restore_fp_context>

	if (!is_pre_kernel) {
   20926:	f1b8 0f00 	cmp.w	r8, #0
   2092a:	d002      	beq.n	20932 <tfm_ns_interface_dispatch+0x3e>
	return z_impl_k_mutex_unlock(mutex);
   2092c:	4809      	ldr	r0, [pc, #36]	; (20954 <tfm_ns_interface_dispatch+0x60>)
   2092e:	f002 fd8f 	bl	23450 <z_impl_k_mutex_unlock>

		k_mutex_unlock(&tfm_mutex);
	}

	return result;
}
   20932:	4620      	mov	r0, r4
   20934:	b022      	add	sp, #136	; 0x88
   20936:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return z_impl_k_mutex_lock(mutex, timeout);
   2093a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2093e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   20942:	4804      	ldr	r0, [pc, #16]	; (20954 <tfm_ns_interface_dispatch+0x60>)
   20944:	f002 fd0a 	bl	2335c <z_impl_k_mutex_lock>
		if (k_mutex_lock(&tfm_mutex, K_FOREVER) != 0) {
   20948:	2800      	cmp	r0, #0
   2094a:	d0e0      	beq.n	2090e <tfm_ns_interface_dispatch+0x1a>
			return (int32_t)TFM_ERROR_GENERIC;
   2094c:	241f      	movs	r4, #31
   2094e:	e7f0      	b.n	20932 <tfm_ns_interface_dispatch+0x3e>
   20950:	2000b62b 	.word	0x2000b62b
   20954:	2000a2f4 	.word	0x2000a2f4

00020958 <tfm_platform_ioctl>:
enum tfm_platform_err_t
tfm_platform_ioctl(tfm_platform_ioctl_req_t request,
                   psa_invec *input, psa_outvec *output)
{
    tfm_platform_ioctl_req_t req = request;
    struct psa_invec in_vec[2] = { {0} };
   20958:	2300      	movs	r3, #0
{
   2095a:	b500      	push	{lr}
   2095c:	b089      	sub	sp, #36	; 0x24
    struct psa_invec in_vec[2] = { {0} };
   2095e:	e9cd 3306 	strd	r3, r3, [sp, #24]
    size_t inlen, outlen;
    psa_status_t status = PSA_ERROR_CONNECTION_REFUSED;

    in_vec[0].base = &req;
   20962:	ab03      	add	r3, sp, #12
   20964:	9304      	str	r3, [sp, #16]
    in_vec[0].len = sizeof(req);
   20966:	2304      	movs	r3, #4
    tfm_platform_ioctl_req_t req = request;
   20968:	9003      	str	r0, [sp, #12]
    in_vec[0].len = sizeof(req);
   2096a:	9305      	str	r3, [sp, #20]
    if (input != NULL) {
   2096c:	b1a9      	cbz	r1, 2099a <tfm_platform_ioctl+0x42>
        in_vec[1].base = input->base;
   2096e:	680b      	ldr	r3, [r1, #0]
   20970:	9306      	str	r3, [sp, #24]
        in_vec[1].len = input->len;
   20972:	684b      	ldr	r3, [r1, #4]
   20974:	9307      	str	r3, [sp, #28]
        inlen = 2;
   20976:	2302      	movs	r3, #2
    } else {
        inlen = 1;
    }

    if (output != NULL) {
   20978:	1e11      	subs	r1, r2, #0
   2097a:	bf18      	it	ne
   2097c:	2101      	movne	r1, #1
        outlen = 1;
    } else {
        outlen = 0;
    }

    status = psa_call(TFM_PLATFORM_SERVICE_HANDLE,
   2097e:	4808      	ldr	r0, [pc, #32]	; (209a0 <tfm_platform_ioctl+0x48>)
   20980:	e9cd 2100 	strd	r2, r1, [sp]
   20984:	f240 31f5 	movw	r1, #1013	; 0x3f5
   20988:	aa04      	add	r2, sp, #16
   2098a:	f000 f82b 	bl	209e4 <psa_call>
                      TFM_PLATFORM_API_ID_IOCTL,
                      in_vec, inlen,
                      output, outlen);

    if (status < PSA_SUCCESS) {
   2098e:	2800      	cmp	r0, #0
        return TFM_PLATFORM_ERR_SYSTEM_ERROR;
    } else {
        return (enum tfm_platform_err_t)status;
    }
}
   20990:	bfb8      	it	lt
   20992:	2001      	movlt	r0, #1
   20994:	b009      	add	sp, #36	; 0x24
   20996:	f85d fb04 	ldr.w	pc, [sp], #4
        inlen = 1;
   2099a:	2301      	movs	r3, #1
   2099c:	e7ec      	b.n	20978 <tfm_platform_ioctl+0x20>
   2099e:	bf00      	nop
   209a0:	40000105 	.word	0x40000105

000209a4 <psa_generate_random>:
    return API_DISPATCH_NO_OUTVEC(in_vec);
}

psa_status_t psa_generate_random(uint8_t *output,
                                 size_t output_size)
{
   209a4:	b570      	push	{r4, r5, r6, lr}
    struct tfm_crypto_pack_iovec iov = {
   209a6:	2630      	movs	r6, #48	; 0x30
{
   209a8:	b092      	sub	sp, #72	; 0x48
    struct tfm_crypto_pack_iovec iov = {
   209aa:	ab06      	add	r3, sp, #24
{
   209ac:	4605      	mov	r5, r0
   209ae:	460c      	mov	r4, r1
    struct tfm_crypto_pack_iovec iov = {
   209b0:	4632      	mov	r2, r6
   209b2:	2100      	movs	r1, #0
   209b4:	4618      	mov	r0, r3
   209b6:	f004 fb17 	bl	24fe8 <memset>

    psa_invec in_vec[] = {
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    psa_outvec out_vec[] = {
   209ba:	e9cd 5404 	strd	r5, r4, [sp, #16]
    psa_invec in_vec[] = {
   209be:	e9cd 0602 	strd	r0, r6, [sp, #8]
        {.base = output, .len = output_size},
    };

    if (output_size == 0) {
   209c2:	b154      	cbz	r4, 209da <psa_generate_random+0x36>
        return PSA_SUCCESS;
    }

    return API_DISPATCH(in_vec, out_vec);
   209c4:	2301      	movs	r3, #1
   209c6:	aa04      	add	r2, sp, #16
   209c8:	9200      	str	r2, [sp, #0]
   209ca:	2100      	movs	r1, #0
   209cc:	4804      	ldr	r0, [pc, #16]	; (209e0 <psa_generate_random+0x3c>)
   209ce:	9301      	str	r3, [sp, #4]
   209d0:	aa02      	add	r2, sp, #8
   209d2:	f000 f807 	bl	209e4 <psa_call>
}
   209d6:	b012      	add	sp, #72	; 0x48
   209d8:	bd70      	pop	{r4, r5, r6, pc}
        return PSA_SUCCESS;
   209da:	4620      	mov	r0, r4
   209dc:	e7fb      	b.n	209d6 <psa_generate_random+0x32>
   209de:	bf00      	nop
   209e0:	40000100 	.word	0x40000100

000209e4 <psa_call>:
psa_status_t psa_call(psa_handle_t handle, int32_t type,
                      const psa_invec *in_vec,
                      size_t in_len,
                      psa_outvec *out_vec,
                      size_t out_len)
{
   209e4:	b430      	push	{r4, r5}
    if ((type > INT16_MAX) ||
   209e6:	f501 4500 	add.w	r5, r1, #32768	; 0x8000
   209ea:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
{
   209ee:	9c03      	ldr	r4, [sp, #12]
    if ((type > INT16_MAX) ||
   209f0:	d20d      	bcs.n	20a0e <psa_call+0x2a>
        (type < INT16_MIN) ||
   209f2:	ea43 0504 	orr.w	r5, r3, r4
   209f6:	2dff      	cmp	r5, #255	; 0xff
   209f8:	d809      	bhi.n	20a0e <psa_call+0x2a>
    }

    return tfm_ns_interface_dispatch(
                                (veneer_fn)tfm_psa_call_veneer,
                                (uint32_t)handle,
                                PARAM_PACK(type, in_len, out_len),
   209fa:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
    return tfm_ns_interface_dispatch(
   209fe:	4613      	mov	r3, r2
   20a00:	ea44 4201 	orr.w	r2, r4, r1, lsl #16
   20a04:	4601      	mov	r1, r0
                                (uint32_t)in_vec,
                                (uint32_t)out_vec);
}
   20a06:	bc30      	pop	{r4, r5}
    return tfm_ns_interface_dispatch(
   20a08:	4803      	ldr	r0, [pc, #12]	; (20a18 <psa_call+0x34>)
   20a0a:	f7ff bf73 	b.w	208f4 <tfm_ns_interface_dispatch>
}
   20a0e:	f06f 0080 	mvn.w	r0, #128	; 0x80
   20a12:	bc30      	pop	{r4, r5}
   20a14:	4770      	bx	lr
   20a16:	bf00      	nop
   20a18:	00017c11 	.word	0x00017c11

00020a1c <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
   20a1c:	b570      	push	{r4, r5, r6, lr}
        idx = 31 - NRF_CLZ(prev_mask);
        if (idx < 0) {
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
   20a1e:	2501      	movs	r5, #1
        prev_mask = *p_mask;
   20a20:	6802      	ldr	r2, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
   20a22:	fab2 f382 	clz	r3, r2
   20a26:	f1c3 031f 	rsb	r3, r3, #31
   20a2a:	b2db      	uxtb	r3, r3
        new_mask = prev_mask & ~NRFX_BIT(idx);
   20a2c:	fa05 f403 	lsl.w	r4, r5, r3
   20a30:	ea22 0404 	bic.w	r4, r2, r4
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   20a34:	e8d0 6fef 	ldaex	r6, [r0]
   20a38:	4296      	cmp	r6, r2
   20a3a:	d104      	bne.n	20a46 <nrfx_flag32_alloc+0x2a>
   20a3c:	e8c0 4fec 	stlex	ip, r4, [r0]
   20a40:	f1bc 0f00 	cmp.w	ip, #0
   20a44:	d1f6      	bne.n	20a34 <nrfx_flag32_alloc+0x18>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   20a46:	d1eb      	bne.n	20a20 <nrfx_flag32_alloc+0x4>

    *p_flag = idx;

    return NRFX_SUCCESS;
}
   20a48:	4801      	ldr	r0, [pc, #4]	; (20a50 <nrfx_flag32_alloc+0x34>)
    *p_flag = idx;
   20a4a:	700b      	strb	r3, [r1, #0]
}
   20a4c:	bd70      	pop	{r4, r5, r6, pc}
   20a4e:	bf00      	nop
   20a50:	0bad0000 	.word	0x0bad0000

00020a54 <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
   20a54:	b510      	push	{r4, lr}
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
   20a56:	6803      	ldr	r3, [r0, #0]
   20a58:	40cb      	lsrs	r3, r1
   20a5a:	07db      	lsls	r3, r3, #31
   20a5c:	d410      	bmi.n	20a80 <nrfx_flag32_free+0x2c>
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
        new_mask = prev_mask | NRFX_BIT(flag);
   20a5e:	2301      	movs	r3, #1
   20a60:	408b      	lsls	r3, r1
        prev_mask = *p_mask;
   20a62:	6802      	ldr	r2, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
   20a64:	ea43 0102 	orr.w	r1, r3, r2
   20a68:	e8d0 4fef 	ldaex	r4, [r0]
   20a6c:	4294      	cmp	r4, r2
   20a6e:	d104      	bne.n	20a7a <nrfx_flag32_free+0x26>
   20a70:	e8c0 1fec 	stlex	ip, r1, [r0]
   20a74:	f1bc 0f00 	cmp.w	ip, #0
   20a78:	d1f6      	bne.n	20a68 <nrfx_flag32_free+0x14>
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
   20a7a:	d1f2      	bne.n	20a62 <nrfx_flag32_free+0xe>

    return NRFX_SUCCESS;
   20a7c:	4801      	ldr	r0, [pc, #4]	; (20a84 <nrfx_flag32_free+0x30>)
}
   20a7e:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   20a80:	4801      	ldr	r0, [pc, #4]	; (20a88 <nrfx_flag32_free+0x34>)
   20a82:	e7fc      	b.n	20a7e <nrfx_flag32_free+0x2a>
   20a84:	0bad0000 	.word	0x0bad0000
   20a88:	0bad0004 	.word	0x0bad0004

00020a8c <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
   20a8c:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch (domain)
   20a8e:	2803      	cmp	r0, #3
   20a90:	f200 80a0 	bhi.w	20bd4 <clock_stop+0x148>
   20a94:	e8df f000 	tbb	[pc, r0]
   20a98:	32251802 	.word	0x32251802
    p_reg->INTENCLR = mask;
   20a9c:	2202      	movs	r2, #2
   20a9e:	4b59      	ldr	r3, [pc, #356]	; (20c04 <clock_stop+0x178>)
   20aa0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20aa4:	2200      	movs	r2, #0
   20aa6:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   20aaa:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20aae:	2201      	movs	r2, #1
   20ab0:	60da      	str	r2, [r3, #12]
            return;
    }

    bool stopped;
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   20ab2:	2400      	movs	r4, #0
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
   20ab4:	2301      	movs	r3, #1
   20ab6:	f88d 3007 	strb.w	r3, [sp, #7]
    switch (domain)
   20aba:	2803      	cmp	r0, #3
   20abc:	f200 808a 	bhi.w	20bd4 <clock_stop+0x148>
   20ac0:	e8df f000 	tbb	[pc, r0]
   20ac4:	94736529 	.word	0x94736529
    p_reg->INTENCLR = mask;
   20ac8:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20aca:	2100      	movs	r1, #0
    p_reg->INTENCLR = mask;
   20acc:	4b4d      	ldr	r3, [pc, #308]	; (20c04 <clock_stop+0x178>)
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
   20ace:	f10d 0407 	add.w	r4, sp, #7
   20ad2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20ad6:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
   20ada:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20ade:	605a      	str	r2, [r3, #4]
   20ae0:	e7e8      	b.n	20ab4 <clock_stop+0x28>
    p_reg->INTENCLR = mask;
   20ae2:	f44f 7200 	mov.w	r2, #512	; 0x200
   20ae6:	4b47      	ldr	r3, [pc, #284]	; (20c04 <clock_stop+0x178>)
   20ae8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20aec:	2200      	movs	r2, #0
   20aee:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   20af2:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20af6:	2201      	movs	r2, #1
   20af8:	625a      	str	r2, [r3, #36]	; 0x24
   20afa:	e7da      	b.n	20ab2 <clock_stop+0x26>
    p_reg->INTENCLR = mask;
   20afc:	f44f 7280 	mov.w	r2, #256	; 0x100
   20b00:	4b40      	ldr	r3, [pc, #256]	; (20c04 <clock_stop+0x178>)
   20b02:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20b06:	2200      	movs	r2, #0
   20b08:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   20b0c:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20b10:	2201      	movs	r2, #1
   20b12:	61da      	str	r2, [r3, #28]
   20b14:	e7cd      	b.n	20ab2 <clock_stop+0x26>
    switch (domain)
   20b16:	f242 7510 	movw	r5, #10000	; 0x2710
   20b1a:	4e3a      	ldr	r6, [pc, #232]	; (20c04 <clock_stop+0x178>)
            if (p_clk_src != NULL)
   20b1c:	b36c      	cbz	r4, 20b7a <clock_stop+0xee>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20b1e:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   20b22:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
   20b26:	7023      	strb	r3, [r4, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20b28:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   20b2c:	03d9      	lsls	r1, r3, #15
   20b2e:	d551      	bpl.n	20bd4 <clock_stop+0x148>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   20b30:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20b34:	2801      	cmp	r0, #1
   20b36:	d14d      	bne.n	20bd4 <clock_stop+0x148>
   20b38:	f004 fe67 	bl	2580a <nrfx_busy_wait>
   20b3c:	3d01      	subs	r5, #1
   20b3e:	d1ed      	bne.n	20b1c <clock_stop+0x90>
   20b40:	e048      	b.n	20bd4 <clock_stop+0x148>
   20b42:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20b46:	2801      	cmp	r0, #1
   20b48:	d144      	bne.n	20bd4 <clock_stop+0x148>
   20b4a:	f004 fe5e 	bl	2580a <nrfx_busy_wait>
   20b4e:	3d01      	subs	r5, #1
   20b50:	d14f      	bne.n	20bf2 <clock_stop+0x166>
   20b52:	e03f      	b.n	20bd4 <clock_stop+0x148>
   20b54:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20b58:	2801      	cmp	r0, #1
   20b5a:	d13b      	bne.n	20bd4 <clock_stop+0x148>
   20b5c:	f004 fe55 	bl	2580a <nrfx_busy_wait>
   20b60:	3d01      	subs	r5, #1
   20b62:	d037      	beq.n	20bd4 <clock_stop+0x148>
            if (p_clk_src != NULL)
   20b64:	b1bc      	cbz	r4, 20b96 <clock_stop+0x10a>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
   20b66:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   20b6a:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
   20b6e:	7023      	strb	r3, [r4, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   20b70:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   20b74:	03db      	lsls	r3, r3, #15
   20b76:	d52d      	bpl.n	20bd4 <clock_stop+0x148>
   20b78:	e7ec      	b.n	20b54 <clock_stop+0xc8>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20b7a:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
   20b7e:	03da      	lsls	r2, r3, #15
   20b80:	d528      	bpl.n	20bd4 <clock_stop+0x148>
   20b82:	2001      	movs	r0, #1
   20b84:	f004 fe41 	bl	2580a <nrfx_busy_wait>
   20b88:	3d01      	subs	r5, #1
   20b8a:	d1f6      	bne.n	20b7a <clock_stop+0xee>
   20b8c:	e022      	b.n	20bd4 <clock_stop+0x148>
    switch (domain)
   20b8e:	f242 7510 	movw	r5, #10000	; 0x2710
   20b92:	4e1c      	ldr	r6, [pc, #112]	; (20c04 <clock_stop+0x178>)
   20b94:	e7e6      	b.n	20b64 <clock_stop+0xd8>
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
   20b96:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
   20b9a:	03d8      	lsls	r0, r3, #15
   20b9c:	d51a      	bpl.n	20bd4 <clock_stop+0x148>
   20b9e:	2001      	movs	r0, #1
   20ba0:	f004 fe33 	bl	2580a <nrfx_busy_wait>
   20ba4:	3d01      	subs	r5, #1
   20ba6:	d1f6      	bne.n	20b96 <clock_stop+0x10a>
   20ba8:	e014      	b.n	20bd4 <clock_stop+0x148>
    switch (domain)
   20baa:	f242 7510 	movw	r5, #10000	; 0x2710
   20bae:	4e15      	ldr	r6, [pc, #84]	; (20c04 <clock_stop+0x178>)
            if (p_clk_src != NULL)
   20bb0:	b194      	cbz	r4, 20bd8 <clock_stop+0x14c>
                    (nrf_clock_hfclk_t)((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_SRC_Msk)
   20bb2:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
   20bb6:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
   20bba:	7023      	strb	r3, [r4, #0]
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
   20bbc:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
   20bc0:	03d9      	lsls	r1, r3, #15
   20bc2:	d507      	bpl.n	20bd4 <clock_stop+0x148>
   20bc4:	f89d 0007 	ldrb.w	r0, [sp, #7]
   20bc8:	2801      	cmp	r0, #1
   20bca:	d103      	bne.n	20bd4 <clock_stop+0x148>
   20bcc:	f004 fe1d 	bl	2580a <nrfx_busy_wait>
   20bd0:	3d01      	subs	r5, #1
   20bd2:	d1ed      	bne.n	20bb0 <clock_stop+0x124>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
   20bd4:	b002      	add	sp, #8
   20bd6:	bd70      	pop	{r4, r5, r6, pc}
   20bd8:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
   20bdc:	03da      	lsls	r2, r3, #15
   20bde:	d5f9      	bpl.n	20bd4 <clock_stop+0x148>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
   20be0:	2001      	movs	r0, #1
   20be2:	f004 fe12 	bl	2580a <nrfx_busy_wait>
   20be6:	3d01      	subs	r5, #1
   20be8:	d1f6      	bne.n	20bd8 <clock_stop+0x14c>
   20bea:	e7f3      	b.n	20bd4 <clock_stop+0x148>
    switch (domain)
   20bec:	f242 7510 	movw	r5, #10000	; 0x2710
            return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
   20bf0:	4e04      	ldr	r6, [pc, #16]	; (20c04 <clock_stop+0x178>)
   20bf2:	f8d6 3454 	ldr.w	r3, [r6, #1108]	; 0x454
   20bf6:	03db      	lsls	r3, r3, #15
   20bf8:	d5ec      	bpl.n	20bd4 <clock_stop+0x148>
   20bfa:	2c00      	cmp	r4, #0
   20bfc:	d1a1      	bne.n	20b42 <clock_stop+0xb6>
   20bfe:	2001      	movs	r0, #1
   20c00:	e7a3      	b.n	20b4a <clock_stop+0xbe>
   20c02:	bf00      	nop
   20c04:	40005000 	.word	0x40005000

00020c08 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
   20c08:	4b04      	ldr	r3, [pc, #16]	; (20c1c <nrfx_clock_init+0x14>)
   20c0a:	791a      	ldrb	r2, [r3, #4]
   20c0c:	b922      	cbnz	r2, 20c18 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
   20c0e:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
   20c10:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
   20c12:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
   20c14:	4802      	ldr	r0, [pc, #8]	; (20c20 <nrfx_clock_init+0x18>)
   20c16:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
   20c18:	4802      	ldr	r0, [pc, #8]	; (20c24 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   20c1a:	4770      	bx	lr
   20c1c:	2000b2e8 	.word	0x2000b2e8
   20c20:	0bad0000 	.word	0x0bad0000
   20c24:	0bad000c 	.word	0x0bad000c

00020c28 <nrfx_clock_enable>:

void nrfx_clock_enable(void)
{
   20c28:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   20c2a:	2005      	movs	r0, #5
   20c2c:	f7fd fb72 	bl	1e314 <arch_irq_is_enabled>
   20c30:	b910      	cbnz	r0, 20c38 <nrfx_clock_enable+0x10>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   20c32:	2005      	movs	r0, #5
   20c34:	f7fd fb4c 	bl	1e2d0 <arch_irq_enable>
    p_reg->LFCLKSRC = (uint32_t)(source);
   20c38:	2301      	movs	r3, #1
   20c3a:	4a05      	ldr	r2, [pc, #20]	; (20c50 <nrfx_clock_enable+0x28>)
   20c3c:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    p_reg->HFCLKSRC = (uint32_t)(source);
   20c40:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
                                   >> CLOCK_HFCLK192MCTRL_HCLK192M_Pos);
}

NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLK192MSRC = (uint32_t)(source);
   20c44:	f8c2 3580 	str.w	r3, [r2, #1408]	; 0x580
#endif
#if NRF_CLOCK_HAS_HFCLK192M
    nrf_clock_hfclk192m_src_set(NRF_CLOCK, (nrf_clock_hfclk_t)NRFX_CLOCK_CONFIG_HFCLK192M_SRC);
#endif
#if NRFX_CHECK(NRFX_POWER_ENABLED)
    nrfx_clock_irq_enabled = true;
   20c48:	4a02      	ldr	r2, [pc, #8]	; (20c54 <nrfx_clock_enable+0x2c>)
   20c4a:	7013      	strb	r3, [r2, #0]
#endif

    NRFX_LOG_INFO("Module enabled.");
}
   20c4c:	bd08      	pop	{r3, pc}
   20c4e:	bf00      	nop
   20c50:	40005000 	.word	0x40005000
   20c54:	2000b625 	.word	0x2000b625

00020c58 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
   20c58:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
   20c5a:	2803      	cmp	r0, #3
   20c5c:	d818      	bhi.n	20c90 <nrfx_clock_start+0x38>
   20c5e:	e8df f000 	tbb	[pc, r0]
   20c62:	3002      	.short	0x3002
   20c64:	483b      	.short	0x483b
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20c66:	4a29      	ldr	r2, [pc, #164]	; (20d0c <nrfx_clock_start+0xb4>)
   20c68:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20c6c:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
   20c70:	03c9      	lsls	r1, r1, #15
   20c72:	d40e      	bmi.n	20c92 <nrfx_clock_start+0x3a>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
   20c74:	f8d2 3414 	ldr.w	r3, [r2, #1044]	; 0x414
                    // LF clock is already running. Inspect its source.
                    // If LF clock source is inappropriate then it will be stopped and modified.
                    // Ignore return value as LF clock will be started again regardless of the result.
                    (void)clock_lfclksrc_tweak(&lfclksrc);
                }
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
   20c78:	07db      	lsls	r3, r3, #31
   20c7a:	d513      	bpl.n	20ca4 <nrfx_clock_start+0x4c>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
   20c7c:	f8d2 341c 	ldr.w	r3, [r2, #1052]	; 0x41c
   20c80:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   20c84:	3b01      	subs	r3, #1
   20c86:	2b01      	cmp	r3, #1
   20c88:	d809      	bhi.n	20c9e <nrfx_clock_start+0x46>
    p_reg->INTENSET = mask;
   20c8a:	2302      	movs	r3, #2
   20c8c:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
   20c90:	bd08      	pop	{r3, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20c92:	f003 0303 	and.w	r3, r3, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
   20c96:	2b02      	cmp	r3, #2
   20c98:	d005      	beq.n	20ca6 <nrfx_clock_start+0x4e>
   20c9a:	2b01      	cmp	r3, #1
   20c9c:	d002      	beq.n	20ca4 <nrfx_clock_start+0x4c>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   20c9e:	2000      	movs	r0, #0
   20ca0:	f7ff fef4 	bl	20a8c <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
   20ca4:	2301      	movs	r3, #1
    p_reg->LFCLKSRC = (uint32_t)(source);
   20ca6:	4a19      	ldr	r2, [pc, #100]	; (20d0c <nrfx_clock_start+0xb4>)
   20ca8:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20cac:	2300      	movs	r3, #0
   20cae:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
   20cb2:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    p_reg->INTENSET = mask;
   20cb6:	2302      	movs	r3, #2
   20cb8:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20cbc:	2301      	movs	r3, #1
   20cbe:	6093      	str	r3, [r2, #8]
}
   20cc0:	e7e6      	b.n	20c90 <nrfx_clock_start+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20cc2:	2200      	movs	r2, #0
   20cc4:	4b11      	ldr	r3, [pc, #68]	; (20d0c <nrfx_clock_start+0xb4>)
   20cc6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   20cca:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
   20cce:	2201      	movs	r2, #1
   20cd0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20cd4:	601a      	str	r2, [r3, #0]
}
   20cd6:	e7db      	b.n	20c90 <nrfx_clock_start+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20cd8:	2200      	movs	r2, #0
   20cda:	4b0c      	ldr	r3, [pc, #48]	; (20d0c <nrfx_clock_start+0xb4>)
   20cdc:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   20ce0:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENSET = mask;
   20ce4:	f44f 7200 	mov.w	r2, #512	; 0x200
   20ce8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20cec:	2201      	movs	r2, #1
   20cee:	621a      	str	r2, [r3, #32]
}
   20cf0:	e7ce      	b.n	20c90 <nrfx_clock_start+0x38>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20cf2:	2200      	movs	r2, #0
   20cf4:	4b05      	ldr	r3, [pc, #20]	; (20d0c <nrfx_clock_start+0xb4>)
   20cf6:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   20cfa:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENSET = mask;
   20cfe:	f44f 7280 	mov.w	r2, #256	; 0x100
   20d02:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20d06:	2201      	movs	r2, #1
   20d08:	619a      	str	r2, [r3, #24]
}
   20d0a:	e7c1      	b.n	20c90 <nrfx_clock_start+0x38>
   20d0c:	40005000 	.word	0x40005000

00020d10 <nrfx_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
   20d10:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d12:	4b28      	ldr	r3, [pc, #160]	; (20db4 <nrfx_clock_irq_handler+0xa4>)
   20d14:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
   20d18:	b152      	cbz	r2, 20d30 <nrfx_clock_irq_handler+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d1a:	2000      	movs	r0, #0
   20d1c:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
   20d20:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
   20d24:	2201      	movs	r2, #1
   20d26:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
   20d2a:	4b23      	ldr	r3, [pc, #140]	; (20db8 <nrfx_clock_irq_handler+0xa8>)
   20d2c:	681b      	ldr	r3, [r3, #0]
   20d2e:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d30:	4b20      	ldr	r3, [pc, #128]	; (20db4 <nrfx_clock_irq_handler+0xa4>)
   20d32:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
   20d36:	b18a      	cbz	r2, 20d5c <nrfx_clock_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d38:	2200      	movs	r2, #0
   20d3a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
   20d3e:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
   20d42:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
   20d46:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
   20d4a:	f002 0203 	and.w	r2, r2, #3
   20d4e:	2a01      	cmp	r2, #1
   20d50:	f04f 0102 	mov.w	r1, #2
   20d54:	d126      	bne.n	20da4 <nrfx_clock_irq_handler+0x94>
    p_reg->LFCLKSRC = (uint32_t)(source);
   20d56:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   20d5a:	609a      	str	r2, [r3, #8]
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d5c:	4b15      	ldr	r3, [pc, #84]	; (20db4 <nrfx_clock_irq_handler+0xa4>)
   20d5e:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_CAL_DONE);
    }
#endif // NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)

#if NRF_CLOCK_HAS_HFCLKAUDIO
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED))
   20d62:	b162      	cbz	r2, 20d7e <nrfx_clock_irq_handler+0x6e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d64:	2200      	movs	r2, #0
   20d66:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
   20d6a:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
    p_reg->INTENCLR = mask;
   20d6e:	f44f 7280 	mov.w	r2, #256	; 0x100
   20d72:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLKAUDIO_STARTED);
   20d76:	4b10      	ldr	r3, [pc, #64]	; (20db8 <nrfx_clock_irq_handler+0xa8>)
   20d78:	2004      	movs	r0, #4
   20d7a:	681b      	ldr	r3, [r3, #0]
   20d7c:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   20d7e:	4b0d      	ldr	r3, [pc, #52]	; (20db4 <nrfx_clock_irq_handler+0xa4>)
   20d80:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    }
#endif

#if NRF_CLOCK_HAS_HFCLK192M
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED))
   20d84:	b1aa      	cbz	r2, 20db2 <nrfx_clock_irq_handler+0xa2>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   20d86:	2200      	movs	r2, #0
   20d88:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   20d8c:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
    p_reg->INTENCLR = mask;
   20d90:	f44f 7200 	mov.w	r2, #512	; 0x200
   20d94:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLK192MSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
   20d98:	4b07      	ldr	r3, [pc, #28]	; (20db8 <nrfx_clock_irq_handler+0xa8>)
   20d9a:	2005      	movs	r0, #5
    }
#endif
}
   20d9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
   20da0:	681b      	ldr	r3, [r3, #0]
   20da2:	4718      	bx	r3
   20da4:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
   20da8:	4b03      	ldr	r3, [pc, #12]	; (20db8 <nrfx_clock_irq_handler+0xa8>)
   20daa:	2001      	movs	r0, #1
   20dac:	681b      	ldr	r3, [r3, #0]
   20dae:	4798      	blx	r3
   20db0:	e7d4      	b.n	20d5c <nrfx_clock_irq_handler+0x4c>
}
   20db2:	bd10      	pop	{r4, pc}
   20db4:	40005000 	.word	0x40005000
   20db8:	2000b2e8 	.word	0x2000b2e8

00020dbc <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
   20dbc:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
   20dbe:	f003 021f 	and.w	r2, r3, #31
   20dc2:	6002      	str	r2, [r0, #0]
}
   20dc4:	4a03      	ldr	r2, [pc, #12]	; (20dd4 <nrf_gpio_pin_port_decode+0x18>)
   20dc6:	4804      	ldr	r0, [pc, #16]	; (20dd8 <nrf_gpio_pin_port_decode+0x1c>)
    return pin_number >> 5;
   20dc8:	095b      	lsrs	r3, r3, #5
}
   20dca:	2b01      	cmp	r3, #1
   20dcc:	bf18      	it	ne
   20dce:	4610      	movne	r0, r2
   20dd0:	4770      	bx	lr
   20dd2:	bf00      	nop
   20dd4:	40842500 	.word	0x40842500
   20dd8:	40842800 	.word	0x40842800

00020ddc <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
   20ddc:	4b03      	ldr	r3, [pc, #12]	; (20dec <pin_in_use_by_te+0x10>)
   20dde:	3008      	adds	r0, #8
   20de0:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
   20de4:	f3c0 1040 	ubfx	r0, r0, #5, #1
   20de8:	4770      	bx	lr
   20dea:	bf00      	nop
   20dec:	2000a208 	.word	0x2000a208

00020df0 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
   20df0:	b570      	push	{r4, r5, r6, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20df2:	4c0d      	ldr	r4, [pc, #52]	; (20e28 <call_handler+0x38>)
   20df4:	f100 0308 	add.w	r3, r0, #8
   20df8:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
{
   20dfc:	4605      	mov	r5, r0
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20dfe:	05da      	lsls	r2, r3, #23
{
   20e00:	460e      	mov	r6, r1
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e02:	d507      	bpl.n	20e14 <call_handler+0x24>
   20e04:	f3c3 2343 	ubfx	r3, r3, #9, #4
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);

    if (handler)
    {
        handler->handler(pin, trigger, handler->p_context);
   20e08:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
   20e0c:	6852      	ldr	r2, [r2, #4]
   20e0e:	f854 3033 	ldr.w	r3, [r4, r3, lsl #3]
   20e12:	4798      	blx	r3
    }
    if (m_cb.global_handler.handler)
   20e14:	68a3      	ldr	r3, [r4, #8]
   20e16:	b12b      	cbz	r3, 20e24 <call_handler+0x34>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   20e18:	4631      	mov	r1, r6
   20e1a:	4628      	mov	r0, r5
   20e1c:	68e2      	ldr	r2, [r4, #12]
    }
}
   20e1e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
   20e22:	4718      	bx	r3
}
   20e24:	bd70      	pop	{r4, r5, r6, pc}
   20e26:	bf00      	nop
   20e28:	2000a208 	.word	0x2000a208

00020e2c <release_handler>:
{
   20e2c:	b410      	push	{r4}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
   20e2e:	4a12      	ldr	r2, [pc, #72]	; (20e78 <release_handler+0x4c>)
   20e30:	3008      	adds	r0, #8
   20e32:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
   20e36:	05d9      	lsls	r1, r3, #23
   20e38:	d51b      	bpl.n	20e72 <release_handler+0x46>
   20e3a:	f3c3 2143 	ubfx	r1, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
   20e3e:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   20e42:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   20e46:	2000      	movs	r0, #0
   20e48:	f102 040e 	add.w	r4, r2, #14
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
   20e4c:	f834 3f02 	ldrh.w	r3, [r4, #2]!
   20e50:	f413 7f80 	tst.w	r3, #256	; 0x100
   20e54:	d003      	beq.n	20e5e <release_handler+0x32>
   20e56:	f3c3 2343 	ubfx	r3, r3, #9, #4
   20e5a:	4299      	cmp	r1, r3
   20e5c:	d009      	beq.n	20e72 <release_handler+0x46>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
   20e5e:	3001      	adds	r0, #1
   20e60:	2830      	cmp	r0, #48	; 0x30
   20e62:	d1f3      	bne.n	20e4c <release_handler+0x20>
        m_cb.handlers[handler_id].handler = NULL;
   20e64:	2300      	movs	r3, #0
   20e66:	f842 3031 	str.w	r3, [r2, r1, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   20e6a:	4804      	ldr	r0, [pc, #16]	; (20e7c <release_handler+0x50>)
}
   20e6c:	bc10      	pop	{r4}
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
   20e6e:	f7ff bdf1 	b.w	20a54 <nrfx_flag32_free>
}
   20e72:	bc10      	pop	{r4}
   20e74:	4770      	bx	lr
   20e76:	bf00      	nop
   20e78:	2000a208 	.word	0x2000a208
   20e7c:	2000a27c 	.word	0x2000a27c

00020e80 <pin_handler_trigger_uninit>:
{
   20e80:	b538      	push	{r3, r4, r5, lr}
   20e82:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   20e84:	f7ff ffaa 	bl	20ddc <pin_in_use_by_te>
   20e88:	4c0b      	ldr	r4, [pc, #44]	; (20eb8 <pin_handler_trigger_uninit+0x38>)
   20e8a:	f102 0508 	add.w	r5, r2, #8
   20e8e:	b160      	cbz	r0, 20eaa <pin_handler_trigger_uninit+0x2a>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
   20e90:	2100      	movs	r1, #0
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   20e92:	f834 3015 	ldrh.w	r3, [r4, r5, lsl #1]
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
   20e96:	0b5b      	lsrs	r3, r3, #13
   20e98:	009b      	lsls	r3, r3, #2
   20e9a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   20e9e:	f503 333c 	add.w	r3, r3, #192512	; 0x2f000
   20ea2:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
#if defined(NRF53_SERIES) || defined(NRF91_SERIES)
    p_reg->CONFIG[idx] = 0;
   20ea6:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
    release_handler(pin);
   20eaa:	4610      	mov	r0, r2
   20eac:	f7ff ffbe 	bl	20e2c <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
   20eb0:	2300      	movs	r3, #0
   20eb2:	f824 3015 	strh.w	r3, [r4, r5, lsl #1]
}
   20eb6:	bd38      	pop	{r3, r4, r5, pc}
   20eb8:	2000a208 	.word	0x2000a208

00020ebc <nrfx_gpiote_input_configure>:
{
   20ebc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   20ec0:	4604      	mov	r4, r0
   20ec2:	4690      	mov	r8, r2
   20ec4:	461d      	mov	r5, r3
    if (p_input_config)
   20ec6:	b301      	cbz	r1, 20f0a <nrfx_gpiote_input_configure+0x4e>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   20ec8:	4e4f      	ldr	r6, [pc, #316]	; (21008 <nrfx_gpiote_input_configure+0x14c>)
   20eca:	f100 0708 	add.w	r7, r0, #8
    return pin_is_output(pin) && pin_in_use_by_te(pin);
   20ece:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   20ed2:	079b      	lsls	r3, r3, #30
   20ed4:	d502      	bpl.n	20edc <nrfx_gpiote_input_configure+0x20>
   20ed6:	f7ff ff81 	bl	20ddc <pin_in_use_by_te>
   20eda:	bb28      	cbnz	r0, 20f28 <nrfx_gpiote_input_configure+0x6c>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
   20edc:	2300      	movs	r3, #0
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
   20ede:	4620      	mov	r0, r4
   20ee0:	e9cd 3300 	strd	r3, r3, [sp]
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_INPUT;
   20ee4:	f88d 300e 	strb.w	r3, [sp, #14]
        nrf_gpio_pin_input_t input_connect = NRF_GPIO_PIN_INPUT_CONNECT;
   20ee8:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &input_connect, &p_input_config->pull, NULL, NULL);
   20eec:	f10d 020f 	add.w	r2, sp, #15
   20ef0:	460b      	mov	r3, r1
   20ef2:	f10d 010e 	add.w	r1, sp, #14
   20ef6:	f004 fc8c 	bl	25812 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
   20efa:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   20efe:	f023 0302 	bic.w	r3, r3, #2
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
   20f02:	f043 0301 	orr.w	r3, r3, #1
   20f06:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_trigger_config)
   20f0a:	f1b8 0f00 	cmp.w	r8, #0
   20f0e:	d02d      	beq.n	20f6c <nrfx_gpiote_input_configure+0xb0>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   20f10:	4e3d      	ldr	r6, [pc, #244]	; (21008 <nrfx_gpiote_input_configure+0x14c>)
   20f12:	f104 0708 	add.w	r7, r4, #8
   20f16:	f836 1017 	ldrh.w	r1, [r6, r7, lsl #1]
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
   20f1a:	f898 0000 	ldrb.w	r0, [r8]
        if (pin_is_output(pin))
   20f1e:	078a      	lsls	r2, r1, #30
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
   20f20:	f8d8 3004 	ldr.w	r3, [r8, #4]
        if (pin_is_output(pin))
   20f24:	d502      	bpl.n	20f2c <nrfx_gpiote_input_configure+0x70>
            if (use_evt)
   20f26:	b1cb      	cbz	r3, 20f5c <nrfx_gpiote_input_configure+0xa0>
            return NRFX_ERROR_INVALID_PARAM;
   20f28:	4838      	ldr	r0, [pc, #224]	; (2100c <nrfx_gpiote_input_configure+0x150>)
   20f2a:	e021      	b.n	20f70 <nrfx_gpiote_input_configure+0xb4>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
   20f2c:	f021 0120 	bic.w	r1, r1, #32
   20f30:	04c9      	lsls	r1, r1, #19
   20f32:	0cc9      	lsrs	r1, r1, #19
   20f34:	f826 1017 	strh.w	r1, [r6, r7, lsl #1]
            if (use_evt)
   20f38:	b183      	cbz	r3, 20f5c <nrfx_gpiote_input_configure+0xa0>
                if (!edge)
   20f3a:	2803      	cmp	r0, #3
   20f3c:	d8f4      	bhi.n	20f28 <nrfx_gpiote_input_configure+0x6c>
                uint8_t ch = *p_trigger_config->p_in_channel;
   20f3e:	f8d8 3004 	ldr.w	r3, [r8, #4]
   20f42:	f893 c000 	ldrb.w	ip, [r3]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
   20f46:	4662      	mov	r2, ip
   20f48:	0092      	lsls	r2, r2, #2
   20f4a:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   20f4e:	f502 323c 	add.w	r2, r2, #192512	; 0x2f000
   20f52:	b980      	cbnz	r0, 20f76 <nrfx_gpiote_input_configure+0xba>
    p_reg->CONFIG[idx] = 0;
   20f54:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
    p_reg->CONFIG[idx] = 0;
   20f58:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
   20f5c:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   20f60:	f023 031c 	bic.w	r3, r3, #28
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
   20f64:	ea43 0380 	orr.w	r3, r3, r0, lsl #2
   20f68:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_handler_config)
   20f6c:	bb1d      	cbnz	r5, 20fb6 <nrfx_gpiote_input_configure+0xfa>
        err = NRFX_SUCCESS;
   20f6e:	4828      	ldr	r0, [pc, #160]	; (21010 <nrfx_gpiote_input_configure+0x154>)
}
   20f70:	b004      	add	sp, #16
   20f72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   20f76:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   20f7a:	ea41 314c 	orr.w	r1, r1, ip, lsl #13
   20f7e:	f023 0303 	bic.w	r3, r3, #3
   20f82:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   20f86:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
   20f8a:	f041 0120 	orr.w	r1, r1, #32
   20f8e:	f423 334f 	bic.w	r3, r3, #211968	; 0x33c00
   20f92:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   20f96:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   20f9a:	0223      	lsls	r3, r4, #8
   20f9c:	f8d2 e510 	ldr.w	lr, [r2, #1296]	; 0x510
   20fa0:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
   20fa4:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
   20fa8:	ea43 030e 	orr.w	r3, r3, lr
   20fac:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
   20fb0:	f826 1017 	strh.w	r1, [r6, r7, lsl #1]
   20fb4:	e7d2      	b.n	20f5c <nrfx_gpiote_input_configure+0xa0>
    release_handler(pin);
   20fb6:	4620      	mov	r0, r4
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
   20fb8:	e9d5 6700 	ldrd	r6, r7, [r5]
    release_handler(pin);
   20fbc:	f7ff ff36 	bl	20e2c <release_handler>
    if (!handler)
   20fc0:	2e00      	cmp	r6, #0
   20fc2:	d0d4      	beq.n	20f6e <nrfx_gpiote_input_configure+0xb2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   20fc4:	4d10      	ldr	r5, [pc, #64]	; (21008 <nrfx_gpiote_input_configure+0x14c>)
   20fc6:	e9d5 2300 	ldrd	r2, r3, [r5]
   20fca:	4296      	cmp	r6, r2
   20fcc:	d101      	bne.n	20fd2 <nrfx_gpiote_input_configure+0x116>
   20fce:	429f      	cmp	r7, r3
   20fd0:	d018      	beq.n	21004 <nrfx_gpiote_input_configure+0x148>
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
   20fd2:	4810      	ldr	r0, [pc, #64]	; (21014 <nrfx_gpiote_input_configure+0x158>)
   20fd4:	f10d 010f 	add.w	r1, sp, #15
   20fd8:	f7ff fd20 	bl	20a1c <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
   20fdc:	4b0c      	ldr	r3, [pc, #48]	; (21010 <nrfx_gpiote_input_configure+0x154>)
   20fde:	4298      	cmp	r0, r3
   20fe0:	d1c6      	bne.n	20f70 <nrfx_gpiote_input_configure+0xb4>
        handler_id = (int32_t)id;
   20fe2:	f89d 200f 	ldrb.w	r2, [sp, #15]
    m_cb.handlers[handler_id].p_context = p_context;
   20fe6:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   20fea:	3408      	adds	r4, #8
    m_cb.handlers[handler_id].p_context = p_context;
   20fec:	605f      	str	r7, [r3, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   20fee:	f835 3014 	ldrh.w	r3, [r5, r4, lsl #1]
    m_cb.handlers[handler_id].handler = handler;
   20ff2:	f845 6032 	str.w	r6, [r5, r2, lsl #3]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
   20ff6:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
   20ffa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   20ffe:	f825 3014 	strh.w	r3, [r5, r4, lsl #1]
    return NRFX_SUCCESS;
   21002:	e7b4      	b.n	20f6e <nrfx_gpiote_input_configure+0xb2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
   21004:	2200      	movs	r2, #0
   21006:	e7ee      	b.n	20fe6 <nrfx_gpiote_input_configure+0x12a>
   21008:	2000a208 	.word	0x2000a208
   2100c:	0bad0004 	.word	0x0bad0004
   21010:	0bad0000 	.word	0x0bad0000
   21014:	2000a27c 	.word	0x2000a27c

00021018 <nrfx_gpiote_output_configure>:
{
   21018:	b5f0      	push	{r4, r5, r6, r7, lr}
   2101a:	4604      	mov	r4, r0
   2101c:	4615      	mov	r5, r2
   2101e:	b085      	sub	sp, #20
    if (p_config)
   21020:	b319      	cbz	r1, 2106a <nrfx_gpiote_output_configure+0x52>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   21022:	4e34      	ldr	r6, [pc, #208]	; (210f4 <nrfx_gpiote_output_configure+0xdc>)
   21024:	f100 0708 	add.w	r7, r0, #8
   21028:	f836 2017 	ldrh.w	r2, [r6, r7, lsl #1]
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
   2102c:	0793      	lsls	r3, r2, #30
   2102e:	d403      	bmi.n	21038 <nrfx_gpiote_output_configure+0x20>
   21030:	f7ff fed4 	bl	20ddc <pin_in_use_by_te>
   21034:	2800      	cmp	r0, #0
   21036:	d15a      	bne.n	210ee <nrfx_gpiote_output_configure+0xd6>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
   21038:	f012 0f1c 	tst.w	r2, #28
   2103c:	d002      	beq.n	21044 <nrfx_gpiote_output_configure+0x2c>
   2103e:	784b      	ldrb	r3, [r1, #1]
   21040:	2b01      	cmp	r3, #1
   21042:	d054      	beq.n	210ee <nrfx_gpiote_output_configure+0xd6>
        nrf_gpio_pin_dir_t dir = NRF_GPIO_PIN_DIR_OUTPUT;
   21044:	2301      	movs	r3, #1
   21046:	f88d 300f 	strb.w	r3, [sp, #15]
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
   2104a:	2300      	movs	r3, #0
   2104c:	1c4a      	adds	r2, r1, #1
   2104e:	e9cd 1300 	strd	r1, r3, [sp]
   21052:	4620      	mov	r0, r4
   21054:	1c8b      	adds	r3, r1, #2
   21056:	f10d 010f 	add.w	r1, sp, #15
   2105a:	f004 fbda 	bl	25812 <nrf_gpio_reconfigure>
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
   2105e:	f836 3017 	ldrh.w	r3, [r6, r7, lsl #1]
   21062:	f043 0303 	orr.w	r3, r3, #3
   21066:	f826 3017 	strh.w	r3, [r6, r7, lsl #1]
    if (p_task_config)
   2106a:	b915      	cbnz	r5, 21072 <nrfx_gpiote_output_configure+0x5a>
    return NRFX_SUCCESS;
   2106c:	4822      	ldr	r0, [pc, #136]	; (210f8 <nrfx_gpiote_output_configure+0xe0>)
}
   2106e:	b005      	add	sp, #20
   21070:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   21072:	4e20      	ldr	r6, [pc, #128]	; (210f4 <nrfx_gpiote_output_configure+0xdc>)
   21074:	f104 0708 	add.w	r7, r4, #8
   21078:	f836 0017 	ldrh.w	r0, [r6, r7, lsl #1]
        if (pin_is_input(pin))
   2107c:	0783      	lsls	r3, r0, #30
   2107e:	d536      	bpl.n	210ee <nrfx_gpiote_output_configure+0xd6>
        uint32_t ch = p_task_config->task_ch;
   21080:	f895 c000 	ldrb.w	ip, [r5]
    p_reg->CONFIG[idx] = 0;
   21084:	2300      	movs	r3, #0
   21086:	4661      	mov	r1, ip
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
   21088:	f020 0020 	bic.w	r0, r0, #32
   2108c:	0089      	lsls	r1, r1, #2
   2108e:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
   21092:	04c0      	lsls	r0, r0, #19
   21094:	f501 313c 	add.w	r1, r1, #192512	; 0x2f000
   21098:	0cc0      	lsrs	r0, r0, #19
   2109a:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   2109e:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
    p_reg->CONFIG[idx] = 0;
   210a2:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
   210a6:	786a      	ldrb	r2, [r5, #1]
   210a8:	2a00      	cmp	r2, #0
   210aa:	d0df      	beq.n	2106c <nrfx_gpiote_output_configure+0x54>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
   210ac:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
                                      p_task_config->init_val);
   210b0:	78ad      	ldrb	r5, [r5, #2]
   210b2:	f423 1399 	bic.w	r3, r3, #1253376	; 0x132000
   210b6:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
   210ba:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   210be:	f8d1 e510 	ldr.w	lr, [r1, #1296]	; 0x510
   210c2:	0223      	lsls	r3, r4, #8
   210c4:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
   210c8:	0412      	lsls	r2, r2, #16
   210ca:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   210ce:	ea43 030e 	orr.w	r3, r3, lr
   210d2:	4313      	orrs	r3, r2
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
   210d4:	052a      	lsls	r2, r5, #20
   210d6:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
   210da:	ea40 304c 	orr.w	r0, r0, ip, lsl #13
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   210de:	4313      	orrs	r3, r2
   210e0:	f040 0020 	orr.w	r0, r0, #32
   210e4:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
   210e8:	f826 0017 	strh.w	r0, [r6, r7, lsl #1]
   210ec:	e7be      	b.n	2106c <nrfx_gpiote_output_configure+0x54>
{
   210ee:	4803      	ldr	r0, [pc, #12]	; (210fc <nrfx_gpiote_output_configure+0xe4>)
   210f0:	e7bd      	b.n	2106e <nrfx_gpiote_output_configure+0x56>
   210f2:	bf00      	nop
   210f4:	2000a208 	.word	0x2000a208
   210f8:	0bad0000 	.word	0x0bad0000
   210fc:	0bad0004 	.word	0x0bad0004

00021100 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
   21100:	4b01      	ldr	r3, [pc, #4]	; (21108 <nrfx_gpiote_global_callback_set+0x8>)
    m_cb.global_handler.p_context = p_context;
   21102:	e9c3 0102 	strd	r0, r1, [r3, #8]
}
   21106:	4770      	bx	lr
   21108:	2000a208 	.word	0x2000a208

0002110c <nrfx_gpiote_channel_get>:
{
   2110c:	b508      	push	{r3, lr}
   2110e:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin))
   21110:	f7ff fe64 	bl	20ddc <pin_in_use_by_te>
   21114:	b138      	cbz	r0, 21126 <nrfx_gpiote_channel_get+0x1a>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   21116:	4b05      	ldr	r3, [pc, #20]	; (2112c <nrfx_gpiote_channel_get+0x20>)
   21118:	3208      	adds	r2, #8
   2111a:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
        return NRFX_SUCCESS;
   2111e:	4804      	ldr	r0, [pc, #16]	; (21130 <nrfx_gpiote_channel_get+0x24>)
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   21120:	0b5b      	lsrs	r3, r3, #13
   21122:	700b      	strb	r3, [r1, #0]
}
   21124:	bd08      	pop	{r3, pc}
        return NRFX_ERROR_INVALID_PARAM;
   21126:	4803      	ldr	r0, [pc, #12]	; (21134 <nrfx_gpiote_channel_get+0x28>)
   21128:	e7fc      	b.n	21124 <nrfx_gpiote_channel_get+0x18>
   2112a:	bf00      	nop
   2112c:	2000a208 	.word	0x2000a208
   21130:	0bad0000 	.word	0x0bad0000
   21134:	0bad0004 	.word	0x0bad0004

00021138 <nrfx_gpiote_init>:
{
   21138:	b538      	push	{r3, r4, r5, lr}
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
   2113a:	4c0f      	ldr	r4, [pc, #60]	; (21178 <nrfx_gpiote_init+0x40>)
   2113c:	f894 5078 	ldrb.w	r5, [r4, #120]	; 0x78
   21140:	b9bd      	cbnz	r5, 21172 <nrfx_gpiote_init+0x3a>
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
   21142:	2260      	movs	r2, #96	; 0x60
   21144:	4629      	mov	r1, r5
   21146:	f104 0010 	add.w	r0, r4, #16
   2114a:	f003 ff4d 	bl	24fe8 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
   2114e:	202f      	movs	r0, #47	; 0x2f
   21150:	f7fd f8be 	bl	1e2d0 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   21154:	4b09      	ldr	r3, [pc, #36]	; (2117c <nrfx_gpiote_init+0x44>)
    return err_code;
   21156:	480a      	ldr	r0, [pc, #40]	; (21180 <nrfx_gpiote_init+0x48>)
   21158:	f8c3 517c 	str.w	r5, [r3, #380]	; 0x17c
   2115c:	f8d3 217c 	ldr.w	r2, [r3, #380]	; 0x17c
    p_reg->INTENSET = mask;
   21160:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   21164:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
   21168:	2301      	movs	r3, #1
   2116a:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
   2116e:	6763      	str	r3, [r4, #116]	; 0x74
}
   21170:	bd38      	pop	{r3, r4, r5, pc}
        return err_code;
   21172:	4804      	ldr	r0, [pc, #16]	; (21184 <nrfx_gpiote_init+0x4c>)
   21174:	e7fc      	b.n	21170 <nrfx_gpiote_init+0x38>
   21176:	bf00      	nop
   21178:	2000a208 	.word	0x2000a208
   2117c:	4002f000 	.word	0x4002f000
   21180:	0bad0000 	.word	0x0bad0000
   21184:	0bad0005 	.word	0x0bad0005

00021188 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
   21188:	4b03      	ldr	r3, [pc, #12]	; (21198 <nrfx_gpiote_is_init+0x10>)
   2118a:	f893 0078 	ldrb.w	r0, [r3, #120]	; 0x78
}
   2118e:	3800      	subs	r0, #0
   21190:	bf18      	it	ne
   21192:	2001      	movne	r0, #1
   21194:	4770      	bx	lr
   21196:	bf00      	nop
   21198:	2000a208 	.word	0x2000a208

0002119c <nrfx_gpiote_channel_free>:
{
   2119c:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
   2119e:	4801      	ldr	r0, [pc, #4]	; (211a4 <nrfx_gpiote_channel_free+0x8>)
   211a0:	f7ff bc58 	b.w	20a54 <nrfx_flag32_free>
   211a4:	2000a278 	.word	0x2000a278

000211a8 <nrfx_gpiote_channel_alloc>:
{
   211a8:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
   211aa:	4801      	ldr	r0, [pc, #4]	; (211b0 <nrfx_gpiote_channel_alloc+0x8>)
   211ac:	f7ff bc36 	b.w	20a1c <nrfx_flag32_alloc>
   211b0:	2000a278 	.word	0x2000a278

000211b4 <nrfx_gpiote_trigger_enable>:
{
   211b4:	b537      	push	{r0, r1, r2, r4, r5, lr}
   211b6:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   211b8:	f7ff fe10 	bl	20ddc <pin_in_use_by_te>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   211bc:	4b1d      	ldr	r3, [pc, #116]	; (21234 <nrfx_gpiote_trigger_enable+0x80>)
   211be:	f104 0208 	add.w	r2, r4, #8
   211c2:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   211c6:	b1d0      	cbz	r0, 211fe <nrfx_gpiote_trigger_enable+0x4a>
   211c8:	f013 0502 	ands.w	r5, r3, #2
   211cc:	d117      	bne.n	211fe <nrfx_gpiote_trigger_enable+0x4a>
    return ((uint32_t)p_reg + event);
   211ce:	481a      	ldr	r0, [pc, #104]	; (21238 <nrfx_gpiote_trigger_enable+0x84>)
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   211d0:	0b5b      	lsrs	r3, r3, #13
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
   211d2:	009a      	lsls	r2, r3, #2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   211d4:	5085      	str	r5, [r0, r2]
   211d6:	5880      	ldr	r0, [r0, r2]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   211d8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   211dc:	f502 323c 	add.w	r2, r2, #192512	; 0x2f000
   211e0:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
   211e4:	f040 0001 	orr.w	r0, r0, #1
   211e8:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
        if (int_enable)
   211ec:	b129      	cbz	r1, 211fa <nrfx_gpiote_trigger_enable+0x46>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
   211ee:	2201      	movs	r2, #1
   211f0:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENSET = mask;
   211f4:	4a11      	ldr	r2, [pc, #68]	; (2123c <nrfx_gpiote_trigger_enable+0x88>)
   211f6:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
   211fa:	b003      	add	sp, #12
   211fc:	bd30      	pop	{r4, r5, pc}
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   211fe:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
   21202:	2b04      	cmp	r3, #4
   21204:	d011      	beq.n	2122a <nrfx_gpiote_trigger_enable+0x76>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
   21206:	2b05      	cmp	r3, #5
   21208:	d011      	beq.n	2122e <nrfx_gpiote_trigger_enable+0x7a>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2120a:	a801      	add	r0, sp, #4
   2120c:	9401      	str	r4, [sp, #4]
   2120e:	f7ff fdd5 	bl	20dbc <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   21212:	9b01      	ldr	r3, [sp, #4]
    return p_reg->IN;
   21214:	6901      	ldr	r1, [r0, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   21216:	40d9      	lsrs	r1, r3
   21218:	f001 0101 	and.w	r1, r1, #1
   2121c:	3102      	adds	r1, #2
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   2121e:	4620      	mov	r0, r4
}
   21220:	b003      	add	sp, #12
   21222:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        nrf_gpio_cfg_sense_set(pin, get_initial_sense(pin));
   21226:	f004 bb3d 	b.w	258a4 <nrf_gpio_cfg_sense_set>
        sense = NRF_GPIO_PIN_SENSE_LOW;
   2122a:	2103      	movs	r1, #3
   2122c:	e7f7      	b.n	2121e <nrfx_gpiote_trigger_enable+0x6a>
        sense = NRF_GPIO_PIN_SENSE_HIGH;
   2122e:	2102      	movs	r1, #2
   21230:	e7f5      	b.n	2121e <nrfx_gpiote_trigger_enable+0x6a>
   21232:	bf00      	nop
   21234:	2000a208 	.word	0x2000a208
   21238:	4002f100 	.word	0x4002f100
   2123c:	4002f000 	.word	0x4002f000

00021240 <nrfx_gpiote_trigger_disable>:
{
   21240:	b508      	push	{r3, lr}
   21242:	4602      	mov	r2, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   21244:	f7ff fdca 	bl	20ddc <pin_in_use_by_te>
   21248:	b1c0      	cbz	r0, 2127c <nrfx_gpiote_trigger_disable+0x3c>
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
   2124a:	4b0f      	ldr	r3, [pc, #60]	; (21288 <nrfx_gpiote_trigger_disable+0x48>)
   2124c:	f102 0108 	add.w	r1, r2, #8
   21250:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
   21254:	0799      	lsls	r1, r3, #30
   21256:	d411      	bmi.n	2127c <nrfx_gpiote_trigger_disable+0x3c>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   21258:	2201      	movs	r2, #1
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
   2125a:	0b5b      	lsrs	r3, r3, #13
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
   2125c:	409a      	lsls	r2, r3
    p_reg->INTENCLR = mask;
   2125e:	490b      	ldr	r1, [pc, #44]	; (2128c <nrfx_gpiote_trigger_disable+0x4c>)
   21260:	009b      	lsls	r3, r3, #2
   21262:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   21266:	f8c1 2308 	str.w	r2, [r1, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
   2126a:	f503 333c 	add.w	r3, r3, #192512	; 0x2f000
   2126e:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   21272:	f022 0203 	bic.w	r2, r2, #3
   21276:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
}
   2127a:	bd08      	pop	{r3, pc}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   2127c:	2100      	movs	r1, #0
}
   2127e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   21282:	4610      	mov	r0, r2
   21284:	f004 bb0e 	b.w	258a4 <nrf_gpio_cfg_sense_set>
   21288:	2000a208 	.word	0x2000a208
   2128c:	4002f000 	.word	0x4002f000

00021290 <nrfx_gpiote_pin_uninit>:
{
   21290:	b513      	push	{r0, r1, r4, lr}
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
   21292:	4b10      	ldr	r3, [pc, #64]	; (212d4 <nrfx_gpiote_pin_uninit+0x44>)
   21294:	f100 0208 	add.w	r2, r0, #8
   21298:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
{
   2129c:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
   2129e:	07db      	lsls	r3, r3, #31
   212a0:	d516      	bpl.n	212d0 <nrfx_gpiote_pin_uninit+0x40>
    nrfx_gpiote_trigger_disable(pin);
   212a2:	f7ff ffcd 	bl	21240 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
   212a6:	4620      	mov	r0, r4
   212a8:	f7ff fdea 	bl	20e80 <pin_handler_trigger_uninit>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   212ac:	a801      	add	r0, sp, #4
   212ae:	9401      	str	r4, [sp, #4]
   212b0:	f7ff fd84 	bl	20dbc <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   212b4:	9b01      	ldr	r3, [sp, #4]
   212b6:	eb00 0083 	add.w	r0, r0, r3, lsl #2
   212ba:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   212be:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   212c2:	f043 0302 	orr.w	r3, r3, #2
    reg->PIN_CNF[pin_number] = cnf;
   212c6:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    nrf_gpio_cfg(
   212ca:	4803      	ldr	r0, [pc, #12]	; (212d8 <nrfx_gpiote_pin_uninit+0x48>)
}
   212cc:	b002      	add	sp, #8
   212ce:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_INVALID_PARAM;
   212d0:	4802      	ldr	r0, [pc, #8]	; (212dc <nrfx_gpiote_pin_uninit+0x4c>)
   212d2:	e7fb      	b.n	212cc <nrfx_gpiote_pin_uninit+0x3c>
   212d4:	2000a208 	.word	0x2000a208
   212d8:	0bad0000 	.word	0x0bad0000
   212dc:	0bad0004 	.word	0x0bad0004

000212e0 <nrfx_gpiote_irq_handler>:
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    }
}

void nrfx_gpiote_irq_handler(void)
{
   212e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t status = 0;
   212e4:	2600      	movs	r6, #0
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
   212e6:	2201      	movs	r2, #1
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   212e8:	4634      	mov	r4, r6
{
   212ea:	4b63      	ldr	r3, [pc, #396]	; (21478 <nrfx_gpiote_irq_handler+0x198>)
    return p_reg->INTENSET & mask;
   212ec:	4863      	ldr	r0, [pc, #396]	; (2147c <nrfx_gpiote_irq_handler+0x19c>)

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   212ee:	4964      	ldr	r1, [pc, #400]	; (21480 <nrfx_gpiote_irq_handler+0x1a0>)
{
   212f0:	b087      	sub	sp, #28
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   212f2:	681d      	ldr	r5, [r3, #0]
    {
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
   212f4:	b135      	cbz	r5, 21304 <nrfx_gpiote_irq_handler+0x24>
    return p_reg->INTENSET & mask;
   212f6:	f8d0 5304 	ldr.w	r5, [r0, #772]	; 0x304
   212fa:	4215      	tst	r5, r2
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   212fc:	bf1e      	ittt	ne
   212fe:	601c      	strne	r4, [r3, #0]
   21300:	681d      	ldrne	r5, [r3, #0]
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
   21302:	4316      	orrne	r6, r2
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   21304:	3304      	adds	r3, #4
   21306:	428b      	cmp	r3, r1
        }
        mask <<= 1;
   21308:	ea4f 0242 	mov.w	r2, r2, lsl #1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
   2130c:	d1f1      	bne.n	212f2 <nrfx_gpiote_irq_handler+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2130e:	f8df a16c 	ldr.w	sl, [pc, #364]	; 2147c <nrfx_gpiote_irq_handler+0x19c>
   21312:	f8da 317c 	ldr.w	r3, [sl, #380]	; 0x17c
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
   21316:	2b00      	cmp	r3, #0
   21318:	f000 8091 	beq.w	2143e <nrfx_gpiote_irq_handler+0x15e>
        *p_masks = gpio_regs[i]->LATCH;
   2131c:	f8df 8164 	ldr.w	r8, [pc, #356]	; 21484 <nrfx_gpiote_irq_handler+0x1a4>
   21320:	f8d8 3020 	ldr.w	r3, [r8, #32]
   21324:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
   21326:	f8c8 3020 	str.w	r3, [r8, #32]
        *p_masks = gpio_regs[i]->LATCH;
   2132a:	4b57      	ldr	r3, [pc, #348]	; (21488 <nrfx_gpiote_irq_handler+0x1a8>)
   2132c:	6a1a      	ldr	r2, [r3, #32]
   2132e:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
   21330:	621a      	str	r2, [r3, #32]
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   21332:	f04f 0900 	mov.w	r9, #0
            while (latch[i])
   21336:	f10d 0b10 	add.w	fp, sp, #16
   2133a:	ea4f 1349 	mov.w	r3, r9, lsl #5
   2133e:	9300      	str	r3, [sp, #0]
   21340:	e048      	b.n	213d4 <nrfx_gpiote_irq_handler+0xf4>
                uint32_t pin = NRF_CTZ(latch[i]);
   21342:	fa94 f4a4 	rbit	r4, r4
   21346:	fab4 f484 	clz	r4, r4
                pin += 32 * i;
   2134a:	9b00      	ldr	r3, [sp, #0]
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   2134c:	4a4f      	ldr	r2, [pc, #316]	; (2148c <nrfx_gpiote_irq_handler+0x1ac>)
                pin += 32 * i;
   2134e:	441c      	add	r4, r3
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   21350:	f104 0308 	add.w	r3, r4, #8
   21354:	f832 7013 	ldrh.w	r7, [r2, r3, lsl #1]
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    bit = BITMASK_RELBIT_GET(bit);
    p_mask8[byte_idx] &= ~(1 << bit);
   21358:	2301      	movs	r3, #1
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
   2135a:	08e0      	lsrs	r0, r4, #3
    bit = BITMASK_RELBIT_GET(bit);
   2135c:	f004 0207 	and.w	r2, r4, #7
    p_mask8[byte_idx] &= ~(1 << bit);
   21360:	fa03 f202 	lsl.w	r2, r3, r2
   21364:	f81b 3000 	ldrb.w	r3, [fp, r0]
   21368:	9403      	str	r4, [sp, #12]
   2136a:	ea23 0302 	bic.w	r3, r3, r2
   2136e:	f80b 3000 	strb.w	r3, [fp, r0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   21372:	a803      	add	r0, sp, #12
   21374:	f7ff fd22 	bl	20dbc <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   21378:	9b03      	ldr	r3, [sp, #12]
   2137a:	08b9      	lsrs	r1, r7, #2
   2137c:	3380      	adds	r3, #128	; 0x80
   2137e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
   21382:	f3c7 0582 	ubfx	r5, r7, #2, #3
    if (is_level(trigger))
   21386:	074a      	lsls	r2, r1, #29
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
   21388:	462f      	mov	r7, r5
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
   2138a:	f3c3 4301 	ubfx	r3, r3, #16, #2
    if (is_level(trigger))
   2138e:	d52b      	bpl.n	213e8 <nrfx_gpiote_irq_handler+0x108>
        call_handler(pin, trigger);
   21390:	4620      	mov	r0, r4
   21392:	4639      	mov	r1, r7
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   21394:	b2dd      	uxtb	r5, r3
   21396:	f7ff fd2b 	bl	20df0 <call_handler>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2139a:	a803      	add	r0, sp, #12
   2139c:	9403      	str	r4, [sp, #12]
   2139e:	f7ff fd0d 	bl	20dbc <nrf_gpio_pin_port_decode>
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
   213a2:	9b03      	ldr	r3, [sp, #12]
   213a4:	3380      	adds	r3, #128	; 0x80
   213a6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
        if (nrf_gpio_pin_sense_get(pin) == sense)
   213aa:	f3c3 4301 	ubfx	r3, r3, #16, #2
   213ae:	429d      	cmp	r5, r3
   213b0:	d107      	bne.n	213c2 <nrfx_gpiote_irq_handler+0xe2>
            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
   213b2:	2100      	movs	r1, #0
   213b4:	4620      	mov	r0, r4
   213b6:	f004 fa75 	bl	258a4 <nrf_gpio_cfg_sense_set>
            nrf_gpio_cfg_sense_set(pin, sense);
   213ba:	4629      	mov	r1, r5
   213bc:	4620      	mov	r0, r4
   213be:	f004 fa71 	bl	258a4 <nrf_gpio_cfg_sense_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   213c2:	a803      	add	r0, sp, #12
   213c4:	9403      	str	r4, [sp, #12]
   213c6:	f7ff fcf9 	bl	20dbc <nrf_gpio_pin_port_decode>
    reg->LATCH = (1 << pin_number);
   213ca:	2201      	movs	r2, #1
   213cc:	9b03      	ldr	r3, [sp, #12]
   213ce:	fa02 f303 	lsl.w	r3, r2, r3
   213d2:	6203      	str	r3, [r0, #32]
            while (latch[i])
   213d4:	f85b 4029 	ldr.w	r4, [fp, r9, lsl #2]
   213d8:	2c00      	cmp	r4, #0
   213da:	d1b2      	bne.n	21342 <nrfx_gpiote_irq_handler+0x62>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
   213dc:	f1b9 0f00 	cmp.w	r9, #0
   213e0:	d11d      	bne.n	2141e <nrfx_gpiote_irq_handler+0x13e>
   213e2:	f04f 0901 	mov.w	r9, #1
   213e6:	e7a8      	b.n	2133a <nrfx_gpiote_irq_handler+0x5a>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
   213e8:	2b02      	cmp	r3, #2
   213ea:	d10c      	bne.n	21406 <nrfx_gpiote_irq_handler+0x126>
        nrf_gpio_cfg_sense_set(pin, next_sense);
   213ec:	2103      	movs	r1, #3
   213ee:	4620      	mov	r0, r4
   213f0:	f004 fa58 	bl	258a4 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   213f4:	f005 0305 	and.w	r3, r5, #5
   213f8:	2b01      	cmp	r3, #1
   213fa:	d1e2      	bne.n	213c2 <nrfx_gpiote_irq_handler+0xe2>
            call_handler(pin, trigger);
   213fc:	4639      	mov	r1, r7
   213fe:	4620      	mov	r0, r4
   21400:	f7ff fcf6 	bl	20df0 <call_handler>
   21404:	e7dd      	b.n	213c2 <nrfx_gpiote_irq_handler+0xe2>
        nrf_gpio_cfg_sense_set(pin, next_sense);
   21406:	2102      	movs	r1, #2
   21408:	4620      	mov	r0, r4
   2140a:	9301      	str	r3, [sp, #4]
   2140c:	f004 fa4a 	bl	258a4 <nrf_gpio_cfg_sense_set>
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
   21410:	2d03      	cmp	r5, #3
   21412:	d0f3      	beq.n	213fc <nrfx_gpiote_irq_handler+0x11c>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
   21414:	9b01      	ldr	r3, [sp, #4]
   21416:	2b03      	cmp	r3, #3
   21418:	d1d3      	bne.n	213c2 <nrfx_gpiote_irq_handler+0xe2>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
   2141a:	2d02      	cmp	r5, #2
   2141c:	e7ed      	b.n	213fa <nrfx_gpiote_irq_handler+0x11a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   2141e:	f8ca 417c 	str.w	r4, [sl, #380]	; 0x17c
   21422:	f8da 317c 	ldr.w	r3, [sl, #380]	; 0x17c
        *p_masks = gpio_regs[i]->LATCH;
   21426:	f8d8 3020 	ldr.w	r3, [r8, #32]
   2142a:	4917      	ldr	r1, [pc, #92]	; (21488 <nrfx_gpiote_irq_handler+0x1a8>)
   2142c:	9304      	str	r3, [sp, #16]
        gpio_regs[i]->LATCH = *p_masks;
   2142e:	f8c8 3020 	str.w	r3, [r8, #32]
        *p_masks = gpio_regs[i]->LATCH;
   21432:	6a0a      	ldr	r2, [r1, #32]
        if (latch[port_idx])
   21434:	4313      	orrs	r3, r2
   21436:	9205      	str	r2, [sp, #20]
        gpio_regs[i]->LATCH = *p_masks;
   21438:	620a      	str	r2, [r1, #32]
   2143a:	f47f af7a 	bne.w	21332 <nrfx_gpiote_irq_handler+0x52>
        mask &= ~NRFX_BIT(ch);
   2143e:	2401      	movs	r4, #1
    while (mask)
   21440:	b916      	cbnz	r6, 21448 <nrfx_gpiote_irq_handler+0x168>
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
}
   21442:	b007      	add	sp, #28
   21444:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        uint32_t ch = NRF_CTZ(mask);
   21448:	fa96 f3a6 	rbit	r3, r6
   2144c:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
   21450:	fa04 f203 	lsl.w	r2, r4, r3
   21454:	009b      	lsls	r3, r3, #2
   21456:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2145a:	f503 333c 	add.w	r3, r3, #192512	; 0x2f000
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   2145e:	f8d3 0510 	ldr.w	r0, [r3, #1296]	; 0x510
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
   21462:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   21466:	f3c0 2005 	ubfx	r0, r0, #8, #6
   2146a:	f3c1 4101 	ubfx	r1, r1, #16, #2
        mask &= ~NRFX_BIT(ch);
   2146e:	ea26 0602 	bic.w	r6, r6, r2
        call_handler(pin, gpiote_polarity_to_trigger(polarity));
   21472:	f7ff fcbd 	bl	20df0 <call_handler>
   21476:	e7e3      	b.n	21440 <nrfx_gpiote_irq_handler+0x160>
   21478:	4002f100 	.word	0x4002f100
   2147c:	4002f000 	.word	0x4002f000
   21480:	4002f120 	.word	0x4002f120
   21484:	40842500 	.word	0x40842500
   21488:	40842800 	.word	0x40842800
   2148c:	2000a208 	.word	0x2000a208

00021490 <nrfx_power_init>:
    return m_usbevt_handler;
}
#endif

nrfx_err_t nrfx_power_init(nrfx_power_config_t const * p_config)
{
   21490:	b510      	push	{r4, lr}
    NRFX_ASSERT(p_config);
    if (m_initialized)
   21492:	4c0e      	ldr	r4, [pc, #56]	; (214cc <nrfx_power_init+0x3c>)
   21494:	7823      	ldrb	r3, [r4, #0]
   21496:	b9b3      	cbnz	r3, 214c6 <nrfx_power_init+0x36>
#endif // NRF_REGULATORS_HAS_POFCON_VDDH

#if NRF_REGULATORS_HAS_DCDCEN_VDDH
NRF_STATIC_INLINE void nrf_regulators_dcdcen_vddh_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
    p_reg->VREGH.DCDCEN = (enable) ? REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled :
   21498:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    }

#if NRF_POWER_HAS_DCDCEN_VDDH
    nrf_power_dcdcen_vddh_set(NRF_POWER, p_config->dcdcenhv);
#elif NRF_REGULATORS_HAS_DCDCEN_VDDH
    nrf_regulators_dcdcen_vddh_set(NRF_REGULATORS, p_config->dcdcenhv);
   2149c:	7803      	ldrb	r3, [r0, #0]
   2149e:	f3c3 0340 	ubfx	r3, r3, #1, #1
   214a2:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
#endif

#if NRF_POWER_HAS_DCDCEN
    nrf_power_dcdcen_set(NRF_POWER, p_config->dcdcen);
#elif defined(REGULATORS_PRESENT)
    nrf_regulators_dcdcen_set(NRF_REGULATORS, p_config->dcdcen);
   214a6:	7803      	ldrb	r3, [r0, #0]
    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   214a8:	2005      	movs	r0, #5
    p_reg->VREGMAIN.DCDCEN = (enable ? REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Msk : 0);
   214aa:	f003 0301 	and.w	r3, r3, #1
   214ae:	f8c2 3704 	str.w	r3, [r2, #1796]	; 0x704
   214b2:	f7fc ff2f 	bl	1e314 <arch_irq_is_enabled>
   214b6:	b910      	cbnz	r0, 214be <nrfx_power_init+0x2e>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   214b8:	2005      	movs	r0, #5
   214ba:	f7fc ff09 	bl	1e2d0 <arch_irq_enable>
#endif
#endif // defined(REGULATORS_PRESENT)

    nrfx_power_clock_irq_init();

    m_initialized = true;
   214be:	2301      	movs	r3, #1
    return NRFX_SUCCESS;
   214c0:	4803      	ldr	r0, [pc, #12]	; (214d0 <nrfx_power_init+0x40>)
    m_initialized = true;
   214c2:	7023      	strb	r3, [r4, #0]
}
   214c4:	bd10      	pop	{r4, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
   214c6:	4803      	ldr	r0, [pc, #12]	; (214d4 <nrfx_power_init+0x44>)
   214c8:	e7fc      	b.n	214c4 <nrfx_power_init+0x34>
   214ca:	bf00      	nop
   214cc:	2000b626 	.word	0x2000b626
   214d0:	0bad0000 	.word	0x0bad0000
   214d4:	0bad000c 	.word	0x0bad000c

000214d8 <nrfx_power_irq_handler>:

#endif /* NRF_POWER_HAS_USBREG */


void nrfx_power_irq_handler(void)
{
   214d8:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
}

NRF_STATIC_INLINE uint32_t nrf_power_int_enable_get(NRF_POWER_Type const * p_reg)
{
    return p_reg->INTENSET;
   214da:	4b18      	ldr	r3, [pc, #96]	; (2153c <nrfx_power_irq_handler+0x64>)
   214dc:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
    uint32_t enabled = nrf_power_int_enable_get(NRF_POWER);
    /* Prevent "unused variable" warning when all below blocks are disabled. */
    (void)enabled;

#if NRFX_POWER_SUPPORTS_POFCON
    if ((0 != (enabled & NRF_POWER_INT_POFWARN_MASK)) &&
   214e0:	0761      	lsls	r1, r4, #29
   214e2:	d50a      	bpl.n	214fa <nrfx_power_irq_handler+0x22>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   214e4:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    if (ret)
   214e8:	b13a      	cbz	r2, 214fa <nrfx_power_irq_handler+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   214ea:	2200      	movs	r2, #0
   214ec:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   214f0:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_POFWARN))
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_pofwarn_handler != NULL);
        m_pofwarn_handler();
   214f4:	4b12      	ldr	r3, [pc, #72]	; (21540 <nrfx_power_irq_handler+0x68>)
   214f6:	681b      	ldr	r3, [r3, #0]
   214f8:	4798      	blx	r3
    }
#endif
#if NRF_POWER_HAS_SLEEPEVT
    if ((0 != (enabled & NRF_POWER_INT_SLEEPENTER_MASK)) &&
   214fa:	06a2      	lsls	r2, r4, #26
   214fc:	d50b      	bpl.n	21516 <nrfx_power_irq_handler+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   214fe:	4b0f      	ldr	r3, [pc, #60]	; (2153c <nrfx_power_irq_handler+0x64>)
   21500:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
    if (ret)
   21504:	b13a      	cbz	r2, 21516 <nrfx_power_irq_handler+0x3e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21506:	2000      	movs	r0, #0
   21508:	f8c3 0114 	str.w	r0, [r3, #276]	; 0x114
   2150c:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPENTER))
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_ENTER);
   21510:	4b0c      	ldr	r3, [pc, #48]	; (21544 <nrfx_power_irq_handler+0x6c>)
   21512:	681b      	ldr	r3, [r3, #0]
   21514:	4798      	blx	r3
    }
    if ((0 != (enabled & NRF_POWER_INT_SLEEPEXIT_MASK)) &&
   21516:	0663      	lsls	r3, r4, #25
   21518:	d50e      	bpl.n	21538 <nrfx_power_irq_handler+0x60>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2151a:	4b08      	ldr	r3, [pc, #32]	; (2153c <nrfx_power_irq_handler+0x64>)
   2151c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (ret)
   21520:	b152      	cbz	r2, 21538 <nrfx_power_irq_handler+0x60>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21522:	2200      	movs	r2, #0
   21524:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   21528:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        nrf_power_event_get_and_clear(NRF_POWER, NRF_POWER_EVENT_SLEEPEXIT))
    {
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_sleepevt_handler != NULL);
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_EXIT);
   2152c:	4b05      	ldr	r3, [pc, #20]	; (21544 <nrfx_power_irq_handler+0x6c>)
   2152e:	2001      	movs	r0, #1
        /* Cannot be null if event is enabled */
        NRFX_ASSERT(m_usbevt_handler != NULL);
        m_usbevt_handler(NRFX_POWER_USB_EVT_READY);
    }
#endif
}
   21530:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_sleepevt_handler(NRFX_POWER_SLEEP_EVT_EXIT);
   21534:	681b      	ldr	r3, [r3, #0]
   21536:	4718      	bx	r3
}
   21538:	bd10      	pop	{r4, pc}
   2153a:	bf00      	nop
   2153c:	40005000 	.word	0x40005000
   21540:	2000b2f4 	.word	0x2000b2f4
   21544:	2000b2f0 	.word	0x2000b2f0

00021548 <nrf_gpio_pin_clear>:
        case 0: return NRF_P0;
   21548:	4a05      	ldr	r2, [pc, #20]	; (21560 <nrf_gpio_pin_clear+0x18>)
   2154a:	4b06      	ldr	r3, [pc, #24]	; (21564 <nrf_gpio_pin_clear+0x1c>)
    *p_pin = pin_number & 0x1F;
   2154c:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
   21550:	0940      	lsrs	r0, r0, #5
        case 0: return NRF_P0;
   21552:	2801      	cmp	r0, #1
   21554:	bf18      	it	ne
   21556:	4613      	movne	r3, r2
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   21558:	2201      	movs	r2, #1
   2155a:	408a      	lsls	r2, r1
    p_reg->OUTCLR = clr_mask;
   2155c:	60da      	str	r2, [r3, #12]
}
   2155e:	4770      	bx	lr
   21560:	40842500 	.word	0x40842500
   21564:	40842800 	.word	0x40842800

00021568 <nrf_gpio_cfg.constprop.0>:
NRF_STATIC_INLINE void nrf_gpio_cfg(
   21568:	b570      	push	{r4, r5, r6, lr}
        case 0: return NRF_P0;
   2156a:	4c0d      	ldr	r4, [pc, #52]	; (215a0 <nrf_gpio_cfg.constprop.0+0x38>)
   2156c:	4e0d      	ldr	r6, [pc, #52]	; (215a4 <nrf_gpio_cfg.constprop.0+0x3c>)
    *p_pin = pin_number & 0x1F;
   2156e:	f000 051f 	and.w	r5, r0, #31
    return pin_number >> 5;
   21572:	0940      	lsrs	r0, r0, #5
        case 0: return NRF_P0;
   21574:	2801      	cmp	r0, #1
   21576:	bf18      	it	ne
   21578:	4634      	movne	r4, r6
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   2157a:	f89d 0010 	ldrb.w	r0, [sp, #16]
   2157e:	eb04 0485 	add.w	r4, r4, r5, lsl #2
   21582:	0200      	lsls	r0, r0, #8
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21584:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   21588:	ea40 0083 	orr.w	r0, r0, r3, lsl #2
   2158c:	4308      	orrs	r0, r1
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   2158e:	f005 45e0 	and.w	r5, r5, #1879048192	; 0x70000000
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   21592:	ea40 0042 	orr.w	r0, r0, r2, lsl #1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   21596:	4328      	orrs	r0, r5
    reg->PIN_CNF[pin_number] = cnf;
   21598:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
}
   2159c:	bd70      	pop	{r4, r5, r6, pc}
   2159e:	bf00      	nop
   215a0:	40842800 	.word	0x40842800
   215a4:	40842500 	.word	0x40842500

000215a8 <nrf_gpio_pin_set>:
        case 0: return NRF_P0;
   215a8:	4a05      	ldr	r2, [pc, #20]	; (215c0 <nrf_gpio_pin_set+0x18>)
   215aa:	4b06      	ldr	r3, [pc, #24]	; (215c4 <nrf_gpio_pin_set+0x1c>)
    *p_pin = pin_number & 0x1F;
   215ac:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
   215b0:	0940      	lsrs	r0, r0, #5
        case 0: return NRF_P0;
   215b2:	2801      	cmp	r0, #1
   215b4:	bf18      	it	ne
   215b6:	4613      	movne	r3, r2
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   215b8:	2201      	movs	r2, #1
   215ba:	408a      	lsls	r2, r1
    p_reg->OUTSET = set_mask;
   215bc:	609a      	str	r2, [r3, #8]
}
   215be:	4770      	bx	lr
   215c0:	40842500 	.word	0x40842500
   215c4:	40842800 	.word	0x40842800

000215c8 <nrfx_spim_init>:

nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
                          nrfx_spim_config_t const * p_config,
                          nrfx_spim_evt_handler_t    handler,
                          void *                     p_context)
{
   215c8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   215cc:	4607      	mov	r7, r0
   215ce:	460c      	mov	r4, r1
    NRFX_ASSERT(p_config);
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   215d0:	4e93      	ldr	r6, [pc, #588]	; (21820 <nrfx_spim_init+0x258>)
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   215d2:	7939      	ldrb	r1, [r7, #4]
{
   215d4:	4610      	mov	r0, r2
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   215d6:	eb06 1241 	add.w	r2, r6, r1, lsl #5
   215da:	f892 a01c 	ldrb.w	sl, [r2, #28]
   215de:	ea4f 1941 	mov.w	r9, r1, lsl #5
   215e2:	f1ba 0f00 	cmp.w	sl, #0
   215e6:	f040 8116 	bne.w	21816 <nrfx_spim_init+0x24e>
        return err_code;
    }

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // Check if SPIM instance supports the extended features.
    if (
   215ea:	b949      	cbnz	r1, 21600 <nrfx_spim_init+0x38>
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   215ec:	68a2      	ldr	r2, [r4, #8]
   215ee:	f1b2 6f20 	cmp.w	r2, #167772160	; 0xa000000
   215f2:	d003      	beq.n	215fc <nrfx_spim_init+0x34>
   215f4:	f1b2 5fa0 	cmp.w	r2, #335544320	; 0x14000000
   215f8:	f040 80ee 	bne.w	217d8 <nrfx_spim_init+0x210>
    {
        err_code = NRFX_ERROR_NOT_SUPPORTED;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
   215fc:	4889      	ldr	r0, [pc, #548]	; (21824 <nrfx_spim_init+0x25c>)
   215fe:	e0e8      	b.n	217d2 <nrfx_spim_init+0x20a>
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   21600:	2901      	cmp	r1, #1
   21602:	d1fb      	bne.n	215fc <nrfx_spim_init+0x34>
        ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
   21604:	7be1      	ldrb	r1, [r4, #15]

#if NRF_SPIM_HAS_32_MHZ_FREQ && defined(NRF5340_XXAA_APPLICATION)
    // Check if dedicated SPIM pins are used, unless both GPIO configuration
    // and pin selection are to be skipped (pin numbers may be not specified
    // in such case).
    if (!(p_config->skip_gpio_cfg && p_config->skip_psel_cfg) &&
   21606:	7ce2      	ldrb	r2, [r4, #19]
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   21608:	f8d7 8000 	ldr.w	r8, [r7]
    if (!(p_config->skip_gpio_cfg && p_config->skip_psel_cfg) &&
   2160c:	b10a      	cbz	r2, 21612 <nrfx_spim_init+0x4a>
   2160e:	7d22      	ldrb	r2, [r4, #20]
   21610:	bb1a      	cbnz	r2, 2165a <nrfx_spim_init+0x92>
   21612:	4a85      	ldr	r2, [pc, #532]	; (21828 <nrfx_spim_init+0x260>)
   21614:	4590      	cmp	r8, r2
   21616:	d120      	bne.n	2165a <nrfx_spim_init+0x92>
        (p_spim == NRF_SPIM4) && (p_config->frequency == NRF_SPIM_FREQ_32M))
   21618:	68a2      	ldr	r2, [r4, #8]
   2161a:	f1b2 5fa0 	cmp.w	r2, #335544320	; 0x14000000
   2161e:	d11c      	bne.n	2165a <nrfx_spim_init+0x92>
            SPIM_MISO_DEDICATED = NRF_GPIO_PIN_MAP(0, 10),
            SPIM_CSN_DEDICATED  = NRF_GPIO_PIN_MAP(0, 11),
            SPIM_DCX_DEDICATED  = NRF_GPIO_PIN_MAP(0, 12),
        };

        if (!SPIM_DEDICATED_PIN_VALIDATE(p_config->sck_pin, SPIM_SCK_DEDICATED) ||
   21620:	7822      	ldrb	r2, [r4, #0]
   21622:	2aff      	cmp	r2, #255	; 0xff
   21624:	d002      	beq.n	2162c <nrfx_spim_init+0x64>
   21626:	2a08      	cmp	r2, #8
   21628:	f040 80f7 	bne.w	2181a <nrfx_spim_init+0x252>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->ss_pin,  SPIM_CSN_DEDICATED) ||
   2162c:	78e2      	ldrb	r2, [r4, #3]
        if (!SPIM_DEDICATED_PIN_VALIDATE(p_config->sck_pin, SPIM_SCK_DEDICATED) ||
   2162e:	2aff      	cmp	r2, #255	; 0xff
   21630:	d002      	beq.n	21638 <nrfx_spim_init+0x70>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->ss_pin,  SPIM_CSN_DEDICATED) ||
   21632:	2a0b      	cmp	r2, #11
   21634:	f040 80f1 	bne.w	2181a <nrfx_spim_init+0x252>
   21638:	29ff      	cmp	r1, #255	; 0xff
   2163a:	d002      	beq.n	21642 <nrfx_spim_init+0x7a>
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->dcx_pin, SPIM_DCX_DEDICATED) ||
   2163c:	290c      	cmp	r1, #12
   2163e:	f040 80ec 	bne.w	2181a <nrfx_spim_init+0x252>
#endif
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
   21642:	7862      	ldrb	r2, [r4, #1]
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->dcx_pin, SPIM_DCX_DEDICATED) ||
   21644:	2aff      	cmp	r2, #255	; 0xff
   21646:	d002      	beq.n	2164e <nrfx_spim_init+0x86>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
   21648:	2a09      	cmp	r2, #9
   2164a:	f040 80e6 	bne.w	2181a <nrfx_spim_init+0x252>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->miso_pin, SPIM_MISO_DEDICATED))
   2164e:	78a2      	ldrb	r2, [r4, #2]
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->mosi_pin, SPIM_MOSI_DEDICATED) ||
   21650:	2aff      	cmp	r2, #255	; 0xff
   21652:	d002      	beq.n	2165a <nrfx_spim_init+0x92>
            !SPIM_DEDICATED_PIN_VALIDATE(p_config->miso_pin, SPIM_MISO_DEDICATED))
   21654:	2a0a      	cmp	r2, #10
   21656:	f040 80e0 	bne.w	2181a <nrfx_spim_init+0x252>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
   2165a:	eb06 0209 	add.w	r2, r6, r9
   2165e:	f846 0009 	str.w	r0, [r6, r9]
    p_cb->p_context = p_context;
   21662:	6053      	str	r3, [r2, #4]

    p_cb->skip_gpio_cfg = p_config->skip_gpio_cfg;
   21664:	7ce0      	ldrb	r0, [r4, #19]
   21666:	7f91      	ldrb	r1, [r2, #30]
   21668:	f360 0100 	bfi	r1, r0, #0, #1
   2166c:	7791      	strb	r1, [r2, #30]
    p_cb->ss_active_high = p_config->ss_active_high;
   2166e:	7920      	ldrb	r0, [r4, #4]
   21670:	b2c9      	uxtb	r1, r1
   21672:	f360 0141 	bfi	r1, r0, #1, #1
   21676:	7791      	strb	r1, [r2, #30]
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    p_cb->use_hw_ss = p_config->use_hw_ss;
   21678:	7c60      	ldrb	r0, [r4, #17]
   2167a:	b2c9      	uxtb	r1, r1
   2167c:	f360 0182 	bfi	r1, r0, #2, #1
   21680:	7791      	strb	r1, [r2, #30]
#endif
    p_cb->ss_pin = p_config->ss_pin;
   21682:	78e3      	ldrb	r3, [r4, #3]
   21684:	77d3      	strb	r3, [r2, #31]
    if (!p_config->skip_gpio_cfg)
   21686:	7ce3      	ldrb	r3, [r4, #19]
    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   21688:	683d      	ldr	r5, [r7, #0]
    if (!p_config->skip_gpio_cfg)
   2168a:	2b00      	cmp	r3, #0
   2168c:	d148      	bne.n	21720 <nrfx_spim_init+0x158>
                    : NRF_GPIO_PIN_S0S1;
   2168e:	68a3      	ldr	r3, [r4, #8]
        nrf_gpio_pin_write(p_config->sck_pin,
   21690:	7820      	ldrb	r0, [r4, #0]
                    : NRF_GPIO_PIN_S0S1;
   21692:	f1b3 5fa0 	cmp.w	r3, #335544320	; 0x14000000
    if (value == 0)
   21696:	7b23      	ldrb	r3, [r4, #12]
   21698:	bf08      	it	eq
   2169a:	f04f 0a03 	moveq.w	sl, #3
   2169e:	2b01      	cmp	r3, #1
   216a0:	f200 80a3 	bhi.w	217ea <nrfx_spim_init+0x222>
        nrf_gpio_pin_clear(pin_number);
   216a4:	f7ff ff50 	bl	21548 <nrf_gpio_pin_clear>
        nrf_gpio_cfg(p_config->sck_pin,
   216a8:	2300      	movs	r3, #0
   216aa:	f8cd a000 	str.w	sl, [sp]
   216ae:	7820      	ldrb	r0, [r4, #0]
   216b0:	461a      	mov	r2, r3
   216b2:	2101      	movs	r1, #1
   216b4:	f7ff ff58 	bl	21568 <nrf_gpio_cfg.constprop.0>
        if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   216b8:	7860      	ldrb	r0, [r4, #1]
   216ba:	28ff      	cmp	r0, #255	; 0xff
   216bc:	d009      	beq.n	216d2 <nrfx_spim_init+0x10a>
   216be:	f7ff ff43 	bl	21548 <nrf_gpio_pin_clear>
            nrf_gpio_cfg(p_config->mosi_pin,
   216c2:	2201      	movs	r2, #1
   216c4:	f8cd a000 	str.w	sl, [sp]
   216c8:	2300      	movs	r3, #0
   216ca:	4611      	mov	r1, r2
   216cc:	7860      	ldrb	r0, [r4, #1]
   216ce:	f7ff ff4b 	bl	21568 <nrf_gpio_cfg.constprop.0>
        if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   216d2:	78a0      	ldrb	r0, [r4, #2]
   216d4:	28ff      	cmp	r0, #255	; 0xff
   216d6:	d006      	beq.n	216e6 <nrfx_spim_init+0x11e>
            nrf_gpio_cfg(p_config->miso_pin,
   216d8:	2200      	movs	r2, #0
   216da:	f8cd a000 	str.w	sl, [sp]
   216de:	4611      	mov	r1, r2
   216e0:	7ba3      	ldrb	r3, [r4, #14]
   216e2:	f7ff ff41 	bl	21568 <nrf_gpio_cfg.constprop.0>
        if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   216e6:	78e0      	ldrb	r0, [r4, #3]
   216e8:	28ff      	cmp	r0, #255	; 0xff
   216ea:	d00c      	beq.n	21706 <nrfx_spim_init+0x13e>
    if (value == 0)
   216ec:	7923      	ldrb	r3, [r4, #4]
   216ee:	2b00      	cmp	r3, #0
   216f0:	d07e      	beq.n	217f0 <nrfx_spim_init+0x228>
        nrf_gpio_pin_clear(pin_number);
   216f2:	f7ff ff29 	bl	21548 <nrf_gpio_pin_clear>
            nrf_gpio_cfg(p_config->ss_pin,
   216f6:	2201      	movs	r2, #1
   216f8:	f8cd a000 	str.w	sl, [sp]
   216fc:	2300      	movs	r3, #0
   216fe:	4611      	mov	r1, r2
   21700:	78e0      	ldrb	r0, [r4, #3]
   21702:	f7ff ff31 	bl	21568 <nrf_gpio_cfg.constprop.0>
        if (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
   21706:	7be0      	ldrb	r0, [r4, #15]
   21708:	28ff      	cmp	r0, #255	; 0xff
   2170a:	d009      	beq.n	21720 <nrfx_spim_init+0x158>
        nrf_gpio_pin_set(pin_number);
   2170c:	f7ff ff4c 	bl	215a8 <nrf_gpio_pin_set>
            nrf_gpio_cfg(p_config->dcx_pin,
   21710:	2201      	movs	r2, #1
   21712:	f8cd a000 	str.w	sl, [sp]
   21716:	2300      	movs	r3, #0
   21718:	4611      	mov	r1, r2
   2171a:	7be0      	ldrb	r0, [r4, #15]
   2171c:	f7ff ff24 	bl	21568 <nrf_gpio_cfg.constprop.0>
    if (!p_config->skip_psel_cfg)
   21720:	7d23      	ldrb	r3, [r4, #20]
   21722:	bb6b      	cbnz	r3, 21780 <nrfx_spim_init+0x1b8>
        uint32_t mosi_pin = (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   21724:	7863      	ldrb	r3, [r4, #1]
        nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
   21726:	7821      	ldrb	r1, [r4, #0]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   21728:	2bff      	cmp	r3, #255	; 0xff
   2172a:	bf18      	it	ne
   2172c:	461a      	movne	r2, r3
        uint32_t miso_pin = (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   2172e:	78a3      	ldrb	r3, [r4, #2]
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   21730:	bf08      	it	eq
   21732:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
                            : NRF_SPIM_PIN_NOT_CONNECTED;
   21736:	2bff      	cmp	r3, #255	; 0xff
   21738:	bf08      	it	eq
   2173a:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
NRF_STATIC_INLINE void nrf_spim_pins_set(NRF_SPIM_Type * p_reg,
                                         uint32_t        sck_pin,
                                         uint32_t        mosi_pin,
                                         uint32_t        miso_pin)
{
    p_reg->PSEL.SCK  = sck_pin;
   2173e:	f8c5 1508 	str.w	r1, [r5, #1288]	; 0x508
    p_reg->PSEL.MOSI = mosi_pin;
   21742:	f8c5 250c 	str.w	r2, [r5, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   21746:	f8c5 3510 	str.w	r3, [r5, #1296]	; 0x510
        if (SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx))
   2174a:	793b      	ldrb	r3, [r7, #4]
   2174c:	2b01      	cmp	r3, #1
   2174e:	d117      	bne.n	21780 <nrfx_spim_init+0x1b8>
            if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED &&
   21750:	78e3      	ldrb	r3, [r4, #3]
   21752:	2bff      	cmp	r3, #255	; 0xff
   21754:	d04f      	beq.n	217f6 <nrfx_spim_init+0x22e>
   21756:	7c62      	ldrb	r2, [r4, #17]
   21758:	2a00      	cmp	r2, #0
   2175a:	d04c      	beq.n	217f6 <nrfx_spim_init+0x22e>
                                    (p_config->ss_active_high == true
   2175c:	7921      	ldrb	r1, [r4, #4]
                nrf_spim_csn_configure(p_spim,
   2175e:	7ca2      	ldrb	r2, [r4, #18]
NRF_STATIC_INLINE void nrf_spim_csn_configure(NRF_SPIM_Type *    p_reg,
                                              uint32_t           pin,
                                              nrf_spim_csn_pol_t polarity,
                                              uint32_t           duration)
{
    p_reg->PSEL.CSN = pin;
   21760:	f8c5 3514 	str.w	r3, [r5, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
   21764:	f8c5 1568 	str.w	r1, [r5, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
   21768:	f8c5 2564 	str.w	r2, [r5, #1380]	; 0x564
        if (SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
   2176c:	793b      	ldrb	r3, [r7, #4]
   2176e:	2b01      	cmp	r3, #1
   21770:	d106      	bne.n	21780 <nrfx_spim_init+0x1b8>
            uint32_t dcx_pin = (p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED)
   21772:	7be3      	ldrb	r3, [r4, #15]
                               : NRF_SPIM_PIN_NOT_CONNECTED;
   21774:	2bff      	cmp	r3, #255	; 0xff
   21776:	bf08      	it	eq
   21778:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff

#if NRF_SPIM_DCX_PRESENT
NRF_STATIC_INLINE void nrf_spim_dcx_pin_set(NRF_SPIM_Type * p_reg,
                                            uint32_t        dcx_pin)
{
    p_reg->PSELDCX = dcx_pin;
   2177c:	f8c5 356c 	str.w	r3, [r5, #1388]	; 0x56c

    configure_pins(p_instance, p_config);

#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
    // Change rx delay
    nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
   21780:	7c23      	ldrb	r3, [r4, #16]

#if NRF_SPIM_RXDELAY_PRESENT
NRF_STATIC_INLINE void nrf_spim_iftiming_set(NRF_SPIM_Type * p_reg,
                                             uint32_t        rxdelay)
{
    p_reg->IFTIMING.RXDELAY = rxdelay;
   21782:	f8c8 3560 	str.w	r3, [r8, #1376]	; 0x560
#endif // defined(SPIM_STALLSTAT_TX_Msk)

NRF_STATIC_INLINE void nrf_spim_frequency_set(NRF_SPIM_Type *      p_reg,
                                              nrf_spim_frequency_t frequency)
{
    p_reg->FREQUENCY = (uint32_t)frequency;
   21786:	68a3      	ldr	r3, [r4, #8]
   21788:	f8c8 3524 	str.w	r3, [r8, #1316]	; 0x524
NRF_STATIC_INLINE void nrf_spim_configure(NRF_SPIM_Type *      p_reg,
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
   2178c:	7b63      	ldrb	r3, [r4, #13]
#endif

    nrf_spim_frequency_set(p_spim, p_config->frequency);
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
   2178e:	7b22      	ldrb	r2, [r4, #12]
   21790:	3b00      	subs	r3, #0
   21792:	bf18      	it	ne
   21794:	2301      	movne	r3, #1
    switch (spi_mode)
   21796:	2a02      	cmp	r2, #2
   21798:	d037      	beq.n	2180a <nrfx_spim_init+0x242>
   2179a:	2a03      	cmp	r2, #3
   2179c:	d038      	beq.n	21810 <nrfx_spim_init+0x248>
   2179e:	2a01      	cmp	r2, #1
   217a0:	d101      	bne.n	217a6 <nrfx_spim_init+0x1de>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   217a2:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   217a6:	f8c8 3554 	str.w	r3, [r8, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
   217aa:	79a3      	ldrb	r3, [r4, #6]
   217ac:	f8c8 35c0 	str.w	r3, [r8, #1472]	; 0x5c0
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
   217b0:	2307      	movs	r3, #7
   217b2:	f8c8 3500 	str.w	r3, [r8, #1280]	; 0x500

    nrf_spim_orc_set(p_spim, p_config->orc);

    nrf_spim_enable(p_spim);

    if (p_cb->handler)
   217b6:	f856 3009 	ldr.w	r3, [r6, r9]
   217ba:	b123      	cbz	r3, 217c6 <nrfx_spim_init+0x1fe>
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   217bc:	6838      	ldr	r0, [r7, #0]
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   217be:	f340 3007 	sbfx	r0, r0, #12, #8
   217c2:	f7fc fd85 	bl	1e2d0 <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
   217c6:	2300      	movs	r3, #0
   217c8:	444e      	add	r6, r9
   217ca:	7773      	strb	r3, [r6, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   217cc:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   217ce:	4817      	ldr	r0, [pc, #92]	; (2182c <nrfx_spim_init+0x264>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   217d0:	7733      	strb	r3, [r6, #28]
}
   217d2:	b002      	add	sp, #8
   217d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        (!SPIM_SUPPORTED_FREQ_VALIDATE(p_instance->drv_inst_idx, p_config->frequency)) ||
   217d8:	7c62      	ldrb	r2, [r4, #17]
   217da:	2a00      	cmp	r2, #0
   217dc:	f47f af0e 	bne.w	215fc <nrfx_spim_init+0x34>
        ((p_config->dcx_pin != NRFX_SPIM_PIN_NOT_USED) &&
   217e0:	7be1      	ldrb	r1, [r4, #15]
         !SPIM_HW_CSN_PRESENT_VALIDATE(p_instance->drv_inst_idx)) ||
   217e2:	29ff      	cmp	r1, #255	; 0xff
   217e4:	f47f af0a 	bne.w	215fc <nrfx_spim_init+0x34>
   217e8:	e70d      	b.n	21606 <nrfx_spim_init+0x3e>
   217ea:	f7ff fedd 	bl	215a8 <nrf_gpio_pin_set>
   217ee:	e75b      	b.n	216a8 <nrfx_spim_init+0xe0>
   217f0:	f7ff feda 	bl	215a8 <nrf_gpio_pin_set>
   217f4:	e77f      	b.n	216f6 <nrfx_spim_init+0x12e>
    p_reg->PSEL.CSN = pin;
   217f6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   217fa:	f8c5 3514 	str.w	r3, [r5, #1300]	; 0x514
    p_reg->CSNPOL = polarity;
   217fe:	2300      	movs	r3, #0
   21800:	f8c5 3568 	str.w	r3, [r5, #1384]	; 0x568
    p_reg->IFTIMING.CSNDUR = duration;
   21804:	f8c5 3564 	str.w	r3, [r5, #1380]	; 0x564
}
   21808:	e7b0      	b.n	2176c <nrfx_spim_init+0x1a4>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   2180a:	f043 0304 	orr.w	r3, r3, #4
        break;
   2180e:	e7ca      	b.n	217a6 <nrfx_spim_init+0x1de>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   21810:	f043 0306 	orr.w	r3, r3, #6
        break;
   21814:	e7c7      	b.n	217a6 <nrfx_spim_init+0x1de>
        return err_code;
   21816:	4806      	ldr	r0, [pc, #24]	; (21830 <nrfx_spim_init+0x268>)
   21818:	e7db      	b.n	217d2 <nrfx_spim_init+0x20a>
            return err_code;
   2181a:	4806      	ldr	r0, [pc, #24]	; (21834 <nrfx_spim_init+0x26c>)
   2181c:	e7d9      	b.n	217d2 <nrfx_spim_init+0x20a>
   2181e:	bf00      	nop
   21820:	2000b2f8 	.word	0x2000b2f8
   21824:	0bad0003 	.word	0x0bad0003
   21828:	4000a000 	.word	0x4000a000
   2182c:	0bad0000 	.word	0x0bad0000
   21830:	0bad0005 	.word	0x0bad0005
   21834:	0bad0004 	.word	0x0bad0004

00021838 <nrfx_spim_uninit>:

    nrf_gpio_cfg_default(pin);
}

void nrfx_spim_uninit(nrfx_spim_t const * p_instance)
{
   21838:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2183c:	7903      	ldrb	r3, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
    NRF_SPIM_Type * p_spim = p_instance->p_reg;

    if (p_cb->handler)
   2183e:	4d26      	ldr	r5, [pc, #152]	; (218d8 <nrfx_spim_uninit+0xa0>)
   21840:	015e      	lsls	r6, r3, #5
   21842:	eb05 1843 	add.w	r8, r5, r3, lsl #5
   21846:	59ab      	ldr	r3, [r5, r6]
{
   21848:	4607      	mov	r7, r0
    NRF_SPIM_Type * p_spim = p_instance->p_reg;
   2184a:	6804      	ldr	r4, [r0, #0]
    if (p_cb->handler)
   2184c:	b1cb      	cbz	r3, 21882 <nrfx_spim_uninit+0x4a>
    {
        NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
   2184e:	f344 3007 	sbfx	r0, r4, #12, #8
   21852:	f7fc fd4b 	bl	1e2ec <arch_irq_disable>
    p_reg->INTENCLR = mask;
   21856:	4b21      	ldr	r3, [pc, #132]	; (218dc <nrfx_spim_uninit+0xa4>)
   21858:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
        nrf_spim_int_disable(p_spim, NRF_SPIM_ALL_INTS_MASK);
        if (p_cb->transfer_in_progress)
   2185c:	f898 301d 	ldrb.w	r3, [r8, #29]
   21860:	b17b      	cbz	r3, 21882 <nrfx_spim_uninit+0x4a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21862:	2301      	movs	r3, #1
   21864:	f04f 0864 	mov.w	r8, #100	; 0x64
   21868:	6163      	str	r3, [r4, #20]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2186a:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    NRFX_WAIT_FOR(nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_STOPPED), 100, 1, stopped);
   2186e:	b92b      	cbnz	r3, 2187c <nrfx_spim_uninit+0x44>
   21870:	2001      	movs	r0, #1
   21872:	f003 ffca 	bl	2580a <nrfx_busy_wait>
   21876:	f1b8 0801 	subs.w	r8, r8, #1
   2187a:	d1f6      	bne.n	2186a <nrfx_spim_uninit+0x32>
    p_cb->transfer_in_progress = false;
   2187c:	2200      	movs	r2, #0
   2187e:	19ab      	adds	r3, r5, r6
   21880:	775a      	strb	r2, [r3, #29]
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Disabled << SPIM_ENABLE_ENABLE_Pos);
   21882:	2300      	movs	r3, #0
   21884:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
        }
    }

    nrf_spim_disable(p_spim);

    if (!p_cb->skip_gpio_cfg)
   21888:	19ab      	adds	r3, r5, r6
   2188a:	7f9b      	ldrb	r3, [r3, #30]
   2188c:	07db      	lsls	r3, r3, #31
   2188e:	d41c      	bmi.n	218ca <nrfx_spim_uninit+0x92>
    return p_reg->PSEL.SCK;
   21890:	f8d4 0508 	ldr.w	r0, [r4, #1288]	; 0x508
    {
        spim_pin_uninit(nrf_spim_sck_pin_get(p_spim));
   21894:	f004 f81c 	bl	258d0 <spim_pin_uninit>
    return p_reg->PSEL.MISO;
   21898:	f8d4 0510 	ldr.w	r0, [r4, #1296]	; 0x510
        spim_pin_uninit(nrf_spim_miso_pin_get(p_spim));
   2189c:	f004 f818 	bl	258d0 <spim_pin_uninit>
    return p_reg->PSEL.MOSI;
   218a0:	f8d4 050c 	ldr.w	r0, [r4, #1292]	; 0x50c
        spim_pin_uninit(nrf_spim_mosi_pin_get(p_spim));
   218a4:	f004 f814 	bl	258d0 <spim_pin_uninit>
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (SPIM_DCX_PRESENT_VALIDATE(p_instance->drv_inst_idx))
   218a8:	793b      	ldrb	r3, [r7, #4]
   218aa:	2b01      	cmp	r3, #1
   218ac:	d103      	bne.n	218b6 <nrfx_spim_uninit+0x7e>
    return p_reg->PSELDCX;
   218ae:	f8d4 056c 	ldr.w	r0, [r4, #1388]	; 0x56c
        {
            spim_pin_uninit(nrf_spim_dcx_pin_get(p_spim));
   218b2:	f004 f80d 	bl	258d0 <spim_pin_uninit>
        }
#endif
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   218b6:	19ab      	adds	r3, r5, r6
   218b8:	7fd8      	ldrb	r0, [r3, #31]
   218ba:	28ff      	cmp	r0, #255	; 0xff
   218bc:	d005      	beq.n	218ca <nrfx_spim_uninit+0x92>
    nrf_gpio_cfg(
   218be:	2300      	movs	r3, #0
   218c0:	2201      	movs	r2, #1
   218c2:	4619      	mov	r1, r3
   218c4:	9300      	str	r3, [sp, #0]
   218c6:	f7ff fe4f 	bl	21568 <nrf_gpio_cfg.constprop.0>

#if NRFX_CHECK(NRFX_PRS_ENABLED)
    nrfx_prs_release(p_instance->p_reg);
#endif

    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
   218ca:	2300      	movs	r3, #0
   218cc:	4435      	add	r5, r6
   218ce:	772b      	strb	r3, [r5, #28]
}
   218d0:	b002      	add	sp, #8
   218d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   218d6:	bf00      	nop
   218d8:	2000b2f8 	.word	0x2000b2f8
   218dc:	00080152 	.word	0x00080152

000218e0 <nrfx_spim_xfer>:
}

nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
                          nrfx_spim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   218e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   218e4:	4f38      	ldr	r7, [pc, #224]	; (219c8 <nrfx_spim_xfer+0xe8>)
   218e6:	7903      	ldrb	r3, [r0, #4]
{
   218e8:	4615      	mov	r5, r2
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   218ea:	eb07 1843 	add.w	r8, r7, r3, lsl #5
#endif
                (p_cb->ss_pin == NRFX_SPIM_PIN_NOT_USED));

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
   218ee:	f898 201d 	ldrb.w	r2, [r8, #29]
{
   218f2:	4681      	mov	r9, r0
   218f4:	460c      	mov	r4, r1
    if (p_cb->transfer_in_progress)
   218f6:	015e      	lsls	r6, r3, #5
   218f8:	2a00      	cmp	r2, #0
   218fa:	d163      	bne.n	219c4 <nrfx_spim_xfer+0xe4>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
   218fc:	59ba      	ldr	r2, [r7, r6]
   218fe:	b12a      	cbz	r2, 2190c <nrfx_spim_xfer+0x2c>
   21900:	f015 0f14 	tst.w	r5, #20
                                        NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
        {
            p_cb->transfer_in_progress = true;
   21904:	bf04      	itt	eq
   21906:	2201      	moveq	r2, #1
   21908:	f888 201d 	strbeq.w	r2, [r8, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
   2190c:	eb07 0c06 	add.w	ip, r7, r6
   21910:	f10c 0c0c 	add.w	ip, ip, #12
   21914:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   21918:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

    set_ss_pin_state(p_cb, true);
   2191c:	2101      	movs	r1, #1
   2191e:	4640      	mov	r0, r8
   21920:	f003 ffe2 	bl	258e8 <set_ss_pin_state>
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   21924:	6821      	ldr	r1, [r4, #0]

    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   21926:	f8d9 3000 	ldr.w	r3, [r9]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   2192a:	b121      	cbz	r1, 21936 <nrfx_spim_xfer+0x56>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   2192c:	f001 4260 	and.w	r2, r1, #3758096384	; 0xe0000000
   21930:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   21934:	d106      	bne.n	21944 <nrfx_spim_xfer+0x64>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   21936:	68a2      	ldr	r2, [r4, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   21938:	b152      	cbz	r2, 21950 <nrfx_spim_xfer+0x70>
   2193a:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   2193e:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   21942:	d005      	beq.n	21950 <nrfx_spim_xfer+0x70>
        p_cb->transfer_in_progress = false;
   21944:	2300      	movs	r3, #0
   21946:	443e      	add	r6, r7
        return err_code;
   21948:	4820      	ldr	r0, [pc, #128]	; (219cc <nrfx_spim_xfer+0xec>)
        p_cb->transfer_in_progress = false;
   2194a:	7773      	strb	r3, [r6, #29]
}
   2194c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   21950:	6862      	ldr	r2, [r4, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21952:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21956:	f8c3 2548 	str.w	r2, [r3, #1352]	; 0x548
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   2195a:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
   2195e:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   21962:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21966:	2200      	movs	r2, #0
   21968:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   2196c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   21970:	f015 0201 	ands.w	r2, r5, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   21974:	bf18      	it	ne
   21976:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   21978:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   2197c:	f015 0202 	ands.w	r2, r5, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   21980:	bf18      	it	ne
   21982:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   21984:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   21988:	072a      	lsls	r2, r5, #28
   2198a:	d507      	bpl.n	2199c <nrfx_spim_xfer+0xbc>
    if (!p_cb->handler)
   2198c:	59ba      	ldr	r2, [r7, r6]
   2198e:	b972      	cbnz	r2, 219ae <nrfx_spim_xfer+0xce>
        set_ss_pin_state(p_cb, false);
   21990:	2100      	movs	r1, #0
   21992:	4640      	mov	r0, r8
   21994:	f003 ffa8 	bl	258e8 <set_ss_pin_state>
    return err_code;
   21998:	480d      	ldr	r0, [pc, #52]	; (219d0 <nrfx_spim_xfer+0xf0>)
   2199a:	e7d7      	b.n	2194c <nrfx_spim_xfer+0x6c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2199c:	2201      	movs	r2, #1
   2199e:	611a      	str	r2, [r3, #16]
    if (!p_cb->handler)
   219a0:	59ba      	ldr	r2, [r7, r6]
   219a2:	b922      	cbnz	r2, 219ae <nrfx_spim_xfer+0xce>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   219a4:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
            while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   219a8:	2a00      	cmp	r2, #0
   219aa:	d0fb      	beq.n	219a4 <nrfx_spim_xfer+0xc4>
   219ac:	e7f0      	b.n	21990 <nrfx_spim_xfer+0xb0>
    if (!enable)
   219ae:	f015 0f04 	tst.w	r5, #4
   219b2:	f04f 0240 	mov.w	r2, #64	; 0x40
   219b6:	d002      	beq.n	219be <nrfx_spim_xfer+0xde>
    p_reg->INTENCLR = mask;
   219b8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   219bc:	e7ec      	b.n	21998 <nrfx_spim_xfer+0xb8>
    p_reg->INTENSET = mask;
   219be:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   219c2:	e7e9      	b.n	21998 <nrfx_spim_xfer+0xb8>
        return err_code;
   219c4:	4803      	ldr	r0, [pc, #12]	; (219d4 <nrfx_spim_xfer+0xf4>)
   219c6:	e7c1      	b.n	2194c <nrfx_spim_xfer+0x6c>
   219c8:	2000b2f8 	.word	0x2000b2f8
   219cc:	0bad000a 	.word	0x0bad000a
   219d0:	0bad0000 	.word	0x0bad0000
   219d4:	0bad000b 	.word	0x0bad000b

000219d8 <nrfx_spim_3_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   219d8:	4b06      	ldr	r3, [pc, #24]	; (219f4 <nrfx_spim_3_irq_handler+0x1c>)
   219da:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
        nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
        return;
    }
#endif

    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   219de:	b13a      	cbz	r2, 219f0 <nrfx_spim_3_irq_handler+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   219e0:	2200      	movs	r2, #0
   219e2:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   219e6:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        }
#endif
        nrf_spim_event_clear(p_spim, NRF_SPIM_EVENT_END);
        NRFX_ASSERT(p_cb->handler);
        NRFX_LOG_DEBUG("Event: NRF_SPIM_EVENT_END.");
        finish_transfer(p_cb);
   219ea:	4803      	ldr	r0, [pc, #12]	; (219f8 <nrfx_spim_3_irq_handler+0x20>)
   219ec:	f003 bf8c 	b.w	25908 <finish_transfer>

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
}
   219f0:	4770      	bx	lr
   219f2:	bf00      	nop
   219f4:	4000c000 	.word	0x4000c000
   219f8:	2000b2f8 	.word	0x2000b2f8

000219fc <nrfx_spim_4_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   219fc:	4b06      	ldr	r3, [pc, #24]	; (21a18 <nrfx_spim_4_irq_handler+0x1c>)
   219fe:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   21a02:	b13a      	cbz	r2, 21a14 <nrfx_spim_4_irq_handler+0x18>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21a04:	2200      	movs	r2, #0
   21a06:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   21a0a:	f8d3 3118 	ldr.w	r3, [r3, #280]	; 0x118
        finish_transfer(p_cb);
   21a0e:	4803      	ldr	r0, [pc, #12]	; (21a1c <nrfx_spim_4_irq_handler+0x20>)
   21a10:	f003 bf7a 	b.w	25908 <finish_transfer>

#if NRFX_CHECK(NRFX_SPIM4_ENABLED)
void nrfx_spim_4_irq_handler(void)
{
    irq_handler(NRF_SPIM4, &m_cb[NRFX_SPIM4_INST_IDX]);
}
   21a14:	4770      	bx	lr
   21a16:	bf00      	nop
   21a18:	4000a000 	.word	0x4000a000
   21a1c:	2000b318 	.word	0x2000b318

00021a20 <nrfx_twim_init>:
    NRFX_ASSERT(p_config);
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   21a20:	f04f 0c34 	mov.w	ip, #52	; 0x34
{
   21a24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   21a28:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   21a2a:	4d46      	ldr	r5, [pc, #280]	; (21b44 <nrfx_twim_init+0x124>)
   21a2c:	fb0c fc06 	mul.w	ip, ip, r6
   21a30:	eb05 040c 	add.w	r4, r5, ip
{
   21a34:	469e      	mov	lr, r3
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   21a36:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
   21a3a:	2b00      	cmp	r3, #0
   21a3c:	d17d      	bne.n	21b3a <nrfx_twim_init+0x11a>
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   21a3e:	6807      	ldr	r7, [r0, #0]
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler         = event_handler;
    p_cb->p_context       = p_context;
    p_cb->int_mask        = 0;
   21a40:	60a3      	str	r3, [r4, #8]
    p_cb->handler         = event_handler;
   21a42:	f845 200c 	str.w	r2, [r5, ip]
    p_cb->p_context       = p_context;
   21a46:	f8c4 e004 	str.w	lr, [r4, #4]
    p_cb->repeated        = false;
   21a4a:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    p_cb->busy            = false;
   21a4e:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   21a52:	7b4b      	ldrb	r3, [r1, #13]
   21a54:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
    p_cb->skip_gpio_cfg   = p_config->skip_gpio_cfg;
   21a58:	f891 c00e 	ldrb.w	ip, [r1, #14]
   21a5c:	f884 c033 	strb.w	ip, [r4, #51]	; 0x33
    if (p_config->skip_gpio_cfg && p_config->skip_psel_cfg)
   21a60:	688b      	ldr	r3, [r1, #8]
   21a62:	f1bc 0f00 	cmp.w	ip, #0
   21a66:	d01c      	beq.n	21aa2 <nrfx_twim_init+0x82>
   21a68:	7bcc      	ldrb	r4, [r1, #15]
   21a6a:	b944      	cbnz	r4, 21a7e <nrfx_twim_init+0x5e>
    if (p_config->frequency >= NRF_TWIM_FREQ_1000K)
   21a6c:	f1b3 6f7f 	cmp.w	r3, #267386880	; 0xff00000
   21a70:	d24d      	bcs.n	21b0e <nrfx_twim_init+0xee>
        nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
   21a72:	e9d1 4300 	ldrd	r4, r3, [r1]
    p_reg->PSEL.SCL = scl_pin;
   21a76:	f8c7 4508 	str.w	r4, [r7, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   21a7a:	f8c7 350c 	str.w	r3, [r7, #1292]	; 0x50c
    if (!twim_pins_configure(p_twim, p_config))
    {
        return NRFX_ERROR_INVALID_PARAM;
    }

    nrf_twim_frequency_set(p_twim, (nrf_twim_frequency_t)p_config->frequency);
   21a7e:	688b      	ldr	r3, [r1, #8]
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   21a80:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524

    if (p_cb->handler)
   21a84:	b122      	cbz	r2, 21a90 <nrfx_twim_init+0x70>
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   21a86:	6800      	ldr	r0, [r0, #0]
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_twim),
            p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   21a88:	f340 3007 	sbfx	r0, r0, #12, #8
   21a8c:	f7fc fc20 	bl	1e2d0 <arch_irq_enable>
    }

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21a90:	2334      	movs	r3, #52	; 0x34
   21a92:	fb03 5506 	mla	r5, r3, r6, r5
   21a96:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   21a98:	482b      	ldr	r0, [pc, #172]	; (21b48 <nrfx_twim_init+0x128>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21a9a:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
}
   21a9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (p_config->frequency >= NRF_TWIM_FREQ_1000K)
   21aa2:	f1b3 6f7f 	cmp.w	r3, #267386880	; 0xff00000
   21aa6:	d345      	bcc.n	21b34 <nrfx_twim_init+0x114>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   21aa8:	680b      	ldr	r3, [r1, #0]
   21aaa:	2b22      	cmp	r3, #34	; 0x22
   21aac:	d139      	bne.n	21b22 <nrfx_twim_init+0x102>
   21aae:	684b      	ldr	r3, [r1, #4]
   21ab0:	2b23      	cmp	r3, #35	; 0x23
   21ab2:	d144      	bne.n	21b3e <nrfx_twim_init+0x11e>
   21ab4:	f04f 0c0b 	mov.w	ip, #11
        TWIM_PIN_INIT(p_config->scl, drive);
   21ab8:	680c      	ldr	r4, [r1, #0]
        case 0: return NRF_P0;
   21aba:	4b24      	ldr	r3, [pc, #144]	; (21b4c <nrfx_twim_init+0x12c>)
   21abc:	f8df 8090 	ldr.w	r8, [pc, #144]	; 21b50 <nrfx_twim_init+0x130>
    *p_pin = pin_number & 0x1F;
   21ac0:	f004 091f 	and.w	r9, r4, #31
    return pin_number >> 5;
   21ac4:	0964      	lsrs	r4, r4, #5
        case 0: return NRF_P0;
   21ac6:	2c01      	cmp	r4, #1
   21ac8:	bf0c      	ite	eq
   21aca:	469e      	moveq	lr, r3
   21acc:	46c6      	movne	lr, r8
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21ace:	eb0e 0e89 	add.w	lr, lr, r9, lsl #2
   21ad2:	f8de 4200 	ldr.w	r4, [lr, #512]	; 0x200
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
   21ad6:	ea4f 2c0c 	mov.w	ip, ip, lsl #8
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
   21ada:	f04c 0c0c 	orr.w	ip, ip, #12
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21ade:	f004 44e0 	and.w	r4, r4, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   21ae2:	ea44 040c 	orr.w	r4, r4, ip
    reg->PIN_CNF[pin_number] = cnf;
   21ae6:	f8ce 4200 	str.w	r4, [lr, #512]	; 0x200
        TWIM_PIN_INIT(p_config->sda, drive);
   21aea:	684c      	ldr	r4, [r1, #4]
    *p_pin = pin_number & 0x1F;
   21aec:	f004 0e1f 	and.w	lr, r4, #31
    return pin_number >> 5;
   21af0:	0964      	lsrs	r4, r4, #5
        case 0: return NRF_P0;
   21af2:	2c01      	cmp	r4, #1
   21af4:	bf18      	it	ne
   21af6:	4643      	movne	r3, r8
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   21af8:	eb03 038e 	add.w	r3, r3, lr, lsl #2
   21afc:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
   21b00:	f004 44e0 	and.w	r4, r4, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   21b04:	ea44 040c 	orr.w	r4, r4, ip
    reg->PIN_CNF[pin_number] = cnf;
   21b08:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
   21b0c:	e005      	b.n	21b1a <nrfx_twim_init+0xfa>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   21b0e:	680b      	ldr	r3, [r1, #0]
   21b10:	2b22      	cmp	r3, #34	; 0x22
   21b12:	d106      	bne.n	21b22 <nrfx_twim_init+0x102>
   21b14:	684b      	ldr	r3, [r1, #4]
   21b16:	2b23      	cmp	r3, #35	; 0x23
   21b18:	d111      	bne.n	21b3e <nrfx_twim_init+0x11e>
    if (!p_config->skip_psel_cfg)
   21b1a:	7bcb      	ldrb	r3, [r1, #15]
   21b1c:	2b00      	cmp	r3, #0
   21b1e:	d1ae      	bne.n	21a7e <nrfx_twim_init+0x5e>
   21b20:	e7a7      	b.n	21a72 <nrfx_twim_init+0x52>
        if (((p_config->scl != e0e1_pin_1) || (p_config->sda != e0e1_pin_2)) &&
   21b22:	2b23      	cmp	r3, #35	; 0x23
   21b24:	d10b      	bne.n	21b3e <nrfx_twim_init+0x11e>
            ((p_config->scl != e0e1_pin_2) || (p_config->sda != e0e1_pin_1)))
   21b26:	684b      	ldr	r3, [r1, #4]
   21b28:	2b22      	cmp	r3, #34	; 0x22
   21b2a:	d108      	bne.n	21b3e <nrfx_twim_init+0x11e>
    if (!p_config->skip_gpio_cfg)
   21b2c:	f1bc 0f00 	cmp.w	ip, #0
   21b30:	d1f3      	bne.n	21b1a <nrfx_twim_init+0xfa>
   21b32:	e7bf      	b.n	21ab4 <nrfx_twim_init+0x94>
        drive = NRF_GPIO_PIN_S0D1;
   21b34:	f04f 0c06 	mov.w	ip, #6
   21b38:	e7be      	b.n	21ab8 <nrfx_twim_init+0x98>
        return err_code;
   21b3a:	4806      	ldr	r0, [pc, #24]	; (21b54 <nrfx_twim_init+0x134>)
   21b3c:	e7af      	b.n	21a9e <nrfx_twim_init+0x7e>
        return NRFX_ERROR_INVALID_PARAM;
   21b3e:	4806      	ldr	r0, [pc, #24]	; (21b58 <nrfx_twim_init+0x138>)
   21b40:	e7ad      	b.n	21a9e <nrfx_twim_init+0x7e>
   21b42:	bf00      	nop
   21b44:	2000b338 	.word	0x2000b338
   21b48:	0bad0000 	.word	0x0bad0000
   21b4c:	40842800 	.word	0x40842800
   21b50:	40842500 	.word	0x40842500
   21b54:	0bad0005 	.word	0x0bad0005
   21b58:	0bad0004 	.word	0x0bad0004

00021b5c <nrfx_twim_enable>:
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   21b5c:	2106      	movs	r1, #6
void nrfx_twim_enable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);

    nrf_twim_enable(p_instance->p_twim);
   21b5e:	6803      	ldr	r3, [r0, #0]
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21b60:	7902      	ldrb	r2, [r0, #4]
   21b62:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500

    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   21b66:	2134      	movs	r1, #52	; 0x34
   21b68:	4b03      	ldr	r3, [pc, #12]	; (21b78 <nrfx_twim_enable+0x1c>)
   21b6a:	fb01 3302 	mla	r3, r1, r2, r3
   21b6e:	2202      	movs	r2, #2
   21b70:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance enabled: %d.", p_instance->drv_inst_idx);
}
   21b74:	4770      	bx	lr
   21b76:	bf00      	nop
   21b78:	2000b338 	.word	0x2000b338

00021b7c <nrfx_twim_disable>:

void nrfx_twim_disable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21b7c:	7901      	ldrb	r1, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   21b7e:	6802      	ldr	r2, [r0, #0]
    p_cb->int_mask = 0;
   21b80:	2034      	movs	r0, #52	; 0x34
   21b82:	4b0b      	ldr	r3, [pc, #44]	; (21bb0 <nrfx_twim_disable+0x34>)
   21b84:	fb00 3301 	mla	r3, r0, r1, r3
   21b88:	2100      	movs	r1, #0
    p_reg->INTENCLR = mask;
   21b8a:	480a      	ldr	r0, [pc, #40]	; (21bb4 <nrfx_twim_disable+0x38>)
   21b8c:	6099      	str	r1, [r3, #8]
   21b8e:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   21b92:	f8d2 0200 	ldr.w	r0, [r2, #512]	; 0x200
   21b96:	f420 50bc 	bic.w	r0, r0, #6016	; 0x1780
   21b9a:	f8c2 0200 	str.w	r0, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   21b9e:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    nrf_twim_shorts_disable(p_twim, NRF_TWIM_ALL_SHORTS_MASK);
    nrf_twim_disable(p_twim);

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21ba2:	2201      	movs	r2, #1
    p_cb->busy = false;
   21ba4:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   21ba8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance disabled: %d.", p_instance->drv_inst_idx);
}
   21bac:	4770      	bx	lr
   21bae:	bf00      	nop
   21bb0:	2000b338 	.word	0x2000b338
   21bb4:	019c0202 	.word	0x019c0202

00021bb8 <nrfx_twim_xfer>:
                            nrfx_twim_xfer_desc_t const * p_xfer_desc,
                            uint32_t                      flags)
{
    nrfx_err_t err_code = NRFX_SUCCESS;
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
    p_cb->error = false;
   21bb8:	2334      	movs	r3, #52	; 0x34


nrfx_err_t nrfx_twim_xfer(nrfx_twim_t           const * p_instance,
                          nrfx_twim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   21bba:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   21bbe:	4617      	mov	r7, r2
    p_cb->error = false;
   21bc0:	2200      	movs	r2, #0
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
                                     p_xfer_desc->primary_length,
                                     p_xfer_desc->secondary_length));

    nrfx_err_t err_code = NRFX_SUCCESS;
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   21bc2:	f890 e004 	ldrb.w	lr, [r0, #4]
    p_cb->error = false;
   21bc6:	f8df c2e4 	ldr.w	ip, [pc, #740]	; 21eac <nrfx_twim_xfer+0x2f4>
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   21bca:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
   21bcc:	fb03 c30e 	mla	r3, r3, lr, ip
   21bd0:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   21bd4:	684b      	ldr	r3, [r1, #4]
{
   21bd6:	460d      	mov	r5, r1
    if (p_xfer_desc->primary_length != 0 && !nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   21bd8:	b14b      	cbz	r3, 21bee <nrfx_twim_xfer+0x36>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   21bda:	68cb      	ldr	r3, [r1, #12]
   21bdc:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   21be0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   21be4:	d003      	beq.n	21bee <nrfx_twim_xfer+0x36>
        return err_code;
   21be6:	4eb2      	ldr	r6, [pc, #712]	; (21eb0 <nrfx_twim_xfer+0x2f8>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   21be8:	4630      	mov	r0, r6
   21bea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (p_cb->busy)
   21bee:	2634      	movs	r6, #52	; 0x34
   21bf0:	fb06 c60e 	mla	r6, r6, lr, ip
    p_reg->INTENCLR = mask;
   21bf4:	4baf      	ldr	r3, [pc, #700]	; (21eb4 <nrfx_twim_xfer+0x2fc>)
   21bf6:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
   21bfa:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
   21bfe:	f003 0aff 	and.w	sl, r3, #255	; 0xff
   21c02:	b123      	cbz	r3, 21c0e <nrfx_twim_xfer+0x56>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   21c04:	68b3      	ldr	r3, [r6, #8]
        return err_code;
   21c06:	4eac      	ldr	r6, [pc, #688]	; (21eb8 <nrfx_twim_xfer+0x300>)
    p_reg->INTENSET = mask;
   21c08:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   21c0c:	e7ec      	b.n	21be8 <nrfx_twim_xfer+0x30>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   21c0e:	f017 0f14 	tst.w	r7, #20
   21c12:	bf0c      	ite	eq
   21c14:	2301      	moveq	r3, #1
   21c16:	2300      	movne	r3, #0
    p_cb->xfer_desc = *p_xfer_desc;
   21c18:	46a9      	mov	r9, r5
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   21c1a:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
   21c1e:	f106 080c 	add.w	r8, r6, #12
   21c22:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
   21c26:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
   21c2a:	f8d9 3000 	ldr.w	r3, [r9]
    p_cb->flags = flags;
   21c2e:	6237      	str	r7, [r6, #32]
    p_cb->xfer_desc = *p_xfer_desc;
   21c30:	f8c8 3000 	str.w	r3, [r8]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   21c34:	f3c7 1300 	ubfx	r3, r7, #4, #1
   21c38:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   21c3c:	786b      	ldrb	r3, [r5, #1]
   21c3e:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21c42:	f8c4 a104 	str.w	sl, [r4, #260]	; 0x104
   21c46:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
   21c4a:	f8c4 a124 	str.w	sl, [r4, #292]	; 0x124
   21c4e:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
   21c52:	f8c4 a160 	str.w	sl, [r4, #352]	; 0x160
   21c56:	f8d4 3160 	ldr.w	r3, [r4, #352]	; 0x160
   21c5a:	f8c4 a148 	str.w	sl, [r4, #328]	; 0x148
   21c5e:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   21c62:	f017 0301 	ands.w	r3, r7, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   21c66:	bf18      	it	ne
   21c68:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   21c6a:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   21c6e:	f017 0302 	ands.w	r3, r7, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   21c72:	bf18      	it	ne
   21c74:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   21c76:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
   21c7a:	782b      	ldrb	r3, [r5, #0]
   21c7c:	2b03      	cmp	r3, #3
   21c7e:	f200 80b9 	bhi.w	21df4 <nrfx_twim_xfer+0x23c>
   21c82:	e8df f003 	tbb	[pc, r3]
   21c86:	a48b      	.short	0xa48b
   21c88:	026d      	.short	0x026d
   21c8a:	692b      	ldr	r3, [r5, #16]
   21c8c:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   21c90:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   21c94:	d1a7      	bne.n	21be6 <nrfx_twim_xfer+0x2e>
    p_reg->SHORTS = mask;
   21c96:	f44f 7380 	mov.w	r3, #256	; 0x100
   21c9a:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21c9e:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21ca0:	68ea      	ldr	r2, [r5, #12]
   21ca2:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21ca6:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21caa:	2300      	movs	r3, #0
   21cac:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   21cb0:	f8d4 2150 	ldr.w	r2, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21cb4:	2201      	movs	r2, #1
   21cb6:	6222      	str	r2, [r4, #32]
   21cb8:	60a2      	str	r2, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21cba:	f8d4 2150 	ldr.w	r2, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   21cbe:	2a00      	cmp	r2, #0
   21cc0:	d0fb      	beq.n	21cba <nrfx_twim_xfer+0x102>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21cc2:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   21cc6:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21cca:	692a      	ldr	r2, [r5, #16]
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   21ccc:	68ab      	ldr	r3, [r5, #8]
   21cce:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21cd2:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   21cd6:	2334      	movs	r3, #52	; 0x34
   21cd8:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   21cdc:	fb03 c30e 	mla	r3, r3, lr, ip
   21ce0:	609a      	str	r2, [r3, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   21ce2:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   21ce4:	4e75      	ldr	r6, [pc, #468]	; (21ebc <nrfx_twim_xfer+0x304>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   21ce6:	0738      	lsls	r0, r7, #28
   21ce8:	d407      	bmi.n	21cfa <nrfx_twim_xfer+0x142>
   21cea:	782a      	ldrb	r2, [r5, #0]
   21cec:	2a03      	cmp	r2, #3
   21cee:	d004      	beq.n	21cfa <nrfx_twim_xfer+0x142>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21cf0:	2201      	movs	r2, #1
   21cf2:	50e2      	str	r2, [r4, r3]
        if (p_xfer_desc->primary_length == 0)
   21cf4:	686b      	ldr	r3, [r5, #4]
   21cf6:	b903      	cbnz	r3, 21cfa <nrfx_twim_xfer+0x142>
   21cf8:	6162      	str	r2, [r4, #20]
    if (p_cb->handler)
   21cfa:	2334      	movs	r3, #52	; 0x34
   21cfc:	fb03 f30e 	mul.w	r3, r3, lr
   21d00:	f85c 1003 	ldr.w	r1, [ip, r3]
   21d04:	eb0c 0203 	add.w	r2, ip, r3
   21d08:	2900      	cmp	r1, #0
   21d0a:	d176      	bne.n	21dfa <nrfx_twim_xfer+0x242>
   21d0c:	2001      	movs	r0, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21d0e:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   21d12:	2b00      	cmp	r3, #0
   21d14:	f000 8089 	beq.w	21e2a <nrfx_twim_xfer+0x272>
   21d18:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21d1c:	2b00      	cmp	r3, #0
   21d1e:	f040 8087 	bne.w	21e30 <nrfx_twim_xfer+0x278>
   21d22:	f8d4 3124 	ldr.w	r3, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   21d26:	2b00      	cmp	r3, #0
   21d28:	f000 8095 	beq.w	21e56 <nrfx_twim_xfer+0x29e>
                transmission_finished = true;
   21d2c:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21d2e:	f8c4 1124 	str.w	r1, [r4, #292]	; 0x124
   21d32:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21d36:	f8d4 5160 	ldr.w	r5, [r4, #352]	; 0x160
    return p_reg->SHORTS;
   21d3a:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   21d3e:	2d00      	cmp	r5, #0
   21d40:	f000 8081 	beq.w	21e46 <nrfx_twim_xfer+0x28e>
   21d44:	f412 7f00 	tst.w	r2, #512	; 0x200
   21d48:	f402 7280 	and.w	r2, r2, #256	; 0x100
   21d4c:	d17e      	bne.n	21e4c <nrfx_twim_xfer+0x294>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21d4e:	6220      	str	r0, [r4, #32]
   21d50:	6160      	str	r0, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   21d52:	2a00      	cmp	r2, #0
   21d54:	d0db      	beq.n	21d0e <nrfx_twim_xfer+0x156>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21d56:	f8c4 1148 	str.w	r1, [r4, #328]	; 0x148
   21d5a:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
                    transmission_finished = false;
   21d5e:	e7d6      	b.n	21d0e <nrfx_twim_xfer+0x156>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21d60:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21d62:	68ea      	ldr	r2, [r5, #12]
   21d64:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21d68:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   21d6c:	692b      	ldr	r3, [r5, #16]
   21d6e:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   21d72:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   21d76:	f47f af36 	bne.w	21be6 <nrfx_twim_xfer+0x2e>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   21d7a:	68aa      	ldr	r2, [r5, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   21d7c:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
   21d80:	f44f 5384 	mov.w	r3, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
   21d84:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   21d88:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21d8c:	2334      	movs	r3, #52	; 0x34
   21d8e:	2202      	movs	r2, #2
   21d90:	fb03 c30e 	mla	r3, r3, lr, ip
   21d94:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21d96:	2301      	movs	r3, #1
   21d98:	6223      	str	r3, [r4, #32]
   21d9a:	e7a2      	b.n	21ce2 <nrfx_twim_xfer+0x12a>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21d9c:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   21d9e:	68ea      	ldr	r2, [r5, #12]
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   21da0:	f017 0f20 	tst.w	r7, #32
   21da4:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   21da8:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   21dac:	f04f 0334 	mov.w	r3, #52	; 0x34
   21db0:	d008      	beq.n	21dc4 <nrfx_twim_xfer+0x20c>
    p_reg->SHORTS = mask;
   21db2:	f44f 7280 	mov.w	r2, #256	; 0x100
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   21db6:	fb03 c30e 	mla	r3, r3, lr, ip
   21dba:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
   21dbe:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   21dc2:	e7e7      	b.n	21d94 <nrfx_twim_xfer+0x1dc>
   21dc4:	f44f 7200 	mov.w	r2, #512	; 0x200
   21dc8:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21dcc:	e7df      	b.n	21d8e <nrfx_twim_xfer+0x1d6>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   21dce:	686b      	ldr	r3, [r5, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   21dd0:	68ea      	ldr	r2, [r5, #12]
   21dd2:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   21dd6:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   21dda:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   21dde:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21de2:	2334      	movs	r3, #52	; 0x34
   21de4:	2202      	movs	r2, #2
   21de6:	fb03 c30e 	mla	r3, r3, lr, ip
   21dea:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21dec:	2301      	movs	r3, #1
   21dee:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
   21df0:	2300      	movs	r3, #0
   21df2:	e777      	b.n	21ce4 <nrfx_twim_xfer+0x12c>
    switch (p_xfer_desc->type)
   21df4:	2308      	movs	r3, #8
   21df6:	4e32      	ldr	r6, [pc, #200]	; (21ec0 <nrfx_twim_xfer+0x308>)
   21df8:	e775      	b.n	21ce6 <nrfx_twim_xfer+0x12e>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   21dfa:	0779      	lsls	r1, r7, #29
            p_cb->int_mask = 0;
   21dfc:	bf44      	itt	mi
   21dfe:	2300      	movmi	r3, #0
   21e00:	6093      	strmi	r3, [r2, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   21e02:	067a      	lsls	r2, r7, #25
   21e04:	d406      	bmi.n	21e14 <nrfx_twim_xfer+0x25c>
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   21e06:	2334      	movs	r3, #52	; 0x34
   21e08:	fb03 c30e 	mla	r3, r3, lr, ip
   21e0c:	689a      	ldr	r2, [r3, #8]
   21e0e:	f042 0202 	orr.w	r2, r2, #2
   21e12:	609a      	str	r2, [r3, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   21e14:	2334      	movs	r3, #52	; 0x34
   21e16:	fb03 c30e 	mla	r3, r3, lr, ip
   21e1a:	689a      	ldr	r2, [r3, #8]
   21e1c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
   21e20:	609a      	str	r2, [r3, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   21e22:	689b      	ldr	r3, [r3, #8]
    p_reg->INTENSET = mask;
   21e24:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   21e28:	e6de      	b.n	21be8 <nrfx_twim_xfer+0x30>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21e2a:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21e2e:	b123      	cbz	r3, 21e3a <nrfx_twim_xfer+0x282>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21e30:	f8c4 1104 	str.w	r1, [r4, #260]	; 0x104
   21e34:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21e38:	e773      	b.n	21d22 <nrfx_twim_xfer+0x16a>
   21e3a:	f8d4 2124 	ldr.w	r2, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   21e3e:	2a00      	cmp	r2, #0
   21e40:	f43f af65 	beq.w	21d0e <nrfx_twim_xfer+0x156>
   21e44:	e773      	b.n	21d2e <nrfx_twim_xfer+0x176>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21e46:	6220      	str	r0, [r4, #32]
   21e48:	6160      	str	r0, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   21e4a:	e760      	b.n	21d0e <nrfx_twim_xfer+0x156>
   21e4c:	2a00      	cmp	r2, #0
   21e4e:	d182      	bne.n	21d56 <nrfx_twim_xfer+0x19e>
        } while (!transmission_finished);
   21e50:	2b00      	cmp	r3, #0
   21e52:	f43f af5c 	beq.w	21d0e <nrfx_twim_xfer+0x156>
        p_cb->busy = false;
   21e56:	2134      	movs	r1, #52	; 0x34
   21e58:	2000      	movs	r0, #0
   21e5a:	fb01 c20e 	mla	r2, r1, lr, ip
    uint32_t error_source = p_reg->ERRORSRC;
   21e5e:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   21e62:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
   21e66:	f882 002f 	strb.w	r0, [r2, #47]	; 0x2f
        if (errorsrc)
   21e6a:	b18b      	cbz	r3, 21e90 <nrfx_twim_xfer+0x2d8>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   21e6c:	4a15      	ldr	r2, [pc, #84]	; (21ec4 <nrfx_twim_xfer+0x30c>)
   21e6e:	f013 0f01 	tst.w	r3, #1
   21e72:	4e15      	ldr	r6, [pc, #84]	; (21ec8 <nrfx_twim_xfer+0x310>)
   21e74:	bf18      	it	ne
   21e76:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   21e78:	f013 0f02 	tst.w	r3, #2
   21e7c:	f102 0201 	add.w	r2, r2, #1
   21e80:	bf18      	it	ne
   21e82:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   21e84:	f013 0f04 	tst.w	r3, #4
   21e88:	4b10      	ldr	r3, [pc, #64]	; (21ecc <nrfx_twim_xfer+0x314>)
   21e8a:	bf18      	it	ne
   21e8c:	461e      	movne	r6, r3
   21e8e:	e6ab      	b.n	21be8 <nrfx_twim_xfer+0x30>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   21e90:	067b      	lsls	r3, r7, #25
   21e92:	f53f aea9 	bmi.w	21be8 <nrfx_twim_xfer+0x30>
                !xfer_completeness_check(p_twim, p_cb))
   21e96:	4620      	mov	r0, r4
   21e98:	fb0e c101 	mla	r1, lr, r1, ip
   21e9c:	f003 fd43 	bl	25926 <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
   21ea0:	4b09      	ldr	r3, [pc, #36]	; (21ec8 <nrfx_twim_xfer+0x310>)
   21ea2:	2800      	cmp	r0, #0
   21ea4:	bf08      	it	eq
   21ea6:	461e      	moveq	r6, r3
   21ea8:	e69e      	b.n	21be8 <nrfx_twim_xfer+0x30>
   21eaa:	bf00      	nop
   21eac:	2000b338 	.word	0x2000b338
   21eb0:	0bad000a 	.word	0x0bad000a
   21eb4:	019c0202 	.word	0x019c0202
   21eb8:	0bad000b 	.word	0x0bad000b
   21ebc:	0bad0000 	.word	0x0bad0000
   21ec0:	0bad0004 	.word	0x0bad0004
   21ec4:	0bae0000 	.word	0x0bae0000
   21ec8:	0bad0001 	.word	0x0bad0001
   21ecc:	0bae0002 	.word	0x0bae0002

00021ed0 <nrfx_twim_1_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM1_ENABLED)
void nrfx_twim_1_irq_handler(void)
{
   21ed0:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21ed2:	4d5a      	ldr	r5, [pc, #360]	; (2203c <nrfx_twim_1_irq_handler+0x16c>)
   21ed4:	4c5a      	ldr	r4, [pc, #360]	; (22040 <nrfx_twim_1_irq_handler+0x170>)
   21ed6:	f8d5 3124 	ldr.w	r3, [r5, #292]	; 0x124
   21eda:	b087      	sub	sp, #28
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   21edc:	b1fb      	cbz	r3, 21f1e <nrfx_twim_1_irq_handler+0x4e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21ede:	2300      	movs	r3, #0
   21ee0:	f8c5 3124 	str.w	r3, [r5, #292]	; 0x124
   21ee4:	f8d5 3124 	ldr.w	r3, [r5, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21ee8:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21eec:	b9bb      	cbnz	r3, 21f1e <nrfx_twim_1_irq_handler+0x4e>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   21eee:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   21ef0:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   21ef4:	2302      	movs	r3, #2
   21ef6:	60a3      	str	r3, [r4, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   21ef8:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   21efa:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21efe:	f8d5 3160 	ldr.w	r3, [r5, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   21f02:	b11b      	cbz	r3, 21f0c <nrfx_twim_1_irq_handler+0x3c>
    return p_reg->SHORTS;
   21f04:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
   21f08:	059e      	lsls	r6, r3, #22
   21f0a:	d403      	bmi.n	21f14 <nrfx_twim_1_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   21f0c:	2201      	movs	r2, #1
   21f0e:	4b4b      	ldr	r3, [pc, #300]	; (2203c <nrfx_twim_1_irq_handler+0x16c>)
   21f10:	621a      	str	r2, [r3, #32]
   21f12:	615a      	str	r2, [r3, #20]
            p_cb->error = true;
   21f14:	2301      	movs	r3, #1
   21f16:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
    twim_irq_handler(NRF_TWIM1, &m_cb[NRFX_TWIM1_INST_IDX]);
}
   21f1a:	b007      	add	sp, #28
   21f1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   21f1e:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   21f22:	2b00      	cmp	r3, #0
   21f24:	d05a      	beq.n	21fdc <nrfx_twim_1_irq_handler+0x10c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21f26:	2300      	movs	r3, #0
   21f28:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   21f2c:	6a27      	ldr	r7, [r4, #32]
   21f2e:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
   21f32:	067d      	lsls	r5, r7, #25
   21f34:	d40a      	bmi.n	21f4c <nrfx_twim_1_irq_handler+0x7c>
   21f36:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   21f3a:	b93b      	cbnz	r3, 21f4c <nrfx_twim_1_irq_handler+0x7c>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   21f3c:	4940      	ldr	r1, [pc, #256]	; (22040 <nrfx_twim_1_irq_handler+0x170>)
   21f3e:	483f      	ldr	r0, [pc, #252]	; (2203c <nrfx_twim_1_irq_handler+0x16c>)
   21f40:	f003 fcf1 	bl	25926 <xfer_completeness_check>
   21f44:	f080 0001 	eor.w	r0, r0, #1
   21f48:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   21f4c:	f017 0704 	ands.w	r7, r7, #4
            if (!p_cb->repeated || p_cb->error)
   21f50:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   21f54:	d120      	bne.n	21f98 <nrfx_twim_1_irq_handler+0xc8>
            event.xfer_desc = p_cb->xfer_desc;
   21f56:	4e3b      	ldr	r6, [pc, #236]	; (22044 <nrfx_twim_1_irq_handler+0x174>)
   21f58:	ad01      	add	r5, sp, #4
   21f5a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   21f5c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   21f5e:	6833      	ldr	r3, [r6, #0]
   21f60:	602b      	str	r3, [r5, #0]
   21f62:	4b36      	ldr	r3, [pc, #216]	; (2203c <nrfx_twim_1_irq_handler+0x16c>)
   21f64:	f8c3 7160 	str.w	r7, [r3, #352]	; 0x160
   21f68:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
   21f6c:	f8c3 715c 	str.w	r7, [r3, #348]	; 0x15c
   21f70:	f8d3 215c 	ldr.w	r2, [r3, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
   21f74:	f1bc 0f00 	cmp.w	ip, #0
   21f78:	d002      	beq.n	21f80 <nrfx_twim_1_irq_handler+0xb0>
   21f7a:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
   21f7e:	b15a      	cbz	r2, 21f98 <nrfx_twim_1_irq_handler+0xc8>
    p_reg->SHORTS = mask;
   21f80:	2200      	movs	r2, #0
   21f82:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                p_cb->int_mask = 0;
   21f86:	60a2      	str	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   21f88:	4a2f      	ldr	r2, [pc, #188]	; (22048 <nrfx_twim_1_irq_handler+0x178>)
   21f8a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   21f8e:	f44f 7200 	mov.w	r2, #512	; 0x200
   21f92:	4b2e      	ldr	r3, [pc, #184]	; (2204c <nrfx_twim_1_irq_handler+0x17c>)
   21f94:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    uint32_t error_source = p_reg->ERRORSRC;
   21f98:	4a28      	ldr	r2, [pc, #160]	; (2203c <nrfx_twim_1_irq_handler+0x16c>)
   21f9a:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   21f9e:	0798      	lsls	r0, r3, #30
    p_reg->ERRORSRC = error_source;
   21fa0:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
   21fa4:	d443      	bmi.n	2202e <nrfx_twim_1_irq_handler+0x15e>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   21fa6:	0759      	lsls	r1, r3, #29
   21fa8:	d443      	bmi.n	22032 <nrfx_twim_1_irq_handler+0x162>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   21faa:	07da      	lsls	r2, r3, #31
   21fac:	d443      	bmi.n	22036 <nrfx_twim_1_irq_handler+0x166>
    else if (p_cb->error)
   21fae:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   21fb2:	009b      	lsls	r3, r3, #2
   21fb4:	b2db      	uxtb	r3, r3
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   21fb6:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
   21fba:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   21fbe:	b90b      	cbnz	r3, 21fc4 <nrfx_twim_1_irq_handler+0xf4>
        p_cb->busy = false;
   21fc0:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   21fc4:	6a23      	ldr	r3, [r4, #32]
   21fc6:	075b      	lsls	r3, r3, #29
   21fc8:	d503      	bpl.n	21fd2 <nrfx_twim_1_irq_handler+0x102>
   21fca:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   21fce:	2b00      	cmp	r3, #0
   21fd0:	d0a3      	beq.n	21f1a <nrfx_twim_1_irq_handler+0x4a>
        p_cb->handler(&event, p_cb->p_context);
   21fd2:	e9d4 3100 	ldrd	r3, r1, [r4]
   21fd6:	4668      	mov	r0, sp
   21fd8:	4798      	blx	r3
}
   21fda:	e79e      	b.n	21f1a <nrfx_twim_1_irq_handler+0x4a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   21fdc:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
   21fe0:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   21fe4:	7b23      	ldrb	r3, [r4, #12]
   21fe6:	b983      	cbnz	r3, 2200a <nrfx_twim_1_irq_handler+0x13a>
            event.xfer_desc = p_cb->xfer_desc;
   21fe8:	4f16      	ldr	r7, [pc, #88]	; (22044 <nrfx_twim_1_irq_handler+0x174>)
   21fea:	ae01      	add	r6, sp, #4
   21fec:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   21fee:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   21ff0:	683b      	ldr	r3, [r7, #0]
   21ff2:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
   21ff4:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   21ff8:	2b00      	cmp	r3, #0
   21ffa:	d1cd      	bne.n	21f98 <nrfx_twim_1_irq_handler+0xc8>
    p_reg->SHORTS = mask;
   21ffc:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
                p_cb->int_mask = 0;
   22000:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   22002:	4b11      	ldr	r3, [pc, #68]	; (22048 <nrfx_twim_1_irq_handler+0x178>)
   22004:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
   22008:	e7c1      	b.n	21f8e <nrfx_twim_1_irq_handler+0xbe>
    p_reg->SHORTS = mask;
   2200a:	f44f 7300 	mov.w	r3, #512	; 0x200
   2200e:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   22012:	f240 2302 	movw	r3, #514	; 0x202
   22016:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   22018:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   2201c:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   22020:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   22022:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   22026:	2301      	movs	r3, #1
   22028:	60ab      	str	r3, [r5, #8]
   2202a:	622b      	str	r3, [r5, #32]
            return;
   2202c:	e775      	b.n	21f1a <nrfx_twim_1_irq_handler+0x4a>
   2202e:	2301      	movs	r3, #1
   22030:	e7c1      	b.n	21fb6 <nrfx_twim_1_irq_handler+0xe6>
   22032:	2302      	movs	r3, #2
   22034:	e7bf      	b.n	21fb6 <nrfx_twim_1_irq_handler+0xe6>
   22036:	2303      	movs	r3, #3
   22038:	e7bd      	b.n	21fb6 <nrfx_twim_1_irq_handler+0xe6>
   2203a:	bf00      	nop
   2203c:	40009000 	.word	0x40009000
   22040:	2000b338 	.word	0x2000b338
   22044:	2000b344 	.word	0x2000b344
   22048:	019c0202 	.word	0x019c0202
   2204c:	e000e100 	.word	0xe000e100

00022050 <ep_state_access>:
 * @param ep Endpoint number.
 */
static inline usbd_ep_state_t* ep_state_access(nrfx_usbd_ep_t ep)
{
    NRFX_USBD_ASSERT_EP_VALID(ep);
    return ((NRF_USBD_EPIN_CHECK(ep) ? m_ep_state.ep_in : m_ep_state.ep_out) +
   22050:	4b05      	ldr	r3, [pc, #20]	; (22068 <ep_state_access+0x18>)
   22052:	f010 0f80 	tst.w	r0, #128	; 0x80
   22056:	f1a3 0290 	sub.w	r2, r3, #144	; 0x90
   2205a:	bf08      	it	eq
   2205c:	4613      	moveq	r3, r2
        NRF_USBD_EP_NR_GET(ep));
   2205e:	f000 000f 	and.w	r0, r0, #15
}
   22062:	eb03 1000 	add.w	r0, r3, r0, lsl #4
   22066:	4770      	bx	lr
   22068:	2000b514 	.word	0x2000b514

0002206c <ev_usbreset_handler>:
 * @{
 */

static void ev_usbreset_handler(void)
{
    m_bus_suspend = false;
   2206c:	2300      	movs	r3, #0
{
   2206e:	b507      	push	{r0, r1, r2, lr}
    m_bus_suspend = false;
   22070:	4a06      	ldr	r2, [pc, #24]	; (2208c <ev_usbreset_handler+0x20>)

    const nrfx_usbd_evt_t evt = {
            .type = NRFX_USBD_EVT_RESET
    };

    m_event_handler(&evt);
   22072:	a801      	add	r0, sp, #4
    m_bus_suspend = false;
   22074:	7013      	strb	r3, [r2, #0]
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   22076:	4a06      	ldr	r2, [pc, #24]	; (22090 <ev_usbreset_handler+0x24>)
   22078:	7013      	strb	r3, [r2, #0]
    const nrfx_usbd_evt_t evt = {
   2207a:	2301      	movs	r3, #1
   2207c:	9301      	str	r3, [sp, #4]
    m_event_handler(&evt);
   2207e:	4b05      	ldr	r3, [pc, #20]	; (22094 <ev_usbreset_handler+0x28>)
   22080:	681b      	ldr	r3, [r3, #0]
   22082:	4798      	blx	r3
}
   22084:	b003      	add	sp, #12
   22086:	f85d fb04 	ldr.w	pc, [sp], #4
   2208a:	bf00      	nop
   2208c:	2000b629 	.word	0x2000b629
   22090:	2000b628 	.word	0x2000b628
   22094:	2000b5ac 	.word	0x2000b5ac

00022098 <ev_usbevent_handler>:
    };
    m_event_handler(&evt);
}

static void ev_usbevent_handler(void)
{
   22098:	b513      	push	{r0, r1, r4, lr}
    return p_reg->EVENTCAUSE;
   2209a:	4b19      	ldr	r3, [pc, #100]	; (22100 <ev_usbevent_handler+0x68>)
   2209c:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
    p_reg->EVENTCAUSE = flags;
   220a0:	f8c3 4400 	str.w	r4, [r3, #1024]	; 0x400
    if (event & NRF_USBD_EVENTCAUSE_ISOOUTCRC_MASK)
    {
        NRFX_LOG_DEBUG("USBD event: ISOOUTCRC");
        /* Currently no support */
    }
    if (event & NRF_USBD_EVENTCAUSE_SUSPEND_MASK)
   220a4:	05e1      	lsls	r1, r4, #23
    (void) p_reg->EVENTCAUSE;
   220a6:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
   220aa:	d508      	bpl.n	220be <ev_usbevent_handler+0x26>
    {
        NRFX_LOG_DEBUG("USBD event: SUSPEND");
        m_bus_suspend = true;
   220ac:	2201      	movs	r2, #1
   220ae:	4b15      	ldr	r3, [pc, #84]	; (22104 <ev_usbevent_handler+0x6c>)
        const nrfx_usbd_evt_t evt = {
                .type = NRFX_USBD_EVT_SUSPEND
        };
        m_event_handler(&evt);
   220b0:	a801      	add	r0, sp, #4
        m_bus_suspend = true;
   220b2:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
   220b4:	2302      	movs	r3, #2
   220b6:	9301      	str	r3, [sp, #4]
        m_event_handler(&evt);
   220b8:	4b13      	ldr	r3, [pc, #76]	; (22108 <ev_usbevent_handler+0x70>)
   220ba:	681b      	ldr	r3, [r3, #0]
   220bc:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   220be:	05a2      	lsls	r2, r4, #22
   220c0:	d508      	bpl.n	220d4 <ev_usbevent_handler+0x3c>
    {
        NRFX_LOG_DEBUG("USBD event: RESUME");
        m_bus_suspend = false;
   220c2:	2200      	movs	r2, #0
   220c4:	4b0f      	ldr	r3, [pc, #60]	; (22104 <ev_usbevent_handler+0x6c>)
        const nrfx_usbd_evt_t evt = {
                .type = NRFX_USBD_EVT_RESUME
        };
        m_event_handler(&evt);
   220c6:	a801      	add	r0, sp, #4
        m_bus_suspend = false;
   220c8:	701a      	strb	r2, [r3, #0]
        const nrfx_usbd_evt_t evt = {
   220ca:	2303      	movs	r3, #3
   220cc:	9301      	str	r3, [sp, #4]
        m_event_handler(&evt);
   220ce:	4b0e      	ldr	r3, [pc, #56]	; (22108 <ev_usbevent_handler+0x70>)
   220d0:	681b      	ldr	r3, [r3, #0]
   220d2:	4798      	blx	r3
    }
    if (event & NRF_USBD_EVENTCAUSE_WUREQ_MASK)
   220d4:	0563      	lsls	r3, r4, #21
   220d6:	d510      	bpl.n	220fa <ev_usbevent_handler+0x62>
    {
        NRFX_LOG_DEBUG("USBD event: WUREQ (%s)", m_bus_suspend ? "In Suspend" : "Active");
        if (m_bus_suspend)
   220d8:	4b0a      	ldr	r3, [pc, #40]	; (22104 <ev_usbevent_handler+0x6c>)
   220da:	781a      	ldrb	r2, [r3, #0]
   220dc:	b16a      	cbz	r2, 220fa <ev_usbevent_handler+0x62>
        {
            NRFX_ASSERT(!nrf_usbd_lowpower_check(NRF_USBD));
            m_bus_suspend = false;
   220de:	2200      	movs	r2, #0
   220e0:	701a      	strb	r2, [r3, #0]
    p_reg->DPDMVALUE = ((uint32_t)val) << USBD_DPDMVALUE_STATE_Pos;
   220e2:	2201      	movs	r2, #1
   220e4:	4b06      	ldr	r3, [pc, #24]	; (22100 <ev_usbevent_handler+0x68>)
            nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_DRIVEDPDM);

            const nrfx_usbd_evt_t evt = {
                    .type = NRFX_USBD_EVT_WUREQ
            };
            m_event_handler(&evt);
   220e6:	a801      	add	r0, sp, #4
   220e8:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   220ec:	659a      	str	r2, [r3, #88]	; 0x58
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   220ee:	6d9b      	ldr	r3, [r3, #88]	; 0x58
            const nrfx_usbd_evt_t evt = {
   220f0:	2304      	movs	r3, #4
   220f2:	9301      	str	r3, [sp, #4]
            m_event_handler(&evt);
   220f4:	4b04      	ldr	r3, [pc, #16]	; (22108 <ev_usbevent_handler+0x70>)
   220f6:	681b      	ldr	r3, [r3, #0]
   220f8:	4798      	blx	r3
        }
    }
}
   220fa:	b002      	add	sp, #8
   220fc:	bd10      	pop	{r4, pc}
   220fe:	bf00      	nop
   22100:	40036000 	.word	0x40036000
   22104:	2000b629 	.word	0x2000b629
   22108:	2000b5ac 	.word	0x2000b5ac

0002210c <nrfx_usbd_feeder_flash>:
{
   2210c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2210e:	684b      	ldr	r3, [r1, #4]
   22110:	4606      	mov	r6, r0
   22112:	429a      	cmp	r2, r3
   22114:	bf28      	it	cs
   22116:	461a      	movcs	r2, r3
   22118:	4615      	mov	r5, r2
   2211a:	460c      	mov	r4, r1
    memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   2211c:	4f08      	ldr	r7, [pc, #32]	; (22140 <nrfx_usbd_feeder_flash+0x34>)
   2211e:	6809      	ldr	r1, [r1, #0]
   22120:	4638      	mov	r0, r7
   22122:	f002 ff56 	bl	24fd2 <memcpy>
    p_next->size = tx_size;
   22126:	e9c6 7500 	strd	r7, r5, [r6]
    p_transfer->size -= tx_size;
   2212a:	6860      	ldr	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
   2212c:	6823      	ldr	r3, [r4, #0]
    p_transfer->size -= tx_size;
   2212e:	1b40      	subs	r0, r0, r5
    p_transfer->p_data.addr += tx_size;
   22130:	442b      	add	r3, r5
    p_transfer->size -= tx_size;
   22132:	6060      	str	r0, [r4, #4]
    p_transfer->p_data.addr += tx_size;
   22134:	6023      	str	r3, [r4, #0]
}
   22136:	3800      	subs	r0, #0
   22138:	bf18      	it	ne
   2213a:	2001      	movne	r0, #1
   2213c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2213e:	bf00      	nop
   22140:	2000b36c 	.word	0x2000b36c

00022144 <nrfx_usbd_feeder_flash_zlp>:
{
   22144:	b570      	push	{r4, r5, r6, lr}
   22146:	684b      	ldr	r3, [r1, #4]
   22148:	4606      	mov	r6, r0
   2214a:	429a      	cmp	r2, r3
   2214c:	bf28      	it	cs
   2214e:	461a      	movcs	r2, r3
   22150:	460d      	mov	r5, r1
   22152:	4614      	mov	r4, r2
    if (tx_size != 0)
   22154:	b18a      	cbz	r2, 2217a <nrfx_usbd_feeder_flash_zlp+0x36>
        memcpy(p_buffer, (p_transfer->p_data.tx), tx_size);
   22156:	6809      	ldr	r1, [r1, #0]
   22158:	4809      	ldr	r0, [pc, #36]	; (22180 <nrfx_usbd_feeder_flash_zlp+0x3c>)
   2215a:	f002 ff3a 	bl	24fd2 <memcpy>
        p_next->p_data.tx = p_buffer;
   2215e:	4b08      	ldr	r3, [pc, #32]	; (22180 <nrfx_usbd_feeder_flash_zlp+0x3c>)
    p_next->size = tx_size;
   22160:	e9c6 3400 	strd	r3, r4, [r6]
    p_transfer->size -= tx_size;
   22164:	686b      	ldr	r3, [r5, #4]
}
   22166:	1e20      	subs	r0, r4, #0
    p_transfer->size -= tx_size;
   22168:	eba3 0304 	sub.w	r3, r3, r4
   2216c:	606b      	str	r3, [r5, #4]
    p_transfer->p_data.addr += tx_size;
   2216e:	682b      	ldr	r3, [r5, #0]
}
   22170:	bf18      	it	ne
   22172:	2001      	movne	r0, #1
    p_transfer->p_data.addr += tx_size;
   22174:	4423      	add	r3, r4
   22176:	602b      	str	r3, [r5, #0]
}
   22178:	bd70      	pop	{r4, r5, r6, pc}
   2217a:	4613      	mov	r3, r2
   2217c:	e7f0      	b.n	22160 <nrfx_usbd_feeder_flash_zlp+0x1c>
   2217e:	bf00      	nop
   22180:	2000b36c 	.word	0x2000b36c

00022184 <ev_sof_handler>:
    nrfx_usbd_evt_t evt =  {
   22184:	2300      	movs	r3, #0
{
   22186:	b507      	push	{r0, r1, r2, lr}
    nrfx_usbd_evt_t evt =  {
   22188:	f88d 3004 	strb.w	r3, [sp, #4]
    return p_reg->FRAMECNTR;
   2218c:	4b0b      	ldr	r3, [pc, #44]	; (221bc <ev_sof_handler+0x38>)
    m_event_handler(&evt);
   2218e:	a801      	add	r0, sp, #4
   22190:	f8d3 2520 	ldr.w	r2, [r3, #1312]	; 0x520
            .data = { .sof = { .framecnt = (uint16_t)nrf_usbd_framecntr_get(NRF_USBD) }}
   22194:	f8ad 2006 	strh.w	r2, [sp, #6]
    size_t size_isoout = p_reg->SIZE.ISOOUT;
   22198:	f8d3 34c0 	ldr.w	r3, [r3, #1216]	; 0x4c0
    m_ep_ready |= iso_ready_mask;
   2219c:	4a08      	ldr	r2, [pc, #32]	; (221c0 <ev_sof_handler+0x3c>)
    uint32_t iso_ready_mask = (1U << ep2bit(NRFX_USBD_EPIN8));
   2219e:	2b00      	cmp	r3, #0
   221a0:	bf14      	ite	ne
   221a2:	f04f 2101 	movne.w	r1, #16777472	; 0x1000100
   221a6:	f44f 7180 	moveq.w	r1, #256	; 0x100
    m_ep_ready |= iso_ready_mask;
   221aa:	6813      	ldr	r3, [r2, #0]
   221ac:	430b      	orrs	r3, r1
   221ae:	6013      	str	r3, [r2, #0]
    m_event_handler(&evt);
   221b0:	4b04      	ldr	r3, [pc, #16]	; (221c4 <ev_sof_handler+0x40>)
   221b2:	681b      	ldr	r3, [r3, #0]
   221b4:	4798      	blx	r3
}
   221b6:	b003      	add	sp, #12
   221b8:	f85d fb04 	ldr.w	pc, [sp], #4
   221bc:	40036000 	.word	0x40036000
   221c0:	2000b5a8 	.word	0x2000b5a8
   221c4:	2000b5ac 	.word	0x2000b5ac

000221c8 <atomic_and.constprop.0.isra.0>:
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   221c8:	4b04      	ldr	r3, [pc, #16]	; (221dc <atomic_and.constprop.0.isra.0+0x14>)
   221ca:	e8d3 1fef 	ldaex	r1, [r3]
   221ce:	4001      	ands	r1, r0
   221d0:	e8c3 1fe2 	stlex	r2, r1, [r3]
   221d4:	2a00      	cmp	r2, #0
   221d6:	d1f8      	bne.n	221ca <atomic_and.constprop.0.isra.0+0x2>
}
   221d8:	4770      	bx	lr
   221da:	bf00      	nop
   221dc:	2000b5a4 	.word	0x2000b5a4

000221e0 <nrf_usbd_epin_dma_handler>:
    m_dma_pending = false;
   221e0:	2200      	movs	r2, #0
{
   221e2:	b508      	push	{r3, lr}
    m_dma_pending = false;
   221e4:	4b0b      	ldr	r3, [pc, #44]	; (22214 <nrf_usbd_epin_dma_handler+0x34>)
{
   221e6:	4601      	mov	r1, r0
    m_dma_pending = false;
   221e8:	701a      	strb	r2, [r3, #0]
    usbd_ep_state_t * p_state = ep_state_access(ep);
   221ea:	f7ff ff31 	bl	22050 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   221ee:	7b83      	ldrb	r3, [r0, #14]
   221f0:	2b03      	cmp	r3, #3
   221f2:	d10a      	bne.n	2220a <nrf_usbd_epin_dma_handler+0x2a>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   221f4:	4608      	mov	r0, r1
   221f6:	f003 fc05 	bl	25a04 <ep2bit>
   221fa:	2301      	movs	r3, #1
   221fc:	fa03 f000 	lsl.w	r0, r3, r0
   22200:	43c0      	mvns	r0, r0
}
   22202:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22206:	f7ff bfdf 	b.w	221c8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   2220a:	6803      	ldr	r3, [r0, #0]
   2220c:	2b00      	cmp	r3, #0
   2220e:	d0f1      	beq.n	221f4 <nrf_usbd_epin_dma_handler+0x14>
}
   22210:	bd08      	pop	{r3, pc}
   22212:	bf00      	nop
   22214:	2000b627 	.word	0x2000b627

00022218 <nrf_usbd_ep0in_dma_handler>:
    m_dma_pending = false;
   22218:	2200      	movs	r2, #0
   2221a:	4b08      	ldr	r3, [pc, #32]	; (2223c <nrf_usbd_ep0in_dma_handler+0x24>)
   2221c:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   2221e:	4b08      	ldr	r3, [pc, #32]	; (22240 <nrf_usbd_ep0in_dma_handler+0x28>)
   22220:	f893 209e 	ldrb.w	r2, [r3, #158]	; 0x9e
   22224:	2a03      	cmp	r2, #3
   22226:	d103      	bne.n	22230 <nrf_usbd_ep0in_dma_handler+0x18>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22228:	f06f 0001 	mvn.w	r0, #1
   2222c:	f7ff bfcc 	b.w	221c8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   22230:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   22234:	2b00      	cmp	r3, #0
   22236:	d0f7      	beq.n	22228 <nrf_usbd_ep0in_dma_handler+0x10>
}
   22238:	4770      	bx	lr
   2223a:	bf00      	nop
   2223c:	2000b627 	.word	0x2000b627
   22240:	2000b484 	.word	0x2000b484

00022244 <usbd_ep_data_handler>:
    m_ep_ready |= (1U << bitpos);
   22244:	2201      	movs	r2, #1
{
   22246:	b573      	push	{r0, r1, r4, r5, r6, lr}
    m_ep_ready |= (1U << bitpos);
   22248:	fa02 f501 	lsl.w	r5, r2, r1
   2224c:	491c      	ldr	r1, [pc, #112]	; (222c0 <usbd_ep_data_handler+0x7c>)
    if (NRF_USBD_EPIN_CHECK(ep))
   2224e:	f010 0f80 	tst.w	r0, #128	; 0x80
    m_ep_ready |= (1U << bitpos);
   22252:	680b      	ldr	r3, [r1, #0]
{
   22254:	4604      	mov	r4, r0
    m_ep_ready |= (1U << bitpos);
   22256:	ea43 0305 	orr.w	r3, r3, r5
   2225a:	4e1a      	ldr	r6, [pc, #104]	; (222c4 <usbd_ep_data_handler+0x80>)
   2225c:	600b      	str	r3, [r1, #0]
    if (NRF_USBD_EPIN_CHECK(ep))
   2225e:	d024      	beq.n	222aa <usbd_ep_data_handler+0x66>
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   22260:	4b19      	ldr	r3, [pc, #100]	; (222c8 <usbd_ep_data_handler+0x84>)
   22262:	f000 020f 	and.w	r2, r0, #15
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   22266:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   2226a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2226e:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   22272:	681a      	ldr	r2, [r3, #0]
    if (ret)
   22274:	b132      	cbz	r2, 22284 <usbd_ep_data_handler+0x40>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   22276:	2200      	movs	r2, #0
            if (ep != NRFX_USBD_EPIN0)
   22278:	2880      	cmp	r0, #128	; 0x80
   2227a:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   2227c:	681b      	ldr	r3, [r3, #0]
   2227e:	d011      	beq.n	222a4 <usbd_ep_data_handler+0x60>
                nrf_usbd_epin_dma_handler(ep);
   22280:	f7ff ffae 	bl	221e0 <nrf_usbd_epin_dma_handler>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   22284:	6833      	ldr	r3, [r6, #0]
   22286:	402b      	ands	r3, r5
   22288:	d10a      	bne.n	222a0 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2228a:	2206      	movs	r2, #6
   2228c:	f88d 4006 	strb.w	r4, [sp, #6]
   22290:	f88d 2004 	strb.w	r2, [sp, #4]
   22294:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
   22298:	4b0c      	ldr	r3, [pc, #48]	; (222cc <usbd_ep_data_handler+0x88>)
   2229a:	a801      	add	r0, sp, #4
   2229c:	681b      	ldr	r3, [r3, #0]
   2229e:	4798      	blx	r3
}
   222a0:	b002      	add	sp, #8
   222a2:	bd70      	pop	{r4, r5, r6, pc}
                nrf_usbd_ep0in_dma_handler();
   222a4:	f7ff ffb8 	bl	22218 <nrf_usbd_ep0in_dma_handler>
   222a8:	e7ec      	b.n	22284 <usbd_ep_data_handler+0x40>
        if (0 == (m_ep_dma_waiting & (1U << bitpos)))
   222aa:	6833      	ldr	r3, [r6, #0]
   222ac:	421d      	tst	r5, r3
   222ae:	d1f7      	bne.n	222a0 <usbd_ep_data_handler+0x5c>
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_WAITING);
   222b0:	2306      	movs	r3, #6
   222b2:	f88d 0006 	strb.w	r0, [sp, #6]
   222b6:	f88d 3004 	strb.w	r3, [sp, #4]
   222ba:	f88d 2007 	strb.w	r2, [sp, #7]
   222be:	e7eb      	b.n	22298 <usbd_ep_data_handler+0x54>
   222c0:	2000b5a8 	.word	0x2000b5a8
   222c4:	2000b5a4 	.word	0x2000b5a4
   222c8:	0002699a 	.word	0x0002699a
   222cc:	2000b5ac 	.word	0x2000b5ac

000222d0 <ev_setup_data_handler>:
{
   222d0:	b508      	push	{r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   222d2:	4b05      	ldr	r3, [pc, #20]	; (222e8 <ev_setup_data_handler+0x18>)
   222d4:	781a      	ldrb	r2, [r3, #0]
   222d6:	4610      	mov	r0, r2
   222d8:	f003 fb94 	bl	25a04 <ep2bit>
}
   222dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    usbd_ep_data_handler(m_last_setup_dir, ep2bit(m_last_setup_dir));
   222e0:	4601      	mov	r1, r0
   222e2:	4610      	mov	r0, r2
   222e4:	f7ff bfae 	b.w	22244 <usbd_ep_data_handler>
   222e8:	2000b628 	.word	0x2000b628

000222ec <ev_dma_epout8_handler>:
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   222ec:	b507      	push	{r0, r1, r2, lr}
    m_dma_pending = false;
   222ee:	2200      	movs	r2, #0
   222f0:	4b0d      	ldr	r3, [pc, #52]	; (22328 <ev_dma_epout8_handler+0x3c>)
   222f2:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   222f4:	4b0d      	ldr	r3, [pc, #52]	; (2232c <ev_dma_epout8_handler+0x40>)
   222f6:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
   222fa:	2a03      	cmp	r2, #3
   222fc:	d010      	beq.n	22320 <ev_dma_epout8_handler+0x34>
    else if (p_state->handler.consumer == NULL)
   222fe:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
   22302:	b96b      	cbnz	r3, 22320 <ev_dma_epout8_handler+0x34>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22304:	f06f 7080 	mvn.w	r0, #16777216	; 0x1000000
   22308:	f7ff ff5e 	bl	221c8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2230c:	2306      	movs	r3, #6
   2230e:	f88d 3004 	strb.w	r3, [sp, #4]
   22312:	2308      	movs	r3, #8
   22314:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   22318:	4b05      	ldr	r3, [pc, #20]	; (22330 <ev_dma_epout8_handler+0x44>)
   2231a:	a801      	add	r0, sp, #4
   2231c:	681b      	ldr	r3, [r3, #0]
   2231e:	4798      	blx	r3
static void ev_dma_epout8_handler(void) { nrf_usbd_epoutiso_dma_handler(NRFX_USBD_EPOUT8); }
   22320:	b003      	add	sp, #12
   22322:	f85d fb04 	ldr.w	pc, [sp], #4
   22326:	bf00      	nop
   22328:	2000b627 	.word	0x2000b627
   2232c:	2000b484 	.word	0x2000b484
   22330:	2000b5ac 	.word	0x2000b5ac

00022334 <ev_dma_epin8_handler>:
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   22334:	b507      	push	{r0, r1, r2, lr}
    m_dma_pending = false;
   22336:	2200      	movs	r2, #0
   22338:	4b10      	ldr	r3, [pc, #64]	; (2237c <ev_dma_epin8_handler+0x48>)
   2233a:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   2233c:	4b10      	ldr	r3, [pc, #64]	; (22380 <ev_dma_epin8_handler+0x4c>)
   2233e:	f893 211e 	ldrb.w	r2, [r3, #286]	; 0x11e
   22342:	2a03      	cmp	r2, #3
   22344:	d106      	bne.n	22354 <ev_dma_epin8_handler+0x20>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22346:	f46f 7080 	mvn.w	r0, #256	; 0x100
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   2234a:	b003      	add	sp, #12
   2234c:	f85d eb04 	ldr.w	lr, [sp], #4
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22350:	f7ff bf3a 	b.w	221c8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.feeder == NULL)
   22354:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
   22358:	b96b      	cbnz	r3, 22376 <ev_dma_epin8_handler+0x42>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2235a:	f46f 7080 	mvn.w	r0, #256	; 0x100
   2235e:	f7ff ff33 	bl	221c8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22362:	2306      	movs	r3, #6
   22364:	f88d 3004 	strb.w	r3, [sp, #4]
   22368:	2388      	movs	r3, #136	; 0x88
   2236a:	f8ad 3006 	strh.w	r3, [sp, #6]
        m_event_handler(&evt);
   2236e:	4b05      	ldr	r3, [pc, #20]	; (22384 <ev_dma_epin8_handler+0x50>)
   22370:	a801      	add	r0, sp, #4
   22372:	681b      	ldr	r3, [r3, #0]
   22374:	4798      	blx	r3
static void ev_dma_epin8_handler(void)  { nrf_usbd_epiniso_dma_handler(NRFX_USBD_EPIN8 ); }
   22376:	b003      	add	sp, #12
   22378:	f85d fb04 	ldr.w	pc, [sp], #4
   2237c:	2000b627 	.word	0x2000b627
   22380:	2000b484 	.word	0x2000b484
   22384:	2000b5ac 	.word	0x2000b5ac

00022388 <nrfx_usbd_uninit>:

void nrfx_usbd_uninit(void)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_INITIALIZED);

    m_event_handler = NULL;
   22388:	2300      	movs	r3, #0
   2238a:	4a02      	ldr	r2, [pc, #8]	; (22394 <nrfx_usbd_uninit+0xc>)
   2238c:	6013      	str	r3, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_UNINITIALIZED;
   2238e:	4a02      	ldr	r2, [pc, #8]	; (22398 <nrfx_usbd_uninit+0x10>)
   22390:	7013      	strb	r3, [r2, #0]
    return;
}
   22392:	4770      	bx	lr
   22394:	2000b5ac 	.word	0x2000b5ac
   22398:	2000b62a 	.word	0x2000b62a

0002239c <nrfx_usbd_enable>:
    p_reg->EVENTCAUSE = flags;
   2239c:	f44f 6200 	mov.w	r2, #2048	; 0x800
   223a0:	4b13      	ldr	r3, [pc, #76]	; (223f0 <nrfx_usbd_enable+0x54>)
   223a2:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   223a6:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Enabled << USBD_ENABLE_ENABLE_Pos;
   223aa:	2201      	movs	r2, #1
   223ac:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   223b0:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
    return p_reg->EVENTCAUSE;
   223b4:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    while (0 == (eventcause & nrf_usbd_eventcause_get(NRF_USBD)))
   223b8:	0512      	lsls	r2, r2, #20
   223ba:	d5fb      	bpl.n	223b4 <nrfx_usbd_enable+0x18>
    p_reg->EVENTCAUSE = flags;
   223bc:	f44f 6200 	mov.w	r2, #2048	; 0x800
   223c0:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    (void) p_reg->EVENTCAUSE;
   223c4:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    p_reg->ISOSPLIT = split << USBD_ISOSPLIT_SPLIT_Pos;
   223c8:	2280      	movs	r2, #128	; 0x80
   223ca:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
    p_reg->ISOINCONFIG = ((uint32_t)config) << USBD_ISOINCONFIG_RESPONSE_Pos;
   223ce:	2200      	movs	r2, #0
    else
    {
        nrfx_usbd_isoinconfig_set(NRF_USBD_ISOINCONFIG_NORESP);
    }

    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   223d0:	f240 11ff 	movw	r1, #511	; 0x1ff
   223d4:	f8c3 2530 	str.w	r2, [r3, #1328]	; 0x530
   223d8:	4b06      	ldr	r3, [pc, #24]	; (223f4 <nrfx_usbd_enable+0x58>)
   223da:	6019      	str	r1, [r3, #0]
    m_ep_dma_waiting = 0;
   223dc:	4b06      	ldr	r3, [pc, #24]	; (223f8 <nrfx_usbd_enable+0x5c>)
   223de:	601a      	str	r2, [r3, #0]
    m_dma_pending = false;
   223e0:	4b06      	ldr	r3, [pc, #24]	; (223fc <nrfx_usbd_enable+0x60>)
   223e2:	701a      	strb	r2, [r3, #0]
    usbd_dma_pending_clear();
    m_last_setup_dir = NRFX_USBD_EPOUT0;
   223e4:	4b06      	ldr	r3, [pc, #24]	; (22400 <nrfx_usbd_enable+0x64>)
   223e6:	701a      	strb	r2, [r3, #0]

    m_drv_state = NRFX_DRV_STATE_POWERED_ON;
   223e8:	2202      	movs	r2, #2
   223ea:	4b06      	ldr	r3, [pc, #24]	; (22404 <nrfx_usbd_enable+0x68>)
   223ec:	701a      	strb	r2, [r3, #0]
    if (nrfx_usbd_errata_187())
#endif
    {
        usbd_errata_187_211_end();
    }
}
   223ee:	4770      	bx	lr
   223f0:	40036000 	.word	0x40036000
   223f4:	2000b5a8 	.word	0x2000b5a8
   223f8:	2000b5a4 	.word	0x2000b5a4
   223fc:	2000b627 	.word	0x2000b627
   22400:	2000b628 	.word	0x2000b628
   22404:	2000b62a 	.word	0x2000b62a

00022408 <nrfx_usbd_start>:
}

void nrfx_usbd_start(bool enable_sof)
{
    NRFX_ASSERT(m_drv_state == NRFX_DRV_STATE_POWERED_ON);
    m_bus_suspend = false;
   22408:	2200      	movs	r2, #0
   2240a:	4b0a      	ldr	r3, [pc, #40]	; (22434 <nrfx_usbd_start+0x2c>)
{
   2240c:	b510      	push	{r4, lr}
    m_bus_suspend = false;
   2240e:	701a      	strb	r2, [r3, #0]

    uint32_t ints_to_enable =
   22410:	4a09      	ldr	r2, [pc, #36]	; (22438 <nrfx_usbd_start+0x30>)
   22412:	4b0a      	ldr	r3, [pc, #40]	; (2243c <nrfx_usbd_start+0x34>)
    p_reg->INTENSET = mask;
   22414:	4c0a      	ldr	r4, [pc, #40]	; (22440 <nrfx_usbd_start+0x38>)
   22416:	2800      	cmp	r0, #0
   22418:	bf08      	it	eq
   2241a:	4613      	moveq	r3, r2
   /* Enable all required interrupts */
   nrf_usbd_int_enable(NRF_USBD, ints_to_enable);

   /* Enable interrupt globally */
   NRFX_IRQ_PRIORITY_SET(USBD_IRQn, NRFX_USBD_DEFAULT_CONFIG_IRQ_PRIORITY);
   NRFX_IRQ_ENABLE(USBD_IRQn);
   2241c:	2036      	movs	r0, #54	; 0x36
   2241e:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   22422:	f7fb ff55 	bl	1e2d0 <arch_irq_enable>
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Enabled << USBD_USBPULLUP_CONNECT_Pos;
   22426:	2301      	movs	r3, #1
   22428:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    (void) p_reg->USBPULLUP;
   2242c:	f8d4 3504 	ldr.w	r3, [r4, #1284]	; 0x504

   /* Enable pullups */
   nrf_usbd_pullup_enable(NRF_USBD);
}
   22430:	bd10      	pop	{r4, pc}
   22432:	bf00      	nop
   22434:	2000b629 	.word	0x2000b629
   22438:	01c01407 	.word	0x01c01407
   2243c:	01e01407 	.word	0x01e01407
   22440:	40036000 	.word	0x40036000

00022444 <nrfx_usbd_is_enabled>:
    return (m_drv_state >= NRFX_DRV_STATE_INITIALIZED);
}

bool nrfx_usbd_is_enabled(void)
{
    return (m_drv_state >= NRFX_DRV_STATE_POWERED_ON);
   22444:	4b03      	ldr	r3, [pc, #12]	; (22454 <nrfx_usbd_is_enabled+0x10>)
   22446:	7818      	ldrb	r0, [r3, #0]
}
   22448:	2801      	cmp	r0, #1
   2244a:	bf94      	ite	ls
   2244c:	2000      	movls	r0, #0
   2244e:	2001      	movhi	r0, #1
   22450:	4770      	bx	lr
   22452:	bf00      	nop
   22454:	2000b62a 	.word	0x2000b62a

00022458 <nrfx_usbd_suspend>:
{
    return (nrfx_usbd_is_enabled() && NRFX_IRQ_IS_ENABLED(USBD_IRQn));
}

bool nrfx_usbd_suspend(void)
{
   22458:	b510      	push	{r4, lr}
	__asm__ volatile(
   2245a:	f04f 0320 	mov.w	r3, #32
   2245e:	f3ef 8111 	mrs	r1, BASEPRI
   22462:	f383 8812 	msr	BASEPRI_MAX, r3
   22466:	f3bf 8f6f 	isb	sy
    bool suspended = false;

    NRFX_CRITICAL_SECTION_ENTER();
    if (m_bus_suspend)
   2246a:	4b0f      	ldr	r3, [pc, #60]	; (224a8 <nrfx_usbd_suspend+0x50>)
   2246c:	781b      	ldrb	r3, [r3, #0]
   2246e:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   22472:	b193      	cbz	r3, 2249a <nrfx_usbd_suspend+0x42>
    return p_reg->EVENTCAUSE;
   22474:	4b0d      	ldr	r3, [pc, #52]	; (224ac <nrfx_usbd_suspend+0x54>)
   22476:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    {
        if (!(nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK))
   2247a:	f412 7200 	ands.w	r2, r2, #512	; 0x200
   2247e:	d10c      	bne.n	2249a <nrfx_usbd_suspend+0x42>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_LowPower << USBD_LOWPOWER_LOWPOWER_Pos;
   22480:	2401      	movs	r4, #1
   22482:	f8c3 452c 	str.w	r4, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   22486:	f8d3 452c 	ldr.w	r4, [r3, #1324]	; 0x52c
    return p_reg->EVENTCAUSE;
   2248a:	f8d3 4400 	ldr.w	r4, [r3, #1024]	; 0x400
        {
            nrf_usbd_lowpower_enable(NRF_USBD);
            if (nrf_usbd_eventcause_get(NRF_USBD) & NRF_USBD_EVENTCAUSE_RESUME_MASK)
   2248e:	05a4      	lsls	r4, r4, #22
   22490:	d504      	bpl.n	2249c <nrfx_usbd_suspend+0x44>
    p_reg->LOWPOWER = USBD_LOWPOWER_LOWPOWER_ForceNormal << USBD_LOWPOWER_LOWPOWER_Pos;
   22492:	f8c3 252c 	str.w	r2, [r3, #1324]	; 0x52c
    (void) p_reg->LOWPOWER;
   22496:	f8d3 352c 	ldr.w	r3, [r3, #1324]	; 0x52c
    bool suspended = false;
   2249a:	2000      	movs	r0, #0
	__asm__ volatile(
   2249c:	f381 8811 	msr	BASEPRI, r1
   224a0:	f3bf 8f6f 	isb	sy
        }
    }
    NRFX_CRITICAL_SECTION_EXIT();

    return suspended;
}
   224a4:	bd10      	pop	{r4, pc}
   224a6:	bf00      	nop
   224a8:	2000b629 	.word	0x2000b629
   224ac:	40036000 	.word	0x40036000

000224b0 <nrfx_usbd_init>:
{
   224b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (m_drv_state != NRFX_DRV_STATE_UNINITIALIZED)
   224b2:	4b1c      	ldr	r3, [pc, #112]	; (22524 <nrfx_usbd_init+0x74>)
   224b4:	781c      	ldrb	r4, [r3, #0]
   224b6:	bb94      	cbnz	r4, 2251e <nrfx_usbd_init+0x6e>
    m_event_handler = event_handler;
   224b8:	4a1b      	ldr	r2, [pc, #108]	; (22528 <nrfx_usbd_init+0x78>)
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224ba:	f240 17ff 	movw	r7, #511	; 0x1ff
    m_event_handler = event_handler;
   224be:	6010      	str	r0, [r2, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   224c0:	2201      	movs	r2, #1
        p_state->status = NRFX_USBD_EP_OK;
   224c2:	4626      	mov	r6, r4
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   224c4:	701a      	strb	r2, [r3, #0]
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   224c6:	f064 057f 	orn	r5, r4, #127	; 0x7f
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224ca:	f014 0f08 	tst.w	r4, #8
        nrfx_usbd_ep_t ep = NRFX_USBD_EPIN(n);
   224ce:	b2ed      	uxtb	r5, r5
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224d0:	bf14      	ite	ne
   224d2:	4639      	movne	r1, r7
   224d4:	2140      	moveq	r1, #64	; 0x40
   224d6:	4628      	mov	r0, r5
   224d8:	f003 fab4 	bl	25a44 <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   224dc:	4628      	mov	r0, r5
   224de:	f7ff fdb7 	bl	22050 <ep_state_access>
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   224e2:	3401      	adds	r4, #1
   224e4:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
   224e6:	7386      	strb	r6, [r0, #14]
        p_state->handler.feeder = NULL;
   224e8:	6006      	str	r6, [r0, #0]
        p_state->transfer_cnt = 0;
   224ea:	6086      	str	r6, [r0, #8]
    for (n = 0; n < NRF_USBD_EPIN_CNT; ++n)
   224ec:	d1eb      	bne.n	224c6 <nrfx_usbd_init+0x16>
   224ee:	2400      	movs	r4, #0
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224f0:	f240 17ff 	movw	r7, #511	; 0x1ff
        p_state->status = NRFX_USBD_EP_OK;
   224f4:	4625      	mov	r5, r4
        nrfx_usbd_ep_max_packet_size_set(ep, NRF_USBD_EPISO_CHECK(ep) ?
   224f6:	f014 0f08 	tst.w	r4, #8
   224fa:	b2e6      	uxtb	r6, r4
   224fc:	bf14      	ite	ne
   224fe:	4639      	movne	r1, r7
   22500:	2140      	moveq	r1, #64	; 0x40
   22502:	4630      	mov	r0, r6
   22504:	f003 fa9e 	bl	25a44 <nrfx_usbd_ep_max_packet_size_set>
        usbd_ep_state_t * p_state = ep_state_access(ep);
   22508:	4630      	mov	r0, r6
   2250a:	f7ff fda1 	bl	22050 <ep_state_access>
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   2250e:	3401      	adds	r4, #1
   22510:	2c09      	cmp	r4, #9
        p_state->status = NRFX_USBD_EP_OK;
   22512:	7385      	strb	r5, [r0, #14]
        p_state->handler.consumer = NULL;
   22514:	6005      	str	r5, [r0, #0]
        p_state->transfer_cnt = 0;
   22516:	6085      	str	r5, [r0, #8]
    for (n = 0; n < NRF_USBD_EPOUT_CNT; ++n)
   22518:	d1ed      	bne.n	224f6 <nrfx_usbd_init+0x46>
    return NRFX_SUCCESS;
   2251a:	4804      	ldr	r0, [pc, #16]	; (2252c <nrfx_usbd_init+0x7c>)
}
   2251c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return NRFX_ERROR_INVALID_STATE;
   2251e:	4804      	ldr	r0, [pc, #16]	; (22530 <nrfx_usbd_init+0x80>)
   22520:	e7fc      	b.n	2251c <nrfx_usbd_init+0x6c>
   22522:	bf00      	nop
   22524:	2000b62a 	.word	0x2000b62a
   22528:	2000b5ac 	.word	0x2000b5ac
   2252c:	0bad0000 	.word	0x0bad0000
   22530:	0bad0005 	.word	0x0bad0005

00022534 <nrfx_usbd_ep_transfer>:
}

nrfx_err_t nrfx_usbd_ep_transfer(
    nrfx_usbd_ep_t               ep,
    nrfx_usbd_transfer_t const * p_transfer)
{
   22534:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   22538:	4604      	mov	r4, r0
	__asm__ volatile(
   2253a:	f04f 0320 	mov.w	r3, #32
   2253e:	f3ef 8611 	mrs	r6, BASEPRI
   22542:	f383 8812 	msr	BASEPRI_MAX, r3
   22546:	f3bf 8f6f 	isb	sy
    const uint8_t ep_bitpos = ep2bit(ep);
    NRFX_ASSERT(NULL != p_transfer);

    NRFX_CRITICAL_SECTION_ENTER();
    /* Setup data transaction can go only in one direction at a time */
    if ((NRF_USBD_EP_NR_GET(ep) == 0) && (ep != m_last_setup_dir))
   2254a:	f010 090f 	ands.w	r9, r0, #15
   2254e:	d103      	bne.n	22558 <nrfx_usbd_ep_transfer+0x24>
   22550:	4b28      	ldr	r3, [pc, #160]	; (225f4 <nrfx_usbd_ep_transfer+0xc0>)
   22552:	781b      	ldrb	r3, [r3, #0]
   22554:	4283      	cmp	r3, r0
   22556:	d148      	bne.n	225ea <nrfx_usbd_ep_transfer+0xb6>
            (NRFX_USBD_ISO_DEBUG || (!NRF_USBD_EPISO_CHECK(ep))))
        {
            NRFX_LOG_DEBUG("Transfer failed: Invalid EPr\n");
        }
    }
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   22558:	4b27      	ldr	r3, [pc, #156]	; (225f8 <nrfx_usbd_ep_transfer+0xc4>)
   2255a:	4f28      	ldr	r7, [pc, #160]	; (225fc <nrfx_usbd_ep_transfer+0xc8>)
   2255c:	681a      	ldr	r2, [r3, #0]
   2255e:	683b      	ldr	r3, [r7, #0]
   22560:	43d2      	mvns	r2, r2
    const uint8_t ep_bitpos = ep2bit(ep);
   22562:	4620      	mov	r0, r4
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   22564:	b292      	uxth	r2, r2
   22566:	431a      	orrs	r2, r3
   22568:	f04f 0801 	mov.w	r8, #1
    const uint8_t ep_bitpos = ep2bit(ep);
   2256c:	f003 fa4a 	bl	25a04 <ep2bit>
    else if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK)) & (1U << ep_bitpos))
   22570:	fa08 f800 	lsl.w	r8, r8, r0
   22574:	ea12 0f08 	tst.w	r2, r8
   22578:	d139      	bne.n	225ee <nrfx_usbd_ep_transfer+0xba>
            NRFX_LOG_DEBUG("Transfer failed: EP is busy");
        }
    }
    else
    {
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   2257a:	4620      	mov	r0, r4
   2257c:	f7ff fd68 	bl	22050 <ep_state_access>
        /* Prepare transfer context and handler description */
        nrfx_usbd_transfer_t * p_context;
        if (NRF_USBD_EPIN_CHECK(ep))
        {
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   22580:	230c      	movs	r3, #12
        if (NRF_USBD_EPIN_CHECK(ep))
   22582:	0622      	lsls	r2, r4, #24
        usbd_ep_state_t * p_state =  ep_state_access(ep);
   22584:	4605      	mov	r5, r0
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   22586:	fb03 f309 	mul.w	r3, r3, r9
        if (NRF_USBD_EPIN_CHECK(ep))
   2258a:	d52a      	bpl.n	225e2 <nrfx_usbd_ep_transfer+0xae>
   2258c:	680a      	ldr	r2, [r1, #0]
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
            {
                /* RAM */
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   2258e:	6888      	ldr	r0, [r1, #8]
   22590:	f002 4260 	and.w	r2, r2, #3758096384	; 0xe0000000
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
   22594:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   22598:	f000 0001 	and.w	r0, r0, #1
            if (nrfx_is_in_ram(p_transfer->p_data.tx))
   2259c:	d11e      	bne.n	225dc <nrfx_usbd_ep_transfer+0xa8>
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   2259e:	4a18      	ldr	r2, [pc, #96]	; (22600 <nrfx_usbd_ep_transfer+0xcc>)
   225a0:	4c18      	ldr	r4, [pc, #96]	; (22604 <nrfx_usbd_ep_transfer+0xd0>)
   225a2:	2800      	cmp	r0, #0
   225a4:	bf08      	it	eq
   225a6:	4622      	moveq	r2, r4
            p_context = m_ep_feeder_state + NRF_USBD_EP_NR_GET(ep);
   225a8:	4817      	ldr	r0, [pc, #92]	; (22608 <nrfx_usbd_ep_transfer+0xd4>)
   225aa:	4403      	add	r3, r0
        }
        else
        {
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
            NRFX_ASSERT((p_transfer->p_data.rx == NULL) || (nrfx_is_in_ram(p_transfer->p_data.rx)));
            p_state->handler.consumer = nrfx_usbd_consumer;
   225ac:	602a      	str	r2, [r5, #0]
        }
        *p_context = *p_transfer;
   225ae:	c907      	ldmia	r1, {r0, r1, r2}
   225b0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        p_state->p_context = p_context;
   225b4:	606b      	str	r3, [r5, #4]

        p_state->transfer_cnt = 0;
   225b6:	2300      	movs	r3, #0
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   225b8:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
   225bc:	60ab      	str	r3, [r5, #8]
        p_state->status    =  NRFX_USBD_EP_OK;
   225be:	73ab      	strb	r3, [r5, #14]
        m_ep_dma_waiting   |= 1U << ep_bitpos;
   225c0:	683b      	ldr	r3, [r7, #0]
        ret = NRFX_SUCCESS;
   225c2:	4812      	ldr	r0, [pc, #72]	; (2260c <nrfx_usbd_ep_transfer+0xd8>)
        m_ep_dma_waiting   |= 1U << ep_bitpos;
   225c4:	ea43 0308 	orr.w	r3, r3, r8
   225c8:	603b      	str	r3, [r7, #0]
   225ca:	4b11      	ldr	r3, [pc, #68]	; (22610 <nrfx_usbd_ep_transfer+0xdc>)
   225cc:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	__asm__ volatile(
   225d0:	f386 8811 	msr	BASEPRI, r6
   225d4:	f3bf 8f6f 	isb	sy
        usbd_int_rise();
    }
    NRFX_CRITICAL_SECTION_EXIT();
    return ret;
}
   225d8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (0 == (p_transfer->flags & NRFX_USBD_TRANSFER_ZLP_FLAG))
   225dc:	4a0d      	ldr	r2, [pc, #52]	; (22614 <nrfx_usbd_ep_transfer+0xe0>)
   225de:	4c0e      	ldr	r4, [pc, #56]	; (22618 <nrfx_usbd_ep_transfer+0xe4>)
   225e0:	e7df      	b.n	225a2 <nrfx_usbd_ep_transfer+0x6e>
            p_context = m_ep_consumer_state + NRF_USBD_EP_NR_GET(ep);
   225e2:	4a0e      	ldr	r2, [pc, #56]	; (2261c <nrfx_usbd_ep_transfer+0xe8>)
   225e4:	4413      	add	r3, r2
            p_state->handler.consumer = nrfx_usbd_consumer;
   225e6:	4a0e      	ldr	r2, [pc, #56]	; (22620 <nrfx_usbd_ep_transfer+0xec>)
   225e8:	e7e0      	b.n	225ac <nrfx_usbd_ep_transfer+0x78>
        ret = NRFX_ERROR_INVALID_ADDR;
   225ea:	480e      	ldr	r0, [pc, #56]	; (22624 <nrfx_usbd_ep_transfer+0xf0>)
   225ec:	e7f0      	b.n	225d0 <nrfx_usbd_ep_transfer+0x9c>
        ret = NRFX_ERROR_BUSY;
   225ee:	480e      	ldr	r0, [pc, #56]	; (22628 <nrfx_usbd_ep_transfer+0xf4>)
   225f0:	e7ee      	b.n	225d0 <nrfx_usbd_ep_transfer+0x9c>
   225f2:	bf00      	nop
   225f4:	2000b628 	.word	0x2000b628
   225f8:	2000b5a8 	.word	0x2000b5a8
   225fc:	2000b5a4 	.word	0x2000b5a4
   22600:	000259db 	.word	0x000259db
   22604:	000259b9 	.word	0x000259b9
   22608:	2000b418 	.word	0x2000b418
   2260c:	0bad0000 	.word	0x0bad0000
   22610:	e000e100 	.word	0xe000e100
   22614:	00022145 	.word	0x00022145
   22618:	0002210d 	.word	0x0002210d
   2261c:	2000b3ac 	.word	0x2000b3ac
   22620:	00025987 	.word	0x00025987
   22624:	0bad000a 	.word	0x0bad000a
   22628:	0bad000b 	.word	0x0bad000b

0002262c <nrfx_usbd_epout_size_get>:
    if (NRF_USBD_EPISO_CHECK(ep))
   2262c:	f010 0f08 	tst.w	r0, #8
   22630:	4b07      	ldr	r3, [pc, #28]	; (22650 <nrfx_usbd_epout_size_get+0x24>)
   22632:	d006      	beq.n	22642 <nrfx_usbd_epout_size_get+0x16>
        size_t size_isoout = p_reg->SIZE.ISOOUT;
   22634:	f8d3 04c0 	ldr.w	r0, [r3, #1216]	; 0x4c0
            size_isoout = 0;
   22638:	f410 3f80 	tst.w	r0, #65536	; 0x10000
   2263c:	bf18      	it	ne
   2263e:	2000      	movne	r0, #0
   22640:	4770      	bx	lr
    return p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   22642:	f000 000f 	and.w	r0, r0, #15
   22646:	f500 7094 	add.w	r0, r0, #296	; 0x128
   2264a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}

size_t nrfx_usbd_epout_size_get(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_epout_size_get(NRF_USBD, ep_to_hal(ep));
}
   2264e:	4770      	bx	lr
   22650:	40036000 	.word	0x40036000

00022654 <usbd_dmareq_process>:
{
   22654:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (!m_dma_pending)
   22658:	4e54      	ldr	r6, [pc, #336]	; (227ac <usbd_dmareq_process+0x158>)
{
   2265a:	b085      	sub	sp, #20
    if (!m_dma_pending)
   2265c:	7833      	ldrb	r3, [r6, #0]
   2265e:	2b00      	cmp	r3, #0
   22660:	d169      	bne.n	22736 <usbd_dmareq_process+0xe2>
        while (0 != (req = m_ep_dma_waiting & m_ep_ready))
   22662:	f8df 814c 	ldr.w	r8, [pc, #332]	; 227b0 <usbd_dmareq_process+0x15c>
   22666:	4d53      	ldr	r5, [pc, #332]	; (227b4 <usbd_dmareq_process+0x160>)
   22668:	f8d8 4000 	ldr.w	r4, [r8]
   2266c:	682b      	ldr	r3, [r5, #0]
   2266e:	401c      	ands	r4, r3
   22670:	d061      	beq.n	22736 <usbd_dmareq_process+0xe2>
            if (NRFX_USBD_CONFIG_DMASCHEDULER_ISO_BOOST && ((req & USBD_EPISO_BIT_MASK) != 0))
   22672:	f014 2301 	ands.w	r3, r4, #16777472	; 0x1000100
    return NRF_CTZ(req);
   22676:	bf14      	ite	ne
   22678:	fa93 f4a3 	rbitne	r4, r3
   2267c:	fa94 f4a4 	rbiteq	r4, r4
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   22680:	f04f 0901 	mov.w	r9, #1
    return NRF_CTZ(req);
   22684:	fab4 f484 	clz	r4, r4
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   22688:	fa09 f904 	lsl.w	r9, r9, r4
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   2268c:	2c0f      	cmp	r4, #15
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   2268e:	ea6f 0909 	mvn.w	r9, r9
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   22692:	d953      	bls.n	2273c <usbd_dmareq_process+0xe8>
   22694:	3c10      	subs	r4, #16
   22696:	b2e4      	uxtb	r4, r4
            usbd_ep_state_t * p_state = ep_state_access(ep);
   22698:	4620      	mov	r0, r4
   2269a:	f7ff fcd9 	bl	22050 <ep_state_access>
   2269e:	4682      	mov	sl, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   226a0:	4620      	mov	r0, r4
   226a2:	f7ff ffc3 	bl	2262c <nrfx_usbd_epout_size_get>
                continue_transfer = p_state->handler.consumer(
   226a6:	f8da 7000 	ldr.w	r7, [sl]
   226aa:	4603      	mov	r3, r0
                const size_t rx_size = nrfx_usbd_epout_size_get(ep);
   226ac:	4683      	mov	fp, r0
                continue_transfer = p_state->handler.consumer(
   226ae:	f8ba 200c 	ldrh.w	r2, [sl, #12]
   226b2:	f8da 1004 	ldr.w	r1, [sl, #4]
   226b6:	a802      	add	r0, sp, #8
   226b8:	47b8      	blx	r7
                if (transfer.p_data.rx == NULL)
   226ba:	9b02      	ldr	r3, [sp, #8]
   226bc:	2b00      	cmp	r3, #0
   226be:	d149      	bne.n	22754 <usbd_dmareq_process+0x100>
                if (!continue_transfer)
   226c0:	b908      	cbnz	r0, 226c6 <usbd_dmareq_process+0x72>
                    p_state->handler.consumer = NULL;
   226c2:	f8ca 0000 	str.w	r0, [sl]
    m_dma_pending = true;
   226c6:	2301      	movs	r3, #1
   226c8:	7033      	strb	r3, [r6, #0]
            m_ep_ready &= ~(1U << pos);
   226ca:	682b      	ldr	r3, [r5, #0]
            p_state->transfer_cnt += transfer.size;
   226cc:	9a03      	ldr	r2, [sp, #12]
            m_ep_ready &= ~(1U << pos);
   226ce:	ea03 0309 	and.w	r3, r3, r9
   226d2:	602b      	str	r3, [r5, #0]
            p_state->transfer_cnt += transfer.size;
   226d4:	f8da 3008 	ldr.w	r3, [sl, #8]
            if (NRF_USBD_EPIN_CHECK(ep))
   226d8:	b261      	sxtb	r1, r4
            p_state->transfer_cnt += transfer.size;
   226da:	4413      	add	r3, r2
    if (NRF_USBD_EPIN_CHECK(ep))
   226dc:	2900      	cmp	r1, #0
   226de:	f8ca 3008 	str.w	r3, [sl, #8]
            nrf_usbd_ep_easydma_set(NRF_USBD, ep, transfer.p_data.addr, (uint32_t)transfer.size);
   226e2:	f004 0508 	and.w	r5, r4, #8
   226e6:	9802      	ldr	r0, [sp, #8]
   226e8:	4b33      	ldr	r3, [pc, #204]	; (227b8 <usbd_dmareq_process+0x164>)
            uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   226ea:	f004 040f 	and.w	r4, r4, #15
    if (NRF_USBD_EPIN_CHECK(ep))
   226ee:	da4e      	bge.n	2278e <usbd_dmareq_process+0x13a>
        if (NRF_USBD_EPISO_CHECK(ep))
   226f0:	2d00      	cmp	r5, #0
   226f2:	d044      	beq.n	2277e <usbd_dmareq_process+0x12a>
            p_reg->ISOIN.PTR    = ptr;
   226f4:	f8c3 06a0 	str.w	r0, [r3, #1696]	; 0x6a0
            p_reg->ISOIN.MAXCNT = maxcnt;
   226f8:	f8c3 26a4 	str.w	r2, [r3, #1700]	; 0x6a4
    return (nrf_usbd_task_t)(
   226fc:	2304      	movs	r3, #4
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   226fe:	2201      	movs	r2, #1
   22700:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    return (volatile uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   22704:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   22708:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   2270c:	601a      	str	r2, [r3, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   2270e:	681b      	ldr	r3, [r3, #0]
    return (NRF_USBD_EPIN_CHECK(ep) ? epin_endev : epout_endev)[NRF_USBD_EP_NR_GET(ep)];
   22710:	4a2a      	ldr	r2, [pc, #168]	; (227bc <usbd_dmareq_process+0x168>)
   22712:	4b2b      	ldr	r3, [pc, #172]	; (227c0 <usbd_dmareq_process+0x16c>)
   22714:	ea13 0321 	ands.w	r3, r3, r1, asr #32
   22718:	bf38      	it	cc
   2271a:	4613      	movcc	r3, r2
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   2271c:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
   22720:	4925      	ldr	r1, [pc, #148]	; (227b8 <usbd_dmareq_process+0x164>)
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   22722:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   22726:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   2272a:	681a      	ldr	r2, [r3, #0]
            while (!nrf_usbd_event_check(NRF_USBD, nrfx_usbd_ep_to_endevent(ep)) &&
   2272c:	b91a      	cbnz	r2, 22736 <usbd_dmareq_process+0xe2>
   2272e:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
   22732:	2a00      	cmp	r2, #0
   22734:	d0f9      	beq.n	2272a <usbd_dmareq_process+0xd6>
}
   22736:	b005      	add	sp, #20
   22738:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   2273c:	f044 0480 	orr.w	r4, r4, #128	; 0x80
            usbd_ep_state_t * p_state = ep_state_access(ep);
   22740:	4620      	mov	r0, r4
   22742:	f7ff fc85 	bl	22050 <ep_state_access>
   22746:	4682      	mov	sl, r0
                continue_transfer = p_state->handler.feeder(
   22748:	6803      	ldr	r3, [r0, #0]
   2274a:	8982      	ldrh	r2, [r0, #12]
   2274c:	6841      	ldr	r1, [r0, #4]
   2274e:	a802      	add	r0, sp, #8
   22750:	4798      	blx	r3
   22752:	e7b5      	b.n	226c0 <usbd_dmareq_process+0x6c>
                else if (transfer.size < rx_size)
   22754:	9b03      	ldr	r3, [sp, #12]
   22756:	459b      	cmp	fp, r3
   22758:	d9b2      	bls.n	226c0 <usbd_dmareq_process+0x6c>
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   2275a:	2702      	movs	r7, #2
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   2275c:	4648      	mov	r0, r9
                    p_state->status = NRFX_USBD_EP_OVERLOAD;
   2275e:	f88a 700e 	strb.w	r7, [sl, #14]
                    (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << pos)));
   22762:	f7ff fd31 	bl	221c8 <atomic_and.constprop.0.isra.0>
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   22766:	2306      	movs	r3, #6
   22768:	f88d 3004 	strb.w	r3, [sp, #4]
                    m_event_handler(&evt);
   2276c:	4b15      	ldr	r3, [pc, #84]	; (227c4 <usbd_dmareq_process+0x170>)
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   2276e:	f88d 4006 	strb.w	r4, [sp, #6]
                    m_event_handler(&evt);
   22772:	681b      	ldr	r3, [r3, #0]
                    NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OVERLOAD);
   22774:	f88d 7007 	strb.w	r7, [sp, #7]
                    m_event_handler(&evt);
   22778:	a801      	add	r0, sp, #4
   2277a:	4798      	blx	r3
                    continue;
   2277c:	e774      	b.n	22668 <usbd_dmareq_process+0x14>
            p_reg->EPIN[epnr].PTR    = ptr;
   2277e:	2514      	movs	r5, #20
   22780:	fb05 3304 	mla	r3, r5, r4, r3
   22784:	f8c3 0600 	str.w	r0, [r3, #1536]	; 0x600
            p_reg->EPIN[epnr].MAXCNT = maxcnt;
   22788:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
    return (nrf_usbd_task_t)(
   2278c:	e7b6      	b.n	226fc <usbd_dmareq_process+0xa8>
        if (NRF_USBD_EPISO_CHECK(ep))
   2278e:	b12d      	cbz	r5, 2279c <usbd_dmareq_process+0x148>
            p_reg->ISOOUT.PTR    = ptr;
   22790:	f8c3 07a0 	str.w	r0, [r3, #1952]	; 0x7a0
            p_reg->ISOOUT.MAXCNT = maxcnt;
   22794:	f8c3 27a4 	str.w	r2, [r3, #1956]	; 0x7a4
   22798:	2328      	movs	r3, #40	; 0x28
   2279a:	e7b0      	b.n	226fe <usbd_dmareq_process+0xaa>
            p_reg->EPOUT[epnr].PTR    = ptr;
   2279c:	2514      	movs	r5, #20
   2279e:	fb05 3304 	mla	r3, r5, r4, r3
   227a2:	f8c3 0700 	str.w	r0, [r3, #1792]	; 0x700
            p_reg->EPOUT[epnr].MAXCNT = maxcnt;
   227a6:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
   227aa:	e7f5      	b.n	22798 <usbd_dmareq_process+0x144>
   227ac:	2000b627 	.word	0x2000b627
   227b0:	2000b5a4 	.word	0x2000b5a4
   227b4:	2000b5a8 	.word	0x2000b5a8
   227b8:	40036000 	.word	0x40036000
   227bc:	00026988 	.word	0x00026988
   227c0:	0002699a 	.word	0x0002699a
   227c4:	2000b5ac 	.word	0x2000b5ac

000227c8 <ev_epdata_handler>:
{
   227c8:	b538      	push	{r3, r4, r5, lr}
        dataepstatus &= ~(1UL << bitpos);
   227ca:	2501      	movs	r5, #1
    return p_reg->EPDATASTATUS;
   227cc:	4b0e      	ldr	r3, [pc, #56]	; (22808 <ev_epdata_handler+0x40>)
   227ce:	f8d3 446c 	ldr.w	r4, [r3, #1132]	; 0x46c
    p_reg->EPDATASTATUS = flags;
   227d2:	f8c3 446c 	str.w	r4, [r3, #1132]	; 0x46c
    while (dataepstatus)
   227d6:	b91c      	cbnz	r4, 227e0 <ev_epdata_handler+0x18>
}
   227d8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        usbd_dmareq_process();
   227dc:	f7ff bf3a 	b.w	22654 <usbd_dmareq_process>
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
   227e0:	fa94 f3a4 	rbit	r3, r4
   227e4:	fab3 f383 	clz	r3, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   227e8:	2b0f      	cmp	r3, #15
   227ea:	bfc8      	it	gt
   227ec:	f1a3 0010 	subgt.w	r0, r3, #16
        uint8_t bitpos    = NRF_CTZ(dataepstatus);
   227f0:	4619      	mov	r1, r3
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   227f2:	bfd4      	ite	le
   227f4:	f043 0080 	orrle.w	r0, r3, #128	; 0x80
   227f8:	b2c0      	uxtbgt	r0, r0
        dataepstatus &= ~(1UL << bitpos);
   227fa:	fa05 f303 	lsl.w	r3, r5, r3
   227fe:	ea24 0403 	bic.w	r4, r4, r3
        (void)(usbd_ep_data_handler(ep, bitpos));
   22802:	f7ff fd1f 	bl	22244 <usbd_ep_data_handler>
   22806:	e7e6      	b.n	227d6 <ev_epdata_handler+0xe>
   22808:	40036000 	.word	0x40036000

0002280c <nrf_usbd_epout_dma_handler>:
{
   2280c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    m_dma_pending = false;
   2280e:	2200      	movs	r2, #0
   22810:	4b16      	ldr	r3, [pc, #88]	; (2286c <nrf_usbd_epout_dma_handler+0x60>)
{
   22812:	4604      	mov	r4, r0
    m_dma_pending = false;
   22814:	701a      	strb	r2, [r3, #0]
    usbd_ep_state_t * p_state = ep_state_access(ep);
   22816:	f7ff fc1b 	bl	22050 <ep_state_access>
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   2281a:	7b83      	ldrb	r3, [r0, #14]
   2281c:	2b03      	cmp	r3, #3
   2281e:	d10d      	bne.n	2283c <nrf_usbd_epout_dma_handler+0x30>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22820:	4620      	mov	r0, r4
   22822:	f003 f8ef 	bl	25a04 <ep2bit>
   22826:	2301      	movs	r3, #1
   22828:	fa03 f000 	lsl.w	r0, r3, r0
   2282c:	43c0      	mvns	r0, r0
   2282e:	f7ff fccb 	bl	221c8 <atomic_and.constprop.0.isra.0>
}
   22832:	b003      	add	sp, #12
   22834:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    usbd_dmareq_process();
   22838:	f7ff bf0c 	b.w	22654 <usbd_dmareq_process>
    else if (p_state->handler.consumer == NULL)
   2283c:	6805      	ldr	r5, [r0, #0]
   2283e:	2d00      	cmp	r5, #0
   22840:	d1f7      	bne.n	22832 <nrf_usbd_epout_dma_handler+0x26>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22842:	4620      	mov	r0, r4
   22844:	f003 f8de 	bl	25a04 <ep2bit>
   22848:	2301      	movs	r3, #1
   2284a:	fa03 f000 	lsl.w	r0, r3, r0
   2284e:	43c0      	mvns	r0, r0
   22850:	f7ff fcba 	bl	221c8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22854:	2306      	movs	r3, #6
   22856:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   2285a:	4b05      	ldr	r3, [pc, #20]	; (22870 <nrf_usbd_epout_dma_handler+0x64>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2285c:	f88d 4006 	strb.w	r4, [sp, #6]
        m_event_handler(&evt);
   22860:	681b      	ldr	r3, [r3, #0]
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22862:	f88d 5007 	strb.w	r5, [sp, #7]
        m_event_handler(&evt);
   22866:	a801      	add	r0, sp, #4
   22868:	4798      	blx	r3
   2286a:	e7e2      	b.n	22832 <nrf_usbd_epout_dma_handler+0x26>
   2286c:	2000b627 	.word	0x2000b627
   22870:	2000b5ac 	.word	0x2000b5ac

00022874 <nrfx_usbd_ep_stall>:
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_Stall << USBD_EPSTALL_STALL_Pos) | ep;
   22874:	4b02      	ldr	r3, [pc, #8]	; (22880 <nrfx_usbd_ep_stall+0xc>)
   22876:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   2287a:	f8c3 0518 	str.w	r0, [r3, #1304]	; 0x518

void nrfx_usbd_ep_stall(nrfx_usbd_ep_t ep)
{
    NRFX_LOG_DEBUG("USB: EP %x stalled.", ep);
    nrf_usbd_ep_stall(NRF_USBD, ep_to_hal(ep));
}
   2287e:	4770      	bx	lr
   22880:	40036000 	.word	0x40036000

00022884 <nrfx_usbd_ep_stall_check>:
    if (NRF_USBD_EPISO_CHECK(ep))
   22884:	0702      	lsls	r2, r0, #28
   22886:	d413      	bmi.n	228b0 <nrfx_usbd_ep_stall_check+0x2c>
        return p_reg->HALTED.EPIN[epnr];
   22888:	f000 030f 	and.w	r3, r0, #15
    if (NRF_USBD_EPIN_CHECK(ep))
   2288c:	f010 0f80 	tst.w	r0, #128	; 0x80
   22890:	4a08      	ldr	r2, [pc, #32]	; (228b4 <nrfx_usbd_ep_stall_check+0x30>)
        return p_reg->HALTED.EPOUT[epnr];
   22892:	bf0b      	itete	eq
   22894:	f503 7388 	addeq.w	r3, r3, #272	; 0x110
        return p_reg->HALTED.EPIN[epnr];
   22898:	f503 7384 	addne.w	r3, r3, #264	; 0x108
        return p_reg->HALTED.EPOUT[epnr];
   2289c:	eb02 0283 	addeq.w	r2, r2, r3, lsl #2
        return p_reg->HALTED.EPIN[epnr];
   228a0:	f852 0023 	ldrne.w	r0, [r2, r3, lsl #2]
        return p_reg->HALTED.EPOUT[epnr];
   228a4:	bf08      	it	eq
   228a6:	6850      	ldreq	r0, [r2, #4]
    return USBD_HALTED_EPOUT_GETSTATUS_Halted == nrf_usbd_halted_get(p_reg, ep);
   228a8:	1e43      	subs	r3, r0, #1
   228aa:	4258      	negs	r0, r3
   228ac:	4158      	adcs	r0, r3
   228ae:	4770      	bx	lr
        return false;
   228b0:	2000      	movs	r0, #0
}

bool nrfx_usbd_ep_stall_check(nrfx_usbd_ep_t ep)
{
    return nrf_usbd_ep_is_stall(NRF_USBD, ep_to_hal(ep));
}
   228b2:	4770      	bx	lr
   228b4:	40036000 	.word	0x40036000

000228b8 <nrfx_usbd_ep_dtoggle_clear>:
    p_reg->DTOGGLE = ep | (NRF_USBD_DTOGGLE_NOP << USBD_DTOGGLE_VALUE_Pos);
   228b8:	4b04      	ldr	r3, [pc, #16]	; (228cc <nrfx_usbd_ep_dtoggle_clear+0x14>)
   228ba:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    p_reg->DTOGGLE = ep | (op << USBD_DTOGGLE_VALUE_Pos);
   228be:	f440 7080 	orr.w	r0, r0, #256	; 0x100
   228c2:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
    (void) p_reg->DTOGGLE;
   228c6:	f8d3 350c 	ldr.w	r3, [r3, #1292]	; 0x50c

void nrfx_usbd_ep_dtoggle_clear(nrfx_usbd_ep_t ep)
{
    nrf_usbd_dtoggle_set(NRF_USBD, ep, NRF_USBD_DTOGGLE_DATA0);
}
   228ca:	4770      	bx	lr
   228cc:	40036000 	.word	0x40036000

000228d0 <nrfx_usbd_setup_get>:

void nrfx_usbd_setup_get(nrfx_usbd_setup_t * p_setup)
{
   228d0:	b510      	push	{r4, lr}
   228d2:	4604      	mov	r4, r0
    memset(p_setup, 0, sizeof(nrfx_usbd_setup_t));
   228d4:	2208      	movs	r2, #8
   228d6:	2100      	movs	r1, #0
   228d8:	f002 fb86 	bl	24fe8 <memset>
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   228dc:	4b0e      	ldr	r3, [pc, #56]	; (22918 <nrfx_usbd_setup_get+0x48>)
   228de:	f8d3 2480 	ldr.w	r2, [r3, #1152]	; 0x480
   228e2:	7022      	strb	r2, [r4, #0]
    return (uint8_t)(p_reg->BREQUEST);
   228e4:	f8d3 2484 	ldr.w	r2, [r3, #1156]	; 0x484
   228e8:	7062      	strb	r2, [r4, #1]
    const uint16_t val = p_reg->WVALUEL;
   228ea:	f8d3 2488 	ldr.w	r2, [r3, #1160]	; 0x488
    return (uint16_t)(val | ((p_reg->WVALUEH) << 8));
   228ee:	f8d3 148c 	ldr.w	r1, [r3, #1164]	; 0x48c
   228f2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->bmRequestType = nrf_usbd_setup_bmrequesttype_get(NRF_USBD);
    p_setup->bRequest      = nrf_usbd_setup_brequest_get(NRF_USBD);
    p_setup->wValue        = nrf_usbd_setup_wvalue_get(NRF_USBD);
   228f6:	8062      	strh	r2, [r4, #2]
    const uint16_t val = p_reg->WINDEXL;
   228f8:	f8d3 2490 	ldr.w	r2, [r3, #1168]	; 0x490
    return (uint16_t)(val | ((p_reg->WINDEXH) << 8));
   228fc:	f8d3 1494 	ldr.w	r1, [r3, #1172]	; 0x494
   22900:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
    p_setup->wIndex        = nrf_usbd_setup_windex_get(NRF_USBD);
   22904:	80a2      	strh	r2, [r4, #4]
    const uint16_t val = p_reg->WLENGTHL;
   22906:	f8d3 2498 	ldr.w	r2, [r3, #1176]	; 0x498
    return (uint16_t)(val | ((p_reg->WLENGTHH) << 8));
   2290a:	f8d3 349c 	ldr.w	r3, [r3, #1180]	; 0x49c
   2290e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    p_setup->wLength       = nrf_usbd_setup_wlength_get(NRF_USBD);
   22912:	80e3      	strh	r3, [r4, #6]
}
   22914:	bd10      	pop	{r4, pc}
   22916:	bf00      	nop
   22918:	40036000 	.word	0x40036000

0002291c <nrfx_usbd_setup_data_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   2291c:	2201      	movs	r2, #1
   2291e:	4b02      	ldr	r3, [pc, #8]	; (22928 <nrfx_usbd_setup_data_clear+0xc>)
   22920:	64da      	str	r2, [r3, #76]	; 0x4c
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   22922:	6cdb      	ldr	r3, [r3, #76]	; 0x4c

void nrfx_usbd_setup_data_clear(void)
{
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0RCVOUT);
}
   22924:	4770      	bx	lr
   22926:	bf00      	nop
   22928:	40036000 	.word	0x40036000

0002292c <ev_dma_epout0_handler>:
    m_dma_pending = false;
   2292c:	2200      	movs	r2, #0
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   2292e:	b513      	push	{r0, r1, r4, lr}
    m_dma_pending = false;
   22930:	4b11      	ldr	r3, [pc, #68]	; (22978 <ev_dma_epout0_handler+0x4c>)
   22932:	701a      	strb	r2, [r3, #0]
    if (NRFX_USBD_EP_ABORTED == p_state->status)
   22934:	4b11      	ldr	r3, [pc, #68]	; (2297c <ev_dma_epout0_handler+0x50>)
   22936:	7b9a      	ldrb	r2, [r3, #14]
   22938:	2a03      	cmp	r2, #3
   2293a:	d106      	bne.n	2294a <ev_dma_epout0_handler+0x1e>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2293c:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   22940:	b002      	add	sp, #8
   22942:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   22946:	f7ff bc3f 	b.w	221c8 <atomic_and.constprop.0.isra.0>
    else if (p_state->handler.consumer == NULL)
   2294a:	681c      	ldr	r4, [r3, #0]
   2294c:	b974      	cbnz	r4, 2296c <ev_dma_epout0_handler+0x40>
        (void)(NRFX_ATOMIC_FETCH_AND(&m_ep_dma_waiting, ~(1U << ep2bit(ep))));
   2294e:	f46f 3080 	mvn.w	r0, #65536	; 0x10000
   22952:	f7ff fc39 	bl	221c8 <atomic_and.constprop.0.isra.0>
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   22956:	2306      	movs	r3, #6
   22958:	f88d 3004 	strb.w	r3, [sp, #4]
        m_event_handler(&evt);
   2295c:	4b08      	ldr	r3, [pc, #32]	; (22980 <ev_dma_epout0_handler+0x54>)
        NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_OK);
   2295e:	f8ad 4006 	strh.w	r4, [sp, #6]
        m_event_handler(&evt);
   22962:	681b      	ldr	r3, [r3, #0]
   22964:	a801      	add	r0, sp, #4
   22966:	4798      	blx	r3
static void ev_dma_epout0_handler(void) { nrf_usbd_ep0out_dma_handler(); }
   22968:	b002      	add	sp, #8
   2296a:	bd10      	pop	{r4, pc}
   2296c:	b002      	add	sp, #8
   2296e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        nrfx_usbd_setup_data_clear();
   22972:	f7ff bfd3 	b.w	2291c <nrfx_usbd_setup_data_clear>
   22976:	bf00      	nop
   22978:	2000b627 	.word	0x2000b627
   2297c:	2000b484 	.word	0x2000b484
   22980:	2000b5ac 	.word	0x2000b5ac

00022984 <nrfx_usbd_setup_clear>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   22984:	2201      	movs	r2, #1
   22986:	4b02      	ldr	r3, [pc, #8]	; (22990 <nrfx_usbd_setup_clear+0xc>)
   22988:	651a      	str	r2, [r3, #80]	; 0x50
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   2298a:	6d1b      	ldr	r3, [r3, #80]	; 0x50

void nrfx_usbd_setup_clear(void)
{
    NRFX_LOG_DEBUG(">> ep0status >>");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STATUS);
}
   2298c:	4770      	bx	lr
   2298e:	bf00      	nop
   22990:	40036000 	.word	0x40036000

00022994 <nrfx_usbd_setup_stall>:
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)task)) = 1UL;
   22994:	2201      	movs	r2, #1
   22996:	4b02      	ldr	r3, [pc, #8]	; (229a0 <nrfx_usbd_setup_stall+0xc>)
   22998:	655a      	str	r2, [r3, #84]	; 0x54
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)task));
   2299a:	6d5b      	ldr	r3, [r3, #84]	; 0x54

void nrfx_usbd_setup_stall(void)
{
    NRFX_LOG_DEBUG("Setup stalled.");
    nrf_usbd_task_trigger(NRF_USBD, NRF_USBD_TASK_EP0STALL);
}
   2299c:	4770      	bx	lr
   2299e:	bf00      	nop
   229a0:	40036000 	.word	0x40036000

000229a4 <nrfx_usbd_last_setup_dir_get>:

nrfx_usbd_ep_t nrfx_usbd_last_setup_dir_get(void)
{
    return m_last_setup_dir;
}
   229a4:	4b01      	ldr	r3, [pc, #4]	; (229ac <nrfx_usbd_last_setup_dir_get+0x8>)
   229a6:	7818      	ldrb	r0, [r3, #0]
   229a8:	4770      	bx	lr
   229aa:	bf00      	nop
   229ac:	2000b628 	.word	0x2000b628

000229b0 <nrfx_usbd_transfer_out_drop>:

void nrfx_usbd_transfer_out_drop(nrfx_usbd_ep_t ep)
{
   229b0:	4602      	mov	r2, r0
   229b2:	b510      	push	{r4, lr}
	__asm__ volatile(
   229b4:	f04f 0320 	mov.w	r3, #32
   229b8:	f3ef 8411 	mrs	r4, BASEPRI
   229bc:	f383 8812 	msr	BASEPRI_MAX, r3
   229c0:	f3bf 8f6f 	isb	sy
    NRFX_ASSERT(NRF_USBD_EPOUT_CHECK(ep));

    NRFX_CRITICAL_SECTION_ENTER();
    m_ep_ready &= ~(1U << ep2bit(ep));
   229c4:	f003 f81e 	bl	25a04 <ep2bit>
   229c8:	2301      	movs	r3, #1
   229ca:	490d      	ldr	r1, [pc, #52]	; (22a00 <nrfx_usbd_transfer_out_drop+0x50>)
   229cc:	fa03 f000 	lsl.w	r0, r3, r0
   229d0:	680b      	ldr	r3, [r1, #0]
   229d2:	ea23 0300 	bic.w	r3, r3, r0
   229d6:	600b      	str	r3, [r1, #0]
    if (!NRF_USBD_EPISO_CHECK(ep))
   229d8:	f012 0108 	ands.w	r1, r2, #8
   229dc:	d10a      	bne.n	229f4 <nrfx_usbd_transfer_out_drop+0x44>
    p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)] = 0;
   229de:	f002 030f 	and.w	r3, r2, #15
   229e2:	009b      	lsls	r3, r3, #2
   229e4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   229e8:	f503 3358 	add.w	r3, r3, #221184	; 0x36000
   229ec:	f8c3 14a0 	str.w	r1, [r3, #1184]	; 0x4a0
    (void) p_reg->SIZE.EPOUT[NRF_USBD_EP_NR_GET(ep)];
   229f0:	f8d3 34a0 	ldr.w	r3, [r3, #1184]	; 0x4a0
	__asm__ volatile(
   229f4:	f384 8811 	msr	BASEPRI, r4
   229f8:	f3bf 8f6f 	isb	sy
    {
        nrf_usbd_epout_clear(NRF_USBD, ep);
    }
    NRFX_CRITICAL_SECTION_EXIT();
}
   229fc:	bd10      	pop	{r4, pc}
   229fe:	bf00      	nop
   22a00:	2000b5a8 	.word	0x2000b5a8

00022a04 <usbd_ep_abort>:
{
   22a04:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   22a06:	4601      	mov	r1, r0
	__asm__ volatile(
   22a08:	f04f 0320 	mov.w	r3, #32
   22a0c:	f3ef 8511 	mrs	r5, BASEPRI
   22a10:	f383 8812 	msr	BASEPRI_MAX, r3
   22a14:	f3bf 8f6f 	isb	sy
    usbd_ep_state_t * p_state = ep_state_access(ep);
   22a18:	f7ff fb1a 	bl	22050 <ep_state_access>
   22a1c:	4606      	mov	r6, r0
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   22a1e:	4608      	mov	r0, r1
   22a20:	f002 fff0 	bl	25a04 <ep2bit>
   22a24:	2201      	movs	r2, #1
    if (NRF_USBD_EPOUT_CHECK(ep))
   22a26:	f011 0f80 	tst.w	r1, #128	; 0x80
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   22a2a:	fa02 f200 	lsl.w	r2, r2, r0
   22a2e:	482e      	ldr	r0, [pc, #184]	; (22ae8 <usbd_ep_abort+0xe4>)
    if (NRF_USBD_EPOUT_CHECK(ep))
   22a30:	d119      	bne.n	22a66 <usbd_ep_abort+0x62>
        if ((~m_ep_dma_waiting) & (1U << ep2bit(ep)))
   22a32:	6803      	ldr	r3, [r0, #0]
   22a34:	ea32 0303 	bics.w	r3, r2, r3
   22a38:	d00a      	beq.n	22a50 <usbd_ep_abort+0x4c>
            nrfx_usbd_transfer_out_drop(ep);
   22a3a:	4608      	mov	r0, r1
   22a3c:	f7ff ffb8 	bl	229b0 <nrfx_usbd_transfer_out_drop>
        p_state->status = NRFX_USBD_EP_ABORTED;
   22a40:	2303      	movs	r3, #3
   22a42:	73b3      	strb	r3, [r6, #14]
	__asm__ volatile(
   22a44:	f385 8811 	msr	BASEPRI, r5
   22a48:	f3bf 8f6f 	isb	sy
}
   22a4c:	b003      	add	sp, #12
   22a4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
            p_state->handler.consumer = NULL;
   22a50:	6033      	str	r3, [r6, #0]
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22a52:	6803      	ldr	r3, [r0, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
   22a54:	4925      	ldr	r1, [pc, #148]	; (22aec <usbd_ep_abort+0xe8>)
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22a56:	ea23 0302 	bic.w	r3, r3, r2
   22a5a:	6003      	str	r3, [r0, #0]
            m_ep_ready &= ~(1U << ep2bit(ep));
   22a5c:	680b      	ldr	r3, [r1, #0]
   22a5e:	ea23 0302 	bic.w	r3, r3, r2
   22a62:	600b      	str	r3, [r1, #0]
   22a64:	e7ec      	b.n	22a40 <usbd_ep_abort+0x3c>
        if(!NRF_USBD_EPISO_CHECK(ep))
   22a66:	070b      	lsls	r3, r1, #28
   22a68:	d415      	bmi.n	22a96 <usbd_ep_abort+0x92>
            if(ep != NRFX_USBD_EPIN0)
   22a6a:	2980      	cmp	r1, #128	; 0x80
   22a6c:	4b20      	ldr	r3, [pc, #128]	; (22af0 <usbd_ep_abort+0xec>)
   22a6e:	d02f      	beq.n	22ad0 <usbd_ep_abort+0xcc>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B6 + (2u * (NRF_USBD_EP_NR_GET(ep) - 1));
   22a70:	f001 040f 	and.w	r4, r1, #15
   22a74:	f204 34da 	addw	r4, r4, #986	; 0x3da
   22a78:	0064      	lsls	r4, r4, #1
   22a7a:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22a7e:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22a82:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22a86:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22a88:	f044 0402 	orr.w	r4, r4, #2
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22a8c:	433c      	orrs	r4, r7
   22a8e:	f8c3 4804 	str.w	r4, [r3, #2052]	; 0x804
                (void)(*((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)));
   22a92:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
        if ((m_ep_dma_waiting | (~m_ep_ready)) & (1U << ep2bit(ep)))
   22a96:	4f15      	ldr	r7, [pc, #84]	; (22aec <usbd_ep_abort+0xe8>)
   22a98:	6804      	ldr	r4, [r0, #0]
   22a9a:	683b      	ldr	r3, [r7, #0]
   22a9c:	ea64 0c03 	orn	ip, r4, r3
   22aa0:	ea1c 0f02 	tst.w	ip, r2
   22aa4:	d0ce      	beq.n	22a44 <usbd_ep_abort+0x40>
            m_ep_ready       |=   1U << ep2bit(ep) ;
   22aa6:	4313      	orrs	r3, r2
   22aa8:	603b      	str	r3, [r7, #0]
            p_state->handler.feeder = NULL;
   22aaa:	2300      	movs	r3, #0
            m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22aac:	ea24 0402 	bic.w	r4, r4, r2
   22ab0:	6004      	str	r4, [r0, #0]
            p_state->handler.feeder = NULL;
   22ab2:	6033      	str	r3, [r6, #0]
            p_state->status = NRFX_USBD_EP_ABORTED;
   22ab4:	2303      	movs	r3, #3
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22ab6:	2206      	movs	r2, #6
            p_state->status = NRFX_USBD_EP_ABORTED;
   22ab8:	73b3      	strb	r3, [r6, #14]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22aba:	f88d 3007 	strb.w	r3, [sp, #7]
            m_event_handler(&evt);
   22abe:	4b0d      	ldr	r3, [pc, #52]	; (22af4 <usbd_ep_abort+0xf0>)
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22ac0:	f88d 2004 	strb.w	r2, [sp, #4]
            m_event_handler(&evt);
   22ac4:	681b      	ldr	r3, [r3, #0]
            NRFX_USBD_EP_TRANSFER_EVENT(evt, ep, NRFX_USBD_EP_ABORTED);
   22ac6:	f88d 1006 	strb.w	r1, [sp, #6]
            m_event_handler(&evt);
   22aca:	a801      	add	r0, sp, #4
   22acc:	4798      	blx	r3
   22ace:	e7b9      	b.n	22a44 <usbd_ep_abort+0x40>
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x800)) = 0x7B4;
   22ad0:	f240 74b4 	movw	r4, #1972	; 0x7b4
   22ad4:	f8c3 4800 	str.w	r4, [r3, #2048]	; 0x800
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22ad8:	f8d3 4804 	ldr.w	r4, [r3, #2052]	; 0x804
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22adc:	f8d3 7804 	ldr.w	r7, [r3, #2052]	; 0x804
                uint8_t temp = *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804));
   22ae0:	b2e4      	uxtb	r4, r4
                *((volatile uint32_t *)((uint32_t)(NRF_USBD) + 0x804)) |= temp;
   22ae2:	f044 0404 	orr.w	r4, r4, #4
   22ae6:	e7d1      	b.n	22a8c <usbd_ep_abort+0x88>
   22ae8:	2000b5a4 	.word	0x2000b5a4
   22aec:	2000b5a8 	.word	0x2000b5a8
   22af0:	40036000 	.word	0x40036000
   22af4:	2000b5ac 	.word	0x2000b5ac

00022af8 <ev_setup_handler>:
{
   22af8:	b573      	push	{r0, r1, r4, r5, r6, lr}
    return (uint8_t)(p_reg->BMREQUESTTYPE);
   22afa:	4b14      	ldr	r3, [pc, #80]	; (22b4c <ev_setup_handler+0x54>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22afc:	4c14      	ldr	r4, [pc, #80]	; (22b50 <ev_setup_handler+0x58>)
   22afe:	f8d3 5480 	ldr.w	r5, [r3, #1152]	; 0x480
   22b02:	6823      	ldr	r3, [r4, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
   22b04:	4e13      	ldr	r6, [pc, #76]	; (22b54 <ev_setup_handler+0x5c>)
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b06:	43da      	mvns	r2, r3
   22b08:	4b13      	ldr	r3, [pc, #76]	; (22b58 <ev_setup_handler+0x60>)
        & (1U <<ep2bit(m_last_setup_dir)))
   22b0a:	7831      	ldrb	r1, [r6, #0]
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b0c:	681b      	ldr	r3, [r3, #0]
        & (1U <<ep2bit(m_last_setup_dir)))
   22b0e:	4608      	mov	r0, r1
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b10:	b292      	uxth	r2, r2
   22b12:	431a      	orrs	r2, r3
        & (1U <<ep2bit(m_last_setup_dir)))
   22b14:	f002 ff76 	bl	25a04 <ep2bit>
   22b18:	2301      	movs	r3, #1
   22b1a:	4083      	lsls	r3, r0
    if ((m_ep_dma_waiting | ((~m_ep_ready) & NRFX_USBD_EPIN_BIT_MASK))
   22b1c:	4213      	tst	r3, r2
   22b1e:	d002      	beq.n	22b26 <ev_setup_handler+0x2e>
        usbd_ep_abort(m_last_setup_dir);
   22b20:	4608      	mov	r0, r1
   22b22:	f7ff ff6f 	bl	22a04 <usbd_ep_abort>
    (void)(NRFX_ATOMIC_FETCH_AND(
   22b26:	f06f 1001 	mvn.w	r0, #65537	; 0x10001
        NRFX_USBD_EPOUT0 : NRFX_USBD_EPIN0;
   22b2a:	f025 057f 	bic.w	r5, r5, #127	; 0x7f
    m_last_setup_dir =
   22b2e:	7035      	strb	r5, [r6, #0]
    (void)(NRFX_ATOMIC_FETCH_AND(
   22b30:	f7ff fb4a 	bl	221c8 <atomic_and.constprop.0.isra.0>
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
   22b34:	6823      	ldr	r3, [r4, #0]
    m_event_handler(&evt);
   22b36:	a801      	add	r0, sp, #4
    m_ep_ready |= 1U << ep2bit(NRFX_USBD_EPIN0);
   22b38:	f043 0301 	orr.w	r3, r3, #1
   22b3c:	6023      	str	r3, [r4, #0]
    const nrfx_usbd_evt_t evt = {
   22b3e:	2305      	movs	r3, #5
   22b40:	9301      	str	r3, [sp, #4]
    m_event_handler(&evt);
   22b42:	4b06      	ldr	r3, [pc, #24]	; (22b5c <ev_setup_handler+0x64>)
   22b44:	681b      	ldr	r3, [r3, #0]
   22b46:	4798      	blx	r3
}
   22b48:	b002      	add	sp, #8
   22b4a:	bd70      	pop	{r4, r5, r6, pc}
   22b4c:	40036000 	.word	0x40036000
   22b50:	2000b5a8 	.word	0x2000b5a8
   22b54:	2000b628 	.word	0x2000b628
   22b58:	2000b5a4 	.word	0x2000b5a4
   22b5c:	2000b5ac 	.word	0x2000b5ac

00022b60 <nrfx_usbd_irq_handler>:
{
   22b60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return p_reg->INTENSET;
   22b64:	4b1a      	ldr	r3, [pc, #104]	; (22bd0 <nrfx_usbd_irq_handler+0x70>)
            active |= 1UL << event_nr;
   22b66:	2401      	movs	r4, #1
   22b68:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
    uint32_t active = 0;
   22b6c:	2300      	movs	r3, #0
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   22b6e:	461d      	mov	r5, r3
    while (to_process)
   22b70:	b970      	cbnz	r0, 22b90 <nrfx_usbd_irq_handler+0x30>
        active &= ~(1UL << event_nr);
   22b72:	f04f 0801 	mov.w	r8, #1
        m_isr[event_nr]();
   22b76:	4f17      	ldr	r7, [pc, #92]	; (22bd4 <nrfx_usbd_irq_handler+0x74>)
    bool setup_active = 0 != (active & NRF_USBD_INT_EP0SETUP_MASK);
   22b78:	f403 0600 	and.w	r6, r3, #8388608	; 0x800000
    active &= ~NRF_USBD_INT_EP0SETUP_MASK;
   22b7c:	f423 0400 	bic.w	r4, r3, #8388608	; 0x800000
    while (active)
   22b80:	b9bc      	cbnz	r4, 22bb2 <nrfx_usbd_irq_handler+0x52>
    usbd_dmareq_process();
   22b82:	f7ff fd67 	bl	22654 <usbd_dmareq_process>
    if (setup_active)
   22b86:	b306      	cbz	r6, 22bca <nrfx_usbd_irq_handler+0x6a>
}
   22b88:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        m_isr[USBD_INTEN_EP0SETUP_Pos]();
   22b8c:	f7ff bfb4 	b.w	22af8 <ev_setup_handler>
        uint8_t event_nr = NRF_CTZ(to_process);
   22b90:	fa90 f2a0 	rbit	r2, r0
   22b94:	fab2 f282 	clz	r2, r2
    return (volatile const uint32_t*)(((uint8_t *)p_reg) + (uint32_t)offset);
   22b98:	490f      	ldr	r1, [pc, #60]	; (22bd8 <nrfx_usbd_irq_handler+0x78>)
}

NRF_STATIC_INLINE uint32_t nrfx_bitpos_to_event(uint32_t bit)
{
    static const uint32_t event_reg_offset = 0x100u;
    return event_reg_offset + (bit * sizeof(uint32_t));
   22b9a:	0096      	lsls	r6, r2, #2
   22b9c:	4431      	add	r1, r6
    return (bool)*nrf_usbd_getRegPtr_c(p_reg, (uint32_t)event);
   22b9e:	680e      	ldr	r6, [r1, #0]
            active |= 1UL << event_nr;
   22ba0:	fa04 f202 	lsl.w	r2, r4, r2
    if (ret)
   22ba4:	b116      	cbz	r6, 22bac <nrfx_usbd_irq_handler+0x4c>
    *(nrf_usbd_getRegPtr(p_reg, (uint32_t)event)) = 0UL;
   22ba6:	600d      	str	r5, [r1, #0]
    (void)*(nrf_usbd_getRegPtr(p_reg, (uint32_t)event));
   22ba8:	6809      	ldr	r1, [r1, #0]
   22baa:	4313      	orrs	r3, r2
        to_process &= ~(1UL << event_nr);
   22bac:	ea20 0002 	bic.w	r0, r0, r2
   22bb0:	e7de      	b.n	22b70 <nrfx_usbd_irq_handler+0x10>
        uint8_t event_nr = NRF_CTZ(active);
   22bb2:	fa94 f5a4 	rbit	r5, r4
   22bb6:	fab5 f585 	clz	r5, r5
        m_isr[event_nr]();
   22bba:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
        active &= ~(1UL << event_nr);
   22bbe:	fa08 f505 	lsl.w	r5, r8, r5
        m_isr[event_nr]();
   22bc2:	4798      	blx	r3
        active &= ~(1UL << event_nr);
   22bc4:	ea24 0405 	bic.w	r4, r4, r5
   22bc8:	e7da      	b.n	22b80 <nrfx_usbd_irq_handler+0x20>
}
   22bca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   22bce:	bf00      	nop
   22bd0:	40036000 	.word	0x40036000
   22bd4:	00026908 	.word	0x00026908
   22bd8:	40036100 	.word	0x40036100

00022bdc <nrfx_usbd_stop>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   22bdc:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
{
   22be0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   22be2:	4b1a      	ldr	r3, [pc, #104]	; (22c4c <nrfx_usbd_stop+0x70>)
    if (NRFX_IRQ_IS_ENABLED(USBD_IRQn))
   22be4:	2036      	movs	r0, #54	; 0x36
   22be6:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
   22bea:	f7fb fb93 	bl	1e314 <arch_irq_is_enabled>
   22bee:	b1b8      	cbz	r0, 22c20 <nrfx_usbd_stop+0x44>
        ep_waiting &= ~(1U << bitpos);
   22bf0:	2701      	movs	r7, #1
    uint32_t ep_waiting = m_ep_dma_waiting | (m_ep_ready & NRFX_USBD_EPOUT_BIT_MASK);
   22bf2:	4e17      	ldr	r6, [pc, #92]	; (22c50 <nrfx_usbd_stop+0x74>)
   22bf4:	4b17      	ldr	r3, [pc, #92]	; (22c54 <nrfx_usbd_stop+0x78>)
   22bf6:	6834      	ldr	r4, [r6, #0]
   22bf8:	681b      	ldr	r3, [r3, #0]
   22bfa:	0c24      	lsrs	r4, r4, #16
   22bfc:	0424      	lsls	r4, r4, #16
   22bfe:	431c      	orrs	r4, r3
    while (0 != ep_waiting)
   22c00:	b97c      	cbnz	r4, 22c22 <nrfx_usbd_stop+0x46>
    m_ep_ready = (((1U << NRF_USBD_EPIN_CNT) - 1U) << NRFX_USBD_EPIN_BITPOS_0);
   22c02:	f240 13ff 	movw	r3, #511	; 0x1ff
    p_reg->USBPULLUP = USBD_USBPULLUP_CONNECT_Disabled << USBD_USBPULLUP_CONNECT_Pos;
   22c06:	4d14      	ldr	r5, [pc, #80]	; (22c58 <nrfx_usbd_stop+0x7c>)
   22c08:	6033      	str	r3, [r6, #0]
        NRFX_IRQ_DISABLE(USBD_IRQn);
   22c0a:	2036      	movs	r0, #54	; 0x36
   22c0c:	f8c5 4504 	str.w	r4, [r5, #1284]	; 0x504
    (void) p_reg->USBPULLUP;
   22c10:	f8d5 3504 	ldr.w	r3, [r5, #1284]	; 0x504
   22c14:	f7fb fb6a 	bl	1e2ec <arch_irq_disable>
    p_reg->INTENCLR = mask;
   22c18:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   22c1c:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
}
   22c20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        uint8_t bitpos = NRF_CTZ(ep_waiting);
   22c22:	fa94 f5a4 	rbit	r5, r4
   22c26:	fab5 f585 	clz	r5, r5
   22c2a:	4628      	mov	r0, r5
    return (nrfx_usbd_ep_t)((bitpos >= NRFX_USBD_EPOUT_BITPOS_0) ?
   22c2c:	2d0f      	cmp	r5, #15
   22c2e:	bfc6      	itte	gt
   22c30:	f1a5 0010 	subgt.w	r0, r5, #16
   22c34:	b2c0      	uxtbgt	r0, r0
   22c36:	f040 0080 	orrle.w	r0, r0, #128	; 0x80
        if (!NRF_USBD_EPISO_CHECK(bit2ep(bitpos)))
   22c3a:	0703      	lsls	r3, r0, #28
   22c3c:	d401      	bmi.n	22c42 <nrfx_usbd_stop+0x66>
            usbd_ep_abort(bit2ep(bitpos));
   22c3e:	f7ff fee1 	bl	22a04 <usbd_ep_abort>
        ep_waiting &= ~(1U << bitpos);
   22c42:	fa07 f505 	lsl.w	r5, r7, r5
   22c46:	ea24 0405 	bic.w	r4, r4, r5
   22c4a:	e7d9      	b.n	22c00 <nrfx_usbd_stop+0x24>
   22c4c:	e000e100 	.word	0xe000e100
   22c50:	2000b5a8 	.word	0x2000b5a8
   22c54:	2000b5a4 	.word	0x2000b5a4
   22c58:	40036000 	.word	0x40036000

00022c5c <nrfx_usbd_disable>:
{
   22c5c:	b508      	push	{r3, lr}
    nrfx_usbd_stop();
   22c5e:	f7ff ffbd 	bl	22bdc <nrfx_usbd_stop>
    return p_reg->INTENSET;
   22c62:	4b08      	ldr	r3, [pc, #32]	; (22c84 <nrfx_usbd_disable+0x28>)
   22c64:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
    p_reg->INTENCLR = mask;
   22c68:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->ENABLE = USBD_ENABLE_ENABLE_Disabled << USBD_ENABLE_ENABLE_Pos;
   22c6c:	2200      	movs	r2, #0
   22c6e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    (void) p_reg->ENABLE;
   22c72:	f8d3 3500 	ldr.w	r3, [r3, #1280]	; 0x500
    m_dma_pending = false;
   22c76:	4b04      	ldr	r3, [pc, #16]	; (22c88 <nrfx_usbd_disable+0x2c>)
   22c78:	701a      	strb	r2, [r3, #0]
    m_drv_state = NRFX_DRV_STATE_INITIALIZED;
   22c7a:	2201      	movs	r2, #1
   22c7c:	4b03      	ldr	r3, [pc, #12]	; (22c8c <nrfx_usbd_disable+0x30>)
   22c7e:	701a      	strb	r2, [r3, #0]
}
   22c80:	bd08      	pop	{r3, pc}
   22c82:	bf00      	nop
   22c84:	40036000 	.word	0x40036000
   22c88:	2000b627 	.word	0x2000b627
   22c8c:	2000b62a 	.word	0x2000b62a

00022c90 <nrfx_usbd_ep_disable>:
{
   22c90:	b510      	push	{r4, lr}
   22c92:	4604      	mov	r4, r0
    usbd_ep_abort(ep);
   22c94:	f7ff feb6 	bl	22a04 <usbd_ep_abort>
        p_reg->EPINEN &= ~(1UL << epnr);
   22c98:	2301      	movs	r3, #1
    uint8_t epnr = NRF_USBD_EP_NR_GET(ep);
   22c9a:	f004 000f 	and.w	r0, r4, #15
        p_reg->EPINEN &= ~(1UL << epnr);
   22c9e:	4083      	lsls	r3, r0
   22ca0:	43db      	mvns	r3, r3
   22ca2:	4a0c      	ldr	r2, [pc, #48]	; (22cd4 <nrfx_usbd_ep_disable+0x44>)
    if (NRF_USBD_EPIN_CHECK(ep))
   22ca4:	f014 0f80 	tst.w	r4, #128	; 0x80
        p_reg->EPINEN &= ~(1UL << epnr);
   22ca8:	bf15      	itete	ne
   22caa:	f8d2 1510 	ldrne.w	r1, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   22cae:	f8d2 1514 	ldreq.w	r1, [r2, #1300]	; 0x514
        p_reg->EPINEN &= ~(1UL << epnr);
   22cb2:	400b      	andne	r3, r1
        p_reg->EPOUTEN &= ~(1UL << epnr);
   22cb4:	400b      	andeq	r3, r1
        p_reg->EPINEN &= ~(1UL << epnr);
   22cb6:	bf15      	itete	ne
   22cb8:	f8c2 3510 	strne.w	r3, [r2, #1296]	; 0x510
        p_reg->EPOUTEN &= ~(1UL << epnr);
   22cbc:	f8c2 3514 	streq.w	r3, [r2, #1300]	; 0x514
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22cc0:	4b05      	ldrne	r3, [pc, #20]	; (22cd8 <nrfx_usbd_ep_disable+0x48>)
   22cc2:	4b06      	ldreq	r3, [pc, #24]	; (22cdc <nrfx_usbd_ep_disable+0x4c>)
   22cc4:	5c1a      	ldrb	r2, [r3, r0]
   22cc6:	2301      	movs	r3, #1
   22cc8:	4093      	lsls	r3, r2
    p_reg->INTENCLR = mask;
   22cca:	4a02      	ldr	r2, [pc, #8]	; (22cd4 <nrfx_usbd_ep_disable+0x44>)
   22ccc:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
   22cd0:	bd10      	pop	{r4, pc}
   22cd2:	bf00      	nop
   22cd4:	40036000 	.word	0x40036000
   22cd8:	00026b47 	.word	0x00026b47
   22cdc:	00026b3e 	.word	0x00026b3e

00022ce0 <nrfx_usbd_ep_enable>:
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22ce0:	f010 0f80 	tst.w	r0, #128	; 0x80
{
   22ce4:	b570      	push	{r4, r5, r6, lr}
   22ce6:	4924      	ldr	r1, [pc, #144]	; (22d78 <nrfx_usbd_ep_enable+0x98>)
   22ce8:	4604      	mov	r4, r0
   22cea:	f04f 0501 	mov.w	r5, #1
   22cee:	f000 030f 	and.w	r3, r0, #15
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22cf2:	d012      	beq.n	22d1a <nrfx_usbd_ep_enable+0x3a>
   22cf4:	4a21      	ldr	r2, [pc, #132]	; (22d7c <nrfx_usbd_ep_enable+0x9c>)
   22cf6:	5cd2      	ldrb	r2, [r2, r3]
   22cf8:	fa05 f202 	lsl.w	r2, r5, r2
    p_reg->INTENSET = mask;
   22cfc:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
        return 0 != (p_reg->EPINEN & (1UL << epnr));
   22d00:	f8d1 2510 	ldr.w	r2, [r1, #1296]	; 0x510
   22d04:	40da      	lsrs	r2, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   22d06:	07d0      	lsls	r0, r2, #31
   22d08:	d406      	bmi.n	22d18 <nrfx_usbd_ep_enable+0x38>
        p_reg->EPINEN |= 1UL << epnr;
   22d0a:	f8d1 2510 	ldr.w	r2, [r1, #1296]	; 0x510
   22d0e:	fa05 f303 	lsl.w	r3, r5, r3
   22d12:	4313      	orrs	r3, r2
   22d14:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
}
   22d18:	bd70      	pop	{r4, r5, r6, pc}
    return 1UL << (NRF_USBD_EPIN_CHECK(ep) ? epin_bitpos : epout_bitpos)[NRF_USBD_EP_NR_GET(ep)];
   22d1a:	4a19      	ldr	r2, [pc, #100]	; (22d80 <nrfx_usbd_ep_enable+0xa0>)
   22d1c:	5cd2      	ldrb	r2, [r2, r3]
   22d1e:	fa05 f202 	lsl.w	r2, r5, r2
    p_reg->INTENSET = mask;
   22d22:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
        return 0 != (p_reg->EPOUTEN & (1UL << epnr));
   22d26:	f8d1 2514 	ldr.w	r2, [r1, #1300]	; 0x514
   22d2a:	40da      	lsrs	r2, r3
    if (nrf_usbd_ep_enable_check(NRF_USBD, ep))
   22d2c:	07d2      	lsls	r2, r2, #31
   22d2e:	d4f3      	bmi.n	22d18 <nrfx_usbd_ep_enable+0x38>
        p_reg->EPOUTEN |= 1UL << epnr;
   22d30:	f8d1 6514 	ldr.w	r6, [r1, #1300]	; 0x514
   22d34:	fa05 f203 	lsl.w	r2, r5, r3
   22d38:	4332      	orrs	r2, r6
   22d3a:	f8c1 2514 	str.w	r2, [r1, #1300]	; 0x514
    if ((NRF_USBD_EP_NR_GET(ep) != 0) &&
   22d3e:	2b00      	cmp	r3, #0
   22d40:	d0ea      	beq.n	22d18 <nrfx_usbd_ep_enable+0x38>
        NRF_USBD_EPOUT_CHECK(ep) &&
   22d42:	0703      	lsls	r3, r0, #28
   22d44:	d4e8      	bmi.n	22d18 <nrfx_usbd_ep_enable+0x38>
	__asm__ volatile(
   22d46:	f04f 0320 	mov.w	r3, #32
   22d4a:	f3ef 8611 	mrs	r6, BASEPRI
   22d4e:	f383 8812 	msr	BASEPRI_MAX, r3
   22d52:	f3bf 8f6f 	isb	sy
        nrfx_usbd_transfer_out_drop(ep);
   22d56:	f7ff fe2b 	bl	229b0 <nrfx_usbd_transfer_out_drop>
        m_ep_dma_waiting &= ~(1U << ep2bit(ep));
   22d5a:	4620      	mov	r0, r4
   22d5c:	f002 fe52 	bl	25a04 <ep2bit>
   22d60:	4a08      	ldr	r2, [pc, #32]	; (22d84 <nrfx_usbd_ep_enable+0xa4>)
   22d62:	fa05 f000 	lsl.w	r0, r5, r0
   22d66:	6813      	ldr	r3, [r2, #0]
   22d68:	ea23 0300 	bic.w	r3, r3, r0
   22d6c:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
   22d6e:	f386 8811 	msr	BASEPRI, r6
   22d72:	f3bf 8f6f 	isb	sy
}
   22d76:	e7cf      	b.n	22d18 <nrfx_usbd_ep_enable+0x38>
   22d78:	40036000 	.word	0x40036000
   22d7c:	00026b47 	.word	0x00026b47
   22d80:	00026b3e 	.word	0x00026b3e
   22d84:	2000b5a4 	.word	0x2000b5a4

00022d88 <nrfx_usbd_ep_stall_clear>:
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   22d88:	0603      	lsls	r3, r0, #24
{
   22d8a:	b510      	push	{r4, lr}
   22d8c:	4604      	mov	r4, r0
    if (NRF_USBD_EPOUT_CHECK(ep) && nrfx_usbd_ep_stall_check(ep))
   22d8e:	d405      	bmi.n	22d9c <nrfx_usbd_ep_stall_clear+0x14>
   22d90:	f7ff fd78 	bl	22884 <nrfx_usbd_ep_stall_check>
   22d94:	b110      	cbz	r0, 22d9c <nrfx_usbd_ep_stall_clear+0x14>
        nrfx_usbd_transfer_out_drop(ep);
   22d96:	4620      	mov	r0, r4
   22d98:	f7ff fe0a 	bl	229b0 <nrfx_usbd_transfer_out_drop>
    p_reg->EPSTALL = (USBD_EPSTALL_STALL_UnStall << USBD_EPSTALL_STALL_Pos) | ep;
   22d9c:	4b01      	ldr	r3, [pc, #4]	; (22da4 <nrfx_usbd_ep_stall_clear+0x1c>)
   22d9e:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
}
   22da2:	bd10      	pop	{r4, pc}
   22da4:	40036000 	.word	0x40036000

00022da8 <nrfx_usbreg_enable>:
    p_reg->INTENSET = mask;
   22da8:	2207      	movs	r2, #7
   22daa:	4b02      	ldr	r3, [pc, #8]	; (22db4 <nrfx_usbreg_enable+0xc>)
   22dac:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
void nrfx_usbreg_enable(void)
{
    nrf_usbreg_int_enable(NRF_USBREGULATOR, NRF_USBREG_INT_USBDETECTED |
                                            NRF_USBREG_INT_USBREMOVED  |
                                            NRF_USBREG_INT_USBPWRRDY);
}
   22db0:	4770      	bx	lr
   22db2:	bf00      	nop
   22db4:	40037000 	.word	0x40037000

00022db8 <nrfx_usbreg_disable>:
    p_reg->INTENCLR = mask;
   22db8:	2207      	movs	r2, #7
   22dba:	4b02      	ldr	r3, [pc, #8]	; (22dc4 <nrfx_usbreg_disable+0xc>)
   22dbc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
void nrfx_usbreg_disable(void)
{
    nrf_usbreg_int_disable(NRF_USBREGULATOR, NRF_USBREG_INT_USBDETECTED |
                                             NRF_USBREG_INT_USBREMOVED  |
                                             NRF_USBREG_INT_USBPWRRDY);
}
   22dc0:	4770      	bx	lr
   22dc2:	bf00      	nop
   22dc4:	40037000 	.word	0x40037000

00022dc8 <nrfx_usbreg_uninit>:
   22dc8:	2207      	movs	r2, #7

void nrfx_usbreg_uninit(void)
{
   22dca:	b508      	push	{r3, lr}
   22dcc:	4b04      	ldr	r3, [pc, #16]	; (22de0 <nrfx_usbreg_uninit+0x18>)
    nrfx_usbreg_disable();
    NRFX_IRQ_DISABLE(nrfx_get_irq_number(NRF_USBREGULATOR));
   22dce:	2037      	movs	r0, #55	; 0x37
   22dd0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   22dd4:	f7fb fa8a 	bl	1e2ec <arch_irq_disable>
    m_usbevt_handler = NULL;
   22dd8:	2200      	movs	r2, #0
   22dda:	4b02      	ldr	r3, [pc, #8]	; (22de4 <nrfx_usbreg_uninit+0x1c>)
   22ddc:	601a      	str	r2, [r3, #0]
}
   22dde:	bd08      	pop	{r3, pc}
   22de0:	40037000 	.word	0x40037000
   22de4:	2000b5b0 	.word	0x2000b5b0

00022de8 <nrfx_usbreg_init>:
{
   22de8:	b510      	push	{r4, lr}
   22dea:	4604      	mov	r4, r0
    nrfx_usbreg_uninit();
   22dec:	f7ff ffec 	bl	22dc8 <nrfx_usbreg_uninit>
    m_usbevt_handler = p_config->handler;
   22df0:	6822      	ldr	r2, [r4, #0]
   22df2:	4b07      	ldr	r3, [pc, #28]	; (22e10 <nrfx_usbreg_init+0x28>)
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_USBREGULATOR));
   22df4:	2037      	movs	r0, #55	; 0x37
    m_usbevt_handler = p_config->handler;
   22df6:	601a      	str	r2, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22df8:	2200      	movs	r2, #0
   22dfa:	4b06      	ldr	r3, [pc, #24]	; (22e14 <nrfx_usbreg_init+0x2c>)
   22dfc:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   22e00:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   22e04:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
}
   22e08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_USBREGULATOR));
   22e0c:	f7fb ba60 	b.w	1e2d0 <arch_irq_enable>
   22e10:	2000b5b0 	.word	0x2000b5b0
   22e14:	40037000 	.word	0x40037000

00022e18 <nrfx_usbreg_irq_handler>:

void nrfx_usbreg_irq_handler(void)
{
   22e18:	b510      	push	{r4, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e1a:	4c11      	ldr	r4, [pc, #68]	; (22e60 <nrfx_usbreg_irq_handler+0x48>)
   22e1c:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    if (nrf_usbreg_event_check(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBDETECTED))
   22e20:	b12b      	cbz	r3, 22e2e <nrfx_usbreg_irq_handler+0x16>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e22:	2000      	movs	r0, #0
    {
        nrf_usbreg_event_clear(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBDETECTED);
        m_usbevt_handler(NRFX_USBREG_EVT_DETECTED);
   22e24:	4b0f      	ldr	r3, [pc, #60]	; (22e64 <nrfx_usbreg_irq_handler+0x4c>)
   22e26:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
   22e2a:	681b      	ldr	r3, [r3, #0]
   22e2c:	4798      	blx	r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e2e:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    }
    if (nrf_usbreg_event_check(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBREMOVED))
   22e32:	b133      	cbz	r3, 22e42 <nrfx_usbreg_irq_handler+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e34:	2300      	movs	r3, #0
   22e36:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
    {
        nrf_usbreg_event_clear(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBREMOVED);
        m_usbevt_handler(NRFX_USBREG_EVT_REMOVED);
   22e3a:	4b0a      	ldr	r3, [pc, #40]	; (22e64 <nrfx_usbreg_irq_handler+0x4c>)
   22e3c:	2001      	movs	r0, #1
   22e3e:	681b      	ldr	r3, [r3, #0]
   22e40:	4798      	blx	r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   22e42:	4b07      	ldr	r3, [pc, #28]	; (22e60 <nrfx_usbreg_irq_handler+0x48>)
   22e44:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    }
    if (nrf_usbreg_event_check(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBPWRRDY))
   22e48:	b142      	cbz	r2, 22e5c <nrfx_usbreg_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   22e4a:	2200      	movs	r2, #0
   22e4c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    {
        nrf_usbreg_event_clear(NRF_USBREGULATOR, NRF_USBREG_EVENT_USBPWRRDY);
        m_usbevt_handler(NRFX_USBREG_EVT_READY);
   22e50:	4b04      	ldr	r3, [pc, #16]	; (22e64 <nrfx_usbreg_irq_handler+0x4c>)
   22e52:	2002      	movs	r0, #2
    }
}
   22e54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        m_usbevt_handler(NRFX_USBREG_EVT_READY);
   22e58:	681b      	ldr	r3, [r3, #0]
   22e5a:	4718      	bx	r3
}
   22e5c:	bd10      	pop	{r4, pc}
   22e5e:	bf00      	nop
   22e60:	40037000 	.word	0x40037000
   22e64:	2000b5b0 	.word	0x2000b5b0

00022e68 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
   22e68:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
   22e6a:	f003 021f 	and.w	r2, r3, #31
   22e6e:	6002      	str	r2, [r0, #0]
}
   22e70:	4a03      	ldr	r2, [pc, #12]	; (22e80 <nrf_gpio_pin_port_decode+0x18>)
   22e72:	4804      	ldr	r0, [pc, #16]	; (22e84 <nrf_gpio_pin_port_decode+0x1c>)
    return pin_number >> 5;
   22e74:	095b      	lsrs	r3, r3, #5
}
   22e76:	2b01      	cmp	r3, #1
   22e78:	bf18      	it	ne
   22e7a:	4610      	movne	r0, r2
   22e7c:	4770      	bx	lr
   22e7e:	bf00      	nop
   22e80:	40842500 	.word	0x40842500
   22e84:	40842800 	.word	0x40842800

00022e88 <nrfx_twi_twim_bus_recover>:
                                                  NRF_GPIO_PIN_PULLUP,        \
                                                  NRF_GPIO_PIN_S0D1,          \
                                                  NRF_GPIO_PIN_NOSENSE)

nrfx_err_t nrfx_twi_twim_bus_recover(uint32_t scl_pin, uint32_t sda_pin)
{
   22e88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   22e8a:	4606      	mov	r6, r0
    nrf_gpio_pin_set(scl_pin);
   22e8c:	f002 fe0d 	bl	25aaa <nrf_gpio_pin_set>
    nrf_gpio_pin_set(sda_pin);
   22e90:	4608      	mov	r0, r1
   22e92:	f002 fe0a 	bl	25aaa <nrf_gpio_pin_set>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22e96:	a801      	add	r0, sp, #4
   22e98:	9601      	str	r6, [sp, #4]
   22e9a:	f7ff ffe5 	bl	22e68 <nrf_gpio_pin_port_decode>
{
   22e9e:	460c      	mov	r4, r1
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   22ea0:	f240 610d 	movw	r1, #1549	; 0x60d
   22ea4:	9b01      	ldr	r3, [sp, #4]
   22ea6:	9401      	str	r4, [sp, #4]
   22ea8:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   22eac:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200

    TWI_TWIM_PIN_CONFIGURE(scl_pin);
    TWI_TWIM_PIN_CONFIGURE(sda_pin);
    NRFX_DELAY_US(4);
   22eb0:	2509      	movs	r5, #9
   22eb2:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   22eb6:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
   22eb8:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22ebc:	a801      	add	r0, sp, #4
   22ebe:	f7ff ffd3 	bl	22e68 <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   22ec2:	9b01      	ldr	r3, [sp, #4]
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22ec4:	2701      	movs	r7, #1
   22ec6:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & GPIO_PIN_CNF_MCUSEL_Msk;
   22eca:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
   22ece:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
   22ed2:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
   22ed4:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
   22ed8:	2004      	movs	r0, #4
   22eda:	f002 fc96 	bl	2580a <nrfx_busy_wait>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22ede:	a801      	add	r0, sp, #4
   22ee0:	9401      	str	r4, [sp, #4]
   22ee2:	f7ff ffc1 	bl	22e68 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22ee6:	9a01      	ldr	r2, [sp, #4]
    return p_reg->IN;
   22ee8:	6903      	ldr	r3, [r0, #16]
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22eea:	40d3      	lsrs	r3, r2

    for (uint8_t i = 0; i < 9; i++)
    {
        if (nrf_gpio_pin_read(sda_pin))
   22eec:	07db      	lsls	r3, r3, #31
   22eee:	d414      	bmi.n	22f1a <nrfx_twi_twim_bus_recover+0x92>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22ef0:	a801      	add	r0, sp, #4
   22ef2:	9601      	str	r6, [sp, #4]
   22ef4:	f7ff ffb8 	bl	22e68 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22ef8:	9b01      	ldr	r3, [sp, #4]
    for (uint8_t i = 0; i < 9; i++)
   22efa:	3d01      	subs	r5, #1
   22efc:	fa07 f303 	lsl.w	r3, r7, r3
    p_reg->OUTCLR = clr_mask;
   22f00:	60c3      	str	r3, [r0, #12]
        }
        else
        {
            // Pulse CLOCK signal
            nrf_gpio_pin_clear(scl_pin);
            NRFX_DELAY_US(4);
   22f02:	2004      	movs	r0, #4
   22f04:	f002 fc81 	bl	2580a <nrfx_busy_wait>
            nrf_gpio_pin_set(scl_pin);
   22f08:	4630      	mov	r0, r6
   22f0a:	f002 fdce 	bl	25aaa <nrf_gpio_pin_set>
            NRFX_DELAY_US(4);
   22f0e:	2004      	movs	r0, #4
   22f10:	f002 fc7b 	bl	2580a <nrfx_busy_wait>
    for (uint8_t i = 0; i < 9; i++)
   22f14:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   22f18:	d1e1      	bne.n	22ede <nrfx_twi_twim_bus_recover+0x56>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22f1a:	a801      	add	r0, sp, #4
   22f1c:	9401      	str	r4, [sp, #4]
   22f1e:	f7ff ffa3 	bl	22e68 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   22f22:	2301      	movs	r3, #1
   22f24:	9a01      	ldr	r2, [sp, #4]
   22f26:	4093      	lsls	r3, r2
    p_reg->OUTCLR = clr_mask;
   22f28:	60c3      	str	r3, [r0, #12]
        }
    }

    // Generate a STOP condition on the bus
    nrf_gpio_pin_clear(sda_pin);
    NRFX_DELAY_US(4);
   22f2a:	2004      	movs	r0, #4
   22f2c:	f002 fc6d 	bl	2580a <nrfx_busy_wait>
    nrf_gpio_pin_set(sda_pin);
   22f30:	4620      	mov	r0, r4
   22f32:	f002 fdba 	bl	25aaa <nrf_gpio_pin_set>
    NRFX_DELAY_US(4);
   22f36:	2004      	movs	r0, #4
   22f38:	f002 fc67 	bl	2580a <nrfx_busy_wait>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   22f3c:	a801      	add	r0, sp, #4
   22f3e:	9401      	str	r4, [sp, #4]
   22f40:	f7ff ff92 	bl	22e68 <nrf_gpio_pin_port_decode>
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22f44:	9a01      	ldr	r2, [sp, #4]
    return p_reg->IN;
   22f46:	6903      	ldr	r3, [r0, #16]
    }
    else
    {
        return NRFX_ERROR_INTERNAL;
    }
}
   22f48:	4803      	ldr	r0, [pc, #12]	; (22f58 <nrfx_twi_twim_bus_recover+0xd0>)
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
   22f4a:	40d3      	lsrs	r3, r2
   22f4c:	f003 0301 	and.w	r3, r3, #1
   22f50:	1ac0      	subs	r0, r0, r3
   22f52:	b003      	add	sp, #12
   22f54:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22f56:	bf00      	nop
   22f58:	0bad0001 	.word	0x0bad0001

00022f5c <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   22f5c:	4b10      	ldr	r3, [pc, #64]	; (22fa0 <z_sys_init_run_level+0x44>)
{
   22f5e:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   22f60:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   22f64:	3001      	adds	r0, #1
   22f66:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   22f6a:	42a6      	cmp	r6, r4
   22f6c:	d800      	bhi.n	22f70 <z_sys_init_run_level+0x14>
			}
		} else {
			(void)entry->init_fn.sys();
		}
	}
}
   22f6e:	bd70      	pop	{r4, r5, r6, pc}
			int rc = entry->init_fn.dev(dev);
   22f70:	e9d4 3500 	ldrd	r3, r5, [r4]
		if (dev != NULL) {
   22f74:	b18d      	cbz	r5, 22f9a <z_sys_init_run_level+0x3e>
			int rc = entry->init_fn.dev(dev);
   22f76:	4628      	mov	r0, r5
   22f78:	4798      	blx	r3
			if (rc != 0) {
   22f7a:	b138      	cbz	r0, 22f8c <z_sys_init_run_level+0x30>
				if (rc < 0) {
   22f7c:	2800      	cmp	r0, #0
   22f7e:	bfb8      	it	lt
   22f80:	4240      	neglt	r0, r0
				if (rc > UINT8_MAX) {
   22f82:	28ff      	cmp	r0, #255	; 0xff
   22f84:	bfa8      	it	ge
   22f86:	20ff      	movge	r0, #255	; 0xff
				dev->state->init_res = rc;
   22f88:	68eb      	ldr	r3, [r5, #12]
   22f8a:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
   22f8c:	68ea      	ldr	r2, [r5, #12]
   22f8e:	7853      	ldrb	r3, [r2, #1]
   22f90:	f043 0301 	orr.w	r3, r3, #1
   22f94:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   22f96:	3408      	adds	r4, #8
   22f98:	e7e7      	b.n	22f6a <z_sys_init_run_level+0xe>
			(void)entry->init_fn.sys();
   22f9a:	4798      	blx	r3
   22f9c:	e7fb      	b.n	22f96 <z_sys_init_run_level+0x3a>
   22f9e:	bf00      	nop
   22fa0:	00026970 	.word	0x00026970

00022fa4 <bg_thread_main>:
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
   22fa4:	2201      	movs	r2, #1
{
   22fa6:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   22fa8:	4b09      	ldr	r3, [pc, #36]	; (22fd0 <bg_thread_main+0x2c>)

	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
   22faa:	2003      	movs	r0, #3
	z_sys_post_kernel = true;
   22fac:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
   22fae:	f7ff ffd5 	bl	22f5c <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
   22fb2:	f001 fa05 	bl	243c0 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
   22fb6:	2004      	movs	r0, #4
   22fb8:	f7ff ffd0 	bl	22f5c <z_sys_init_run_level>

	z_init_static_threads();
   22fbc:	f000 f956 	bl	2326c <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern int main(void);

	(void)main();
   22fc0:	f7f9 fa30 	bl	1c424 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   22fc4:	4a03      	ldr	r2, [pc, #12]	; (22fd4 <bg_thread_main+0x30>)
   22fc6:	7b13      	ldrb	r3, [r2, #12]
   22fc8:	f023 0301 	bic.w	r3, r3, #1
   22fcc:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   22fce:	bd08      	pop	{r3, pc}
   22fd0:	2000b62b 	.word	0x2000b62b
   22fd4:	2000a5f0 	.word	0x2000a5f0

00022fd8 <z_bss_zero>:
{
   22fd8:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
   22fda:	4803      	ldr	r0, [pc, #12]	; (22fe8 <z_bss_zero+0x10>)
   22fdc:	4a03      	ldr	r2, [pc, #12]	; (22fec <z_bss_zero+0x14>)
   22fde:	2100      	movs	r1, #0
   22fe0:	1a12      	subs	r2, r2, r0
   22fe2:	f002 fd95 	bl	25b10 <z_early_memset>
}
   22fe6:	bd08      	pop	{r3, pc}
   22fe8:	2000a410 	.word	0x2000a410
   22fec:	2000b630 	.word	0x2000b630

00022ff0 <z_init_cpu>:

#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
   22ff0:	2300      	movs	r3, #0
   22ff2:	2201      	movs	r2, #1
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
   22ff4:	b570      	push	{r4, r5, r6, lr}
   22ff6:	b086      	sub	sp, #24
	z_setup_new_thread(thread, stack,
   22ff8:	e9cd 2304 	strd	r2, r3, [sp, #16]
   22ffc:	220f      	movs	r2, #15
   22ffe:	9301      	str	r3, [sp, #4]
   23000:	e9cd 3202 	strd	r3, r2, [sp, #8]
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   23004:	2314      	movs	r3, #20
	z_setup_new_thread(thread, stack,
   23006:	f44f 72a0 	mov.w	r2, #320	; 0x140
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   2300a:	4d0e      	ldr	r5, [pc, #56]	; (23044 <z_init_cpu+0x54>)
	struct k_thread *thread = &z_idle_threads[i];
   2300c:	4e0e      	ldr	r6, [pc, #56]	; (23048 <z_init_cpu+0x58>)
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
   2300e:	fb03 5500 	mla	r5, r3, r0, r5
	z_setup_new_thread(thread, stack,
   23012:	490e      	ldr	r1, [pc, #56]	; (2304c <z_init_cpu+0x5c>)
	struct k_thread *thread = &z_idle_threads[i];
   23014:	eb06 16c0 	add.w	r6, r6, r0, lsl #7
{
   23018:	4604      	mov	r4, r0
	z_setup_new_thread(thread, stack,
   2301a:	fb02 1100 	mla	r1, r2, r0, r1
   2301e:	4b0c      	ldr	r3, [pc, #48]	; (23050 <z_init_cpu+0x60>)
   23020:	4630      	mov	r0, r6
   23022:	9500      	str	r5, [sp, #0]
   23024:	f000 f8c6 	bl	231b4 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   23028:	7b73      	ldrb	r3, [r6, #13]
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
   2302a:	742c      	strb	r4, [r5, #16]
   2302c:	f023 0304 	bic.w	r3, r3, #4
   23030:	7373      	strb	r3, [r6, #13]
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
   23032:	4b08      	ldr	r3, [pc, #32]	; (23054 <z_init_cpu+0x64>)
   23034:	3401      	adds	r4, #1
   23036:	eb03 23c4 	add.w	r3, r3, r4, lsl #11
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
   2303a:	60ee      	str	r6, [r5, #12]
	_kernel.cpus[id].irq_stack =
   2303c:	606b      	str	r3, [r5, #4]
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
   2303e:	b006      	add	sp, #24
   23040:	bd70      	pop	{r4, r5, r6, pc}
   23042:	bf00      	nop
   23044:	2000b5b4 	.word	0x2000b5b4
   23048:	2000a570 	.word	0x2000a570
   2304c:	2000c630 	.word	0x2000c630
   23050:	00023325 	.word	0x00023325
   23054:	2000be30 	.word	0x2000be30

00023058 <z_cstart>:
 * @return Does not return
 */
__boot_func
FUNC_NO_STACK_PROTECTOR
FUNC_NORETURN void z_cstart(void)
{
   23058:	b580      	push	{r7, lr}
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	/* initialize early init calls */
	z_sys_init_run_level(INIT_LEVEL_EARLY);
   2305a:	2000      	movs	r0, #0
{
   2305c:	b0a6      	sub	sp, #152	; 0x98
	z_sys_init_run_level(INIT_LEVEL_EARLY);
   2305e:	f7ff ff7d 	bl	22f5c <z_sys_init_run_level>
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
   23062:	4b2d      	ldr	r3, [pc, #180]	; (23118 <z_cstart+0xc0>)
	uint32_t msp =
   23064:	f503 6200 	add.w	r2, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   23068:	f382 8808 	msr	MSP, r2
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure MSPLIM is RAZ/WI
  (void)MainStackPtrLimit;
#else
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   2306c:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   23070:	2400      	movs	r4, #0
   23072:	23e0      	movs	r3, #224	; 0xe0
   23074:	4d29      	ldr	r5, [pc, #164]	; (2311c <z_cstart+0xc4>)

#ifdef CONFIG_TIMESLICE_PER_THREAD
	dummy_thread->base.slice_ticks = 0;
#endif

	_current_cpu->current = dummy_thread;
   23076:	4e2a      	ldr	r6, [pc, #168]	; (23120 <z_cstart+0xc8>)
   23078:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   2307c:	77ec      	strb	r4, [r5, #31]
   2307e:	762c      	strb	r4, [r5, #24]
   23080:	766c      	strb	r4, [r5, #25]
   23082:	76ac      	strb	r4, [r5, #26]
   23084:	f885 4020 	strb.w	r4, [r5, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   23088:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   2308a:	4f26      	ldr	r7, [pc, #152]	; (23124 <z_cstart+0xcc>)
   2308c:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   23090:	626b      	str	r3, [r5, #36]	; 0x24
   23092:	f885 4023 	strb.w	r4, [r5, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   23096:	f7fb fb6d 	bl	1e774 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   2309a:	f7fb f8ed 	bl	1e278 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   2309e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   230a2:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   230a4:	62eb      	str	r3, [r5, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
   230a6:	f7fb fd6f 	bl	1eb88 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   230aa:	f7fb fc15 	bl	1e8d8 <z_arm_configure_static_mpu_regions>
	dummy_thread->base.user_options = K_ESSENTIAL;
   230ae:	f240 1301 	movw	r3, #257	; 0x101
   230b2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   230b6:	ab06      	add	r3, sp, #24
   230b8:	60b3      	str	r3, [r6, #8]
	dummy_thread->stack_info.size = 0U;
   230ba:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
	dummy_thread->resource_pool = NULL;
   230be:	9422      	str	r4, [sp, #136]	; 0x88
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
   230c0:	f002 fcff 	bl	25ac2 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
   230c4:	2001      	movs	r0, #1
   230c6:	f7ff ff49 	bl	22f5c <z_sys_init_run_level>
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
   230ca:	2002      	movs	r0, #2
	_kernel.ready_q.cache = &z_main_thread;
   230cc:	4d16      	ldr	r5, [pc, #88]	; (23128 <z_cstart+0xd0>)
	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
   230ce:	f7ff ff45 	bl	22f5c <z_sys_init_run_level>
	z_sched_init();
   230d2:	f000 fe23 	bl	23d1c <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   230d6:	4b15      	ldr	r3, [pc, #84]	; (2312c <z_cstart+0xd4>)
	_kernel.ready_q.cache = &z_main_thread;
   230d8:	61b5      	str	r5, [r6, #24]
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
   230da:	9305      	str	r3, [sp, #20]
   230dc:	2301      	movs	r3, #1
   230de:	4914      	ldr	r1, [pc, #80]	; (23130 <z_cstart+0xd8>)
   230e0:	f44f 6280 	mov.w	r2, #1024	; 0x400
   230e4:	e9cd 4303 	strd	r4, r3, [sp, #12]
   230e8:	4628      	mov	r0, r5
   230ea:	463b      	mov	r3, r7
   230ec:	e9cd 4401 	strd	r4, r4, [sp, #4]
   230f0:	9400      	str	r4, [sp, #0]
   230f2:	f000 f85f 	bl	231b4 <z_setup_new_thread>
   230f6:	4606      	mov	r6, r0
   230f8:	7b6a      	ldrb	r2, [r5, #13]
	z_ready_thread(&z_main_thread);
   230fa:	4628      	mov	r0, r5
   230fc:	f022 0204 	bic.w	r2, r2, #4
   23100:	736a      	strb	r2, [r5, #13]
   23102:	f002 fe93 	bl	25e2c <z_ready_thread>
	z_init_cpu(0);
   23106:	4620      	mov	r0, r4
   23108:	f7ff ff72 	bl	22ff0 <z_init_cpu>
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
   2310c:	463a      	mov	r2, r7
   2310e:	4631      	mov	r1, r6
   23110:	4628      	mov	r0, r5
   23112:	f7fb f9bb 	bl	1e48c <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   23116:	bf00      	nop
   23118:	2000be30 	.word	0x2000be30
   2311c:	e000ed00 	.word	0xe000ed00
   23120:	2000b5b4 	.word	0x2000b5b4
   23124:	00022fa5 	.word	0x00022fa5
   23128:	2000a5f0 	.word	0x2000a5f0
   2312c:	00026b5a 	.word	0x00026b5a
   23130:	2000c770 	.word	0x2000c770

00023134 <init_mem_slab_module>:
 *
 * @return 0 on success, fails otherwise.
 */
static int init_mem_slab_module(void)
{
	int rc = 0;
   23134:	2000      	movs	r0, #0
{
   23136:	b538      	push	{r3, r4, r5, lr}

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   23138:	4c05      	ldr	r4, [pc, #20]	; (23150 <init_mem_slab_module+0x1c>)
   2313a:	4d06      	ldr	r5, [pc, #24]	; (23154 <init_mem_slab_module+0x20>)
   2313c:	42ac      	cmp	r4, r5
   2313e:	d300      	bcc.n	23142 <init_mem_slab_module+0xe>
		z_object_init(slab);
	}

out:
	return rc;
}
   23140:	bd38      	pop	{r3, r4, r5, pc}
		rc = create_free_list(slab);
   23142:	4620      	mov	r0, r4
   23144:	f002 fce8 	bl	25b18 <create_free_list>
		if (rc < 0) {
   23148:	2800      	cmp	r0, #0
   2314a:	dbf9      	blt.n	23140 <init_mem_slab_module+0xc>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   2314c:	341c      	adds	r4, #28
   2314e:	e7f5      	b.n	2313c <init_mem_slab_module+0x8>
   23150:	2000a2d8 	.word	0x2000a2d8
   23154:	2000a2f4 	.word	0x2000a2f4

00023158 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   23158:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2315a:	460c      	mov	r4, r1
	__asm__ volatile(
   2315c:	f04f 0520 	mov.w	r5, #32
   23160:	f3ef 8111 	mrs	r1, BASEPRI
   23164:	f385 8812 	msr	BASEPRI_MAX, r5
   23168:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
   2316c:	6945      	ldr	r5, [r0, #20]
   2316e:	b15d      	cbz	r5, 23188 <k_mem_slab_alloc+0x30>
		/* take a free block */
		*mem = slab->free_list;
   23170:	6025      	str	r5, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   23172:	682b      	ldr	r3, [r5, #0]
   23174:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   23176:	6983      	ldr	r3, [r0, #24]
   23178:	3301      	adds	r3, #1
   2317a:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
   2317c:	2000      	movs	r0, #0
	__asm__ volatile(
   2317e:	f381 8811 	msr	BASEPRI, r1
   23182:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
   23186:	e011      	b.n	231ac <k_mem_slab_alloc+0x54>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
   23188:	ea52 0603 	orrs.w	r6, r2, r3
   2318c:	d103      	bne.n	23196 <k_mem_slab_alloc+0x3e>
		result = -ENOMEM;
   2318e:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   23192:	6025      	str	r5, [r4, #0]
		result = -ENOMEM;
   23194:	e7f3      	b.n	2317e <k_mem_slab_alloc+0x26>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
   23196:	e9cd 2300 	strd	r2, r3, [sp]
   2319a:	4602      	mov	r2, r0
   2319c:	3008      	adds	r0, #8
   2319e:	f000 fcc7 	bl	23b30 <z_pend_curr>
		if (result == 0) {
   231a2:	b918      	cbnz	r0, 231ac <k_mem_slab_alloc+0x54>
			*mem = _current->base.swap_data;
   231a4:	4b02      	ldr	r3, [pc, #8]	; (231b0 <k_mem_slab_alloc+0x58>)
   231a6:	689b      	ldr	r3, [r3, #8]
   231a8:	695b      	ldr	r3, [r3, #20]
   231aa:	6023      	str	r3, [r4, #0]
}
   231ac:	b002      	add	sp, #8
   231ae:	bd70      	pop	{r4, r5, r6, pc}
   231b0:	2000b5b4 	.word	0x2000b5b4

000231b4 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
   231b4:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
	thread_base->user_options = (uint8_t)options;
   231b8:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
   231ba:	f100 0558 	add.w	r5, r0, #88	; 0x58
   231be:	7306      	strb	r6, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
   231c0:	2604      	movs	r6, #4
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
	list->tail = (sys_dnode_t *)list;
   231c2:	e9c0 5516 	strd	r5, r5, [r0, #88]	; 0x58
	thread_base->pended_on = NULL;
   231c6:	2500      	movs	r5, #0
{
   231c8:	4604      	mov	r4, r0
	thread_base->thread_state = (uint8_t)initial_state;
   231ca:	7346      	strb	r6, [r0, #13]

	thread_base->prio = priority;
   231cc:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
	node->prev = NULL;
   231ce:	e9c0 5506 	strd	r5, r5, [r0, #24]
   231d2:	7386      	strb	r6, [r0, #14]
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   231d4:	1dd6      	adds	r6, r2, #7
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   231d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
   231d8:	f026 0607 	bic.w	r6, r6, #7
	new_thread->stack_info.size = stack_buf_size;
   231dc:	e9c0 1619 	strd	r1, r6, [r0, #100]	; 0x64
	thread_base->pended_on = NULL;
   231e0:	6085      	str	r5, [r0, #8]

	thread_base->sched_locked = 0U;
   231e2:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
   231e4:	66c5      	str	r5, [r0, #108]	; 0x6c
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   231e6:	9202      	str	r2, [sp, #8]
   231e8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
   231ea:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
   231ee:	9201      	str	r2, [sp, #4]
   231f0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   231f2:	9200      	str	r2, [sp, #0]
   231f4:	4642      	mov	r2, r8
   231f6:	f7fb f92b 	bl	1e450 <arch_new_thread>
	if (!_current) {
   231fa:	4b05      	ldr	r3, [pc, #20]	; (23210 <z_setup_new_thread+0x5c>)
	new_thread->init_data = NULL;
   231fc:	6565      	str	r5, [r4, #84]	; 0x54
	if (!_current) {
   231fe:	689b      	ldr	r3, [r3, #8]
   23200:	b103      	cbz	r3, 23204 <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
   23202:	6f1b      	ldr	r3, [r3, #112]	; 0x70
}
   23204:	4640      	mov	r0, r8
   23206:	6723      	str	r3, [r4, #112]	; 0x70
   23208:	b004      	add	sp, #16
   2320a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2320e:	bf00      	nop
   23210:	2000b5b4 	.word	0x2000b5b4

00023214 <z_impl_k_thread_create>:
{
   23214:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23216:	2500      	movs	r5, #0
{
   23218:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2321a:	9505      	str	r5, [sp, #20]
   2321c:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   2321e:	e9dd 7612 	ldrd	r7, r6, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23222:	9504      	str	r5, [sp, #16]
   23224:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   23226:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   23228:	9503      	str	r5, [sp, #12]
   2322a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   2322c:	9502      	str	r5, [sp, #8]
   2322e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   23230:	9501      	str	r5, [sp, #4]
   23232:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   23234:	9500      	str	r5, [sp, #0]
   23236:	f7ff ffbd 	bl	231b4 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   2323a:	f1b6 3fff 	cmp.w	r6, #4294967295	; 0xffffffff
   2323e:	bf08      	it	eq
   23240:	f1b7 3fff 	cmpeq.w	r7, #4294967295	; 0xffffffff
   23244:	d005      	beq.n	23252 <z_impl_k_thread_create+0x3e>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   23246:	ea56 0307 	orrs.w	r3, r6, r7
   2324a:	d105      	bne.n	23258 <z_impl_k_thread_create+0x44>
	z_sched_start(thread);
   2324c:	4620      	mov	r0, r4
   2324e:	f000 fce5 	bl	23c1c <z_sched_start>
}
   23252:	4620      	mov	r0, r4
   23254:	b007      	add	sp, #28
   23256:	bdf0      	pop	{r4, r5, r6, r7, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   23258:	463a      	mov	r2, r7
   2325a:	4633      	mov	r3, r6
   2325c:	4902      	ldr	r1, [pc, #8]	; (23268 <z_impl_k_thread_create+0x54>)
   2325e:	f104 0018 	add.w	r0, r4, #24
   23262:	f000 fef1 	bl	24048 <z_add_timeout>
   23266:	e7f4      	b.n	23252 <z_impl_k_thread_create+0x3e>
   23268:	00025eb5 	.word	0x00025eb5

0002326c <z_init_static_threads>:
{
   2326c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   23270:	4c29      	ldr	r4, [pc, #164]	; (23318 <z_init_static_threads+0xac>)
	_FOREACH_STATIC_THREAD(thread_data) {
   23272:	4d2a      	ldr	r5, [pc, #168]	; (2331c <z_init_static_threads+0xb0>)
{
   23274:	b087      	sub	sp, #28
   23276:	4626      	mov	r6, r4
	_FOREACH_STATIC_THREAD(thread_data) {
   23278:	42ae      	cmp	r6, r5
   2327a:	f104 042c 	add.w	r4, r4, #44	; 0x2c
   2327e:	d30f      	bcc.n	232a0 <z_init_static_threads+0x34>
	k_sched_lock();
   23280:	f000 fd1c 	bl	23cbc <k_sched_lock>
   23284:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   23288:	f240 37e7 	movw	r7, #999	; 0x3e7
	_FOREACH_STATIC_THREAD(thread_data) {
   2328c:	4c22      	ldr	r4, [pc, #136]	; (23318 <z_init_static_threads+0xac>)
   2328e:	f8df 9090 	ldr.w	r9, [pc, #144]	; 23320 <z_init_static_threads+0xb4>
   23292:	42ac      	cmp	r4, r5
   23294:	d320      	bcc.n	232d8 <z_init_static_threads+0x6c>
}
   23296:	b007      	add	sp, #28
   23298:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   2329c:	f000 bd22 	b.w	23ce4 <k_sched_unlock>
		z_setup_new_thread(
   232a0:	f854 3c04 	ldr.w	r3, [r4, #-4]
   232a4:	9305      	str	r3, [sp, #20]
   232a6:	f854 3c0c 	ldr.w	r3, [r4, #-12]
   232aa:	9304      	str	r3, [sp, #16]
   232ac:	f854 3c10 	ldr.w	r3, [r4, #-16]
   232b0:	9303      	str	r3, [sp, #12]
   232b2:	f854 3c14 	ldr.w	r3, [r4, #-20]
   232b6:	9302      	str	r3, [sp, #8]
   232b8:	f854 3c18 	ldr.w	r3, [r4, #-24]
   232bc:	9301      	str	r3, [sp, #4]
   232be:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   232c2:	9300      	str	r3, [sp, #0]
   232c4:	e954 2309 	ldrd	r2, r3, [r4, #-36]	; 0x24
   232c8:	e954 010b 	ldrd	r0, r1, [r4, #-44]	; 0x2c
   232cc:	f7ff ff72 	bl	231b4 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   232d0:	f854 3c2c 	ldr.w	r3, [r4, #-44]
   232d4:	655e      	str	r6, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
   232d6:	e7ce      	b.n	23276 <z_init_static_threads+0xa>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   232d8:	6a63      	ldr	r3, [r4, #36]	; 0x24
   232da:	1c5a      	adds	r2, r3, #1
   232dc:	d00d      	beq.n	232fa <z_init_static_threads+0x8e>
   232de:	2100      	movs	r1, #0
   232e0:	4638      	mov	r0, r7
					    K_MSEC(thread_data->init_delay));
   232e2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   232e6:	fbc3 0106 	smlal	r0, r1, r3, r6
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   232ea:	ea51 33c3 	orrs.w	r3, r1, r3, lsl #15
			schedule_new_thread(thread_data->init_thread,
   232ee:	f8d4 8000 	ldr.w	r8, [r4]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   232f2:	d104      	bne.n	232fe <z_init_static_threads+0x92>
	z_sched_start(thread);
   232f4:	4640      	mov	r0, r8
   232f6:	f000 fc91 	bl	23c1c <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   232fa:	342c      	adds	r4, #44	; 0x2c
   232fc:	e7c9      	b.n	23292 <z_init_static_threads+0x26>
   232fe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   23302:	2300      	movs	r3, #0
   23304:	f7f8 ff26 	bl	1c154 <__aeabi_uldivmod>
   23308:	4602      	mov	r2, r0
   2330a:	460b      	mov	r3, r1
   2330c:	f108 0018 	add.w	r0, r8, #24
   23310:	4649      	mov	r1, r9
   23312:	f000 fe99 	bl	24048 <z_add_timeout>
   23316:	e7f0      	b.n	232fa <z_init_static_threads+0x8e>
   23318:	00026518 	.word	0x00026518
   2331c:	00026518 	.word	0x00026518
   23320:	00025eb5 	.word	0x00025eb5

00023324 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
   23324:	b508      	push	{r3, lr}
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
   23326:	4c0b      	ldr	r4, [pc, #44]	; (23354 <idle+0x30>)
   23328:	4d0b      	ldr	r5, [pc, #44]	; (23358 <idle+0x34>)
	__asm__ volatile(
   2332a:	f04f 0220 	mov.w	r2, #32
   2332e:	f3ef 8311 	mrs	r3, BASEPRI
   23332:	f382 8812 	msr	BASEPRI_MAX, r2
   23336:	f3bf 8f6f 	isb	sy
   2333a:	f002 fe52 	bl	25fe2 <z_get_next_timeout_expiry>
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   2333e:	782b      	ldrb	r3, [r5, #0]
		_kernel.idle = z_get_next_timeout_expiry();
   23340:	6160      	str	r0, [r4, #20]
		if (k_is_pre_kernel() || !pm_system_suspend(_kernel.idle)) {
   23342:	b913      	cbnz	r3, 2334a <idle+0x26>
	arch_cpu_idle();
   23344:	f7fa ff9e 	bl	1e284 <arch_cpu_idle>
}
   23348:	e7ef      	b.n	2332a <idle+0x6>
   2334a:	f7f9 fe3b 	bl	1cfc4 <pm_system_suspend>
   2334e:	2800      	cmp	r0, #0
   23350:	d1eb      	bne.n	2332a <idle+0x6>
   23352:	e7f7      	b.n	23344 <idle+0x20>
   23354:	2000b5b4 	.word	0x2000b5b4
   23358:	2000b62b 	.word	0x2000b62b

0002335c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   2335c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   23360:	4604      	mov	r4, r0
   23362:	4617      	mov	r7, r2
   23364:	461e      	mov	r6, r3
   23366:	f04f 0320 	mov.w	r3, #32
   2336a:	f3ef 8811 	mrs	r8, BASEPRI
   2336e:	f383 8812 	msr	BASEPRI_MAX, r3
   23372:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   23376:	68c3      	ldr	r3, [r0, #12]
   23378:	4a33      	ldr	r2, [pc, #204]	; (23448 <z_impl_k_mutex_lock+0xec>)
   2337a:	b17b      	cbz	r3, 2339c <z_impl_k_mutex_lock+0x40>
   2337c:	6880      	ldr	r0, [r0, #8]
   2337e:	6891      	ldr	r1, [r2, #8]
   23380:	4288      	cmp	r0, r1
   23382:	d019      	beq.n	233b8 <z_impl_k_mutex_lock+0x5c>
		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   23384:	ea57 0306 	orrs.w	r3, r7, r6
   23388:	d118      	bne.n	233bc <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   2338a:	f388 8811 	msr	BASEPRI, r8
   2338e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EBUSY);

		return -EBUSY;
   23392:	f06f 000f 	mvn.w	r0, #15
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
   23396:	b002      	add	sp, #8
   23398:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   2339c:	6891      	ldr	r1, [r2, #8]
   2339e:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   233a2:	3301      	adds	r3, #1
   233a4:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   233a6:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   233a8:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   233aa:	60a3      	str	r3, [r4, #8]
   233ac:	f388 8811 	msr	BASEPRI, r8
   233b0:	f3bf 8f6f 	isb	sy
		return 0;
   233b4:	2000      	movs	r0, #0
   233b6:	e7ee      	b.n	23396 <z_impl_k_mutex_lock+0x3a>
					_current->base.prio :
   233b8:	6921      	ldr	r1, [r4, #16]
   233ba:	e7f2      	b.n	233a2 <z_impl_k_mutex_lock+0x46>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   233bc:	f991 100e 	ldrsb.w	r1, [r1, #14]
   233c0:	f990 300e 	ldrsb.w	r3, [r0, #14]
	return prio >= CONFIG_PRIORITY_CEILING;
}

static inline int z_get_new_prio_with_ceiling(int prio)
{
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
   233c4:	f06f 027e 	mvn.w	r2, #126	; 0x7e
   233c8:	4299      	cmp	r1, r3
   233ca:	bfa8      	it	ge
   233cc:	4619      	movge	r1, r3
   233ce:	4291      	cmp	r1, r2
   233d0:	bfb8      	it	lt
   233d2:	4611      	movlt	r1, r2
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   233d4:	428b      	cmp	r3, r1
   233d6:	dd2e      	ble.n	23436 <z_impl_k_mutex_lock+0xda>
		resched = adjust_owner_prio(mutex, new_prio);
   233d8:	f002 fbef 	bl	25bba <adjust_owner_prio.isra.0>
   233dc:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   233de:	4622      	mov	r2, r4
   233e0:	4641      	mov	r1, r8
   233e2:	e9cd 7600 	strd	r7, r6, [sp]
   233e6:	4819      	ldr	r0, [pc, #100]	; (2344c <z_impl_k_mutex_lock+0xf0>)
   233e8:	f000 fba2 	bl	23b30 <z_pend_curr>
	if (got_mutex == 0) {
   233ec:	2800      	cmp	r0, #0
   233ee:	d0e1      	beq.n	233b4 <z_impl_k_mutex_lock+0x58>
	__asm__ volatile(
   233f0:	f04f 0320 	mov.w	r3, #32
   233f4:	f3ef 8611 	mrs	r6, BASEPRI
   233f8:	f383 8812 	msr	BASEPRI_MAX, r3
   233fc:	f3bf 8f6f 	isb	sy
	if (likely(mutex->owner != NULL)) {
   23400:	68a0      	ldr	r0, [r4, #8]
   23402:	b1d0      	cbz	r0, 2343a <z_impl_k_mutex_lock+0xde>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   23404:	6823      	ldr	r3, [r4, #0]
			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   23406:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23408:	429c      	cmp	r4, r3
   2340a:	d00a      	beq.n	23422 <z_impl_k_mutex_lock+0xc6>
   2340c:	b14b      	cbz	r3, 23422 <z_impl_k_mutex_lock+0xc6>
   2340e:	f993 300e 	ldrsb.w	r3, [r3, #14]
   23412:	4299      	cmp	r1, r3
   23414:	bfa8      	it	ge
   23416:	4619      	movge	r1, r3
   23418:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   2341c:	4299      	cmp	r1, r3
   2341e:	bfb8      	it	lt
   23420:	4619      	movlt	r1, r3
		resched = adjust_owner_prio(mutex, new_prio) || resched;
   23422:	f002 fbca 	bl	25bba <adjust_owner_prio.isra.0>
   23426:	b140      	cbz	r0, 2343a <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
   23428:	4631      	mov	r1, r6
   2342a:	4808      	ldr	r0, [pc, #32]	; (2344c <z_impl_k_mutex_lock+0xf0>)
   2342c:	f000 fbe4 	bl	23bf8 <z_reschedule>
	return -EAGAIN;
   23430:	f06f 000a 	mvn.w	r0, #10
   23434:	e7af      	b.n	23396 <z_impl_k_mutex_lock+0x3a>
	bool resched = false;
   23436:	2500      	movs	r5, #0
   23438:	e7d1      	b.n	233de <z_impl_k_mutex_lock+0x82>
	if (resched) {
   2343a:	2d00      	cmp	r5, #0
   2343c:	d1f4      	bne.n	23428 <z_impl_k_mutex_lock+0xcc>
	__asm__ volatile(
   2343e:	f386 8811 	msr	BASEPRI, r6
   23442:	f3bf 8f6f 	isb	sy
   23446:	e7f3      	b.n	23430 <z_impl_k_mutex_lock+0xd4>
   23448:	2000b5b4 	.word	0x2000b5b4
   2344c:	2000b62c 	.word	0x2000b62c

00023450 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   23450:	b538      	push	{r3, r4, r5, lr}

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
   23452:	6883      	ldr	r3, [r0, #8]
{
   23454:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   23456:	b36b      	cbz	r3, 234b4 <z_impl_k_mutex_unlock+0x64>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   23458:	4a19      	ldr	r2, [pc, #100]	; (234c0 <z_impl_k_mutex_unlock+0x70>)
   2345a:	6892      	ldr	r2, [r2, #8]
   2345c:	4293      	cmp	r3, r2
   2345e:	d12c      	bne.n	234ba <z_impl_k_mutex_unlock+0x6a>

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
   23460:	68c3      	ldr	r3, [r0, #12]
   23462:	2b01      	cmp	r3, #1
   23464:	d903      	bls.n	2346e <z_impl_k_mutex_unlock+0x1e>
		mutex->lock_count--;
   23466:	3b01      	subs	r3, #1
   23468:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	return 0;
   2346a:	2000      	movs	r0, #0
}
   2346c:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   2346e:	f04f 0320 	mov.w	r3, #32
   23472:	f3ef 8511 	mrs	r5, BASEPRI
   23476:	f383 8812 	msr	BASEPRI_MAX, r3
   2347a:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   2347e:	6901      	ldr	r1, [r0, #16]
   23480:	6880      	ldr	r0, [r0, #8]
   23482:	f002 fb9a 	bl	25bba <adjust_owner_prio.isra.0>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   23486:	4620      	mov	r0, r4
   23488:	f002 fd18 	bl	25ebc <z_unpend_first_thread>
	mutex->owner = new_owner;
   2348c:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   2348e:	b158      	cbz	r0, 234a8 <z_impl_k_mutex_unlock+0x58>
		mutex->owner_orig_prio = new_owner->base.prio;
   23490:	f990 200e 	ldrsb.w	r2, [r0, #14]
   23494:	6122      	str	r2, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   23496:	2200      	movs	r2, #0
   23498:	6782      	str	r2, [r0, #120]	; 0x78
		z_ready_thread(new_owner);
   2349a:	f002 fcc7 	bl	25e2c <z_ready_thread>
		z_reschedule(&lock, key);
   2349e:	4629      	mov	r1, r5
   234a0:	4808      	ldr	r0, [pc, #32]	; (234c4 <z_impl_k_mutex_unlock+0x74>)
   234a2:	f000 fba9 	bl	23bf8 <z_reschedule>
   234a6:	e7e0      	b.n	2346a <z_impl_k_mutex_unlock+0x1a>
		mutex->lock_count = 0U;
   234a8:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   234aa:	f385 8811 	msr	BASEPRI, r5
   234ae:	f3bf 8f6f 	isb	sy
   234b2:	e7da      	b.n	2346a <z_impl_k_mutex_unlock+0x1a>
		return -EINVAL;
   234b4:	f06f 0015 	mvn.w	r0, #21
   234b8:	e7d8      	b.n	2346c <z_impl_k_mutex_unlock+0x1c>
		return -EPERM;
   234ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   234be:	e7d5      	b.n	2346c <z_impl_k_mutex_unlock+0x1c>
   234c0:	2000b5b4 	.word	0x2000b5b4
   234c4:	2000b62c 	.word	0x2000b62c

000234c8 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   234c8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   234ca:	4611      	mov	r1, r2
	__asm__ volatile(
   234cc:	f04f 0220 	mov.w	r2, #32
   234d0:	f3ef 8511 	mrs	r5, BASEPRI
   234d4:	f382 8812 	msr	BASEPRI_MAX, r2
   234d8:	f3bf 8f6f 	isb	sy
   234dc:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_queue, get, queue, timeout);

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   234de:	b19c      	cbz	r4, 23508 <z_impl_k_queue_get+0x40>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   234e0:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   234e2:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   234e4:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   234e8:	4294      	cmp	r4, r2
	list->head = node;
   234ea:	6003      	str	r3, [r0, #0]
	list->tail = node;
   234ec:	bf08      	it	eq
   234ee:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   234f0:	2101      	movs	r1, #1
   234f2:	4620      	mov	r0, r4
   234f4:	f002 fbd2 	bl	25c9c <z_queue_node_peek>
   234f8:	4604      	mov	r4, r0
	__asm__ volatile(
   234fa:	f385 8811 	msr	BASEPRI, r5
   234fe:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_queue, get, queue, timeout,
		(ret != 0) ? NULL : _current->base.swap_data);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   23502:	4620      	mov	r0, r4
   23504:	b003      	add	sp, #12
   23506:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   23508:	ea51 0203 	orrs.w	r2, r1, r3
   2350c:	d0f5      	beq.n	234fa <z_impl_k_queue_get+0x32>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2350e:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   23512:	e9cd 1300 	strd	r1, r3, [sp]
   23516:	4610      	mov	r0, r2
   23518:	4629      	mov	r1, r5
   2351a:	f000 fb09 	bl	23b30 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   2351e:	2800      	cmp	r0, #0
   23520:	d1ef      	bne.n	23502 <z_impl_k_queue_get+0x3a>
   23522:	4b02      	ldr	r3, [pc, #8]	; (2352c <z_impl_k_queue_get+0x64>)
   23524:	689b      	ldr	r3, [r3, #8]
   23526:	695c      	ldr	r4, [r3, #20]
   23528:	e7eb      	b.n	23502 <z_impl_k_queue_get+0x3a>
   2352a:	bf00      	nop
   2352c:	2000b5b4 	.word	0x2000b5b4

00023530 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   23530:	b538      	push	{r3, r4, r5, lr}
   23532:	4604      	mov	r4, r0
	__asm__ volatile(
   23534:	f04f 0320 	mov.w	r3, #32
   23538:	f3ef 8511 	mrs	r5, BASEPRI
   2353c:	f383 8812 	msr	BASEPRI_MAX, r3
   23540:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
   23544:	f002 fcba 	bl	25ebc <z_unpend_first_thread>

	if (thread != NULL) {
   23548:	b148      	cbz	r0, 2355e <z_impl_k_sem_give+0x2e>
   2354a:	2200      	movs	r2, #0
   2354c:	6782      	str	r2, [r0, #120]	; 0x78
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   2354e:	f002 fc6d 	bl	25e2c <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
   23552:	4629      	mov	r1, r5

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
   23554:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   23558:	4804      	ldr	r0, [pc, #16]	; (2356c <z_impl_k_sem_give+0x3c>)
   2355a:	f000 bb4d 	b.w	23bf8 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   2355e:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   23562:	429a      	cmp	r2, r3
   23564:	bf18      	it	ne
   23566:	3301      	addne	r3, #1
   23568:	60a3      	str	r3, [r4, #8]
}
   2356a:	e7f2      	b.n	23552 <z_impl_k_sem_give+0x22>
   2356c:	2000b62c 	.word	0x2000b62c

00023570 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   23570:	b513      	push	{r0, r1, r4, lr}
   23572:	f04f 0420 	mov.w	r4, #32
   23576:	f3ef 8111 	mrs	r1, BASEPRI
   2357a:	f384 8812 	msr	BASEPRI_MAX, r4
   2357e:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
   23582:	6884      	ldr	r4, [r0, #8]
   23584:	b144      	cbz	r4, 23598 <z_impl_k_sem_take+0x28>
		sem->count--;
   23586:	3c01      	subs	r4, #1
   23588:	6084      	str	r4, [r0, #8]
	__asm__ volatile(
   2358a:	f381 8811 	msr	BASEPRI, r1
   2358e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   23592:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
   23594:	b002      	add	sp, #8
   23596:	bd10      	pop	{r4, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   23598:	ea52 0403 	orrs.w	r4, r2, r3
   2359c:	d106      	bne.n	235ac <z_impl_k_sem_take+0x3c>
   2359e:	f381 8811 	msr	BASEPRI, r1
   235a2:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   235a6:	f06f 000f 	mvn.w	r0, #15
   235aa:	e7f3      	b.n	23594 <z_impl_k_sem_take+0x24>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   235ac:	e9cd 2300 	strd	r2, r3, [sp]
   235b0:	4602      	mov	r2, r0
   235b2:	4802      	ldr	r0, [pc, #8]	; (235bc <z_impl_k_sem_take+0x4c>)
   235b4:	f000 fabc 	bl	23b30 <z_pend_curr>
	return ret;
   235b8:	e7ec      	b.n	23594 <z_impl_k_sem_take+0x24>
   235ba:	bf00      	nop
   235bc:	2000b62c 	.word	0x2000b62c

000235c0 <z_impl_k_sem_reset>:

void z_impl_k_sem_reset(struct k_sem *sem)
{
   235c0:	b570      	push	{r4, r5, r6, lr}
   235c2:	4604      	mov	r4, r0
	__asm__ volatile(
   235c4:	f04f 0320 	mov.w	r3, #32
   235c8:	f3ef 8511 	mrs	r5, BASEPRI
   235cc:	f383 8812 	msr	BASEPRI_MAX, r3
   235d0:	f3bf 8f6f 	isb	sy
   235d4:	f06f 060a 	mvn.w	r6, #10
	struct k_thread *thread;
	k_spinlock_key_t key = k_spin_lock(&lock);

	while (true) {
		thread = z_unpend_first_thread(&sem->wait_q);
   235d8:	4620      	mov	r0, r4
   235da:	f002 fc6f 	bl	25ebc <z_unpend_first_thread>
		if (thread == NULL) {
   235de:	b118      	cbz	r0, 235e8 <z_impl_k_sem_reset+0x28>
   235e0:	6786      	str	r6, [r0, #120]	; 0x78
			break;
		}
		arch_thread_return_value_set(thread, -EAGAIN);
		z_ready_thread(thread);
   235e2:	f002 fc23 	bl	25e2c <z_ready_thread>
		thread = z_unpend_first_thread(&sem->wait_q);
   235e6:	e7f7      	b.n	235d8 <z_impl_k_sem_reset+0x18>
	}
	sem->count = 0;
   235e8:	60a0      	str	r0, [r4, #8]

	SYS_PORT_TRACING_OBJ_FUNC(k_sem, reset, sem);

	handle_poll_events(sem);

	z_reschedule(&lock, key);
   235ea:	4629      	mov	r1, r5
}
   235ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&lock, key);
   235f0:	4801      	ldr	r0, [pc, #4]	; (235f8 <z_impl_k_sem_reset+0x38>)
   235f2:	f000 bb01 	b.w	23bf8 <z_reschedule>
   235f6:	bf00      	nop
   235f8:	2000b62c 	.word	0x2000b62c

000235fc <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
   235fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23600:	4604      	mov	r4, r0
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
					   K_FOREVER, NULL);
   23602:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   23606:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
	return list->head;
   2360a:	4e48      	ldr	r6, [pc, #288]	; (2372c <work_queue_main+0x130>)
{
   2360c:	b085      	sub	sp, #20
   2360e:	f04f 0320 	mov.w	r3, #32
   23612:	f3ef 8711 	mrs	r7, BASEPRI
   23616:	f383 8812 	msr	BASEPRI_MAX, r3
   2361a:	f3bf 8f6f 	isb	sy
   2361e:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
   23622:	b98d      	cbnz	r5, 23648 <work_queue_main+0x4c>
		} else if (flag_test_and_clear(&queue->flags,
   23624:	2102      	movs	r1, #2
   23626:	f104 0098 	add.w	r0, r4, #152	; 0x98
   2362a:	f002 fb5a 	bl	25ce2 <flag_test_and_clear>
   2362e:	2800      	cmp	r0, #0
   23630:	d143      	bne.n	236ba <work_queue_main+0xbe>
			(void)z_sched_wait(&lock, key, &queue->notifyq,
   23632:	2300      	movs	r3, #0
   23634:	4639      	mov	r1, r7
   23636:	e9cd 8900 	strd	r8, r9, [sp]
   2363a:	9302      	str	r3, [sp, #8]
   2363c:	f104 0288 	add.w	r2, r4, #136	; 0x88
   23640:	483b      	ldr	r0, [pc, #236]	; (23730 <work_queue_main+0x134>)
   23642:	f000 fc8f 	bl	23f64 <z_sched_wait>
			continue;
   23646:	e7e2      	b.n	2360e <work_queue_main+0x12>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   23648:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
	return node->next;
   2364c:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   2364e:	4295      	cmp	r5, r2
	list->head = node;
   23650:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	list->tail = node;
   23654:	bf08      	it	eq
   23656:	f8c4 3084 	streq.w	r3, [r4, #132]	; 0x84
	*flagp |= BIT(bit);
   2365a:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   2365e:	f043 0302 	orr.w	r3, r3, #2
   23662:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	*flagp &= ~BIT(bit);
   23666:	68eb      	ldr	r3, [r5, #12]
   23668:	f023 0304 	bic.w	r3, r3, #4
   2366c:	f043 0301 	orr.w	r3, r3, #1
   23670:	60eb      	str	r3, [r5, #12]
			handler = work->handler;
   23672:	686b      	ldr	r3, [r5, #4]
	__asm__ volatile(
   23674:	f387 8811 	msr	BASEPRI, r7
   23678:	f3bf 8f6f 	isb	sy
		}

		k_spin_unlock(&lock, key);

		__ASSERT_NO_MSG(handler != NULL);
		handler(work);
   2367c:	4628      	mov	r0, r5
   2367e:	4798      	blx	r3
	__asm__ volatile(
   23680:	f04f 0320 	mov.w	r3, #32
   23684:	f3ef 8b11 	mrs	fp, BASEPRI
   23688:	f383 8812 	msr	BASEPRI_MAX, r3
   2368c:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
   23690:	68eb      	ldr	r3, [r5, #12]
		 * starving other threads.
		 */
		key = k_spin_lock(&lock);

		flag_clear(&work->flags, K_WORK_RUNNING_BIT);
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   23692:	0799      	lsls	r1, r3, #30
	*flagp &= ~BIT(bit);
   23694:	f023 0201 	bic.w	r2, r3, #1
		if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   23698:	d419      	bmi.n	236ce <work_queue_main+0xd2>
	*flagp &= ~BIT(bit);
   2369a:	60ea      	str	r2, [r5, #12]
   2369c:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   236a0:	f023 0302 	bic.w	r3, r3, #2
   236a4:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
	__asm__ volatile(
   236a8:	f38b 8811 	msr	BASEPRI, fp
   236ac:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);

		/* Optionally yield to prevent the work queue from
		 * starving other threads.
		 */
		if (yield) {
   236b0:	05db      	lsls	r3, r3, #23
   236b2:	d4ac      	bmi.n	2360e <work_queue_main+0x12>
	z_impl_k_yield();
   236b4:	f000 fb3a 	bl	23d2c <z_impl_k_yield>
}
   236b8:	e7a9      	b.n	2360e <work_queue_main+0x12>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
   236ba:	f104 0590 	add.w	r5, r4, #144	; 0x90
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
   236be:	2200      	movs	r2, #0
   236c0:	2101      	movs	r1, #1
   236c2:	4628      	mov	r0, r5
   236c4:	f002 fc54 	bl	25f70 <z_sched_wake>
   236c8:	2800      	cmp	r0, #0
   236ca:	d1f8      	bne.n	236be <work_queue_main+0xc2>
   236cc:	e7b1      	b.n	23632 <work_queue_main+0x36>
	return list->head;
   236ce:	6830      	ldr	r0, [r6, #0]
	*flagp &= ~BIT(bit);
   236d0:	f023 0303 	bic.w	r3, r3, #3
   236d4:	60eb      	str	r3, [r5, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   236d6:	2800      	cmp	r0, #0
   236d8:	d0e0      	beq.n	2369c <work_queue_main+0xa0>
	return node->next;
   236da:	2700      	movs	r7, #0
	parent->next = child;
   236dc:	463b      	mov	r3, r7
	return node->next;
   236de:	f8d0 a000 	ldr.w	sl, [r0]
   236e2:	2800      	cmp	r0, #0
   236e4:	d0da      	beq.n	2369c <work_queue_main+0xa0>
		if (wc->work == work) {
   236e6:	6842      	ldr	r2, [r0, #4]
			sys_slist_remove(&pending_cancels, prev, &wc->node);
   236e8:	4601      	mov	r1, r0
		if (wc->work == work) {
   236ea:	4295      	cmp	r5, r2
   236ec:	d10c      	bne.n	23708 <work_queue_main+0x10c>
   236ee:	6801      	ldr	r1, [r0, #0]
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
   236f0:	b99f      	cbnz	r7, 2371a <work_queue_main+0x11e>
   236f2:	6872      	ldr	r2, [r6, #4]
	list->head = node;
   236f4:	6031      	str	r1, [r6, #0]
Z_GENLIST_REMOVE(slist, snode)
   236f6:	4282      	cmp	r2, r0
   236f8:	d100      	bne.n	236fc <work_queue_main+0x100>
	list->tail = node;
   236fa:	6071      	str	r1, [r6, #4]
	parent->next = child;
   236fc:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
   23700:	f7ff ff16 	bl	23530 <z_impl_k_sem_give>
}
   23704:	4639      	mov	r1, r7
   23706:	2300      	movs	r3, #0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
   23708:	f1ba 0f00 	cmp.w	sl, #0
   2370c:	d00b      	beq.n	23726 <work_queue_main+0x12a>
	return node->next;
   2370e:	f8da 2000 	ldr.w	r2, [sl]
   23712:	4650      	mov	r0, sl
   23714:	460f      	mov	r7, r1
   23716:	4692      	mov	sl, r2
   23718:	e7e3      	b.n	236e2 <work_queue_main+0xe6>
	parent->next = child;
   2371a:	6039      	str	r1, [r7, #0]
Z_GENLIST_REMOVE(slist, snode)
   2371c:	6872      	ldr	r2, [r6, #4]
   2371e:	4282      	cmp	r2, r0
	list->tail = node;
   23720:	bf08      	it	eq
   23722:	6077      	streq	r7, [r6, #4]
}
   23724:	e7ea      	b.n	236fc <work_queue_main+0x100>
   23726:	4652      	mov	r2, sl
   23728:	e7f3      	b.n	23712 <work_queue_main+0x116>
   2372a:	bf00      	nop
   2372c:	2000b5d8 	.word	0x2000b5d8
   23730:	2000b62c 	.word	0x2000b62c

00023734 <submit_to_queue_locked>:
{
   23734:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return (*flagp & BIT(bit)) != 0U;
   23736:	68c3      	ldr	r3, [r0, #12]
{
   23738:	4604      	mov	r4, r0
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   2373a:	079a      	lsls	r2, r3, #30
{
   2373c:	460f      	mov	r7, r1
	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
   2373e:	f3c3 0640 	ubfx	r6, r3, #1, #1
   23742:	d42c      	bmi.n	2379e <submit_to_queue_locked+0x6a>
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
   23744:	075b      	lsls	r3, r3, #29
   23746:	d41a      	bmi.n	2377e <submit_to_queue_locked+0x4a>
		if (*queuep == NULL) {
   23748:	680b      	ldr	r3, [r1, #0]
   2374a:	b90b      	cbnz	r3, 23750 <submit_to_queue_locked+0x1c>
			*queuep = work->queue;
   2374c:	6883      	ldr	r3, [r0, #8]
   2374e:	600b      	str	r3, [r1, #0]
	return (*flagp & BIT(bit)) != 0U;
   23750:	68e3      	ldr	r3, [r4, #12]
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
   23752:	07dd      	lsls	r5, r3, #31
			*queuep = work->queue;
   23754:	bf42      	ittt	mi
   23756:	68a3      	ldrmi	r3, [r4, #8]
			ret = 2;
   23758:	2602      	movmi	r6, #2
			*queuep = work->queue;
   2375a:	603b      	strmi	r3, [r7, #0]
		int rc = queue_submit_locked(*queuep, work);
   2375c:	683d      	ldr	r5, [r7, #0]
		ret = 1;
   2375e:	bf58      	it	pl
   23760:	2601      	movpl	r6, #1
	if (queue == NULL) {
   23762:	2d00      	cmp	r5, #0
   23764:	d03a      	beq.n	237dc <submit_to_queue_locked+0xa8>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   23766:	4b1f      	ldr	r3, [pc, #124]	; (237e4 <submit_to_queue_locked+0xb0>)
   23768:	689b      	ldr	r3, [r3, #8]
   2376a:	42ab      	cmp	r3, r5
   2376c:	d00a      	beq.n	23784 <submit_to_queue_locked+0x50>
	return (*flagp & BIT(bit)) != 0U;
   2376e:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   23772:	07d8      	lsls	r0, r3, #31
	return (*flagp & BIT(bit)) != 0U;
   23774:	f3c3 0280 	ubfx	r2, r3, #2, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   23778:	d414      	bmi.n	237a4 <submit_to_queue_locked+0x70>
		ret = -EBUSY;
   2377a:	f06f 0612 	mvn.w	r6, #18
		*queuep = NULL;
   2377e:	2300      	movs	r3, #0
   23780:	603b      	str	r3, [r7, #0]
	return ret;
   23782:	e025      	b.n	237d0 <submit_to_queue_locked+0x9c>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
   23784:	f002 fa07 	bl	25b96 <k_is_in_isr>
   23788:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
   2378c:	2800      	cmp	r0, #0
   2378e:	d1f0      	bne.n	23772 <submit_to_queue_locked+0x3e>
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   23790:	07d9      	lsls	r1, r3, #31
	return (*flagp & BIT(bit)) != 0U;
   23792:	f3c3 02c0 	ubfx	r2, r3, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
   23796:	d5f0      	bpl.n	2377a <submit_to_queue_locked+0x46>
	} else if (plugged && !draining) {
   23798:	b152      	cbz	r2, 237b0 <submit_to_queue_locked+0x7c>
   2379a:	075b      	lsls	r3, r3, #29
   2379c:	d408      	bmi.n	237b0 <submit_to_queue_locked+0x7c>
		ret = -EBUSY;
   2379e:	f06f 060f 	mvn.w	r6, #15
   237a2:	e7ec      	b.n	2377e <submit_to_queue_locked+0x4a>
	} else if (draining && !chained) {
   237a4:	2a00      	cmp	r2, #0
   237a6:	d1fa      	bne.n	2379e <submit_to_queue_locked+0x6a>
	return (*flagp & BIT(bit)) != 0U;
   237a8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
	} else if (plugged && !draining) {
   237ac:	2b00      	cmp	r3, #0
   237ae:	d1f6      	bne.n	2379e <submit_to_queue_locked+0x6a>
	parent->next = child;
   237b0:	2300      	movs	r3, #0
   237b2:	6023      	str	r3, [r4, #0]
	return list->tail;
   237b4:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
Z_GENLIST_APPEND(slist, snode)
   237b8:	b963      	cbnz	r3, 237d4 <submit_to_queue_locked+0xa0>
	list->head = node;
   237ba:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
		(void)notify_queue_locked(queue);
   237be:	4628      	mov	r0, r5
   237c0:	f002 fa9a 	bl	25cf8 <notify_queue_locked.isra.0>
	*flagp |= BIT(bit);
   237c4:	68e3      	ldr	r3, [r4, #12]
   237c6:	f043 0304 	orr.w	r3, r3, #4
   237ca:	60e3      	str	r3, [r4, #12]
			work->queue = *queuep;
   237cc:	683b      	ldr	r3, [r7, #0]
   237ce:	60a3      	str	r3, [r4, #8]
}
   237d0:	4630      	mov	r0, r6
   237d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	parent->next = child;
   237d4:	601c      	str	r4, [r3, #0]
	list->tail = node;
   237d6:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
}
   237da:	e7f0      	b.n	237be <submit_to_queue_locked+0x8a>
		return -EINVAL;
   237dc:	f06f 0615 	mvn.w	r6, #21
   237e0:	e7cd      	b.n	2377e <submit_to_queue_locked+0x4a>
   237e2:	bf00      	nop
   237e4:	2000b5b4 	.word	0x2000b5b4

000237e8 <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
   237e8:	b5f0      	push	{r4, r5, r6, r7, lr}
   237ea:	4604      	mov	r4, r0
	list->head = NULL;
   237ec:	2000      	movs	r0, #0
   237ee:	b089      	sub	sp, #36	; 0x24
	list->tail = NULL;
   237f0:	e9c4 0020 	strd	r0, r0, [r4, #128]	; 0x80
   237f4:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   237f6:	f104 0088 	add.w	r0, r4, #136	; 0x88
	list->tail = (sys_dnode_t *)list;
   237fa:	e9c4 0022 	strd	r0, r0, [r4, #136]	; 0x88
   237fe:	f104 0090 	add.w	r0, r4, #144	; 0x90
   23802:	e9c4 0024 	strd	r0, r0, [r4, #144]	; 0x90

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
   23806:	b31d      	cbz	r5, 23850 <k_work_queue_start+0x68>
   23808:	7928      	ldrb	r0, [r5, #4]
		flags |= K_WORK_QUEUE_NO_YIELD;
   2380a:	2800      	cmp	r0, #0
   2380c:	f240 1001 	movw	r0, #257	; 0x101
   23810:	bf08      	it	eq
   23812:	2001      	moveq	r0, #1
	*flagp = flags;
   23814:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   23818:	2000      	movs	r0, #0
   2381a:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2381e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   23822:	e9cd 3003 	strd	r3, r0, [sp, #12]
   23826:	e9cd 0001 	strd	r0, r0, [sp, #4]
   2382a:	e9cd 6706 	strd	r6, r7, [sp, #24]
   2382e:	4620      	mov	r0, r4
   23830:	4b08      	ldr	r3, [pc, #32]	; (23854 <k_work_queue_start+0x6c>)
   23832:	9400      	str	r4, [sp, #0]
   23834:	f7ff fcee 	bl	23214 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
   23838:	b125      	cbz	r5, 23844 <k_work_queue_start+0x5c>
   2383a:	6829      	ldr	r1, [r5, #0]
   2383c:	b111      	cbz	r1, 23844 <k_work_queue_start+0x5c>
	return z_impl_k_thread_name_set(thread, str);
   2383e:	4620      	mov	r0, r4
   23840:	f002 f9af 	bl	25ba2 <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
   23844:	4620      	mov	r0, r4
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
   23846:	b009      	add	sp, #36	; 0x24
   23848:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   2384c:	f002 b9ac 	b.w	25ba8 <z_impl_k_thread_start>
	uint32_t flags = K_WORK_QUEUE_STARTED;
   23850:	2001      	movs	r0, #1
   23852:	e7df      	b.n	23814 <k_work_queue_start+0x2c>
   23854:	000235fd 	.word	0x000235fd

00023858 <k_work_schedule_for_queue>:
}

int k_work_schedule_for_queue(struct k_work_q *queue,
			       struct k_work_delayable *dwork,
			       k_timeout_t delay)
{
   23858:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2385a:	9001      	str	r0, [sp, #4]
   2385c:	4608      	mov	r0, r1
	__asm__ volatile(
   2385e:	f04f 0120 	mov.w	r1, #32
   23862:	f3ef 8411 	mrs	r4, BASEPRI
   23866:	f381 8812 	msr	BASEPRI_MAX, r1
   2386a:	f3bf 8f6f 	isb	sy
	return *flagp;
   2386e:	68c1      	ldr	r1, [r0, #12]
	struct k_work *work = &dwork->work;
	int ret = 0;
	k_spinlock_key_t key = k_spin_lock(&lock);

	/* Schedule the work item if it's idle or running. */
	if ((work_busy_get_locked(work) & ~K_WORK_RUNNING) == 0U) {
   23870:	f011 0f0e 	tst.w	r1, #14
   23874:	d116      	bne.n	238a4 <k_work_schedule_for_queue+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   23876:	ea53 0502 	orrs.w	r5, r3, r2
   2387a:	d108      	bne.n	2388e <k_work_schedule_for_queue+0x36>
		return submit_to_queue_locked(work, queuep);
   2387c:	a901      	add	r1, sp, #4
   2387e:	f7ff ff59 	bl	23734 <submit_to_queue_locked>
	__asm__ volatile(
   23882:	f384 8811 	msr	BASEPRI, r4
   23886:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&lock, key);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work, schedule_for_queue, queue, dwork, delay, ret);

	return ret;
}
   2388a:	b003      	add	sp, #12
   2388c:	bd30      	pop	{r4, r5, pc}
	*flagp |= BIT(bit);
   2388e:	f041 0108 	orr.w	r1, r1, #8
   23892:	60c1      	str	r1, [r0, #12]
	dwork->queue = *queuep;
   23894:	9901      	ldr	r1, [sp, #4]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   23896:	3010      	adds	r0, #16
	dwork->queue = *queuep;
   23898:	6181      	str	r1, [r0, #24]
	z_add_timeout(&dwork->timeout, work_timeout, delay);
   2389a:	4903      	ldr	r1, [pc, #12]	; (238a8 <k_work_schedule_for_queue+0x50>)
   2389c:	f000 fbd4 	bl	24048 <z_add_timeout>
	return ret;
   238a0:	2001      	movs	r0, #1
   238a2:	e7ee      	b.n	23882 <k_work_schedule_for_queue+0x2a>
	int ret = 0;
   238a4:	2000      	movs	r0, #0
   238a6:	e7ec      	b.n	23882 <k_work_schedule_for_queue+0x2a>
   238a8:	00025d07 	.word	0x00025d07

000238ac <sliceable>:
{
	bool ret = is_preempt(thread)
		&& slice_time(thread) != 0
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
		&& !z_is_thread_prevented_from_running(thread)
		&& !z_is_idle_thread_object(thread);
   238ac:	89c3      	ldrh	r3, [r0, #14]
   238ae:	2b7f      	cmp	r3, #127	; 0x7f
   238b0:	d812      	bhi.n	238d8 <sliceable+0x2c>
	int ret = slice_ticks;
   238b2:	4b0a      	ldr	r3, [pc, #40]	; (238dc <sliceable+0x30>)
   238b4:	681b      	ldr	r3, [r3, #0]
		&& slice_time(thread) != 0
   238b6:	b163      	cbz	r3, 238d2 <sliceable+0x26>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   238b8:	4b09      	ldr	r3, [pc, #36]	; (238e0 <sliceable+0x34>)
   238ba:	f990 200e 	ldrsb.w	r2, [r0, #14]
   238be:	681b      	ldr	r3, [r3, #0]
   238c0:	429a      	cmp	r2, r3
   238c2:	db09      	blt.n	238d8 <sliceable+0x2c>
		&& !z_is_thread_prevented_from_running(thread)
   238c4:	7b43      	ldrb	r3, [r0, #13]
   238c6:	06db      	lsls	r3, r3, #27
   238c8:	d106      	bne.n	238d8 <sliceable+0x2c>
		&& !z_is_idle_thread_object(thread);
   238ca:	4b06      	ldr	r3, [pc, #24]	; (238e4 <sliceable+0x38>)
   238cc:	1ac3      	subs	r3, r0, r3
   238ce:	bf18      	it	ne
   238d0:	2301      	movne	r3, #1
#ifdef CONFIG_TIMESLICE_PER_THREAD
	ret |= thread->base.slice_ticks != 0;
#endif

	return ret;
}
   238d2:	f003 0001 	and.w	r0, r3, #1
   238d6:	4770      	bx	lr
		&& !z_is_idle_thread_object(thread);
   238d8:	2300      	movs	r3, #0
   238da:	e7fa      	b.n	238d2 <sliceable+0x26>
   238dc:	2000b5e8 	.word	0x2000b5e8
   238e0:	2000b5e4 	.word	0x2000b5e4
   238e4:	2000a570 	.word	0x2000a570

000238e8 <slice_timeout>:

static void slice_timeout(struct _timeout *t)
{
	int cpu = ARRAY_INDEX(slice_timeouts, t);

	slice_expired[cpu] = true;
   238e8:	2201      	movs	r2, #1
	int cpu = ARRAY_INDEX(slice_timeouts, t);
   238ea:	4b04      	ldr	r3, [pc, #16]	; (238fc <slice_timeout+0x14>)
   238ec:	1ac0      	subs	r0, r0, r3
   238ee:	4b04      	ldr	r3, [pc, #16]	; (23900 <slice_timeout+0x18>)
   238f0:	10c0      	asrs	r0, r0, #3
   238f2:	4358      	muls	r0, r3
	slice_expired[cpu] = true;
   238f4:	4b03      	ldr	r3, [pc, #12]	; (23904 <slice_timeout+0x1c>)
   238f6:	541a      	strb	r2, [r3, r0]
	 * the specific core, but that's not part of the API yet.
	 */
	if (IS_ENABLED(CONFIG_SMP) && cpu != _current_cpu->id) {
		flag_ipi();
	}
}
   238f8:	4770      	bx	lr
   238fa:	bf00      	nop
   238fc:	2000a670 	.word	0x2000a670
   23900:	aaaaaaab 	.word	0xaaaaaaab
   23904:	2000b62c 	.word	0x2000b62c

00023908 <z_reset_time_slice>:

void z_reset_time_slice(struct k_thread *curr)
{
   23908:	b570      	push	{r4, r5, r6, lr}
	int cpu = _current_cpu->id;
   2390a:	4b0e      	ldr	r3, [pc, #56]	; (23944 <z_reset_time_slice+0x3c>)

	z_abort_timeout(&slice_timeouts[cpu]);
   2390c:	4c0e      	ldr	r4, [pc, #56]	; (23948 <z_reset_time_slice+0x40>)
	int cpu = _current_cpu->id;
   2390e:	7c1e      	ldrb	r6, [r3, #16]
{
   23910:	4605      	mov	r5, r0
	z_abort_timeout(&slice_timeouts[cpu]);
   23912:	eb06 0346 	add.w	r3, r6, r6, lsl #1
   23916:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
   2391a:	4620      	mov	r0, r4
   2391c:	f002 fb4b 	bl	25fb6 <z_abort_timeout>
	slice_expired[cpu] = false;
   23920:	2200      	movs	r2, #0
   23922:	4b0a      	ldr	r3, [pc, #40]	; (2394c <z_reset_time_slice+0x44>)
	if (sliceable(curr)) {
   23924:	4628      	mov	r0, r5
	slice_expired[cpu] = false;
   23926:	559a      	strb	r2, [r3, r6]
	if (sliceable(curr)) {
   23928:	f7ff ffc0 	bl	238ac <sliceable>
   2392c:	b148      	cbz	r0, 23942 <z_reset_time_slice+0x3a>
	int ret = slice_ticks;
   2392e:	4b08      	ldr	r3, [pc, #32]	; (23950 <z_reset_time_slice+0x48>)
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
   23930:	4620      	mov	r0, r4
			      K_TICKS(slice_time(curr) - 1));
	}
}
   23932:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			      K_TICKS(slice_time(curr) - 1));
   23936:	681a      	ldr	r2, [r3, #0]
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
   23938:	4906      	ldr	r1, [pc, #24]	; (23954 <z_reset_time_slice+0x4c>)
			      K_TICKS(slice_time(curr) - 1));
   2393a:	3a01      	subs	r2, #1
		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
   2393c:	17d3      	asrs	r3, r2, #31
   2393e:	f000 bb83 	b.w	24048 <z_add_timeout>
}
   23942:	bd70      	pop	{r4, r5, r6, pc}
   23944:	2000b5b4 	.word	0x2000b5b4
   23948:	2000a670 	.word	0x2000a670
   2394c:	2000b62c 	.word	0x2000b62c
   23950:	2000b5e8 	.word	0x2000b5e8
   23954:	000238e9 	.word	0x000238e9

00023958 <update_cache>:
	}
#endif
}

static void update_cache(int preempt_ok)
{
   23958:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
   2395a:	4d0d      	ldr	r5, [pc, #52]	; (23990 <update_cache+0x38>)
   2395c:	462b      	mov	r3, r5
   2395e:	f853 4f1c 	ldr.w	r4, [r3, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23962:	429c      	cmp	r4, r3
   23964:	d000      	beq.n	23968 <update_cache+0x10>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
   23966:	b904      	cbnz	r4, 2396a <update_cache+0x12>
   23968:	68ec      	ldr	r4, [r5, #12]
	if (z_is_thread_prevented_from_running(_current)) {
   2396a:	68ab      	ldr	r3, [r5, #8]
	if (preempt_ok != 0) {
   2396c:	b938      	cbnz	r0, 2397e <update_cache+0x26>
	if (z_is_thread_prevented_from_running(_current)) {
   2396e:	7b5a      	ldrb	r2, [r3, #13]
   23970:	06d2      	lsls	r2, r2, #27
   23972:	d104      	bne.n	2397e <update_cache+0x26>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   23974:	69a2      	ldr	r2, [r4, #24]
   23976:	b912      	cbnz	r2, 2397e <update_cache+0x26>
	if (is_preempt(_current) || is_metairq(thread)) {
   23978:	89da      	ldrh	r2, [r3, #14]
   2397a:	2a7f      	cmp	r2, #127	; 0x7f
   2397c:	d805      	bhi.n	2398a <update_cache+0x32>
#ifndef CONFIG_SMP
	struct k_thread *thread = next_up();

	if (should_preempt(thread, preempt_ok)) {
#ifdef CONFIG_TIMESLICING
		if (thread != _current) {
   2397e:	429c      	cmp	r4, r3
   23980:	d002      	beq.n	23988 <update_cache+0x30>
			z_reset_time_slice(thread);
   23982:	4620      	mov	r0, r4
   23984:	f7ff ffc0 	bl	23908 <z_reset_time_slice>
		}
#endif
		update_metairq_preempt(thread);
		_kernel.ready_q.cache = thread;
   23988:	4623      	mov	r3, r4
   2398a:	61ab      	str	r3, [r5, #24]
	 * thread because if the thread gets preempted for whatever
	 * reason the scheduler will make the same decision anyway.
	 */
	_current_cpu->swap_ok = preempt_ok;
#endif
}
   2398c:	bd38      	pop	{r3, r4, r5, pc}
   2398e:	bf00      	nop
   23990:	2000b5b4 	.word	0x2000b5b4

00023994 <move_thread_to_end_of_prio_q>:
{
   23994:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
   23996:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   2399a:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   2399c:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
   2399e:	7b43      	ldrb	r3, [r0, #13]
   239a0:	da04      	bge.n	239ac <move_thread_to_end_of_prio_q+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   239a2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   239a6:	7343      	strb	r3, [r0, #13]

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
   239a8:	f002 fa06 	bl	25db8 <sys_dlist_remove>
	return list->head == list;
   239ac:	4a15      	ldr	r2, [pc, #84]	; (23a04 <move_thread_to_end_of_prio_q+0x70>)
	thread->base.thread_state |= _THREAD_QUEUED;
   239ae:	7b4b      	ldrb	r3, [r1, #13]
   239b0:	4610      	mov	r0, r2
   239b2:	f063 037f 	orn	r3, r3, #127	; 0x7f
   239b6:	734b      	strb	r3, [r1, #13]
   239b8:	f850 3f1c 	ldr.w	r3, [r0, #28]!
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
   239bc:	6a14      	ldr	r4, [r2, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   239be:	4283      	cmp	r3, r0
   239c0:	bf08      	it	eq
   239c2:	2300      	moveq	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   239c4:	b923      	cbnz	r3, 239d0 <move_thread_to_end_of_prio_q+0x3c>
static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;

	node->next = list;
	node->prev = tail;
   239c6:	e9c1 0400 	strd	r0, r4, [r1]

	tail->next = node;
   239ca:	6021      	str	r1, [r4, #0]
	list->tail = node;
   239cc:	6211      	str	r1, [r2, #32]
}
   239ce:	e00c      	b.n	239ea <move_thread_to_end_of_prio_q+0x56>
	int32_t b1 = thread_1->base.prio;
   239d0:	f991 500e 	ldrsb.w	r5, [r1, #14]
	int32_t b2 = thread_2->base.prio;
   239d4:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
   239d8:	42b5      	cmp	r5, r6
   239da:	d00e      	beq.n	239fa <move_thread_to_end_of_prio_q+0x66>
		if (z_sched_prio_cmp(thread, t) > 0) {
   239dc:	42ae      	cmp	r6, r5
   239de:	dd0c      	ble.n	239fa <move_thread_to_end_of_prio_q+0x66>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
   239e0:	6858      	ldr	r0, [r3, #4]

	node->prev = prev;
	node->next = successor;
   239e2:	e9c1 3000 	strd	r3, r0, [r1]
	prev->next = node;
   239e6:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   239e8:	6059      	str	r1, [r3, #4]
	update_cache(thread == _current);
   239ea:	6890      	ldr	r0, [r2, #8]
}
   239ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
   239f0:	1a43      	subs	r3, r0, r1
   239f2:	4258      	negs	r0, r3
   239f4:	4158      	adcs	r0, r3
   239f6:	f7ff bfaf 	b.w	23958 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   239fa:	429c      	cmp	r4, r3
   239fc:	d0e3      	beq.n	239c6 <move_thread_to_end_of_prio_q+0x32>
   239fe:	681b      	ldr	r3, [r3, #0]
   23a00:	e7e0      	b.n	239c4 <move_thread_to_end_of_prio_q+0x30>
   23a02:	bf00      	nop
   23a04:	2000b5b4 	.word	0x2000b5b4

00023a08 <ready_thread>:
{
   23a08:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
   23a0a:	f990 300d 	ldrsb.w	r3, [r0, #13]
   23a0e:	7b42      	ldrb	r2, [r0, #13]
   23a10:	2b00      	cmp	r3, #0
   23a12:	db29      	blt.n	23a68 <ready_thread+0x60>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   23a14:	06d3      	lsls	r3, r2, #27
   23a16:	d127      	bne.n	23a68 <ready_thread+0x60>
	return node->next != NULL;
   23a18:	6983      	ldr	r3, [r0, #24]
   23a1a:	bb2b      	cbnz	r3, 23a68 <ready_thread+0x60>
	return list->head == list;
   23a1c:	4913      	ldr	r1, [pc, #76]	; (23a6c <ready_thread+0x64>)
	thread->base.thread_state |= _THREAD_QUEUED;
   23a1e:	f062 027f 	orn	r2, r2, #127	; 0x7f
   23a22:	7342      	strb	r2, [r0, #13]
   23a24:	460a      	mov	r2, r1
   23a26:	f852 4f1c 	ldr.w	r4, [r2, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23a2a:	4294      	cmp	r4, r2
   23a2c:	bf18      	it	ne
   23a2e:	4623      	movne	r3, r4
	return (node == list->tail) ? NULL : node->next;
   23a30:	6a0c      	ldr	r4, [r1, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   23a32:	b923      	cbnz	r3, 23a3e <ready_thread+0x36>
	node->prev = tail;
   23a34:	e9c0 2400 	strd	r2, r4, [r0]
	tail->next = node;
   23a38:	6020      	str	r0, [r4, #0]
	list->tail = node;
   23a3a:	6208      	str	r0, [r1, #32]
}
   23a3c:	e00c      	b.n	23a58 <ready_thread+0x50>
	int32_t b1 = thread_1->base.prio;
   23a3e:	f990 500e 	ldrsb.w	r5, [r0, #14]
	int32_t b2 = thread_2->base.prio;
   23a42:	f993 600e 	ldrsb.w	r6, [r3, #14]
	if (b1 != b2) {
   23a46:	42b5      	cmp	r5, r6
   23a48:	d00a      	beq.n	23a60 <ready_thread+0x58>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23a4a:	42ae      	cmp	r6, r5
   23a4c:	dd08      	ble.n	23a60 <ready_thread+0x58>
	sys_dnode_t *const prev = successor->prev;
   23a4e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   23a50:	e9c0 3200 	strd	r3, r2, [r0]
	prev->next = node;
   23a54:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   23a56:	6058      	str	r0, [r3, #4]
		update_cache(0);
   23a58:	2000      	movs	r0, #0
}
   23a5a:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   23a5c:	f7ff bf7c 	b.w	23958 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   23a60:	42a3      	cmp	r3, r4
   23a62:	d0e7      	beq.n	23a34 <ready_thread+0x2c>
   23a64:	681b      	ldr	r3, [r3, #0]
   23a66:	e7e4      	b.n	23a32 <ready_thread+0x2a>
}
   23a68:	bc70      	pop	{r4, r5, r6}
   23a6a:	4770      	bx	lr
   23a6c:	2000b5b4 	.word	0x2000b5b4

00023a70 <unready_thread>:
{
   23a70:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   23a72:	f990 200d 	ldrsb.w	r2, [r0, #13]
{
   23a76:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   23a78:	2a00      	cmp	r2, #0
	return (thread->base.thread_state & state) != 0U;
   23a7a:	7b43      	ldrb	r3, [r0, #13]
   23a7c:	da04      	bge.n	23a88 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23a7e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   23a82:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23a84:	f002 f998 	bl	25db8 <sys_dlist_remove>
	update_cache(thread == _current);
   23a88:	4b04      	ldr	r3, [pc, #16]	; (23a9c <unready_thread+0x2c>)
   23a8a:	6898      	ldr	r0, [r3, #8]
   23a8c:	1a43      	subs	r3, r0, r1
   23a8e:	4258      	negs	r0, r3
   23a90:	4158      	adcs	r0, r3
}
   23a92:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   23a96:	f7ff bf5f 	b.w	23958 <update_cache>
   23a9a:	bf00      	nop
   23a9c:	2000b5b4 	.word	0x2000b5b4

00023aa0 <pend_locked>:
{
   23aa0:	b570      	push	{r4, r5, r6, lr}
   23aa2:	4615      	mov	r5, r2
   23aa4:	461c      	mov	r4, r3
   23aa6:	4606      	mov	r6, r0
	add_to_waitq_locked(thread, wait_q);
   23aa8:	f002 f998 	bl	25ddc <add_to_waitq_locked>
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   23aac:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   23ab0:	bf08      	it	eq
   23ab2:	f1b5 3fff 	cmpeq.w	r5, #4294967295	; 0xffffffff
   23ab6:	d008      	beq.n	23aca <pend_locked+0x2a>
   23ab8:	462a      	mov	r2, r5
   23aba:	4623      	mov	r3, r4
   23abc:	f106 0018 	add.w	r0, r6, #24
   23ac0:	4902      	ldr	r1, [pc, #8]	; (23acc <pend_locked+0x2c>)
}
   23ac2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   23ac6:	f000 babf 	b.w	24048 <z_add_timeout>
   23aca:	bd70      	pop	{r4, r5, r6, pc}
   23acc:	00025eb5 	.word	0x00025eb5

00023ad0 <z_time_slice>:
{
   23ad0:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   23ad2:	f04f 0320 	mov.w	r3, #32
   23ad6:	f3ef 8511 	mrs	r5, BASEPRI
   23ada:	f383 8812 	msr	BASEPRI_MAX, r3
   23ade:	f3bf 8f6f 	isb	sy
	struct k_thread *curr = _current;
   23ae2:	4b10      	ldr	r3, [pc, #64]	; (23b24 <z_time_slice+0x54>)
	if (pending_current == curr) {
   23ae4:	4a10      	ldr	r2, [pc, #64]	; (23b28 <z_time_slice+0x58>)
	struct k_thread *curr = _current;
   23ae6:	689c      	ldr	r4, [r3, #8]
	if (pending_current == curr) {
   23ae8:	6810      	ldr	r0, [r2, #0]
   23aea:	42a0      	cmp	r0, r4
   23aec:	d106      	bne.n	23afc <z_time_slice+0x2c>
		z_reset_time_slice(curr);
   23aee:	f7ff ff0b 	bl	23908 <z_reset_time_slice>
	__asm__ volatile(
   23af2:	f385 8811 	msr	BASEPRI, r5
   23af6:	f3bf 8f6f 	isb	sy
}
   23afa:	bd38      	pop	{r3, r4, r5, pc}
	pending_current = NULL;
   23afc:	2100      	movs	r1, #0
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
   23afe:	7c1b      	ldrb	r3, [r3, #16]
	pending_current = NULL;
   23b00:	6011      	str	r1, [r2, #0]
	if (slice_expired[_current_cpu->id] && sliceable(curr)) {
   23b02:	4a0a      	ldr	r2, [pc, #40]	; (23b2c <z_time_slice+0x5c>)
   23b04:	5cd3      	ldrb	r3, [r2, r3]
   23b06:	2b00      	cmp	r3, #0
   23b08:	d0f3      	beq.n	23af2 <z_time_slice+0x22>
   23b0a:	4620      	mov	r0, r4
   23b0c:	f7ff fece 	bl	238ac <sliceable>
   23b10:	2800      	cmp	r0, #0
   23b12:	d0ee      	beq.n	23af2 <z_time_slice+0x22>
		if (!z_is_thread_prevented_from_running(curr)) {
   23b14:	7b63      	ldrb	r3, [r4, #13]
   23b16:	06db      	lsls	r3, r3, #27
   23b18:	d102      	bne.n	23b20 <z_time_slice+0x50>
			move_thread_to_end_of_prio_q(curr);
   23b1a:	4620      	mov	r0, r4
   23b1c:	f7ff ff3a 	bl	23994 <move_thread_to_end_of_prio_q>
		z_reset_time_slice(curr);
   23b20:	4620      	mov	r0, r4
   23b22:	e7e4      	b.n	23aee <z_time_slice+0x1e>
   23b24:	2000b5b4 	.word	0x2000b5b4
   23b28:	2000b5e0 	.word	0x2000b5e0
   23b2c:	2000b62c 	.word	0x2000b62c

00023b30 <z_pend_curr>:
{
   23b30:	b570      	push	{r4, r5, r6, lr}
	pending_current = _current;
   23b32:	480c      	ldr	r0, [pc, #48]	; (23b64 <z_pend_curr+0x34>)
   23b34:	4d0c      	ldr	r5, [pc, #48]	; (23b68 <z_pend_curr+0x38>)
   23b36:	6886      	ldr	r6, [r0, #8]
{
   23b38:	460c      	mov	r4, r1
	pending_current = _current;
   23b3a:	602e      	str	r6, [r5, #0]
{
   23b3c:	4611      	mov	r1, r2
   23b3e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
	__asm__ volatile(
   23b42:	f04f 0620 	mov.w	r6, #32
   23b46:	f3ef 8511 	mrs	r5, BASEPRI
   23b4a:	f386 8812 	msr	BASEPRI_MAX, r6
   23b4e:	f3bf 8f6f 	isb	sy
	pend_locked(_current, wait_q, timeout);
   23b52:	6880      	ldr	r0, [r0, #8]
   23b54:	f7ff ffa4 	bl	23aa0 <pend_locked>
	ret = arch_swap(key);
   23b58:	4620      	mov	r0, r4
}
   23b5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   23b5e:	f7fa bc1d 	b.w	1e39c <arch_swap>
   23b62:	bf00      	nop
   23b64:	2000b5b4 	.word	0x2000b5b4
   23b68:	2000b5e0 	.word	0x2000b5e0

00023b6c <z_set_prio>:
{
   23b6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   23b6e:	4604      	mov	r4, r0
   23b70:	f04f 0320 	mov.w	r3, #32
   23b74:	f3ef 8611 	mrs	r6, BASEPRI
   23b78:	f383 8812 	msr	BASEPRI_MAX, r3
   23b7c:	f3bf 8f6f 	isb	sy
	uint8_t state = thread->base.thread_state;
   23b80:	7b43      	ldrb	r3, [r0, #13]
				thread->base.prio = prio;
   23b82:	b249      	sxtb	r1, r1
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
   23b84:	06da      	lsls	r2, r3, #27
   23b86:	d119      	bne.n	23bbc <z_set_prio+0x50>
	return node->next != NULL;
   23b88:	6985      	ldr	r5, [r0, #24]
   23b8a:	b9bd      	cbnz	r5, 23bbc <z_set_prio+0x50>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23b8c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   23b90:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23b92:	f002 f911 	bl	25db8 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
   23b96:	7b43      	ldrb	r3, [r0, #13]
	return list->head == list;
   23b98:	4a16      	ldr	r2, [pc, #88]	; (23bf4 <z_set_prio+0x88>)
   23b9a:	f063 037f 	orn	r3, r3, #127	; 0x7f
   23b9e:	7343      	strb	r3, [r0, #13]
   23ba0:	4613      	mov	r3, r2
				thread->base.prio = prio;
   23ba2:	7381      	strb	r1, [r0, #14]
   23ba4:	f853 0f1c 	ldr.w	r0, [r3, #28]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23ba8:	4298      	cmp	r0, r3
   23baa:	bf18      	it	ne
   23bac:	4605      	movne	r5, r0
	return (node == list->tail) ? NULL : node->next;
   23bae:	6a10      	ldr	r0, [r2, #32]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   23bb0:	b95d      	cbnz	r5, 23bca <z_set_prio+0x5e>
	node->prev = tail;
   23bb2:	e9c4 3000 	strd	r3, r0, [r4]
	tail->next = node;
   23bb6:	6004      	str	r4, [r0, #0]
	list->tail = node;
   23bb8:	6214      	str	r4, [r2, #32]
}
   23bba:	e011      	b.n	23be0 <z_set_prio+0x74>
   23bbc:	2000      	movs	r0, #0
			thread->base.prio = prio;
   23bbe:	73a1      	strb	r1, [r4, #14]
	__asm__ volatile(
   23bc0:	f386 8811 	msr	BASEPRI, r6
   23bc4:	f3bf 8f6f 	isb	sy
}
   23bc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int32_t b2 = thread_2->base.prio;
   23bca:	f995 700e 	ldrsb.w	r7, [r5, #14]
	if (b1 != b2) {
   23bce:	42b9      	cmp	r1, r7
   23bd0:	d00b      	beq.n	23bea <z_set_prio+0x7e>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23bd2:	428f      	cmp	r7, r1
   23bd4:	dd09      	ble.n	23bea <z_set_prio+0x7e>
	sys_dnode_t *const prev = successor->prev;
   23bd6:	686b      	ldr	r3, [r5, #4]
	node->next = successor;
   23bd8:	e9c4 5300 	strd	r5, r3, [r4]
	prev->next = node;
   23bdc:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   23bde:	606c      	str	r4, [r5, #4]
			update_cache(1);
   23be0:	2001      	movs	r0, #1
   23be2:	f7ff feb9 	bl	23958 <update_cache>
   23be6:	2001      	movs	r0, #1
   23be8:	e7ea      	b.n	23bc0 <z_set_prio+0x54>
	return (node == list->tail) ? NULL : node->next;
   23bea:	42a8      	cmp	r0, r5
   23bec:	d0e1      	beq.n	23bb2 <z_set_prio+0x46>
   23bee:	682d      	ldr	r5, [r5, #0]
   23bf0:	e7de      	b.n	23bb0 <z_set_prio+0x44>
   23bf2:	bf00      	nop
   23bf4:	2000b5b4 	.word	0x2000b5b4

00023bf8 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   23bf8:	b949      	cbnz	r1, 23c0e <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   23bfa:	f3ef 8005 	mrs	r0, IPSR
   23bfe:	b930      	cbnz	r0, 23c0e <z_reschedule+0x16>
	new_thread = _kernel.ready_q.cache;
   23c00:	4b05      	ldr	r3, [pc, #20]	; (23c18 <z_reschedule+0x20>)
	if (resched(key.key) && need_swap()) {
   23c02:	699a      	ldr	r2, [r3, #24]
   23c04:	689b      	ldr	r3, [r3, #8]
   23c06:	429a      	cmp	r2, r3
   23c08:	d001      	beq.n	23c0e <z_reschedule+0x16>
   23c0a:	f7fa bbc7 	b.w	1e39c <arch_swap>
   23c0e:	f381 8811 	msr	BASEPRI, r1
   23c12:	f3bf 8f6f 	isb	sy
}
   23c16:	4770      	bx	lr
   23c18:	2000b5b4 	.word	0x2000b5b4

00023c1c <z_sched_start>:
{
   23c1c:	b510      	push	{r4, lr}
	__asm__ volatile(
   23c1e:	f04f 0220 	mov.w	r2, #32
   23c22:	f3ef 8411 	mrs	r4, BASEPRI
   23c26:	f382 8812 	msr	BASEPRI_MAX, r2
   23c2a:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
   23c2e:	7b42      	ldrb	r2, [r0, #13]
	if (z_has_thread_started(thread)) {
   23c30:	0751      	lsls	r1, r2, #29
   23c32:	d404      	bmi.n	23c3e <z_sched_start+0x22>
	__asm__ volatile(
   23c34:	f384 8811 	msr	BASEPRI, r4
   23c38:	f3bf 8f6f 	isb	sy
}
   23c3c:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   23c3e:	f022 0204 	bic.w	r2, r2, #4
   23c42:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   23c44:	f7ff fee0 	bl	23a08 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   23c48:	4621      	mov	r1, r4
}
   23c4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   23c4e:	4801      	ldr	r0, [pc, #4]	; (23c54 <z_sched_start+0x38>)
   23c50:	f7ff bfd2 	b.w	23bf8 <z_reschedule>
   23c54:	2000b62d 	.word	0x2000b62d

00023c58 <z_impl_k_thread_suspend>:
{
   23c58:	b570      	push	{r4, r5, r6, lr}
   23c5a:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   23c5c:	3018      	adds	r0, #24
   23c5e:	f002 f9aa 	bl	25fb6 <z_abort_timeout>
	__asm__ volatile(
   23c62:	f04f 0320 	mov.w	r3, #32
   23c66:	f3ef 8611 	mrs	r6, BASEPRI
   23c6a:	f383 8812 	msr	BASEPRI_MAX, r3
   23c6e:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   23c72:	f994 200d 	ldrsb.w	r2, [r4, #13]
	return (thread->base.thread_state & state) != 0U;
   23c76:	7b63      	ldrb	r3, [r4, #13]
   23c78:	2a00      	cmp	r2, #0
   23c7a:	da05      	bge.n	23c88 <z_impl_k_thread_suspend+0x30>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23c7c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	sys_dlist_remove(&thread->base.qnode_dlist);
   23c80:	4620      	mov	r0, r4
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23c82:	7363      	strb	r3, [r4, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23c84:	f002 f898 	bl	25db8 <sys_dlist_remove>
		update_cache(thread == _current);
   23c88:	4d0b      	ldr	r5, [pc, #44]	; (23cb8 <z_impl_k_thread_suspend+0x60>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   23c8a:	7b63      	ldrb	r3, [r4, #13]
   23c8c:	68a8      	ldr	r0, [r5, #8]
   23c8e:	f043 0310 	orr.w	r3, r3, #16
   23c92:	7363      	strb	r3, [r4, #13]
   23c94:	1b03      	subs	r3, r0, r4
   23c96:	4258      	negs	r0, r3
   23c98:	4158      	adcs	r0, r3
   23c9a:	f7ff fe5d 	bl	23958 <update_cache>
	__asm__ volatile(
   23c9e:	f386 8811 	msr	BASEPRI, r6
   23ca2:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   23ca6:	68ab      	ldr	r3, [r5, #8]
   23ca8:	42a3      	cmp	r3, r4
   23caa:	d103      	bne.n	23cb4 <z_impl_k_thread_suspend+0x5c>
}
   23cac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   23cb0:	f002 b944 	b.w	25f3c <z_reschedule_unlocked>
}
   23cb4:	bd70      	pop	{r4, r5, r6, pc}
   23cb6:	bf00      	nop
   23cb8:	2000b5b4 	.word	0x2000b5b4

00023cbc <k_sched_lock>:
	__asm__ volatile(
   23cbc:	f04f 0320 	mov.w	r3, #32
   23cc0:	f3ef 8111 	mrs	r1, BASEPRI
   23cc4:	f383 8812 	msr	BASEPRI_MAX, r3
   23cc8:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
   23ccc:	4b04      	ldr	r3, [pc, #16]	; (23ce0 <k_sched_lock+0x24>)
   23cce:	689a      	ldr	r2, [r3, #8]
   23cd0:	7bd3      	ldrb	r3, [r2, #15]
   23cd2:	3b01      	subs	r3, #1
   23cd4:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   23cd6:	f381 8811 	msr	BASEPRI, r1
   23cda:	f3bf 8f6f 	isb	sy
}
   23cde:	4770      	bx	lr
   23ce0:	2000b5b4 	.word	0x2000b5b4

00023ce4 <k_sched_unlock>:
{
   23ce4:	b510      	push	{r4, lr}
	__asm__ volatile(
   23ce6:	f04f 0320 	mov.w	r3, #32
   23cea:	f3ef 8411 	mrs	r4, BASEPRI
   23cee:	f383 8812 	msr	BASEPRI_MAX, r3
   23cf2:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   23cf6:	4b08      	ldr	r3, [pc, #32]	; (23d18 <k_sched_unlock+0x34>)
		update_cache(0);
   23cf8:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   23cfa:	689a      	ldr	r2, [r3, #8]
   23cfc:	7bd3      	ldrb	r3, [r2, #15]
   23cfe:	3301      	adds	r3, #1
   23d00:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   23d02:	f7ff fe29 	bl	23958 <update_cache>
	__asm__ volatile(
   23d06:	f384 8811 	msr	BASEPRI, r4
   23d0a:	f3bf 8f6f 	isb	sy
}
   23d0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   23d12:	f002 b913 	b.w	25f3c <z_reschedule_unlocked>
   23d16:	bf00      	nop
   23d18:	2000b5b4 	.word	0x2000b5b4

00023d1c <z_sched_init>:
	list->head = (sys_dnode_t *)list;
   23d1c:	4b02      	ldr	r3, [pc, #8]	; (23d28 <z_sched_init+0xc>)
   23d1e:	f103 021c 	add.w	r2, r3, #28
	list->tail = (sys_dnode_t *)list;
   23d22:	e9c3 2207 	strd	r2, r2, [r3, #28]
		init_ready_q(&_kernel.cpus[i].ready_q);
	}
#else
	init_ready_q(&_kernel.ready_q);
#endif
}
   23d26:	4770      	bx	lr
   23d28:	2000b5b4 	.word	0x2000b5b4

00023d2c <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
   23d2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   23d2e:	f04f 0320 	mov.w	r3, #32
   23d32:	f3ef 8511 	mrs	r5, BASEPRI
   23d36:	f383 8812 	msr	BASEPRI_MAX, r3
   23d3a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
   23d3e:	4919      	ldr	r1, [pc, #100]	; (23da4 <z_impl_k_yield+0x78>)
   23d40:	6888      	ldr	r0, [r1, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23d42:	7b43      	ldrb	r3, [r0, #13]
   23d44:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   23d48:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23d4a:	f002 f835 	bl	25db8 <sys_dlist_remove>
	return list->head == list;
   23d4e:	4608      	mov	r0, r1
	}
	queue_thread(_current);
   23d50:	688b      	ldr	r3, [r1, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
   23d52:	7b5a      	ldrb	r2, [r3, #13]
   23d54:	f062 027f 	orn	r2, r2, #127	; 0x7f
   23d58:	735a      	strb	r2, [r3, #13]
   23d5a:	f850 2f1c 	ldr.w	r2, [r0, #28]!
	return (node == list->tail) ? NULL : node->next;
   23d5e:	6a0c      	ldr	r4, [r1, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23d60:	4282      	cmp	r2, r0
   23d62:	bf08      	it	eq
   23d64:	2200      	moveq	r2, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   23d66:	b922      	cbnz	r2, 23d72 <z_impl_k_yield+0x46>
	node->prev = tail;
   23d68:	e9c3 0400 	strd	r0, r4, [r3]
	tail->next = node;
   23d6c:	6023      	str	r3, [r4, #0]
	list->tail = node;
   23d6e:	620b      	str	r3, [r1, #32]
}
   23d70:	e00c      	b.n	23d8c <z_impl_k_yield+0x60>
	int32_t b1 = thread_1->base.prio;
   23d72:	f993 600e 	ldrsb.w	r6, [r3, #14]
	int32_t b2 = thread_2->base.prio;
   23d76:	f992 700e 	ldrsb.w	r7, [r2, #14]
	if (b1 != b2) {
   23d7a:	42be      	cmp	r6, r7
   23d7c:	d00e      	beq.n	23d9c <z_impl_k_yield+0x70>
		if (z_sched_prio_cmp(thread, t) > 0) {
   23d7e:	42b7      	cmp	r7, r6
   23d80:	dd0c      	ble.n	23d9c <z_impl_k_yield+0x70>
	sys_dnode_t *const prev = successor->prev;
   23d82:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   23d84:	e9c3 2100 	strd	r2, r1, [r3]
	prev->next = node;
   23d88:	600b      	str	r3, [r1, #0]
	successor->prev = node;
   23d8a:	6053      	str	r3, [r2, #4]
	update_cache(1);
   23d8c:	2001      	movs	r0, #1
   23d8e:	f7ff fde3 	bl	23958 <update_cache>
   23d92:	4628      	mov	r0, r5
	z_swap(&sched_spinlock, key);
}
   23d94:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   23d98:	f7fa bb00 	b.w	1e39c <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   23d9c:	42a2      	cmp	r2, r4
   23d9e:	d0e3      	beq.n	23d68 <z_impl_k_yield+0x3c>
   23da0:	6812      	ldr	r2, [r2, #0]
   23da2:	e7e0      	b.n	23d66 <z_impl_k_yield+0x3a>
   23da4:	2000b5b4 	.word	0x2000b5b4

00023da8 <z_tick_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	LOG_DBG("thread %p for %lu ticks", _current, (unsigned long)ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   23da8:	ea50 0301 	orrs.w	r3, r0, r1
{
   23dac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23db0:	4605      	mov	r5, r0
   23db2:	460e      	mov	r6, r1
	if (ticks == 0) {
   23db4:	d103      	bne.n	23dbe <z_tick_sleep+0x16>
	z_impl_k_yield();
   23db6:	f7ff ffb9 	bl	23d2c <z_impl_k_yield>
		k_yield();
		return 0;
   23dba:	2000      	movs	r0, #0
   23dbc:	e02c      	b.n	23e18 <z_tick_sleep+0x70>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
   23dbe:	1c83      	adds	r3, r0, #2
   23dc0:	f171 33ff 	sbcs.w	r3, r1, #4294967295	; 0xffffffff
   23dc4:	db2a      	blt.n	23e1c <z_tick_sleep+0x74>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
   23dc6:	f002 f91c 	bl	26002 <sys_clock_tick_get_32>
   23dca:	182c      	adds	r4, r5, r0
   23dcc:	f04f 0320 	mov.w	r3, #32
   23dd0:	f3ef 8811 	mrs	r8, BASEPRI
   23dd4:	f383 8812 	msr	BASEPRI_MAX, r3
   23dd8:	f3bf 8f6f 	isb	sy
	}

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   23ddc:	4f11      	ldr	r7, [pc, #68]	; (23e24 <z_tick_sleep+0x7c>)
   23dde:	4b12      	ldr	r3, [pc, #72]	; (23e28 <z_tick_sleep+0x80>)
   23de0:	68b8      	ldr	r0, [r7, #8]
   23de2:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
   23de4:	f7ff fe44 	bl	23a70 <unready_thread>
	z_add_thread_timeout(_current, timeout);
   23de8:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
   23dea:	4910      	ldr	r1, [pc, #64]	; (23e2c <z_tick_sleep+0x84>)
   23dec:	462a      	mov	r2, r5
   23dee:	4633      	mov	r3, r6
   23df0:	3018      	adds	r0, #24
   23df2:	f000 f929 	bl	24048 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   23df6:	68ba      	ldr	r2, [r7, #8]
   23df8:	4640      	mov	r0, r8
	thread->base.thread_state |= _THREAD_SUSPENDED;
   23dfa:	7b53      	ldrb	r3, [r2, #13]
   23dfc:	f043 0310 	orr.w	r3, r3, #16
   23e00:	7353      	strb	r3, [r2, #13]
   23e02:	f7fa facb 	bl	1e39c <arch_swap>

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
   23e06:	f002 f8fc 	bl	26002 <sys_clock_tick_get_32>
   23e0a:	1a20      	subs	r0, r4, r0
   23e0c:	eb63 0303 	sbc.w	r3, r3, r3
	if (ticks > 0) {
   23e10:	2801      	cmp	r0, #1
   23e12:	f173 0300 	sbcs.w	r3, r3, #0
   23e16:	dbd0      	blt.n	23dba <z_tick_sleep+0x12>
		return ticks;
	}
#endif

	return 0;
}
   23e18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
   23e1c:	f06f 0401 	mvn.w	r4, #1
   23e20:	1a24      	subs	r4, r4, r0
   23e22:	e7d3      	b.n	23dcc <z_tick_sleep+0x24>
   23e24:	2000b5b4 	.word	0x2000b5b4
   23e28:	2000b5e0 	.word	0x2000b5e0
   23e2c:	00025eb5 	.word	0x00025eb5

00023e30 <z_impl_k_sleep>:
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   23e30:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   23e34:	bf08      	it	eq
   23e36:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   23e3a:	b508      	push	{r3, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   23e3c:	d106      	bne.n	23e4c <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
   23e3e:	4b08      	ldr	r3, [pc, #32]	; (23e60 <z_impl_k_sleep+0x30>)
   23e40:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   23e42:	f7ff ff09 	bl	23c58 <z_impl_k_thread_suspend>

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
   23e46:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	int32_t ret = k_ticks_to_ms_floor64(ticks);

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
   23e4a:	bd08      	pop	{r3, pc}
	ticks = z_tick_sleep(ticks);
   23e4c:	f7ff ffac 	bl	23da8 <z_tick_sleep>
   23e50:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   23e54:	fb80 0303 	smull	r0, r3, r0, r3
   23e58:	0bc0      	lsrs	r0, r0, #15
   23e5a:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return ret;
   23e5e:	e7f4      	b.n	23e4a <z_impl_k_sleep+0x1a>
   23e60:	2000b5b4 	.word	0x2000b5b4

00023e64 <z_impl_k_usleep>:
}
#include <syscalls/k_sleep_mrsh.c>
#endif

int32_t z_impl_k_usleep(int us)
{
   23e64:	b538      	push	{r3, r4, r5, lr}
   23e66:	2100      	movs	r1, #0
   23e68:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   23e6c:	4c08      	ldr	r4, [pc, #32]	; (23e90 <z_impl_k_usleep+0x2c>)
   23e6e:	2300      	movs	r3, #0
   23e70:	fbc0 4105 	smlal	r4, r1, r0, r5
   23e74:	4a07      	ldr	r2, [pc, #28]	; (23e94 <z_impl_k_usleep+0x30>)
   23e76:	4620      	mov	r0, r4
   23e78:	f7f8 f96c 	bl	1c154 <__aeabi_uldivmod>
	int32_t ticks;

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, usleep, us);

	ticks = k_us_to_ticks_ceil64(us);
	ticks = z_tick_sleep(ticks);
   23e7c:	17c1      	asrs	r1, r0, #31
   23e7e:	f7ff ff93 	bl	23da8 <z_tick_sleep>
   23e82:	4b04      	ldr	r3, [pc, #16]	; (23e94 <z_impl_k_usleep+0x30>)
   23e84:	fb80 0303 	smull	r0, r3, r0, r3
   23e88:	0bc0      	lsrs	r0, r0, #15

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, usleep, us, k_ticks_to_us_floor64(ticks));

	return k_ticks_to_us_floor64(ticks);
}
   23e8a:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   23e8e:	bd38      	pop	{r3, r4, r5, pc}
   23e90:	000f423f 	.word	0x000f423f
   23e94:	000f4240 	.word	0x000f4240

00023e98 <z_impl_z_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   23e98:	4b01      	ldr	r3, [pc, #4]	; (23ea0 <z_impl_z_current_get+0x8>)
   23e9a:	6898      	ldr	r0, [r3, #8]
   23e9c:	4770      	bx	lr
   23e9e:	bf00      	nop
   23ea0:	2000b5b4 	.word	0x2000b5b4

00023ea4 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
   23ea4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   23ea8:	4604      	mov	r4, r0
   23eaa:	f04f 0320 	mov.w	r3, #32
   23eae:	f3ef 8611 	mrs	r6, BASEPRI
   23eb2:	f383 8812 	msr	BASEPRI_MAX, r3
   23eb6:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
   23eba:	7b03      	ldrb	r3, [r0, #12]
   23ebc:	07d9      	lsls	r1, r3, #31
   23ebe:	d50b      	bpl.n	23ed8 <z_thread_abort+0x34>
	__asm__ volatile(
   23ec0:	f386 8811 	msr	BASEPRI, r6
   23ec4:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
   23ec8:	4040      	eors	r0, r0
   23eca:	f380 8811 	msr	BASEPRI, r0
   23ece:	f04f 0004 	mov.w	r0, #4
   23ed2:	df02      	svc	2
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
   23ed4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
   23ed8:	7b43      	ldrb	r3, [r0, #13]
   23eda:	071a      	lsls	r2, r3, #28
   23edc:	d504      	bpl.n	23ee8 <z_thread_abort+0x44>
   23ede:	f386 8811 	msr	BASEPRI, r6
   23ee2:	f3bf 8f6f 	isb	sy
   23ee6:	e7f5      	b.n	23ed4 <z_thread_abort+0x30>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   23ee8:	f023 0220 	bic.w	r2, r3, #32
   23eec:	f042 0108 	orr.w	r1, r2, #8
		if (z_is_thread_queued(thread)) {
   23ef0:	09d2      	lsrs	r2, r2, #7
   23ef2:	d120      	bne.n	23f36 <z_thread_abort+0x92>
		thread->base.thread_state &= ~_THREAD_ABORTING;
   23ef4:	7341      	strb	r1, [r0, #13]
		if (thread->base.pended_on != NULL) {
   23ef6:	68a3      	ldr	r3, [r4, #8]
   23ef8:	b113      	cbz	r3, 23f00 <z_thread_abort+0x5c>
			unpend_thread_no_timeout(thread);
   23efa:	4620      	mov	r0, r4
   23efc:	f001 ff64 	bl	25dc8 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
   23f00:	f104 0018 	add.w	r0, r4, #24
   23f04:	f002 f857 	bl	25fb6 <z_abort_timeout>
   23f08:	f04f 0800 	mov.w	r8, #0
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   23f0c:	f104 0758 	add.w	r7, r4, #88	; 0x58
	return list->head == list;
   23f10:	6da5      	ldr	r5, [r4, #88]	; 0x58
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23f12:	42bd      	cmp	r5, r7
   23f14:	d000      	beq.n	23f18 <z_thread_abort+0x74>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   23f16:	b9b5      	cbnz	r5, 23f46 <z_thread_abort+0xa2>
		update_cache(1);
   23f18:	2001      	movs	r0, #1
   23f1a:	f7ff fd1d 	bl	23958 <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
   23f1e:	4b10      	ldr	r3, [pc, #64]	; (23f60 <z_thread_abort+0xbc>)
   23f20:	689b      	ldr	r3, [r3, #8]
   23f22:	42a3      	cmp	r3, r4
   23f24:	d1db      	bne.n	23ede <z_thread_abort+0x3a>
   23f26:	f3ef 8305 	mrs	r3, IPSR
   23f2a:	2b00      	cmp	r3, #0
   23f2c:	d1d7      	bne.n	23ede <z_thread_abort+0x3a>
   23f2e:	4630      	mov	r0, r6
   23f30:	f7fa fa34 	bl	1e39c <arch_swap>
	return ret;
   23f34:	e7d3      	b.n	23ede <z_thread_abort+0x3a>
	thread->base.thread_state &= ~_THREAD_QUEUED;
   23f36:	f003 035f 	and.w	r3, r3, #95	; 0x5f
   23f3a:	f043 0308 	orr.w	r3, r3, #8
   23f3e:	7343      	strb	r3, [r0, #13]
	sys_dlist_remove(&thread->base.qnode_dlist);
   23f40:	f001 ff3a 	bl	25db8 <sys_dlist_remove>
}
   23f44:	e7d7      	b.n	23ef6 <z_thread_abort+0x52>
		unpend_thread_no_timeout(thread);
   23f46:	4628      	mov	r0, r5
   23f48:	f001 ff3e 	bl	25dc8 <unpend_thread_no_timeout>
   23f4c:	f105 0018 	add.w	r0, r5, #24
   23f50:	f002 f831 	bl	25fb6 <z_abort_timeout>
		ready_thread(thread);
   23f54:	4628      	mov	r0, r5
   23f56:	f8c5 8078 	str.w	r8, [r5, #120]	; 0x78
   23f5a:	f7ff fd55 	bl	23a08 <ready_thread>
   23f5e:	e7d7      	b.n	23f10 <z_thread_abort+0x6c>
   23f60:	2000b5b4 	.word	0x2000b5b4

00023f64 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
   23f64:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   23f66:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
{
   23f6a:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
   23f6c:	e9cd 6700 	strd	r6, r7, [sp]
   23f70:	f7ff fdde 	bl	23b30 <z_pend_curr>

	if (data != NULL) {
   23f74:	b11c      	cbz	r4, 23f7e <z_sched_wait+0x1a>
		*data = _current->base.swap_data;
   23f76:	4b03      	ldr	r3, [pc, #12]	; (23f84 <z_sched_wait+0x20>)
   23f78:	689b      	ldr	r3, [r3, #8]
   23f7a:	695b      	ldr	r3, [r3, #20]
   23f7c:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
   23f7e:	b002      	add	sp, #8
   23f80:	bdd0      	pop	{r4, r6, r7, pc}
   23f82:	bf00      	nop
   23f84:	2000b5b4 	.word	0x2000b5b4

00023f88 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
   23f88:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
   23f8a:	4806      	ldr	r0, [pc, #24]	; (23fa4 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
   23f8c:	4a06      	ldr	r2, [pc, #24]	; (23fa8 <z_data_copy+0x20>)
   23f8e:	4907      	ldr	r1, [pc, #28]	; (23fac <z_data_copy+0x24>)
   23f90:	1a12      	subs	r2, r2, r0
   23f92:	f001 fdbf 	bl	25b14 <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   23f96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
   23f9a:	4a05      	ldr	r2, [pc, #20]	; (23fb0 <z_data_copy+0x28>)
   23f9c:	4905      	ldr	r1, [pc, #20]	; (23fb4 <z_data_copy+0x2c>)
   23f9e:	4806      	ldr	r0, [pc, #24]	; (23fb8 <z_data_copy+0x30>)
   23fa0:	f001 bdb8 	b.w	25b14 <z_early_memcpy>
   23fa4:	2000a000 	.word	0x2000a000
   23fa8:	2000a410 	.word	0x2000a410
   23fac:	00026b9c 	.word	0x00026b9c
   23fb0:	00000000 	.word	0x00000000
   23fb4:	00026b9c 	.word	0x00026b9c
   23fb8:	2000a000 	.word	0x2000a000

00023fbc <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
   23fbc:	4b03      	ldr	r3, [pc, #12]	; (23fcc <elapsed+0x10>)
   23fbe:	681b      	ldr	r3, [r3, #0]
   23fc0:	b90b      	cbnz	r3, 23fc6 <elapsed+0xa>
   23fc2:	f7fc bc8d 	b.w	208e0 <sys_clock_elapsed>
}
   23fc6:	2000      	movs	r0, #0
   23fc8:	4770      	bx	lr
   23fca:	bf00      	nop
   23fcc:	2000b5ec 	.word	0x2000b5ec

00023fd0 <next_timeout>:

static int32_t next_timeout(void)
{
   23fd0:	b510      	push	{r4, lr}
	return list->head == list;
   23fd2:	4b0e      	ldr	r3, [pc, #56]	; (2400c <next_timeout+0x3c>)
   23fd4:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   23fd6:	429c      	cmp	r4, r3
   23fd8:	d104      	bne.n	23fe4 <next_timeout+0x14>
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
   23fda:	f7ff ffef 	bl	23fbc <elapsed>
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
   23fde:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
	}

	return ret;
}
   23fe2:	bd10      	pop	{r4, pc}
	int32_t ticks_elapsed = elapsed();
   23fe4:	f7ff ffea 	bl	23fbc <elapsed>
	if ((to == NULL) ||
   23fe8:	2c00      	cmp	r4, #0
   23fea:	d0f8      	beq.n	23fde <next_timeout+0xe>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
   23fec:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
   23ff0:	1a1b      	subs	r3, r3, r0
   23ff2:	eb62 72e0 	sbc.w	r2, r2, r0, asr #31
	if ((to == NULL) ||
   23ff6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   23ffa:	f172 0100 	sbcs.w	r1, r2, #0
   23ffe:	daee      	bge.n	23fde <next_timeout+0xe>
		ret = MAX(0, to->dticks - ticks_elapsed);
   24000:	2a00      	cmp	r2, #0
   24002:	bfac      	ite	ge
   24004:	4618      	movge	r0, r3
   24006:	2000      	movlt	r0, #0
	return ret;
   24008:	e7eb      	b.n	23fe2 <next_timeout+0x12>
   2400a:	bf00      	nop
   2400c:	2000a284 	.word	0x2000a284

00024010 <remove_timeout>:
{
   24010:	b530      	push	{r4, r5, lr}
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   24012:	b170      	cbz	r0, 24032 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
   24014:	4b0b      	ldr	r3, [pc, #44]	; (24044 <remove_timeout+0x34>)
   24016:	685b      	ldr	r3, [r3, #4]
   24018:	4298      	cmp	r0, r3
   2401a:	d00a      	beq.n	24032 <remove_timeout+0x22>
   2401c:	6803      	ldr	r3, [r0, #0]
	if (next(t) != NULL) {
   2401e:	b143      	cbz	r3, 24032 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
   24020:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
   24024:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
   24028:	1912      	adds	r2, r2, r4
   2402a:	eb41 0105 	adc.w	r1, r1, r5
   2402e:	e9c3 2104 	strd	r2, r1, [r3, #16]
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
	sys_dnode_t *const next = node->next;
   24032:	e9d0 3200 	ldrd	r3, r2, [r0]

	prev->next = next;
   24036:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   24038:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   2403a:	2300      	movs	r3, #0
	node->prev = NULL;
   2403c:	e9c0 3300 	strd	r3, r3, [r0]
}
   24040:	bd30      	pop	{r4, r5, pc}
   24042:	bf00      	nop
   24044:	2000a284 	.word	0x2000a284

00024048 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   24048:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2404c:	bf08      	it	eq
   2404e:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   24052:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   24054:	4604      	mov	r4, r0
   24056:	461d      	mov	r5, r3
   24058:	4616      	mov	r6, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2405a:	d05c      	beq.n	24116 <z_add_timeout+0xce>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   2405c:	6081      	str	r1, [r0, #8]
	__asm__ volatile(
   2405e:	f04f 0320 	mov.w	r3, #32
   24062:	f3ef 8711 	mrs	r7, BASEPRI
   24066:	f383 8812 	msr	BASEPRI_MAX, r3
   2406a:	f3bf 8f6f 	isb	sy

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
   2406e:	3201      	adds	r2, #1
   24070:	f175 33ff 	sbcs.w	r3, r5, #4294967295	; 0xffffffff
   24074:	da24      	bge.n	240c0 <z_add_timeout+0x78>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
   24076:	f06f 0301 	mvn.w	r3, #1
   2407a:	492c      	ldr	r1, [pc, #176]	; (2412c <z_add_timeout+0xe4>)
   2407c:	e9d1 2000 	ldrd	r2, r0, [r1]
   24080:	1a9b      	subs	r3, r3, r2
   24082:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   24086:	eb62 0000 	sbc.w	r0, r2, r0
   2408a:	1b9e      	subs	r6, r3, r6
   2408c:	eb60 0005 	sbc.w	r0, r0, r5

			to->dticks = MAX(1, ticks);
   24090:	2e01      	cmp	r6, #1
   24092:	f170 0300 	sbcs.w	r3, r0, #0
   24096:	da01      	bge.n	2409c <z_add_timeout+0x54>
   24098:	2601      	movs	r6, #1
   2409a:	2000      	movs	r0, #0
   2409c:	e9c4 6004 	strd	r6, r0, [r4, #16]
	return list->head == list;
   240a0:	4e23      	ldr	r6, [pc, #140]	; (24130 <z_add_timeout+0xe8>)
   240a2:	f8d6 c000 	ldr.w	ip, [r6]
	return (node == list->tail) ? NULL : node->next;
   240a6:	6875      	ldr	r5, [r6, #4]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   240a8:	45b4      	cmp	ip, r6
   240aa:	bf08      	it	eq
   240ac:	f04f 0c00 	moveq.w	ip, #0
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
		}

		for (t = first(); t != NULL; t = next(t)) {
   240b0:	f1bc 0f00 	cmp.w	ip, #0
   240b4:	d10d      	bne.n	240d2 <z_add_timeout+0x8a>
	node->prev = tail;
   240b6:	e9c4 6500 	strd	r6, r5, [r4]
	tail->next = node;
   240ba:	602c      	str	r4, [r5, #0]
	list->tail = node;
   240bc:	6074      	str	r4, [r6, #4]
}
   240be:	e01c      	b.n	240fa <z_add_timeout+0xb2>
			to->dticks = timeout.ticks + 1 + elapsed();
   240c0:	f7ff ff7c 	bl	23fbc <elapsed>
   240c4:	3601      	adds	r6, #1
   240c6:	f145 0500 	adc.w	r5, r5, #0
   240ca:	1836      	adds	r6, r6, r0
   240cc:	eb45 70e0 	adc.w	r0, r5, r0, asr #31
   240d0:	e7e4      	b.n	2409c <z_add_timeout+0x54>
			if (t->dticks > to->dticks) {
   240d2:	e9dc 2004 	ldrd	r2, r0, [ip, #16]
   240d6:	e9d4 3104 	ldrd	r3, r1, [r4, #16]
   240da:	4293      	cmp	r3, r2
   240dc:	eb71 0e00 	sbcs.w	lr, r1, r0
   240e0:	da1a      	bge.n	24118 <z_add_timeout+0xd0>
				t->dticks -= to->dticks;
   240e2:	1ad2      	subs	r2, r2, r3
	sys_dnode_t *const prev = successor->prev;
   240e4:	f8dc 3004 	ldr.w	r3, [ip, #4]
   240e8:	eb60 0001 	sbc.w	r0, r0, r1
   240ec:	e9cc 2004 	strd	r2, r0, [ip, #16]
	node->next = successor;
   240f0:	e9c4 c300 	strd	ip, r3, [r4]
	prev->next = node;
   240f4:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   240f6:	f8cc 4004 	str.w	r4, [ip, #4]
	return list->head == list;
   240fa:	6833      	ldr	r3, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   240fc:	42b3      	cmp	r3, r6
   240fe:	d006      	beq.n	2410e <z_add_timeout+0xc6>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   24100:	429c      	cmp	r4, r3
   24102:	d104      	bne.n	2410e <z_add_timeout+0xc6>
			sys_clock_set_timeout(next_timeout(), false);
   24104:	f7ff ff64 	bl	23fd0 <next_timeout>
   24108:	2100      	movs	r1, #0
   2410a:	f7fc fbb7 	bl	2087c <sys_clock_set_timeout>
	__asm__ volatile(
   2410e:	f387 8811 	msr	BASEPRI, r7
   24112:	f3bf 8f6f 	isb	sy
		}
	}
}
   24116:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			to->dticks -= t->dticks;
   24118:	1a9b      	subs	r3, r3, r2
   2411a:	eb61 0100 	sbc.w	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   2411e:	45ac      	cmp	ip, r5
   24120:	e9c4 3104 	strd	r3, r1, [r4, #16]
   24124:	d0c7      	beq.n	240b6 <z_add_timeout+0x6e>
   24126:	f8dc c000 	ldr.w	ip, [ip]
   2412a:	e7c1      	b.n	240b0 <z_add_timeout+0x68>
   2412c:	2000a688 	.word	0x2000a688
   24130:	2000a284 	.word	0x2000a284

00024134 <sys_clock_announce>:
	}
	return ret;
}

void sys_clock_announce(int32_t ticks)
{
   24134:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	__asm__ volatile(
   24138:	f04f 0320 	mov.w	r3, #32
   2413c:	f3ef 8c11 	mrs	ip, BASEPRI
   24140:	f383 8812 	msr	BASEPRI_MAX, r3
   24144:	f3bf 8f6f 	isb	sy
	return list->head == list;
   24148:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 241fc <sys_clock_announce+0xc8>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
   2414c:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 24200 <sys_clock_announce+0xcc>
	     (t != NULL) && (t->dticks <= announce_remaining);
	     t = first()) {
		int dt = t->dticks;

		curr_tick += dt;
		t->dticks = 0;
   24150:	2400      	movs	r4, #0
	announce_remaining = ticks;
   24152:	f8c9 0000 	str.w	r0, [r9]
   24156:	f8da 0000 	ldr.w	r0, [sl]
		t->dticks = 0;
   2415a:	2500      	movs	r5, #0
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2415c:	4550      	cmp	r0, sl
   2415e:	bf08      	it	eq
   24160:	2000      	moveq	r0, #0
		curr_tick += dt;
   24162:	4f28      	ldr	r7, [pc, #160]	; (24204 <sys_clock_announce+0xd0>)
   24164:	46e0      	mov	r8, ip
   24166:	e9d7 2100 	ldrd	r2, r1, [r7]
	     (t != NULL) && (t->dticks <= announce_remaining);
   2416a:	f8d9 3000 	ldr.w	r3, [r9]
   2416e:	b380      	cbz	r0, 241d2 <sys_clock_announce+0x9e>
   24170:	e9d0 6c04 	ldrd	r6, ip, [r0, #16]
   24174:	ea4f 7ee3 	mov.w	lr, r3, asr #31
   24178:	42b3      	cmp	r3, r6
   2417a:	eb7e 0b0c 	sbcs.w	fp, lr, ip
   2417e:	da05      	bge.n	2418c <sys_clock_announce+0x58>
		key = k_spin_lock(&timeout_lock);
		announce_remaining -= dt;
	}

	if (t != NULL) {
		t->dticks -= announce_remaining;
   24180:	1af6      	subs	r6, r6, r3
   24182:	eb6c 040e 	sbc.w	r4, ip, lr
   24186:	e9c0 6404 	strd	r6, r4, [r0, #16]
   2418a:	e022      	b.n	241d2 <sys_clock_announce+0x9e>
		curr_tick += dt;
   2418c:	18b2      	adds	r2, r6, r2
   2418e:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
		t->dticks = 0;
   24192:	e9c0 4504 	strd	r4, r5, [r0, #16]
		curr_tick += dt;
   24196:	e9c7 2100 	strd	r2, r1, [r7]
		remove_timeout(t);
   2419a:	f7ff ff39 	bl	24010 <remove_timeout>
	__asm__ volatile(
   2419e:	f388 8811 	msr	BASEPRI, r8
   241a2:	f3bf 8f6f 	isb	sy
		t->fn(t);
   241a6:	6883      	ldr	r3, [r0, #8]
   241a8:	4798      	blx	r3
	__asm__ volatile(
   241aa:	f04f 0320 	mov.w	r3, #32
   241ae:	f3ef 8811 	mrs	r8, BASEPRI
   241b2:	f383 8812 	msr	BASEPRI_MAX, r3
   241b6:	f3bf 8f6f 	isb	sy
		announce_remaining -= dt;
   241ba:	f8d9 3000 	ldr.w	r3, [r9]
	return list->head == list;
   241be:	f8da 0000 	ldr.w	r0, [sl]
   241c2:	1b9b      	subs	r3, r3, r6
	return sys_dlist_is_empty(list) ? NULL : list->head;
   241c4:	4550      	cmp	r0, sl
	k.key = arch_irq_lock();
   241c6:	46c4      	mov	ip, r8
   241c8:	f8c9 3000 	str.w	r3, [r9]
   241cc:	d1ca      	bne.n	24164 <sys_clock_announce+0x30>
		curr_tick += dt;
   241ce:	e9d7 2100 	ldrd	r2, r1, [r7]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   241d2:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   241d4:	189a      	adds	r2, r3, r2
   241d6:	eb41 73e3 	adc.w	r3, r1, r3, asr #31
   241da:	e9c7 2300 	strd	r2, r3, [r7]
	announce_remaining = 0;
   241de:	f8c9 4000 	str.w	r4, [r9]

	sys_clock_set_timeout(next_timeout(), false);
   241e2:	f7ff fef5 	bl	23fd0 <next_timeout>
   241e6:	4621      	mov	r1, r4
   241e8:	f7fc fb48 	bl	2087c <sys_clock_set_timeout>
	__asm__ volatile(
   241ec:	f388 8811 	msr	BASEPRI, r8
   241f0:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&timeout_lock, key);

#ifdef CONFIG_TIMESLICING
	z_time_slice();
#endif
}
   241f4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	z_time_slice();
   241f8:	f7ff bc6a 	b.w	23ad0 <z_time_slice>
   241fc:	2000a284 	.word	0x2000a284
   24200:	2000b5ec 	.word	0x2000b5ec
   24204:	2000a688 	.word	0x2000a688

00024208 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
   24208:	b510      	push	{r4, lr}
	__asm__ volatile(
   2420a:	f04f 0320 	mov.w	r3, #32
   2420e:	f3ef 8411 	mrs	r4, BASEPRI
   24212:	f383 8812 	msr	BASEPRI_MAX, r3
   24216:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + elapsed();
   2421a:	f7ff fecf 	bl	23fbc <elapsed>
   2421e:	4603      	mov	r3, r0
   24220:	4a05      	ldr	r2, [pc, #20]	; (24238 <sys_clock_tick_get+0x30>)
   24222:	e9d2 0100 	ldrd	r0, r1, [r2]
   24226:	1818      	adds	r0, r3, r0
   24228:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
	__asm__ volatile(
   2422c:	f384 8811 	msr	BASEPRI, r4
   24230:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   24234:	bd10      	pop	{r4, pc}
   24236:	bf00      	nop
   24238:	2000a688 	.word	0x2000a688

0002423c <z_timer_expiration_handler>:
 * @brief Handle expiration of a kernel timer object.
 *
 * @param t  Timeout used by the timer.
 */
void z_timer_expiration_handler(struct _timeout *t)
{
   2423c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2423e:	4604      	mov	r4, r0
	__asm__ volatile(
   24240:	f04f 0320 	mov.w	r3, #32
   24244:	f3ef 8711 	mrs	r7, BASEPRI
   24248:	f383 8812 	msr	BASEPRI_MAX, r3
   2424c:	f3bf 8f6f 	isb	sy
	 * interrupt. Then, the timeout structure for this timer will turn out
	 * to be linked to the timeout list. And in such case, since the timer
	 * was restarted, its expiration handler should not be executed then,
	 * so the function exits immediately.
	 */
	if (sys_dnode_is_linked(&t->node)) {
   24250:	6802      	ldr	r2, [r0, #0]
   24252:	b122      	cbz	r2, 2425e <z_timer_expiration_handler+0x22>
	__asm__ volatile(
   24254:	f387 8811 	msr	BASEPRI, r7
   24258:	f3bf 8f6f 	isb	sy
	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
}
   2425c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   2425e:	e9d0 360a 	ldrd	r3, r6, [r0, #40]	; 0x28
   24262:	1c58      	adds	r0, r3, #1
   24264:	f146 0100 	adc.w	r1, r6, #0
   24268:	2802      	cmp	r0, #2
   2426a:	f171 0100 	sbcs.w	r1, r1, #0
   2426e:	d327      	bcc.n	242c0 <z_timer_expiration_handler+0x84>
		next.ticks = MAX(next.ticks - 1, 0);
   24270:	2b01      	cmp	r3, #1
   24272:	f176 0100 	sbcs.w	r1, r6, #0
   24276:	bfbc      	itt	lt
   24278:	2301      	movlt	r3, #1
   2427a:	4616      	movlt	r6, r2
   2427c:	1e5d      	subs	r5, r3, #1
   2427e:	f146 36ff 	adc.w	r6, r6, #4294967295	; 0xffffffff
	return z_impl_k_uptime_ticks();
   24282:	f001 fec2 	bl	2600a <z_impl_k_uptime_ticks>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
   24286:	3001      	adds	r0, #1
   24288:	f141 0100 	adc.w	r1, r1, #0
   2428c:	1940      	adds	r0, r0, r5
   2428e:	eb46 0101 	adc.w	r1, r6, r1
   24292:	2801      	cmp	r0, #1
   24294:	f171 0100 	sbcs.w	r1, r1, #0
   24298:	db3a      	blt.n	24310 <z_timer_expiration_handler+0xd4>
   2429a:	f001 feb6 	bl	2600a <z_impl_k_uptime_ticks>
   2429e:	3001      	adds	r0, #1
   242a0:	f141 0100 	adc.w	r1, r1, #0
   242a4:	f06f 0201 	mvn.w	r2, #1
   242a8:	1940      	adds	r0, r0, r5
   242aa:	eb46 0301 	adc.w	r3, r6, r1
   242ae:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   242b2:	1a12      	subs	r2, r2, r0
   242b4:	eb61 0303 	sbc.w	r3, r1, r3
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   242b8:	4620      	mov	r0, r4
   242ba:	4918      	ldr	r1, [pc, #96]	; (2431c <z_timer_expiration_handler+0xe0>)
   242bc:	f7ff fec4 	bl	24048 <z_add_timeout>
	timer->status += 1U;
   242c0:	6b23      	ldr	r3, [r4, #48]	; 0x30
   242c2:	3301      	adds	r3, #1
   242c4:	6323      	str	r3, [r4, #48]	; 0x30
	if (timer->expiry_fn != NULL) {
   242c6:	6a23      	ldr	r3, [r4, #32]
   242c8:	b173      	cbz	r3, 242e8 <z_timer_expiration_handler+0xac>
   242ca:	f387 8811 	msr	BASEPRI, r7
   242ce:	f3bf 8f6f 	isb	sy
		timer->expiry_fn(timer);
   242d2:	4620      	mov	r0, r4
   242d4:	6a23      	ldr	r3, [r4, #32]
   242d6:	4798      	blx	r3
	__asm__ volatile(
   242d8:	f04f 0320 	mov.w	r3, #32
   242dc:	f3ef 8711 	mrs	r7, BASEPRI
   242e0:	f383 8812 	msr	BASEPRI_MAX, r3
   242e4:	f3bf 8f6f 	isb	sy
	return list->head == list;
   242e8:	f854 5f18 	ldr.w	r5, [r4, #24]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   242ec:	42a5      	cmp	r5, r4
   242ee:	d0b1      	beq.n	24254 <z_timer_expiration_handler+0x18>
	if (thread == NULL) {
   242f0:	2d00      	cmp	r5, #0
   242f2:	d0af      	beq.n	24254 <z_timer_expiration_handler+0x18>
	z_unpend_thread_no_timeout(thread);
   242f4:	4628      	mov	r0, r5
   242f6:	f001 fda9 	bl	25e4c <z_unpend_thread_no_timeout>
   242fa:	2300      	movs	r3, #0
   242fc:	67ab      	str	r3, [r5, #120]	; 0x78
	__asm__ volatile(
   242fe:	f387 8811 	msr	BASEPRI, r7
   24302:	f3bf 8f6f 	isb	sy
	z_ready_thread(thread);
   24306:	4628      	mov	r0, r5
}
   24308:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_ready_thread(thread);
   2430c:	f001 bd8e 	b.w	25e2c <z_ready_thread>
		next = K_TIMEOUT_ABS_TICKS(k_uptime_ticks() + 1 + next.ticks);
   24310:	f06f 0201 	mvn.w	r2, #1
   24314:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24318:	e7ce      	b.n	242b8 <z_timer_expiration_handler+0x7c>
   2431a:	bf00      	nop
   2431c:	0002423d 	.word	0x0002423d

00024320 <z_impl_k_timer_start>:
void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer, duration, period);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   24320:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   24324:	bf08      	it	eq
   24326:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
{
   2432a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2432e:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
   24332:	4605      	mov	r5, r0
   24334:	461c      	mov	r4, r3
   24336:	4691      	mov	r9, r2
   24338:	4698      	mov	r8, r3
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
   2433a:	d01c      	beq.n	24376 <z_impl_k_timer_start+0x56>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (Z_TICK_ABS(duration.ticks) < 0) {
   2433c:	1c53      	adds	r3, r2, #1
   2433e:	f174 33ff 	sbcs.w	r3, r4, #4294967295	; 0xffffffff
   24342:	db09      	blt.n	24358 <z_impl_k_timer_start+0x38>
		duration.ticks = MAX(duration.ticks - 1, 0);
   24344:	2a01      	cmp	r2, #1
   24346:	f174 0300 	sbcs.w	r3, r4, #0
   2434a:	bfbc      	itt	lt
   2434c:	2201      	movlt	r2, #1
   2434e:	2400      	movlt	r4, #0
   24350:	f112 39ff 	adds.w	r9, r2, #4294967295	; 0xffffffff
   24354:	f144 38ff 	adc.w	r8, r4, #4294967295	; 0xffffffff
	}

	(void)z_abort_timeout(&timer->timeout);
   24358:	4628      	mov	r0, r5
   2435a:	f001 fe2c 	bl	25fb6 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   2435e:	2300      	movs	r3, #0
	timer->period = period;
   24360:	e9c5 670a 	strd	r6, r7, [r5, #40]	; 0x28
	timer->status = 0U;
   24364:	632b      	str	r3, [r5, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   24366:	464a      	mov	r2, r9
   24368:	4643      	mov	r3, r8
   2436a:	4628      	mov	r0, r5
		     duration);
}
   2436c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   24370:	4902      	ldr	r1, [pc, #8]	; (2437c <z_impl_k_timer_start+0x5c>)
   24372:	f7ff be69 	b.w	24048 <z_add_timeout>
}
   24376:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2437a:	bf00      	nop
   2437c:	0002423d 	.word	0x0002423d

00024380 <z_thread_aligned_alloc>:
#else
#define _SYSTEM_HEAP	NULL
#endif

void *z_thread_aligned_alloc(size_t align, size_t size)
{
   24380:	b573      	push	{r0, r1, r4, r5, r6, lr}
   24382:	4606      	mov	r6, r0
   24384:	460d      	mov	r5, r1
	void *ret;
	struct k_heap *heap;

	if (k_is_in_isr()) {
   24386:	f001 fc06 	bl	25b96 <k_is_in_isr>
   2438a:	b978      	cbnz	r0, 243ac <z_thread_aligned_alloc+0x2c>
		heap = _SYSTEM_HEAP;
	} else {
		heap = _current->resource_pool;
   2438c:	4b0b      	ldr	r3, [pc, #44]	; (243bc <z_thread_aligned_alloc+0x3c>)
   2438e:	689b      	ldr	r3, [r3, #8]
   24390:	6f1c      	ldr	r4, [r3, #112]	; 0x70
	}

	if (heap != NULL) {
   24392:	b17c      	cbz	r4, 243b4 <z_thread_aligned_alloc+0x34>
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   24394:	1d2a      	adds	r2, r5, #4
   24396:	d209      	bcs.n	243ac <z_thread_aligned_alloc+0x2c>
	mem = k_heap_aligned_alloc(heap, __align, size, K_NO_WAIT);
   24398:	2000      	movs	r0, #0
   2439a:	2100      	movs	r1, #0
   2439c:	e9cd 0100 	strd	r0, r1, [sp]
   243a0:	4620      	mov	r0, r4
   243a2:	f046 0104 	orr.w	r1, r6, #4
   243a6:	f001 fe67 	bl	26078 <k_heap_aligned_alloc>
	if (mem == NULL) {
   243aa:	b908      	cbnz	r0, 243b0 <z_thread_aligned_alloc+0x30>
		ret = z_heap_aligned_alloc(heap, align, size);
	} else {
		ret = NULL;
   243ac:	2400      	movs	r4, #0
	}

	return ret;
   243ae:	e001      	b.n	243b4 <z_thread_aligned_alloc+0x34>
	*heap_ref = heap;
   243b0:	6004      	str	r4, [r0, #0]
	mem = ++heap_ref;
   243b2:	1d04      	adds	r4, r0, #4
}
   243b4:	4620      	mov	r0, r4
   243b6:	b002      	add	sp, #8
   243b8:	bd70      	pop	{r4, r5, r6, pc}
   243ba:	bf00      	nop
   243bc:	2000b5b4 	.word	0x2000b5b4

000243c0 <boot_banner>:
	printk("***** delaying boot " DELAY_STR "ms (per build configuration) *****\n");
	k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
#endif /* defined(CONFIG_BOOT_DELAY) && (CONFIG_BOOT_DELAY > 0) */

#if CONFIG_BOOT_BANNER
	printk("*** Booting Zephyr OS build " BANNER_VERSION BANNER_POSTFIX " ***\n");
   243c0:	4801      	ldr	r0, [pc, #4]	; (243c8 <boot_banner+0x8>)
   243c2:	f000 b850 	b.w	24466 <printk>
   243c6:	bf00      	nop
   243c8:	00026b62 	.word	0x00026b62

000243cc <statics_init>:

	SYS_PORT_TRACING_OBJ_INIT(k_heap, h);
}

static int statics_init(void)
{
   243cc:	b538      	push	{r3, r4, r5, lr}
	STRUCT_SECTION_FOREACH(k_heap, h) {
   243ce:	4c06      	ldr	r4, [pc, #24]	; (243e8 <statics_init+0x1c>)
   243d0:	4d06      	ldr	r5, [pc, #24]	; (243ec <statics_init+0x20>)
   243d2:	42ac      	cmp	r4, r5
   243d4:	d301      	bcc.n	243da <statics_init+0xe>
		{
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
		}
	}
	return 0;
}
   243d6:	2000      	movs	r0, #0
   243d8:	bd38      	pop	{r3, r4, r5, pc}
			k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   243da:	4620      	mov	r0, r4
   243dc:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   243e0:	f001 fe42 	bl	26068 <k_heap_init>
	STRUCT_SECTION_FOREACH(k_heap, h) {
   243e4:	3414      	adds	r4, #20
   243e6:	e7f4      	b.n	243d2 <statics_init+0x6>
   243e8:	2000a2f4 	.word	0x2000a2f4
   243ec:	2000a2f4 	.word	0x2000a2f4

000243f0 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(void)
{
   243f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_work_queue_config cfg = {
   243f2:	2400      	movs	r4, #0
   243f4:	4b08      	ldr	r3, [pc, #32]	; (24418 <k_sys_work_q_init+0x28>)
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
   243f6:	f44f 6280 	mov.w	r2, #1024	; 0x400
	struct k_work_queue_config cfg = {
   243fa:	9302      	str	r3, [sp, #8]
	k_work_queue_start(&k_sys_work_q,
   243fc:	ab02      	add	r3, sp, #8
   243fe:	9300      	str	r3, [sp, #0]
   24400:	4906      	ldr	r1, [pc, #24]	; (2441c <k_sys_work_q_init+0x2c>)
   24402:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   24406:	4806      	ldr	r0, [pc, #24]	; (24420 <k_sys_work_q_init+0x30>)
	struct k_work_queue_config cfg = {
   24408:	f88d 400c 	strb.w	r4, [sp, #12]
	k_work_queue_start(&k_sys_work_q,
   2440c:	f7ff f9ec 	bl	237e8 <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
   24410:	4620      	mov	r0, r4
   24412:	b004      	add	sp, #16
   24414:	bd10      	pop	{r4, pc}
   24416:	bf00      	nop
   24418:	00026b92 	.word	0x00026b92
   2441c:	2000cb70 	.word	0x2000cb70
   24420:	2000a690 	.word	0x2000a690

00024424 <gpio_pin_configure_dt>:
{
   24424:	4603      	mov	r3, r0
   24426:	460a      	mov	r2, r1
   24428:	b4f0      	push	{r4, r5, r6, r7}
				  spec->pin,
   2442a:	7919      	ldrb	r1, [r3, #4]
				  spec->dt_flags | extra_flags);
   2442c:	88db      	ldrh	r3, [r3, #6]
	return gpio_pin_configure(spec->port,
   2442e:	6800      	ldr	r0, [r0, #0]
   24430:	4313      	orrs	r3, r2
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   24432:	02dc      	lsls	r4, r3, #11
	const struct gpio_driver_api *api =
   24434:	6887      	ldr	r7, [r0, #8]
	struct gpio_driver_data *data =
   24436:	6906      	ldr	r6, [r0, #16]
	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
   24438:	d506      	bpl.n	24448 <gpio_pin_configure_dt+0x24>
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
   2443a:	f413 2f40 	tst.w	r3, #786432	; 0xc0000
   2443e:	d003      	beq.n	24448 <gpio_pin_configure_dt+0x24>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   24440:	07da      	lsls	r2, r3, #31
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   24442:	bf48      	it	mi
   24444:	f483 2340 	eormi.w	r3, r3, #786432	; 0xc0000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   24448:	2501      	movs	r5, #1
   2444a:	6834      	ldr	r4, [r6, #0]
   2444c:	408d      	lsls	r5, r1
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   2444e:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   24452:	07db      	lsls	r3, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   24454:	bf4c      	ite	mi
   24456:	432c      	orrmi	r4, r5
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   24458:	43ac      	bicpl	r4, r5
   2445a:	6034      	str	r4, [r6, #0]
	return api->pin_configure(port, pin, flags);
   2445c:	683b      	ldr	r3, [r7, #0]
}
   2445e:	bcf0      	pop	{r4, r5, r6, r7}
	return api->pin_configure(port, pin, flags);
   24460:	4718      	bx	r3

00024462 <arch_printk_char_out>:
}
   24462:	2000      	movs	r0, #0
   24464:	4770      	bx	lr

00024466 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
   24466:	b40f      	push	{r0, r1, r2, r3}
   24468:	b507      	push	{r0, r1, r2, lr}
   2446a:	a904      	add	r1, sp, #16
   2446c:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
   24470:	9101      	str	r1, [sp, #4]

	vprintk(fmt, ap);
   24472:	f7f8 f82b 	bl	1c4cc <vprintk>

	va_end(ap);
}
   24476:	b003      	add	sp, #12
   24478:	f85d eb04 	ldr.w	lr, [sp], #4
   2447c:	b004      	add	sp, #16
   2447e:	4770      	bx	lr

00024480 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   24480:	4604      	mov	r4, r0
   24482:	b508      	push	{r3, lr}
   24484:	4608      	mov	r0, r1
   24486:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
   24488:	461a      	mov	r2, r3
   2448a:	47a0      	blx	r4
	return z_impl_z_current_get();
   2448c:	f7ff fd04 	bl	23e98 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
   24490:	f7fa fa0c 	bl	1e8ac <z_impl_k_thread_abort>

00024494 <chunk_size>:
	void *cmem = &buf[c];

	if (big_heap(h)) {
		return ((uint32_t *)cmem)[f];
	} else {
		return ((uint16_t *)cmem)[f];
   24494:	eb00 00c1 	add.w	r0, r0, r1, lsl #3
   24498:	8840      	ldrh	r0, [r0, #2]
}

static inline chunksz_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
}
   2449a:	0840      	lsrs	r0, r0, #1
   2449c:	4770      	bx	lr

0002449e <free_list_add>:
	h->free_bytes += chunksz_to_bytes(h, chunk_size(h, c));
#endif
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   2449e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   244a0:	4603      	mov	r3, r0
	if (!solo_free_header(h, c)) {
		int bidx = bucket_idx(h, chunk_size(h, c));
   244a2:	f7ff fff7 	bl	24494 <chunk_size>
}

static inline int bucket_idx(struct z_heap *h, chunksz_t sz)
{
	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
	return 31 - __builtin_clz(usable_sz);
   244a6:	fab0 f080 	clz	r0, r0
   244aa:	f1c0 001f 	rsb	r0, r0, #31
	if (b->next == 0U) {
   244ae:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   244b2:	f8dc 6010 	ldr.w	r6, [ip, #16]
	void *cmem = &buf[c];
   244b6:	00ca      	lsls	r2, r1, #3
		((uint16_t *)cmem)[f] = val;
   244b8:	1d17      	adds	r7, r2, #4
{
   244ba:	460c      	mov	r4, r1
   244bc:	3206      	adds	r2, #6
   244be:	b28d      	uxth	r5, r1
	if (b->next == 0U) {
   244c0:	b956      	cbnz	r6, 244d8 <free_list_add+0x3a>
		h->avail_buckets |= BIT(bidx);
   244c2:	2101      	movs	r1, #1
   244c4:	fa01 f000 	lsl.w	r0, r1, r0
   244c8:	68d9      	ldr	r1, [r3, #12]
   244ca:	4301      	orrs	r1, r0
   244cc:	60d9      	str	r1, [r3, #12]
		b->next = c;
   244ce:	f8cc 4010 	str.w	r4, [ip, #16]
   244d2:	53dd      	strh	r5, [r3, r7]
   244d4:	529d      	strh	r5, [r3, r2]
		free_list_add_bidx(h, c, bidx);
	}
}
   244d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	void *cmem = &buf[c];
   244d8:	00f1      	lsls	r1, r6, #3
		return ((uint16_t *)cmem)[f];
   244da:	3104      	adds	r1, #4
   244dc:	5a58      	ldrh	r0, [r3, r1]
		((uint16_t *)cmem)[f] = val;
   244de:	53d8      	strh	r0, [r3, r7]
   244e0:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
   244e4:	529e      	strh	r6, [r3, r2]
   244e6:	80c5      	strh	r5, [r0, #6]
   244e8:	525d      	strh	r5, [r3, r1]
   244ea:	e7f4      	b.n	244d6 <free_list_add+0x38>

000244ec <free_list_remove_bidx>:
{
   244ec:	b510      	push	{r4, lr}
		return ((uint16_t *)cmem)[f];
   244ee:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   244f2:	88e3      	ldrh	r3, [r4, #6]
	if (next_free_chunk(h, c) == c) {
   244f4:	4299      	cmp	r1, r3
   244f6:	f102 0104 	add.w	r1, r2, #4
   244fa:	d10a      	bne.n	24512 <free_list_remove_bidx+0x26>
		h->avail_buckets &= ~BIT(bidx);
   244fc:	2301      	movs	r3, #1
   244fe:	fa03 f202 	lsl.w	r2, r3, r2
   24502:	68c3      	ldr	r3, [r0, #12]
   24504:	ea23 0302 	bic.w	r3, r3, r2
   24508:	60c3      	str	r3, [r0, #12]
		b->next = 0;
   2450a:	2300      	movs	r3, #0
   2450c:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
}
   24510:	bd10      	pop	{r4, pc}
   24512:	88a2      	ldrh	r2, [r4, #4]
		b->next = second;
   24514:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		((uint16_t *)cmem)[f] = val;
   24518:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
   2451c:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   24520:	80cb      	strh	r3, [r1, #6]
   24522:	8082      	strh	r2, [r0, #4]
}
   24524:	e7f4      	b.n	24510 <free_list_remove_bidx+0x24>

00024526 <free_list_remove>:
{
   24526:	b508      	push	{r3, lr}
   24528:	4603      	mov	r3, r0
		int bidx = bucket_idx(h, chunk_size(h, c));
   2452a:	f7ff ffb3 	bl	24494 <chunk_size>
	return 31 - __builtin_clz(usable_sz);
   2452e:	fab0 f280 	clz	r2, r0
		free_list_remove_bidx(h, c, bidx);
   24532:	4618      	mov	r0, r3
}
   24534:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		free_list_remove_bidx(h, c, bidx);
   24538:	f1c2 021f 	rsb	r2, r2, #31
   2453c:	f7ff bfd6 	b.w	244ec <free_list_remove_bidx>

00024540 <alloc_chunk>:

	return chunk_sz - (addr - chunk_base);
}

static chunkid_t alloc_chunk(struct z_heap *h, chunksz_t sz)
{
   24540:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   24544:	fab1 f581 	clz	r5, r1
   24548:	f1c5 091f 	rsb	r9, r5, #31
	 * course.  But even in pathological situations we still
	 * maintain our constant time performance and at worst see
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	if (b->next) {
   2454c:	eb00 0889 	add.w	r8, r0, r9, lsl #2
   24550:	f8d8 2010 	ldr.w	r2, [r8, #16]
{
   24554:	4603      	mov	r3, r0
   24556:	460e      	mov	r6, r1
	if (b->next) {
   24558:	b1c2      	cbz	r2, 2458c <alloc_chunk+0x4c>
   2455a:	2703      	movs	r7, #3
		chunkid_t first = b->next;
		int i = CONFIG_SYS_HEAP_ALLOC_LOOPS;
		do {
			chunkid_t c = b->next;
   2455c:	f8d8 4010 	ldr.w	r4, [r8, #16]
			if (chunk_size(h, c) >= sz) {
   24560:	4618      	mov	r0, r3
   24562:	4621      	mov	r1, r4
   24564:	f7ff ff96 	bl	24494 <chunk_size>
   24568:	42b0      	cmp	r0, r6
   2456a:	d306      	bcc.n	2457a <alloc_chunk+0x3a>
				free_list_remove_bidx(h, c, bi);
   2456c:	464a      	mov	r2, r9

	if (bmask != 0U) {
		int minbucket = __builtin_ctz(bmask);
		chunkid_t c = h->buckets[minbucket].next;

		free_list_remove_bidx(h, c, minbucket);
   2456e:	4618      	mov	r0, r3
   24570:	f7ff ffbc 	bl	244ec <free_list_remove_bidx>
		CHECK(chunk_size(h, c) >= sz);
		return c;
	}

	return 0;
}
   24574:	4620      	mov	r0, r4
   24576:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ((uint16_t *)cmem)[f];
   2457a:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   2457e:	88e0      	ldrh	r0, [r4, #6]
		} while (--i && b->next != first);
   24580:	3f01      	subs	r7, #1
			b->next = next_free_chunk(h, c);
   24582:	f8c8 0010 	str.w	r0, [r8, #16]
		} while (--i && b->next != first);
   24586:	d001      	beq.n	2458c <alloc_chunk+0x4c>
   24588:	4282      	cmp	r2, r0
   2458a:	d1e7      	bne.n	2455c <alloc_chunk+0x1c>
	uint32_t bmask = h->avail_buckets & ~BIT_MASK(bi + 1);
   2458c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   24590:	f1c5 0220 	rsb	r2, r5, #32
   24594:	4094      	lsls	r4, r2
   24596:	68da      	ldr	r2, [r3, #12]
	if (bmask != 0U) {
   24598:	4014      	ands	r4, r2
   2459a:	d0eb      	beq.n	24574 <alloc_chunk+0x34>
		int minbucket = __builtin_ctz(bmask);
   2459c:	fa94 f2a4 	rbit	r2, r4
   245a0:	fab2 f282 	clz	r2, r2
		chunkid_t c = h->buckets[minbucket].next;
   245a4:	1d11      	adds	r1, r2, #4
   245a6:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
		free_list_remove_bidx(h, c, minbucket);
   245aa:	4621      	mov	r1, r4
   245ac:	e7df      	b.n	2456e <alloc_chunk+0x2e>

000245ae <merge_chunks>:
{
   245ae:	b538      	push	{r3, r4, r5, lr}
   245b0:	4603      	mov	r3, r0
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   245b2:	f7ff ff6f 	bl	24494 <chunk_size>
{
   245b6:	460d      	mov	r5, r1
	chunksz_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
   245b8:	4604      	mov	r4, r0
   245ba:	4611      	mov	r1, r2
   245bc:	4618      	mov	r0, r3
   245be:	f7ff ff69 	bl	24494 <chunk_size>
   245c2:	4404      	add	r4, r0
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   245c4:	0060      	lsls	r0, r4, #1
		((uint16_t *)cmem)[f] = val;
   245c6:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
   245ca:	8068      	strh	r0, [r5, #2]
	return c + chunk_size(h, c);
   245cc:	4618      	mov	r0, r3
   245ce:	f7ff ff61 	bl	24494 <chunk_size>
	void *cmem = &buf[c];
   245d2:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   245d4:	f823 4031 	strh.w	r4, [r3, r1, lsl #3]
}
   245d8:	bd38      	pop	{r3, r4, r5, pc}

000245da <split_chunks>:
{
   245da:	b538      	push	{r3, r4, r5, lr}
   245dc:	460c      	mov	r4, r1
   245de:	4603      	mov	r3, r0
	chunksz_t sz0 = chunk_size(h, lc);
   245e0:	f7ff ff58 	bl	24494 <chunk_size>
	chunksz_t rsz = sz0 - lsz;
   245e4:	1aa5      	subs	r5, r4, r2
	chunksz_t lsz = rc - lc;
   245e6:	1a51      	subs	r1, r2, r1
	chunksz_t rsz = sz0 - lsz;
   245e8:	4405      	add	r5, r0
   245ea:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   245ee:	0048      	lsls	r0, r1, #1
		((uint16_t *)cmem)[f] = val;
   245f0:	8060      	strh	r0, [r4, #2]
   245f2:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   245f6:	006c      	lsls	r4, r5, #1
		((uint16_t *)cmem)[f] = val;
   245f8:	8044      	strh	r4, [r0, #2]
   245fa:	f823 1032 	strh.w	r1, [r3, r2, lsl #3]
	return c + chunk_size(h, c);
   245fe:	4618      	mov	r0, r3
   24600:	4611      	mov	r1, r2
   24602:	f7ff ff47 	bl	24494 <chunk_size>
	void *cmem = &buf[c];
   24606:	4401      	add	r1, r0
		((uint16_t *)cmem)[f] = val;
   24608:	f823 5031 	strh.w	r5, [r3, r1, lsl #3]
}
   2460c:	bd38      	pop	{r3, r4, r5, pc}

0002460e <free_chunk>:
{
   2460e:	b538      	push	{r3, r4, r5, lr}
   24610:	4605      	mov	r5, r0
	return c + chunk_size(h, c);
   24612:	f7ff ff3f 	bl	24494 <chunk_size>
   24616:	460c      	mov	r4, r1
   24618:	4401      	add	r1, r0
		return ((uint16_t *)cmem)[f];
   2461a:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   2461e:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, right_chunk(h, c))) {
   24620:	07da      	lsls	r2, r3, #31
   24622:	d40a      	bmi.n	2463a <free_chunk+0x2c>
		free_list_remove(h, right_chunk(h, c));
   24624:	4628      	mov	r0, r5
   24626:	f7ff ff7e 	bl	24526 <free_list_remove>
	return c + chunk_size(h, c);
   2462a:	4621      	mov	r1, r4
   2462c:	4628      	mov	r0, r5
   2462e:	f7ff ff31 	bl	24494 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
   24632:	1822      	adds	r2, r4, r0
   24634:	4628      	mov	r0, r5
   24636:	f7ff ffba 	bl	245ae <merge_chunks>
		return ((uint16_t *)cmem)[f];
   2463a:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   2463e:	1a61      	subs	r1, r4, r1
		return ((uint16_t *)cmem)[f];
   24640:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
   24644:	885b      	ldrh	r3, [r3, #2]
	if (!chunk_used(h, left_chunk(h, c))) {
   24646:	07db      	lsls	r3, r3, #31
   24648:	d40c      	bmi.n	24664 <free_chunk+0x56>
		free_list_remove(h, left_chunk(h, c));
   2464a:	4628      	mov	r0, r5
   2464c:	f7ff ff6b 	bl	24526 <free_list_remove>
		return ((uint16_t *)cmem)[f];
   24650:	f835 1034 	ldrh.w	r1, [r5, r4, lsl #3]
		merge_chunks(h, left_chunk(h, c), c);
   24654:	4622      	mov	r2, r4
   24656:	1a61      	subs	r1, r4, r1
   24658:	4628      	mov	r0, r5
   2465a:	f7ff ffa8 	bl	245ae <merge_chunks>
   2465e:	f835 3034 	ldrh.w	r3, [r5, r4, lsl #3]
	return c - chunk_field(h, c, LEFT_SIZE);
   24662:	1ae4      	subs	r4, r4, r3
	free_list_add(h, c);
   24664:	4621      	mov	r1, r4
   24666:	4628      	mov	r0, r5
}
   24668:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	free_list_add(h, c);
   2466c:	f7ff bf17 	b.w	2449e <free_list_add>

00024670 <sys_heap_free>:
	if (mem == NULL) {
   24670:	b161      	cbz	r1, 2468c <sys_heap_free+0x1c>
   24672:	6800      	ldr	r0, [r0, #0]
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   24674:	3904      	subs	r1, #4
   24676:	1a09      	subs	r1, r1, r0
	void *cmem = &buf[c];
   24678:	f021 0307 	bic.w	r3, r1, #7
   2467c:	4403      	add	r3, r0
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   2467e:	885a      	ldrh	r2, [r3, #2]
	free_chunk(h, c);
   24680:	08c9      	lsrs	r1, r1, #3
   24682:	f022 0201 	bic.w	r2, r2, #1
   24686:	805a      	strh	r2, [r3, #2]
   24688:	f7ff bfc1 	b.w	2460e <free_chunk>
}
   2468c:	4770      	bx	lr

0002468e <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   2468e:	b570      	push	{r4, r5, r6, lr}
	struct z_heap *h = heap->heap;
   24690:	6805      	ldr	r5, [r0, #0]
	void *mem;

	if (bytes == 0U || size_too_big(h, bytes)) {
   24692:	b909      	cbnz	r1, 24698 <sys_heap_alloc+0xa>
		return NULL;
   24694:	2000      	movs	r0, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
   24696:	bd70      	pop	{r4, r5, r6, pc}
	if (bytes == 0U || size_too_big(h, bytes)) {
   24698:	68ab      	ldr	r3, [r5, #8]
   2469a:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   2469e:	d9f9      	bls.n	24694 <sys_heap_alloc+0x6>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   246a0:	310b      	adds	r1, #11
   246a2:	08cc      	lsrs	r4, r1, #3
	chunkid_t c = alloc_chunk(h, chunk_sz);
   246a4:	4621      	mov	r1, r4
   246a6:	4628      	mov	r0, r5
   246a8:	f7ff ff4a 	bl	24540 <alloc_chunk>
	if (c == 0U) {
   246ac:	4606      	mov	r6, r0
   246ae:	2800      	cmp	r0, #0
   246b0:	d0f0      	beq.n	24694 <sys_heap_alloc+0x6>
	if (chunk_size(h, c) > chunk_sz) {
   246b2:	4601      	mov	r1, r0
   246b4:	4628      	mov	r0, r5
   246b6:	f7ff feed 	bl	24494 <chunk_size>
   246ba:	42a0      	cmp	r0, r4
   246bc:	d907      	bls.n	246ce <sys_heap_alloc+0x40>
		split_chunks(h, c, c + chunk_sz);
   246be:	4628      	mov	r0, r5
   246c0:	1932      	adds	r2, r6, r4
   246c2:	f7ff ff8a 	bl	245da <split_chunks>
		free_list_add(h, c + chunk_sz);
   246c6:	4611      	mov	r1, r2
   246c8:	4628      	mov	r0, r5
   246ca:	f7ff fee8 	bl	2449e <free_list_add>
	void *cmem = &buf[c];
   246ce:	eb05 02c6 	add.w	r2, r5, r6, lsl #3
	uint8_t *ret = ((uint8_t *)&buf[c]) + chunk_header_bytes(h);
   246d2:	4610      	mov	r0, r2
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   246d4:	8853      	ldrh	r3, [r2, #2]
   246d6:	3004      	adds	r0, #4
   246d8:	f043 0301 	orr.w	r3, r3, #1
   246dc:	8053      	strh	r3, [r2, #2]
	return mem;
   246de:	e7da      	b.n	24696 <sys_heap_alloc+0x8>

000246e0 <sys_heap_aligned_alloc>:

void *sys_heap_aligned_alloc(struct sys_heap *heap, size_t align, size_t bytes)
{
   246e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   246e4:	f101 39ff 	add.w	r9, r1, #4294967295	; 0xffffffff
	 * value to efficiently accommodate z_heap_aligned_alloc().
	 * So if e.g. align = 0x28 (32 | 8) this means we align to a 32-byte
	 * boundary and then rewind 8 bytes.
	 */
	rew = align & -align;
	if (align != rew) {
   246e8:	ea19 0901 	ands.w	r9, r9, r1
{
   246ec:	460f      	mov	r7, r1
   246ee:	4614      	mov	r4, r2
	struct z_heap *h = heap->heap;
   246f0:	6806      	ldr	r6, [r0, #0]
	if (align != rew) {
   246f2:	d00c      	beq.n	2470e <sys_heap_aligned_alloc+0x2e>
	rew = align & -align;
   246f4:	424b      	negs	r3, r1
   246f6:	400b      	ands	r3, r1
		align -= rew;
		gap = MIN(rew, chunk_header_bytes(h));
   246f8:	2b04      	cmp	r3, #4
   246fa:	461a      	mov	r2, r3
   246fc:	464f      	mov	r7, r9
   246fe:	bf28      	it	cs
   24700:	2204      	movcs	r2, #4
	rew = align & -align;
   24702:	4699      	mov	r9, r3
		rew = 0;
		gap = chunk_header_bytes(h);
	}
	__ASSERT((align & (align - 1)) == 0, "align must be a power of 2");

	if (bytes == 0 || size_too_big(h, bytes)) {
   24704:	b964      	cbnz	r4, 24720 <sys_heap_aligned_alloc+0x40>
		return NULL;
   24706:	2500      	movs	r5, #0
				   chunksz_to_bytes(h, chunk_size(h, c)));
#endif

	IF_ENABLED(CONFIG_MSAN, (__msan_allocated_memory(mem, bytes)));
	return mem;
}
   24708:	4628      	mov	r0, r5
   2470a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (align <= chunk_header_bytes(h)) {
   2470e:	2904      	cmp	r1, #4
   24710:	d804      	bhi.n	2471c <sys_heap_aligned_alloc+0x3c>
}
   24712:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			return sys_heap_alloc(heap, bytes);
   24716:	4611      	mov	r1, r2
   24718:	f7ff bfb9 	b.w	2468e <sys_heap_alloc>
		gap = chunk_header_bytes(h);
   2471c:	2204      	movs	r2, #4
   2471e:	e7f1      	b.n	24704 <sys_heap_aligned_alloc+0x24>
	if (bytes == 0 || size_too_big(h, bytes)) {
   24720:	68b3      	ldr	r3, [r6, #8]
   24722:	ebb3 0fd4 	cmp.w	r3, r4, lsr #3
   24726:	d9ee      	bls.n	24706 <sys_heap_aligned_alloc+0x26>
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   24728:	f104 010b 	add.w	r1, r4, #11
   2472c:	4439      	add	r1, r7
   2472e:	1a89      	subs	r1, r1, r2
	chunkid_t c0 = alloc_chunk(h, padded_sz);
   24730:	4630      	mov	r0, r6
   24732:	08c9      	lsrs	r1, r1, #3
   24734:	f7ff ff04 	bl	24540 <alloc_chunk>
	if (c0 == 0) {
   24738:	4680      	mov	r8, r0
   2473a:	2800      	cmp	r0, #0
   2473c:	d0e3      	beq.n	24706 <sys_heap_aligned_alloc+0x26>
	mem = (uint8_t *) ROUND_UP(mem + rew, align) - rew;
   2473e:	f109 0504 	add.w	r5, r9, #4
   24742:	eb05 05c0 	add.w	r5, r5, r0, lsl #3
   24746:	1e7b      	subs	r3, r7, #1
   24748:	4435      	add	r5, r6
   2474a:	441d      	add	r5, r3
   2474c:	427f      	negs	r7, r7
   2474e:	403d      	ands	r5, r7
   24750:	eba5 0509 	sub.w	r5, r5, r9
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   24754:	442c      	add	r4, r5
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   24756:	1f2b      	subs	r3, r5, #4
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   24758:	3407      	adds	r4, #7
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   2475a:	1b9b      	subs	r3, r3, r6
	chunk_unit_t *end = (chunk_unit_t *) ROUND_UP(mem + bytes, CHUNK_UNIT);
   2475c:	f024 0407 	bic.w	r4, r4, #7
	chunkid_t c_end = end - chunk_buf(h);
   24760:	1ba4      	subs	r4, r4, r6
	if (c > c0) {
   24762:	ebb0 0fd3 	cmp.w	r0, r3, lsr #3
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
   24766:	ea4f 07d3 	mov.w	r7, r3, lsr #3
	chunkid_t c_end = end - chunk_buf(h);
   2476a:	ea4f 04e4 	mov.w	r4, r4, asr #3
	if (c > c0) {
   2476e:	d208      	bcs.n	24782 <sys_heap_aligned_alloc+0xa2>
		split_chunks(h, c0, c);
   24770:	4601      	mov	r1, r0
   24772:	463a      	mov	r2, r7
   24774:	4630      	mov	r0, r6
   24776:	f7ff ff30 	bl	245da <split_chunks>
		free_list_add(h, c0);
   2477a:	4641      	mov	r1, r8
   2477c:	4630      	mov	r0, r6
   2477e:	f7ff fe8e 	bl	2449e <free_list_add>
	return c + chunk_size(h, c);
   24782:	4639      	mov	r1, r7
   24784:	4630      	mov	r0, r6
   24786:	f7ff fe85 	bl	24494 <chunk_size>
   2478a:	4438      	add	r0, r7
	if (right_chunk(h, c) > c_end) {
   2478c:	4284      	cmp	r4, r0
   2478e:	d207      	bcs.n	247a0 <sys_heap_aligned_alloc+0xc0>
		split_chunks(h, c, c_end);
   24790:	4630      	mov	r0, r6
   24792:	4622      	mov	r2, r4
   24794:	f7ff ff21 	bl	245da <split_chunks>
		free_list_add(h, c_end);
   24798:	4621      	mov	r1, r4
   2479a:	4630      	mov	r0, r6
   2479c:	f7ff fe7f 	bl	2449e <free_list_add>
	void *cmem = &buf[c];
   247a0:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   247a4:	8873      	ldrh	r3, [r6, #2]
   247a6:	f043 0301 	orr.w	r3, r3, #1
   247aa:	8073      	strh	r3, [r6, #2]
   247ac:	e7ac      	b.n	24708 <sys_heap_aligned_alloc+0x28>

000247ae <sys_heap_init>:
	}
	return ptr2;
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   247ae:	b4f0      	push	{r4, r5, r6, r7}
   247b0:	4604      	mov	r4, r0
		__ASSERT(bytes / CHUNK_UNIT <= 0x7fffffffU, "heap size is too big");
	}

	/* Reserve the end marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
   247b2:	3a04      	subs	r2, #4

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   247b4:	1dc8      	adds	r0, r1, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   247b6:	4411      	add	r1, r2
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   247b8:	f020 0007 	bic.w	r0, r0, #7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   247bc:	f021 0107 	bic.w	r1, r1, #7
	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
   247c0:	1a0e      	subs	r6, r1, r0
   247c2:	08f3      	lsrs	r3, r6, #3
	return 31 - __builtin_clz(usable_sz);
   247c4:	fab3 f283 	clz	r2, r3

	CHECK(end > addr);
	__ASSERT(heap_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
   247c8:	6020      	str	r0, [r4, #0]
	h->end_chunk = heap_sz;
	h->avail_buckets = 0;
   247ca:	2700      	movs	r7, #0
   247cc:	4604      	mov	r4, r0
	h->allocated_bytes = 0;
	h->max_allocated_bytes = 0;
#endif

	int nb_buckets = bucket_idx(h, heap_sz) + 1;
	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
   247ce:	f1c2 0524 	rsb	r5, r2, #36	; 0x24
   247d2:	00ad      	lsls	r5, r5, #2
	h->end_chunk = heap_sz;
   247d4:	6083      	str	r3, [r0, #8]
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   247d6:	3507      	adds	r5, #7
	h->avail_buckets = 0;
   247d8:	f844 7f0c 	str.w	r7, [r4, #12]!
	int nb_buckets = bucket_idx(h, heap_sz) + 1;
   247dc:	f1c2 0220 	rsb	r2, r2, #32
   247e0:	08e9      	lsrs	r1, r5, #3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) <= heap_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
   247e2:	eb04 0282 	add.w	r2, r4, r2, lsl #2
		h->buckets[i].next = 0;
   247e6:	f844 7f04 	str.w	r7, [r4, #4]!
	for (int i = 0; i < nb_buckets; i++) {
   247ea:	4294      	cmp	r4, r2
   247ec:	d1fb      	bne.n	247e6 <sys_heap_init+0x38>
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   247ee:	004a      	lsls	r2, r1, #1
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   247f0:	f042 0201 	orr.w	r2, r2, #1
   247f4:	8042      	strh	r2, [r0, #2]
	set_chunk_size(h, 0, chunk0_size);
	set_left_chunk_size(h, 0, 0);
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
   247f6:	1a5a      	subs	r2, r3, r1
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   247f8:	0055      	lsls	r5, r2, #1
		((uint16_t *)cmem)[f] = val;
   247fa:	eb00 04c1 	add.w	r4, r0, r1, lsl #3
   247fe:	8007      	strh	r7, [r0, #0]
   24800:	8065      	strh	r5, [r4, #2]
   24802:	1984      	adds	r4, r0, r6
   24804:	f820 1031 	strh.w	r1, [r0, r1, lsl #3]
	void *cmem = &buf[c];
   24808:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
		((uint16_t *)cmem)[f] = val;
   2480c:	8067      	strh	r7, [r4, #2]
   2480e:	5382      	strh	r2, [r0, r6]
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   24810:	885a      	ldrh	r2, [r3, #2]
   24812:	f042 0201 	orr.w	r2, r2, #1
   24816:	805a      	strh	r2, [r3, #2]
	set_chunk_size(h, heap_sz, 0);
	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
	set_chunk_used(h, heap_sz, true);

	free_list_add(h, chunk0_size);
}
   24818:	bcf0      	pop	{r4, r5, r6, r7}
	free_list_add(h, chunk0_size);
   2481a:	f7ff be40 	b.w	2449e <free_list_add>

0002481e <sys_slist_find_and_remove>:
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2481e:	2200      	movs	r2, #0
	return list->head;
   24820:	6803      	ldr	r3, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24822:	b90b      	cbnz	r3, 24828 <sys_slist_find_and_remove+0xa>
   24824:	4618      	mov	r0, r3
   24826:	4770      	bx	lr
   24828:	428b      	cmp	r3, r1
   2482a:	d110      	bne.n	2484e <sys_slist_find_and_remove+0x30>
	return node->next;
   2482c:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   2482e:	b942      	cbnz	r2, 24842 <sys_slist_find_and_remove+0x24>
   24830:	6842      	ldr	r2, [r0, #4]
	list->head = node;
   24832:	6003      	str	r3, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   24834:	4291      	cmp	r1, r2
   24836:	d100      	bne.n	2483a <sys_slist_find_and_remove+0x1c>
	list->tail = node;
   24838:	6043      	str	r3, [r0, #4]
	parent->next = child;
   2483a:	2300      	movs	r3, #0
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2483c:	2001      	movs	r0, #1
	parent->next = child;
   2483e:	600b      	str	r3, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   24840:	4770      	bx	lr
	parent->next = child;
   24842:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   24844:	6843      	ldr	r3, [r0, #4]
   24846:	4299      	cmp	r1, r3
	list->tail = node;
   24848:	bf08      	it	eq
   2484a:	6042      	streq	r2, [r0, #4]
}
   2484c:	e7f5      	b.n	2483a <sys_slist_find_and_remove+0x1c>
	return node->next;
   2484e:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   24850:	681b      	ldr	r3, [r3, #0]
   24852:	e7e6      	b.n	24822 <sys_slist_find_and_remove+0x4>

00024854 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   24854:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   24856:	f013 0307 	ands.w	r3, r3, #7
   2485a:	d105      	bne.n	24868 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   2485c:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
   2485e:	2b00      	cmp	r3, #0
   24860:	bf0c      	ite	eq
   24862:	2000      	moveq	r0, #0
   24864:	2003      	movne	r0, #3
   24866:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   24868:	2b02      	cmp	r3, #2
   2486a:	d105      	bne.n	24878 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   2486c:	8b40      	ldrh	r0, [r0, #26]
   2486e:	fab0 f080 	clz	r0, r0
   24872:	0940      	lsrs	r0, r0, #5
   24874:	0080      	lsls	r0, r0, #2
   24876:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   24878:	2b01      	cmp	r3, #1
   2487a:	d105      	bne.n	24888 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   2487c:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
   2487e:	2b00      	cmp	r3, #0
   24880:	bf0c      	ite	eq
   24882:	2000      	moveq	r0, #0
   24884:	2005      	movne	r0, #5
   24886:	4770      	bx	lr
	int evt = EVT_NOP;
   24888:	2000      	movs	r0, #0
}
   2488a:	4770      	bx	lr

0002488c <validate_args>:
{
   2488c:	b510      	push	{r4, lr}
   2488e:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   24890:	b100      	cbz	r0, 24894 <validate_args+0x8>
   24892:	b911      	cbnz	r1, 2489a <validate_args+0xe>
		return -EINVAL;
   24894:	f06f 0015 	mvn.w	r0, #21
}
   24898:	bd10      	pop	{r4, pc}
	int rv = sys_notify_validate(&cli->notify);
   2489a:	1d08      	adds	r0, r1, #4
   2489c:	f000 f8d6 	bl	24a4c <sys_notify_validate>
	if ((rv == 0)
   248a0:	2800      	cmp	r0, #0
   248a2:	d1f9      	bne.n	24898 <validate_args+0xc>
	    && ((cli->notify.flags
   248a4:	68a3      	ldr	r3, [r4, #8]
   248a6:	2b03      	cmp	r3, #3
   248a8:	d9f6      	bls.n	24898 <validate_args+0xc>
   248aa:	e7f3      	b.n	24894 <validate_args+0x8>

000248ac <notify_one>:
{
   248ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   248b0:	460d      	mov	r5, r1
   248b2:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   248b4:	4619      	mov	r1, r3
   248b6:	1d28      	adds	r0, r5, #4
{
   248b8:	4690      	mov	r8, r2
   248ba:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   248bc:	f000 f8d7 	bl	24a6e <sys_notify_finalize>
	if (cb) {
   248c0:	4604      	mov	r4, r0
   248c2:	b138      	cbz	r0, 248d4 <notify_one+0x28>
		cb(mgr, cli, state, res);
   248c4:	4633      	mov	r3, r6
   248c6:	4642      	mov	r2, r8
   248c8:	4629      	mov	r1, r5
   248ca:	4638      	mov	r0, r7
   248cc:	46a4      	mov	ip, r4
}
   248ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   248d2:	4760      	bx	ip
}
   248d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000248d8 <transition_complete>:
{
   248d8:	b410      	push	{r4}
	__asm__ volatile(
   248da:	f04f 0420 	mov.w	r4, #32
   248de:	f3ef 8211 	mrs	r2, BASEPRI
   248e2:	f384 8812 	msr	BASEPRI_MAX, r4
   248e6:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   248ea:	6141      	str	r1, [r0, #20]
}
   248ec:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   248ee:	2101      	movs	r1, #1
   248f0:	f7f7 bdfa 	b.w	1c4e8 <process_event>

000248f4 <onoff_manager_init>:
{
   248f4:	b538      	push	{r3, r4, r5, lr}
   248f6:	460c      	mov	r4, r1
	if ((mgr == NULL)
   248f8:	4605      	mov	r5, r0
   248fa:	b158      	cbz	r0, 24914 <onoff_manager_init+0x20>
	    || (transitions == NULL)
   248fc:	b151      	cbz	r1, 24914 <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   248fe:	680b      	ldr	r3, [r1, #0]
   24900:	b143      	cbz	r3, 24914 <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   24902:	684b      	ldr	r3, [r1, #4]
   24904:	b133      	cbz	r3, 24914 <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   24906:	221c      	movs	r2, #28
   24908:	2100      	movs	r1, #0
   2490a:	f000 fb6d 	bl	24fe8 <memset>
	return 0;
   2490e:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   24910:	612c      	str	r4, [r5, #16]
}
   24912:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   24914:	f06f 0015 	mvn.w	r0, #21
   24918:	e7fb      	b.n	24912 <onoff_manager_init+0x1e>

0002491a <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   2491a:	b570      	push	{r4, r5, r6, lr}
   2491c:	4605      	mov	r5, r0
   2491e:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   24920:	f7ff ffb4 	bl	2488c <validate_args>

	if (rv < 0) {
   24924:	1e04      	subs	r4, r0, #0
   24926:	db15      	blt.n	24954 <onoff_request+0x3a>
   24928:	f04f 0320 	mov.w	r3, #32
   2492c:	f3ef 8211 	mrs	r2, BASEPRI
   24930:	f383 8812 	msr	BASEPRI_MAX, r3
   24934:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   24938:	f64f 71ff 	movw	r1, #65535	; 0xffff
   2493c:	8b6b      	ldrh	r3, [r5, #26]
   2493e:	8b2c      	ldrh	r4, [r5, #24]
   24940:	428b      	cmp	r3, r1
   24942:	f004 0407 	and.w	r4, r4, #7
   24946:	d107      	bne.n	24958 <onoff_request+0x3e>
	__asm__ volatile(
   24948:	f382 8811 	msr	BASEPRI, r2
   2494c:	f3bf 8f6f 	isb	sy
		rv = -EAGAIN;
   24950:	f06f 040a 	mvn.w	r4, #10
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
   24954:	4620      	mov	r0, r4
   24956:	bd70      	pop	{r4, r5, r6, pc}
	if (state == ONOFF_STATE_ON) {
   24958:	2c02      	cmp	r4, #2
   2495a:	d10c      	bne.n	24976 <onoff_request+0x5c>
		mgr->refs += 1U;
   2495c:	3301      	adds	r3, #1
   2495e:	836b      	strh	r3, [r5, #26]
   24960:	f382 8811 	msr	BASEPRI, r2
   24964:	f3bf 8f6f 	isb	sy
			notify_one(mgr, cli, state, 0);
   24968:	2300      	movs	r3, #0
   2496a:	4622      	mov	r2, r4
   2496c:	4631      	mov	r1, r6
   2496e:	4628      	mov	r0, r5
   24970:	f7ff ff9c 	bl	248ac <notify_one>
   24974:	e7ee      	b.n	24954 <onoff_request+0x3a>
	} else if ((state == ONOFF_STATE_OFF)
   24976:	2c06      	cmp	r4, #6
   24978:	d814      	bhi.n	249a4 <onoff_request+0x8a>
   2497a:	e8df f004 	tbb	[pc, r4]
   2497e:	1304      	.short	0x1304
   24980:	1a041313 	.word	0x1a041313
   24984:	04          	.byte	0x04
   24985:	00          	.byte	0x00
	parent->next = child;
   24986:	2300      	movs	r3, #0
   24988:	6033      	str	r3, [r6, #0]
	return list->tail;
   2498a:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_APPEND(slist, snode)
   2498c:	b93b      	cbnz	r3, 2499e <onoff_request+0x84>
	list->head = node;
   2498e:	e9c5 6600 	strd	r6, r6, [r5]
	if (start) {
   24992:	b9ac      	cbnz	r4, 249c0 <onoff_request+0xa6>
		process_event(mgr, EVT_RECHECK, key);
   24994:	2102      	movs	r1, #2
   24996:	4628      	mov	r0, r5
   24998:	f7f7 fda6 	bl	1c4e8 <process_event>
   2499c:	e7da      	b.n	24954 <onoff_request+0x3a>
	parent->next = child;
   2499e:	601e      	str	r6, [r3, #0]
	list->tail = node;
   249a0:	606e      	str	r6, [r5, #4]
}
   249a2:	e7f6      	b.n	24992 <onoff_request+0x78>
   249a4:	f382 8811 	msr	BASEPRI, r2
   249a8:	f3bf 8f6f 	isb	sy
		rv = -EIO;
   249ac:	f06f 0404 	mvn.w	r4, #4
   249b0:	e7d0      	b.n	24954 <onoff_request+0x3a>
   249b2:	f382 8811 	msr	BASEPRI, r2
   249b6:	f3bf 8f6f 	isb	sy
   249ba:	f06f 0485 	mvn.w	r4, #133	; 0x85
   249be:	e7c9      	b.n	24954 <onoff_request+0x3a>
   249c0:	f382 8811 	msr	BASEPRI, r2
   249c4:	f3bf 8f6f 	isb	sy
		if (notify) {
   249c8:	e7c4      	b.n	24954 <onoff_request+0x3a>

000249ca <onoff_release>:

int onoff_release(struct onoff_manager *mgr)
{
   249ca:	b510      	push	{r4, lr}
	__asm__ volatile(
   249cc:	f04f 0320 	mov.w	r3, #32
   249d0:	f3ef 8211 	mrs	r2, BASEPRI
   249d4:	f383 8812 	msr	BASEPRI_MAX, r3
   249d8:	f3bf 8f6f 	isb	sy
	bool stop = false;      /* trigger a stop transition */

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   249dc:	8b04      	ldrh	r4, [r0, #24]
   249de:	f004 0407 	and.w	r4, r4, #7
	int rv = state;

	if (state != ONOFF_STATE_ON) {
   249e2:	2c02      	cmp	r4, #2
   249e4:	d00a      	beq.n	249fc <onoff_release+0x32>
		if (state == ONOFF_STATE_ERROR) {
			rv = -EIO;
		} else {
			rv = -ENOTSUP;
   249e6:	2c01      	cmp	r4, #1
   249e8:	bf0c      	ite	eq
   249ea:	f06f 0004 	mvneq.w	r0, #4
   249ee:	f06f 0085 	mvnne.w	r0, #133	; 0x85
	__asm__ volatile(
   249f2:	f382 8811 	msr	BASEPRI, r2
   249f6:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);
	}

	return rv;
   249fa:	e008      	b.n	24a0e <onoff_release+0x44>
	mgr->refs -= 1U;
   249fc:	8b43      	ldrh	r3, [r0, #26]
   249fe:	3b01      	subs	r3, #1
   24a00:	b29b      	uxth	r3, r3
   24a02:	8343      	strh	r3, [r0, #26]
	if (stop) {
   24a04:	b923      	cbnz	r3, 24a10 <onoff_release+0x46>
		process_event(mgr, EVT_RECHECK, key);
   24a06:	4621      	mov	r1, r4
   24a08:	f7f7 fd6e 	bl	1c4e8 <process_event>
	int rv = state;
   24a0c:	4620      	mov	r0, r4
}
   24a0e:	bd10      	pop	{r4, pc}
	int rv = state;
   24a10:	4620      	mov	r0, r4
   24a12:	e7ee      	b.n	249f2 <onoff_release+0x28>

00024a14 <onoff_cancel>:
	return rv;
}

int onoff_cancel(struct onoff_manager *mgr,
		 struct onoff_client *cli)
{
   24a14:	b538      	push	{r3, r4, r5, lr}
	if ((mgr == NULL) || (cli == NULL)) {
   24a16:	b1b0      	cbz	r0, 24a46 <onoff_cancel+0x32>
   24a18:	b1a9      	cbz	r1, 24a46 <onoff_cancel+0x32>
	__asm__ volatile(
   24a1a:	f04f 0220 	mov.w	r2, #32
   24a1e:	f3ef 8511 	mrs	r5, BASEPRI
   24a22:	f382 8812 	msr	BASEPRI_MAX, r2
   24a26:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	int rv = -EALREADY;
	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   24a2a:	8b04      	ldrh	r4, [r0, #24]

	if (sys_slist_find_and_remove(&mgr->clients, &cli->node)) {
   24a2c:	f7ff fef7 	bl	2481e <sys_slist_find_and_remove>
   24a30:	b130      	cbz	r0, 24a40 <onoff_cancel+0x2c>
		__ASSERT_NO_MSG((state == ONOFF_STATE_TO_ON)
				|| (state == ONOFF_STATE_TO_OFF)
				|| (state == ONOFF_STATE_RESETTING));
		rv = state;
   24a32:	f004 0007 	and.w	r0, r4, #7
	__asm__ volatile(
   24a36:	f385 8811 	msr	BASEPRI, r5
   24a3a:	f3bf 8f6f 	isb	sy
	}

	k_spin_unlock(&mgr->lock, key);

	return rv;
}
   24a3e:	bd38      	pop	{r3, r4, r5, pc}
	int rv = -EALREADY;
   24a40:	f06f 0077 	mvn.w	r0, #119	; 0x77
   24a44:	e7f7      	b.n	24a36 <onoff_cancel+0x22>
		return -EINVAL;
   24a46:	f06f 0015 	mvn.w	r0, #21
   24a4a:	e7f8      	b.n	24a3e <onoff_cancel+0x2a>

00024a4c <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
   24a4c:	4603      	mov	r3, r0
   24a4e:	b158      	cbz	r0, 24a68 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   24a50:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
   24a52:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
   24a56:	2a01      	cmp	r2, #1
   24a58:	d003      	beq.n	24a62 <sys_notify_validate+0x16>
   24a5a:	2a03      	cmp	r2, #3
   24a5c:	d104      	bne.n	24a68 <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
   24a5e:	6802      	ldr	r2, [r0, #0]
   24a60:	b112      	cbz	r2, 24a68 <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
   24a62:	2000      	movs	r0, #0
   24a64:	6098      	str	r0, [r3, #8]
   24a66:	4770      	bx	lr
   24a68:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
   24a6c:	4770      	bx	lr

00024a6e <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
   24a6e:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
   24a70:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
   24a72:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
   24a76:	2a03      	cmp	r2, #3
   24a78:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
   24a7c:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = NULL;
   24a7e:	bf14      	ite	ne
   24a80:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
   24a82:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
   24a84:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
   24a86:	4770      	bx	lr

00024a88 <encode_uint>:
{
   24a88:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24a8c:	469a      	mov	sl, r3
	bool upcase = isupper((int)conv->specifier) != 0;
   24a8e:	78d3      	ldrb	r3, [r2, #3]
{
   24a90:	4680      	mov	r8, r0
	switch (specifier) {
   24a92:	2b6f      	cmp	r3, #111	; 0x6f
{
   24a94:	460f      	mov	r7, r1
   24a96:	4615      	mov	r5, r2
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   24a98:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
   24a9c:	d029      	beq.n	24af2 <encode_uint+0x6a>
   24a9e:	d824      	bhi.n	24aea <encode_uint+0x62>
		return 10;
   24aa0:	2b58      	cmp	r3, #88	; 0x58
   24aa2:	bf0c      	ite	eq
   24aa4:	2610      	moveq	r6, #16
   24aa6:	260a      	movne	r6, #10
	char *bp = bps + (bpe - bps);
   24aa8:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
		unsigned int lsv = (unsigned int)(value % radix);
   24aac:	4632      	mov	r2, r6
   24aae:	2300      	movs	r3, #0
   24ab0:	4640      	mov	r0, r8
   24ab2:	4639      	mov	r1, r7
   24ab4:	f7f7 fb4e 	bl	1c154 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24ab8:	2a09      	cmp	r2, #9
   24aba:	b2d4      	uxtb	r4, r2
   24abc:	d81e      	bhi.n	24afc <encode_uint+0x74>
   24abe:	3430      	adds	r4, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   24ac0:	45b0      	cmp	r8, r6
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24ac2:	b2e4      	uxtb	r4, r4
	} while ((value != 0) && (bps < bp));
   24ac4:	f177 0700 	sbcs.w	r7, r7, #0
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24ac8:	f809 4d01 	strb.w	r4, [r9, #-1]!
	} while ((value != 0) && (bps < bp));
   24acc:	d301      	bcc.n	24ad2 <encode_uint+0x4a>
   24ace:	45d1      	cmp	r9, sl
   24ad0:	d811      	bhi.n	24af6 <encode_uint+0x6e>
	if (conv->flag_hash) {
   24ad2:	782b      	ldrb	r3, [r5, #0]
   24ad4:	069b      	lsls	r3, r3, #26
   24ad6:	d505      	bpl.n	24ae4 <encode_uint+0x5c>
		if (radix == 8) {
   24ad8:	2e08      	cmp	r6, #8
   24ada:	d115      	bne.n	24b08 <encode_uint+0x80>
			conv->altform_0 = true;
   24adc:	78ab      	ldrb	r3, [r5, #2]
   24ade:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   24ae2:	70ab      	strb	r3, [r5, #2]
}
   24ae4:	4648      	mov	r0, r9
   24ae6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   24aea:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 10;
   24aee:	2b70      	cmp	r3, #112	; 0x70
   24af0:	e7d7      	b.n	24aa2 <encode_uint+0x1a>
	switch (specifier) {
   24af2:	2608      	movs	r6, #8
   24af4:	e7d8      	b.n	24aa8 <encode_uint+0x20>
		value /= radix;
   24af6:	4680      	mov	r8, r0
   24af8:	460f      	mov	r7, r1
   24afa:	e7d7      	b.n	24aac <encode_uint+0x24>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   24afc:	f1bb 0f19 	cmp.w	fp, #25
   24b00:	bf94      	ite	ls
   24b02:	3437      	addls	r4, #55	; 0x37
   24b04:	3457      	addhi	r4, #87	; 0x57
   24b06:	e7db      	b.n	24ac0 <encode_uint+0x38>
		} else if (radix == 16) {
   24b08:	2e10      	cmp	r6, #16
   24b0a:	d1eb      	bne.n	24ae4 <encode_uint+0x5c>
			conv->altform_0c = true;
   24b0c:	78ab      	ldrb	r3, [r5, #2]
   24b0e:	f043 0310 	orr.w	r3, r3, #16
   24b12:	e7e6      	b.n	24ae2 <encode_uint+0x5a>

00024b14 <outs>:
{
   24b14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24b18:	4607      	mov	r7, r0
   24b1a:	4688      	mov	r8, r1
   24b1c:	4615      	mov	r5, r2
   24b1e:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   24b20:	4614      	mov	r4, r2
   24b22:	42b4      	cmp	r4, r6
   24b24:	d305      	bcc.n	24b32 <outs+0x1e>
   24b26:	b10e      	cbz	r6, 24b2c <outs+0x18>
	return (int)count;
   24b28:	1b60      	subs	r0, r4, r5
   24b2a:	e008      	b.n	24b3e <outs+0x2a>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   24b2c:	7823      	ldrb	r3, [r4, #0]
   24b2e:	2b00      	cmp	r3, #0
   24b30:	d0fa      	beq.n	24b28 <outs+0x14>
		int rc = out((int)*sp++, ctx);
   24b32:	4641      	mov	r1, r8
   24b34:	f814 0b01 	ldrb.w	r0, [r4], #1
   24b38:	47b8      	blx	r7
		if (rc < 0) {
   24b3a:	2800      	cmp	r0, #0
   24b3c:	daf1      	bge.n	24b22 <outs+0xe>
}
   24b3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024b42 <ring_buf_put_claim>:

#include <zephyr/sys/ring_buffer.h>
#include <string.h>

uint32_t ring_buf_put_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
   24b42:	4694      	mov	ip, r2
   24b44:	b5f0      	push	{r4, r5, r6, r7, lr}
   24b46:	4604      	mov	r4, r0
	uint32_t free_space, wrap_size;
	int32_t base;

	base = buf->put_base;
	wrap_size = buf->put_head - base;
	if (unlikely(wrap_size >= buf->size)) {
   24b48:	69c3      	ldr	r3, [r0, #28]
	base = buf->put_base;
   24b4a:	68c6      	ldr	r6, [r0, #12]
	wrap_size = buf->put_head - base;
   24b4c:	6845      	ldr	r5, [r0, #4]
   24b4e:	6940      	ldr	r0, [r0, #20]
   24b50:	1baf      	subs	r7, r5, r6
   24b52:	1a28      	subs	r0, r5, r0
   24b54:	1a1a      	subs	r2, r3, r0
	if (unlikely(wrap_size >= buf->size)) {
   24b56:	42bb      	cmp	r3, r7
		/* put_base is not yet adjusted */
		wrap_size -= buf->size;
   24b58:	bf9c      	itt	ls
   24b5a:	1aff      	subls	r7, r7, r3
		base += buf->size;
   24b5c:	18f6      	addls	r6, r6, r3
	}
	wrap_size = buf->size - wrap_size;

	free_space = ring_buf_space_get(buf);
	size = MIN(size, free_space);
   24b5e:	4562      	cmp	r2, ip
   24b60:	bf28      	it	cs
   24b62:	4662      	movcs	r2, ip
	wrap_size = buf->size - wrap_size;
   24b64:	1bd8      	subs	r0, r3, r7
	size = MIN(size, wrap_size);
   24b66:	4290      	cmp	r0, r2
   24b68:	bf28      	it	cs
   24b6a:	4610      	movcs	r0, r2

	*data = &buf->buffer[buf->put_head - base];
   24b6c:	6823      	ldr	r3, [r4, #0]
   24b6e:	1bad      	subs	r5, r5, r6
   24b70:	442b      	add	r3, r5
   24b72:	600b      	str	r3, [r1, #0]
	buf->put_head += size;
   24b74:	6863      	ldr	r3, [r4, #4]
   24b76:	4403      	add	r3, r0
   24b78:	6063      	str	r3, [r4, #4]

	return size;
}
   24b7a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00024b7c <ring_buf_put_finish>:

int ring_buf_put_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->put_head - buf->put_tail;
   24b7c:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
   24b80:	1ad2      	subs	r2, r2, r3
	if (unlikely(size > finish_space)) {
   24b82:	428a      	cmp	r2, r1
   24b84:	d30c      	bcc.n	24ba0 <ring_buf_put_finish+0x24>
		return -EINVAL;
	}

	buf->put_tail += size;
   24b86:	4419      	add	r1, r3
	buf->put_head = buf->put_tail;

	wrap_size = buf->put_tail - buf->put_base;
   24b88:	68c3      	ldr	r3, [r0, #12]
	if (unlikely(wrap_size >= buf->size)) {
   24b8a:	69c2      	ldr	r2, [r0, #28]
	buf->put_head = buf->put_tail;
   24b8c:	e9c0 1101 	strd	r1, r1, [r0, #4]
	wrap_size = buf->put_tail - buf->put_base;
   24b90:	1ac9      	subs	r1, r1, r3
	if (unlikely(wrap_size >= buf->size)) {
   24b92:	428a      	cmp	r2, r1
   24b94:	d901      	bls.n	24b9a <ring_buf_put_finish+0x1e>
		/* we wrapped: adjust put_base */
		buf->put_base += buf->size;
	}

	return 0;
   24b96:	2000      	movs	r0, #0
   24b98:	4770      	bx	lr
		buf->put_base += buf->size;
   24b9a:	4413      	add	r3, r2
   24b9c:	60c3      	str	r3, [r0, #12]
   24b9e:	e7fa      	b.n	24b96 <ring_buf_put_finish+0x1a>
		return -EINVAL;
   24ba0:	f06f 0015 	mvn.w	r0, #21
}
   24ba4:	4770      	bx	lr

00024ba6 <ring_buf_put>:

uint32_t ring_buf_put(struct ring_buf *buf, const uint8_t *data, uint32_t size)
{
   24ba6:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   24baa:	4680      	mov	r8, r0
   24bac:	460e      	mov	r6, r1
   24bae:	4615      	mov	r5, r2
	uint8_t *dst;
	uint32_t partial_size;
	uint32_t total_size = 0U;
   24bb0:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_put_claim(buf, &dst, size);
   24bb2:	462a      	mov	r2, r5
   24bb4:	a901      	add	r1, sp, #4
   24bb6:	4640      	mov	r0, r8
   24bb8:	f7ff ffc3 	bl	24b42 <ring_buf_put_claim>
   24bbc:	4604      	mov	r4, r0
		memcpy(dst, data, partial_size);
   24bbe:	4602      	mov	r2, r0
   24bc0:	4631      	mov	r1, r6
   24bc2:	9801      	ldr	r0, [sp, #4]
   24bc4:	f000 fa05 	bl	24fd2 <memcpy>
		total_size += partial_size;
		size -= partial_size;
		data += partial_size;
	} while (size && partial_size);
   24bc8:	1b2d      	subs	r5, r5, r4
		total_size += partial_size;
   24bca:	4427      	add	r7, r4
		data += partial_size;
   24bcc:	4426      	add	r6, r4
	} while (size && partial_size);
   24bce:	d001      	beq.n	24bd4 <ring_buf_put+0x2e>
   24bd0:	2c00      	cmp	r4, #0
   24bd2:	d1ee      	bne.n	24bb2 <ring_buf_put+0xc>

	err = ring_buf_put_finish(buf, total_size);
   24bd4:	4639      	mov	r1, r7
   24bd6:	4640      	mov	r0, r8
   24bd8:	f7ff ffd0 	bl	24b7c <ring_buf_put_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
   24bdc:	4638      	mov	r0, r7
   24bde:	b002      	add	sp, #8
   24be0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024be4 <ring_buf_get_claim>:

uint32_t ring_buf_get_claim(struct ring_buf *buf, uint8_t **data, uint32_t size)
{
   24be4:	b5f0      	push	{r4, r5, r6, r7, lr}
   24be6:	4604      	mov	r4, r0
   24be8:	4694      	mov	ip, r2
	uint32_t available_size, wrap_size;
	int32_t base;

	base = buf->get_base;
   24bea:	6986      	ldr	r6, [r0, #24]
	wrap_size = buf->get_head - base;
   24bec:	6905      	ldr	r5, [r0, #16]
 *
 * @return Ring buffer space used (in bytes).
 */
static inline uint32_t ring_buf_size_get(struct ring_buf *buf)
{
	return buf->put_tail - buf->get_head;
   24bee:	68a3      	ldr	r3, [r4, #8]
	if (unlikely(wrap_size >= buf->size)) {
   24bf0:	69c0      	ldr	r0, [r0, #28]
	wrap_size = buf->get_head - base;
   24bf2:	1baf      	subs	r7, r5, r6
   24bf4:	1b5a      	subs	r2, r3, r5
	if (unlikely(wrap_size >= buf->size)) {
   24bf6:	42b8      	cmp	r0, r7
		/* get_base is not yet adjusted */
		wrap_size -= buf->size;
		base += buf->size;
   24bf8:	bf9c      	itt	ls
   24bfa:	1836      	addls	r6, r6, r0
		wrap_size -= buf->size;
   24bfc:	1a3f      	subls	r7, r7, r0
	}
	wrap_size = buf->size - wrap_size;

	available_size = ring_buf_size_get(buf);
	size = MIN(size, available_size);
   24bfe:	4562      	cmp	r2, ip
   24c00:	bf28      	it	cs
   24c02:	4662      	movcs	r2, ip
	wrap_size = buf->size - wrap_size;
   24c04:	1bc0      	subs	r0, r0, r7
	size = MIN(size, wrap_size);
   24c06:	4290      	cmp	r0, r2
   24c08:	bf28      	it	cs
   24c0a:	4610      	movcs	r0, r2

	*data = &buf->buffer[buf->get_head - base];
   24c0c:	6823      	ldr	r3, [r4, #0]
   24c0e:	1bad      	subs	r5, r5, r6
   24c10:	442b      	add	r3, r5
   24c12:	600b      	str	r3, [r1, #0]
	buf->get_head += size;
   24c14:	6923      	ldr	r3, [r4, #16]
   24c16:	4403      	add	r3, r0
   24c18:	6123      	str	r3, [r4, #16]

	return size;
}
   24c1a:	bdf0      	pop	{r4, r5, r6, r7, pc}

00024c1c <ring_buf_get_finish>:

int ring_buf_get_finish(struct ring_buf *buf, uint32_t size)
{
	uint32_t finish_space, wrap_size;

	finish_space = buf->get_head - buf->get_tail;
   24c1c:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
   24c20:	1ad2      	subs	r2, r2, r3
	if (unlikely(size > finish_space)) {
   24c22:	428a      	cmp	r2, r1
   24c24:	d30c      	bcc.n	24c40 <ring_buf_get_finish+0x24>
		return -EINVAL;
	}

	buf->get_tail += size;
   24c26:	4419      	add	r1, r3
	buf->get_head = buf->get_tail;
   24c28:	e9c0 1104 	strd	r1, r1, [r0, #16]

	wrap_size = buf->get_tail - buf->get_base;
	if (unlikely(wrap_size >= buf->size)) {
   24c2c:	e9d0 3206 	ldrd	r3, r2, [r0, #24]
	wrap_size = buf->get_tail - buf->get_base;
   24c30:	1ac9      	subs	r1, r1, r3
	if (unlikely(wrap_size >= buf->size)) {
   24c32:	428a      	cmp	r2, r1
   24c34:	d901      	bls.n	24c3a <ring_buf_get_finish+0x1e>
		/* we wrapped: adjust get_base */
		buf->get_base += buf->size;
	}

	return 0;
   24c36:	2000      	movs	r0, #0
   24c38:	4770      	bx	lr
		buf->get_base += buf->size;
   24c3a:	4413      	add	r3, r2
   24c3c:	6183      	str	r3, [r0, #24]
   24c3e:	e7fa      	b.n	24c36 <ring_buf_get_finish+0x1a>
		return -EINVAL;
   24c40:	f06f 0015 	mvn.w	r0, #21
}
   24c44:	4770      	bx	lr

00024c46 <ring_buf_get>:

uint32_t ring_buf_get(struct ring_buf *buf, uint8_t *data, uint32_t size)
{
   24c46:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   24c4a:	4680      	mov	r8, r0
   24c4c:	460d      	mov	r5, r1
   24c4e:	4616      	mov	r6, r2
	uint8_t *src;
	uint32_t partial_size;
	uint32_t total_size = 0U;
   24c50:	2700      	movs	r7, #0
	int err;

	do {
		partial_size = ring_buf_get_claim(buf, &src, size);
   24c52:	4632      	mov	r2, r6
   24c54:	4640      	mov	r0, r8
   24c56:	a901      	add	r1, sp, #4
   24c58:	f7ff ffc4 	bl	24be4 <ring_buf_get_claim>
   24c5c:	4604      	mov	r4, r0
		if (data) {
   24c5e:	b12d      	cbz	r5, 24c6c <ring_buf_get+0x26>
			memcpy(data, src, partial_size);
   24c60:	4602      	mov	r2, r0
   24c62:	9901      	ldr	r1, [sp, #4]
   24c64:	4628      	mov	r0, r5
   24c66:	f000 f9b4 	bl	24fd2 <memcpy>
			data += partial_size;
   24c6a:	4425      	add	r5, r4
		}
		total_size += partial_size;
		size -= partial_size;
	} while (size && partial_size);
   24c6c:	1b36      	subs	r6, r6, r4
		total_size += partial_size;
   24c6e:	4427      	add	r7, r4
	} while (size && partial_size);
   24c70:	d001      	beq.n	24c76 <ring_buf_get+0x30>
   24c72:	2c00      	cmp	r4, #0
   24c74:	d1ed      	bne.n	24c52 <ring_buf_get+0xc>

	err = ring_buf_get_finish(buf, total_size);
   24c76:	4639      	mov	r1, r7
   24c78:	4640      	mov	r0, r8
   24c7a:	f7ff ffcf 	bl	24c1c <ring_buf_get_finish>
	__ASSERT_NO_MSG(err == 0);
	ARG_UNUSED(err);

	return total_size;
}
   24c7e:	4638      	mov	r0, r7
   24c80:	b002      	add	sp, #8
   24c82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00024c86 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_MCUBOOT_SIGNATURE_KEY_FILE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_MCUBOOT_EXTRA_IMGTOOL_ARGS, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_MCUBOOT_BOOTLOADER_MODE_SWAP_WITHOUT_SCRATCH, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   24c86:	4770      	bx	lr

00024c88 <nordicsemi_nrf53_init>:
{
   24c88:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   24c8a:	f04f 0320 	mov.w	r3, #32
   24c8e:	f3ef 8511 	mrs	r5, BASEPRI
   24c92:	f383 8812 	msr	BASEPRI_MAX, r3
   24c96:	f3bf 8f6f 	isb	sy
}

NRF_STATIC_INLINE void nrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS_Type *     p_reg,
                                                    nrf_oscillators_lfxo_cap_t cap)
{
    p_reg->XOSC32KI.INTCAP = (uint32_t)cap;
   24c9a:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   24c9e:	2401      	movs	r4, #1
   24ca0:	2202      	movs	r2, #2
		soc_secure_gpio_pin_mcu_select(forwarded_psels[i], NRF_GPIO_PIN_SEL_NETWORK);
   24ca2:	4621      	mov	r1, r4
   24ca4:	f8c3 26d0 	str.w	r2, [r3, #1744]	; 0x6d0
   24ca8:	202b      	movs	r0, #43	; 0x2b
   24caa:	f8c3 4704 	str.w	r4, [r3, #1796]	; 0x704
#endif

#if NRF_REGULATORS_HAS_DCDCEN_RADIO
NRF_STATIC_INLINE void nrf_regulators_dcdcen_radio_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
    p_reg->VREGRADIO.DCDCEN = (enable) ? REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Enabled :
   24cae:	f8c3 4904 	str.w	r4, [r3, #2308]	; 0x904
    p_reg->VREGH.DCDCEN = (enable) ? REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled :
   24cb2:	f8c3 4b00 	str.w	r4, [r3, #2816]	; 0xb00
   24cb6:	f000 f824 	bl	24d02 <soc_secure_gpio_pin_mcu_select>
   24cba:	4621      	mov	r1, r4
   24cbc:	202c      	movs	r0, #44	; 0x2c
   24cbe:	f000 f820 	bl	24d02 <soc_secure_gpio_pin_mcu_select>
   24cc2:	4621      	mov	r1, r4
   24cc4:	202a      	movs	r0, #42	; 0x2a
   24cc6:	f000 f81c 	bl	24d02 <soc_secure_gpio_pin_mcu_select>
   24cca:	4621      	mov	r1, r4
   24ccc:	201e      	movs	r0, #30
   24cce:	f000 f818 	bl	24d02 <soc_secure_gpio_pin_mcu_select>
	__asm__ volatile(
   24cd2:	f385 8811 	msr	BASEPRI, r5
   24cd6:	f3bf 8f6f 	isb	sy
}
   24cda:	2000      	movs	r0, #0
   24cdc:	bd38      	pop	{r3, r4, r5, pc}

00024cde <pm_state_set>:
/* Invoke Low Power/System Off specific Tasks */
__weak void pm_state_set(enum pm_state state, uint8_t substate_id)
{
	ARG_UNUSED(substate_id);

	switch (state) {
   24cde:	2806      	cmp	r0, #6
   24ce0:	d108      	bne.n	24cf4 <pm_state_set+0x16>
    p_reg->SYSTEMOFF = REGULATORS_SYSTEMOFF_SYSTEMOFF_Msk;
   24ce2:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
   24ce6:	2201      	movs	r2, #1
   24ce8:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
   24cec:	f3bf 8f4f 	dsb	sy
        __WFE();
   24cf0:	bf20      	wfe
    while (true)
   24cf2:	e7fd      	b.n	24cf0 <pm_state_set+0x12>
		break;
	default:
		LOG_DBG("Unsupported power state %u", state);
		break;
	}
}
   24cf4:	4770      	bx	lr

00024cf6 <pm_state_exit_post_ops>:
   24cf6:	2300      	movs	r3, #0
   24cf8:	f383 8811 	msr	BASEPRI, r3
   24cfc:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
   24d00:	4770      	bx	lr

00024d02 <soc_secure_gpio_pin_mcu_select>:
#include "tfm_platform_api.h"
#include "tfm_ioctl_api.h"

#if NRF_GPIO_HAS_SEL
void soc_secure_gpio_pin_mcu_select(uint32_t pin_number, nrf_gpio_pin_sel_t mcu)
{
   24d02:	b507      	push	{r0, r1, r2, lr}
	uint32_t result;
	enum tfm_platform_err_t err;

	err = tfm_platform_gpio_pin_mcu_select(pin_number, mcu, &result);
   24d04:	aa01      	add	r2, sp, #4
   24d06:	f000 fd65 	bl	257d4 <tfm_platform_gpio_pin_mcu_select>
	__ASSERT(err == TFM_PLATFORM_ERR_SUCCESS, "TFM platform error (%d)", err);
	__ASSERT(result == 0, "GPIO service error (%d)", result);
}
   24d0a:	b003      	add	sp, #12
   24d0c:	f85d fb04 	ldr.w	pc, [sp], #4

00024d10 <soc_secure_mem_read>:
#endif /* NRF_GPIO_HAS_SEL */

int soc_secure_mem_read(void *dst, void *src, size_t len)
{
   24d10:	b507      	push	{r0, r1, r2, lr}
	enum tfm_platform_err_t status;
	uint32_t result;

	status = tfm_platform_mem_read(dst, (uintptr_t)src, len, &result);
   24d12:	ab01      	add	r3, sp, #4
   24d14:	f000 fd46 	bl	257a4 <tfm_platform_mem_read>

	switch (status) {
   24d18:	2802      	cmp	r0, #2
   24d1a:	d00a      	beq.n	24d32 <soc_secure_mem_read+0x22>
   24d1c:	2803      	cmp	r0, #3
   24d1e:	d00b      	beq.n	24d38 <soc_secure_mem_read+0x28>
   24d20:	b968      	cbnz	r0, 24d3e <soc_secure_mem_read+0x2e>
	case TFM_PLATFORM_ERR_INVALID_PARAM:
		return -EINVAL;
	case TFM_PLATFORM_ERR_NOT_SUPPORTED:
		return -ENOTSUP;
	case TFM_PLATFORM_ERR_SUCCESS:
		if (result == 0) {
   24d22:	9801      	ldr	r0, [sp, #4]
   24d24:	3800      	subs	r0, #0
   24d26:	bf18      	it	ne
   24d28:	2001      	movne	r0, #1
   24d2a:	4240      	negs	r0, r0
		}
		/* Fallthrough */
	default:
		return -EPERM;
	}
}
   24d2c:	b003      	add	sp, #12
   24d2e:	f85d fb04 	ldr.w	pc, [sp], #4
		return -EINVAL;
   24d32:	f06f 0015 	mvn.w	r0, #21
   24d36:	e7f9      	b.n	24d2c <soc_secure_mem_read+0x1c>
	switch (status) {
   24d38:	f06f 0085 	mvn.w	r0, #133	; 0x85
   24d3c:	e7f6      	b.n	24d2c <soc_secure_mem_read+0x1c>
		return -EPERM;
   24d3e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24d42:	e7f3      	b.n	24d2c <soc_secure_mem_read+0x1c>

00024d44 <get_ep_bm_from_addr>:
	if (ep_idx > 15) {
   24d44:	f010 0f70 	tst.w	r0, #112	; 0x70
   24d48:	d109      	bne.n	24d5e <get_ep_bm_from_addr+0x1a>
	ep_idx = ep & (~USB_EP_DIR_IN);
   24d4a:	f000 037f 	and.w	r3, r0, #127	; 0x7f
	if (ep & USB_EP_DIR_IN) {
   24d4e:	f010 0f80 	tst.w	r0, #128	; 0x80
   24d52:	f04f 0001 	mov.w	r0, #1
		ep_bm = BIT(ep_idx + 16);
   24d56:	bf18      	it	ne
   24d58:	3310      	addne	r3, #16
		ep_bm = BIT(ep_idx);
   24d5a:	4098      	lsls	r0, r3
   24d5c:	4770      	bx	lr
	uint32_t ep_bm = 0;
   24d5e:	2000      	movs	r0, #0
}
   24d60:	4770      	bx	lr

00024d62 <usb_write>:
{
   24d62:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   24d66:	4606      	mov	r6, r0
   24d68:	460f      	mov	r7, r1
   24d6a:	4690      	mov	r8, r2
   24d6c:	4699      	mov	r9, r3
   24d6e:	2504      	movs	r5, #4
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   24d70:	464b      	mov	r3, r9
   24d72:	4642      	mov	r2, r8
   24d74:	4639      	mov	r1, r7
   24d76:	4630      	mov	r0, r6
   24d78:	f7fa fbb8 	bl	1f4ec <usb_dc_ep_write>
		if (ret == -EAGAIN) {
   24d7c:	f110 0f0b 	cmn.w	r0, #11
		ret = usb_dc_ep_write(ep, data, data_len, bytes_ret);
   24d80:	4604      	mov	r4, r0
		if (ret == -EAGAIN) {
   24d82:	d103      	bne.n	24d8c <usb_write+0x2a>
	z_impl_k_yield();
   24d84:	f7fe ffd2 	bl	23d2c <z_impl_k_yield>
	} while (ret == -EAGAIN && tries--);
   24d88:	3d01      	subs	r5, #1
   24d8a:	d1f1      	bne.n	24d70 <usb_write+0xe>
}
   24d8c:	4620      	mov	r0, r4
   24d8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00024d92 <usb_get_dev_data_by_cfg>:
	return list->head;
   24d92:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_cfg(sys_slist_t *list,
					     struct usb_cfg_data *cfg)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24d94:	b138      	cbz	r0, 24da6 <usb_get_dev_data_by_cfg+0x14>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg_cur = dev->config;
   24d96:	f850 3c04 	ldr.w	r3, [r0, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24d9a:	3804      	subs	r0, #4

		if (cfg_cur == cfg) {
   24d9c:	685b      	ldr	r3, [r3, #4]
   24d9e:	428b      	cmp	r3, r1
   24da0:	d001      	beq.n	24da6 <usb_get_dev_data_by_cfg+0x14>
	return node->next;
   24da2:	6840      	ldr	r0, [r0, #4]
   24da4:	e7f6      	b.n	24d94 <usb_get_dev_data_by_cfg+0x2>
	}

	LOG_DBG("Device data not found for cfg %p", cfg);

	return NULL;
}
   24da6:	4770      	bx	lr

00024da8 <usb_get_dev_data_by_iface>:
	return list->head;
   24da8:	6800      	ldr	r0, [r0, #0]
struct usb_dev_data *usb_get_dev_data_by_iface(sys_slist_t *list,
					       uint8_t iface_num)
{
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24daa:	b148      	cbz	r0, 24dc0 <usb_get_dev_data_by_iface+0x18>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
   24dac:	f850 3c04 	ldr.w	r3, [r0, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24db0:	3804      	subs	r0, #4
		const struct usb_if_descriptor *if_desc =
   24db2:	685b      	ldr	r3, [r3, #4]
						cfg->interface_descriptor;

		if (if_desc->bInterfaceNumber == iface_num) {
   24db4:	685b      	ldr	r3, [r3, #4]
   24db6:	789b      	ldrb	r3, [r3, #2]
   24db8:	428b      	cmp	r3, r1
   24dba:	d001      	beq.n	24dc0 <usb_get_dev_data_by_iface+0x18>
	return node->next;
   24dbc:	6840      	ldr	r0, [r0, #4]
   24dbe:	e7f4      	b.n	24daa <usb_get_dev_data_by_iface+0x2>
	}

	LOG_DBG("Device data not found for iface number %u", iface_num);

	return NULL;
}
   24dc0:	4770      	bx	lr

00024dc2 <usb_get_dev_data_by_ep>:

struct usb_dev_data *usb_get_dev_data_by_ep(sys_slist_t *list, uint8_t ep)
{
   24dc2:	b530      	push	{r4, r5, lr}
	return list->head;
   24dc4:	6800      	ldr	r0, [r0, #0]
	struct usb_dev_data *dev_data;

	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dc6:	b188      	cbz	r0, 24dec <usb_get_dev_data_by_ep+0x2a>
		const struct device *dev = dev_data->dev;
		const struct usb_cfg_data *cfg = dev->config;
   24dc8:	f850 3c04 	ldr.w	r3, [r0, #-4]
	SYS_SLIST_FOR_EACH_CONTAINER(list, dev_data, node) {
   24dcc:	3804      	subs	r0, #4
		const struct usb_cfg_data *cfg = dev->config;
   24dce:	685b      	ldr	r3, [r3, #4]
		const struct usb_ep_cfg_data *ep_data = cfg->endpoint;
   24dd0:	6a1a      	ldr	r2, [r3, #32]

		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
   24dd2:	7f1d      	ldrb	r5, [r3, #28]
   24dd4:	2300      	movs	r3, #0
			if (ep_data[i].ep_addr == ep) {
   24dd6:	3a04      	subs	r2, #4
		for (uint8_t i = 0; i < cfg->num_endpoints; i++) {
   24dd8:	b2dc      	uxtb	r4, r3
   24dda:	42a5      	cmp	r5, r4
   24ddc:	d801      	bhi.n	24de2 <usb_get_dev_data_by_ep+0x20>
	return node->next;
   24dde:	6840      	ldr	r0, [r0, #4]
   24de0:	e7f1      	b.n	24dc6 <usb_get_dev_data_by_ep+0x4>
			if (ep_data[i].ep_addr == ep) {
   24de2:	3301      	adds	r3, #1
   24de4:	f812 4033 	ldrb.w	r4, [r2, r3, lsl #3]
   24de8:	428c      	cmp	r4, r1
   24dea:	d1f5      	bne.n	24dd8 <usb_get_dev_data_by_ep+0x16>
	}

	LOG_DBG("Device data not found for ep %u", ep);

	return NULL;
}
   24dec:	bd30      	pop	{r4, r5, pc}

00024dee <usb_transfer_is_busy>:
{
   24dee:	b508      	push	{r3, lr}
	struct usb_transfer_data *trans = usb_ep_get_transfer(ep);
   24df0:	f7f8 fee0 	bl	1dbb4 <usb_ep_get_transfer>
	if (trans && trans->status == -EBUSY) {
   24df4:	b128      	cbz	r0, 24e02 <usb_transfer_is_busy+0x14>
   24df6:	6840      	ldr	r0, [r0, #4]
   24df8:	f110 0f10 	cmn.w	r0, #16
   24dfc:	bf14      	ite	ne
   24dfe:	2000      	movne	r0, #0
   24e00:	2001      	moveq	r0, #1
}
   24e02:	bd08      	pop	{r3, pc}

00024e04 <cdc_interface_config>:
	desc->if1.bInterfaceNumber = bInterfaceNumber + 1;
   24e04:	1c4b      	adds	r3, r1, #1
   24e06:	b2db      	uxtb	r3, r3
	desc->if0.bInterfaceNumber = bInterfaceNumber;
   24e08:	7081      	strb	r1, [r0, #2]
	desc->if0_union.bControlInterface = bInterfaceNumber;
   24e0a:	7681      	strb	r1, [r0, #26]
	desc->if1.bInterfaceNumber = bInterfaceNumber + 1;
   24e0c:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
	desc->if0_union.bSubordinateInterface0 = bInterfaceNumber + 1;
   24e10:	76c3      	strb	r3, [r0, #27]
	desc->iad_cdc.bFirstInterface = bInterfaceNumber;
   24e12:	f800 1c06 	strb.w	r1, [r0, #-6]
}
   24e16:	4770      	bx	lr

00024e18 <cdc_acm_irq_callback_work_handler>:
	dev_data->cb(dev_data->common.dev, dev_data->cb_data);
   24e18:	e950 3102 	ldrd	r3, r1, [r0, #-8]
   24e1c:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
   24e20:	4718      	bx	r3

00024e22 <cdc_acm_irq_tx_disable>:
	dev_data->tx_irq_ena = false;
   24e22:	2200      	movs	r2, #0
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e24:	6903      	ldr	r3, [r0, #16]
	dev_data->tx_irq_ena = false;
   24e26:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
}
   24e2a:	4770      	bx	lr

00024e2c <cdc_acm_irq_tx_ready>:
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e2c:	6903      	ldr	r3, [r0, #16]
	if (dev_data->tx_irq_ena && dev_data->tx_ready) {
   24e2e:	f893 004a 	ldrb.w	r0, [r3, #74]	; 0x4a
   24e32:	b108      	cbz	r0, 24e38 <cdc_acm_irq_tx_ready+0xc>
   24e34:	f893 0048 	ldrb.w	r0, [r3, #72]	; 0x48
}
   24e38:	4770      	bx	lr

00024e3a <cdc_acm_irq_rx_disable>:
	dev_data->rx_irq_ena = false;
   24e3a:	2200      	movs	r2, #0
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e3c:	6903      	ldr	r3, [r0, #16]
	dev_data->rx_irq_ena = false;
   24e3e:	f883 204b 	strb.w	r2, [r3, #75]	; 0x4b
}
   24e42:	4770      	bx	lr

00024e44 <cdc_acm_irq_rx_ready>:
	if (dev_data->rx_ready) {
   24e44:	6903      	ldr	r3, [r0, #16]
}
   24e46:	f893 0049 	ldrb.w	r0, [r3, #73]	; 0x49
   24e4a:	4770      	bx	lr

00024e4c <cdc_acm_irq_is_pending>:
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e4c:	6903      	ldr	r3, [r0, #16]
	if (dev_data->tx_ready && dev_data->tx_irq_ena) {
   24e4e:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
   24e52:	b112      	cbz	r2, 24e5a <cdc_acm_irq_is_pending+0xe>
   24e54:	f893 204a 	ldrb.w	r2, [r3, #74]	; 0x4a
   24e58:	b92a      	cbnz	r2, 24e66 <cdc_acm_irq_is_pending+0x1a>
	} else if (dev_data->rx_ready && dev_data->rx_irq_ena) {
   24e5a:	f893 0049 	ldrb.w	r0, [r3, #73]	; 0x49
   24e5e:	b118      	cbz	r0, 24e68 <cdc_acm_irq_is_pending+0x1c>
   24e60:	f893 004b 	ldrb.w	r0, [r3, #75]	; 0x4b
   24e64:	4770      	bx	lr
		return 1;
   24e66:	2001      	movs	r0, #1
}
   24e68:	4770      	bx	lr

00024e6a <cdc_acm_irq_update>:
}
   24e6a:	2001      	movs	r0, #1
   24e6c:	4770      	bx	lr

00024e6e <cdc_acm_irq_callback_set>:
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e6e:	6903      	ldr	r3, [r0, #16]
	dev_data->cb_data = cb_data;
   24e70:	e9c3 1200 	strd	r1, r2, [r3]
}
   24e74:	4770      	bx	lr

00024e76 <cdc_acm_configure>:
}
   24e76:	2000      	movs	r0, #0
   24e78:	4770      	bx	lr

00024e7a <cdc_acm_config_get>:
{
   24e7a:	b510      	push	{r4, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24e7c:	6903      	ldr	r3, [r0, #16]
	cfg->baudrate = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
   24e7e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
   24e82:	600a      	str	r2, [r1, #0]
	switch (dev_data->line_coding.bCharFormat) {
   24e84:	f893 2098 	ldrb.w	r2, [r3, #152]	; 0x98
   24e88:	b16a      	cbz	r2, 24ea6 <cdc_acm_config_get+0x2c>
   24e8a:	2a01      	cmp	r2, #1
   24e8c:	bf0c      	ite	eq
   24e8e:	2202      	moveq	r2, #2
   24e90:	2203      	movne	r2, #3
		cfg->stop_bits = UART_CFG_STOP_BITS_1;
   24e92:	714a      	strb	r2, [r1, #5]
	switch (dev_data->line_coding.bParityType) {
   24e94:	f893 2099 	ldrb.w	r2, [r3, #153]	; 0x99
   24e98:	1e50      	subs	r0, r2, #1
   24e9a:	2803      	cmp	r0, #3
   24e9c:	d805      	bhi.n	24eaa <cdc_acm_config_get+0x30>
   24e9e:	e8df f000 	tbb	[pc, r0]
   24ea2:	0505      	.short	0x0505
   24ea4:	0505      	.short	0x0505
	switch (dev_data->line_coding.bCharFormat) {
   24ea6:	2201      	movs	r2, #1
   24ea8:	e7f3      	b.n	24e92 <cdc_acm_config_get+0x18>
	switch (dev_data->line_coding.bParityType) {
   24eaa:	2200      	movs	r2, #0
		cfg->parity = UART_CFG_PARITY_NONE;
   24eac:	710a      	strb	r2, [r1, #4]
	switch (dev_data->line_coding.bDataBits) {
   24eae:	f893 309a 	ldrb.w	r3, [r3, #154]	; 0x9a
   24eb2:	2b06      	cmp	r3, #6
   24eb4:	d009      	beq.n	24eca <cdc_acm_config_get+0x50>
   24eb6:	2b07      	cmp	r3, #7
   24eb8:	d009      	beq.n	24ece <cdc_acm_config_get+0x54>
   24eba:	2b05      	cmp	r3, #5
   24ebc:	bf0c      	ite	eq
   24ebe:	2300      	moveq	r3, #0
   24ec0:	2303      	movne	r3, #3
	cfg->flow_ctrl = UART_CFG_FLOW_CTRL_NONE;
   24ec2:	2000      	movs	r0, #0
		cfg->data_bits = UART_CFG_DATA_BITS_5;
   24ec4:	718b      	strb	r3, [r1, #6]
	cfg->flow_ctrl = UART_CFG_FLOW_CTRL_NONE;
   24ec6:	71c8      	strb	r0, [r1, #7]
}
   24ec8:	bd10      	pop	{r4, pc}
	switch (dev_data->line_coding.bDataBits) {
   24eca:	2301      	movs	r3, #1
   24ecc:	e7f9      	b.n	24ec2 <cdc_acm_config_get+0x48>
   24ece:	2302      	movs	r3, #2
   24ed0:	e7f7      	b.n	24ec2 <cdc_acm_config_get+0x48>

00024ed2 <cdc_acm_fifo_read>:
{
   24ed2:	b570      	push	{r4, r5, r6, lr}
	struct cdc_acm_dev_data_t * const dev_data = dev->data;
   24ed4:	6904      	ldr	r4, [r0, #16]
{
   24ed6:	4605      	mov	r5, r0
	len = ring_buf_get(dev_data->rx_ringbuf, rx_data, size);
   24ed8:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   24edc:	f7ff feb3 	bl	24c46 <ring_buf_get>
	if (ring_buf_is_empty(dev_data->rx_ringbuf)) {
   24ee0:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
	len = ring_buf_get(dev_data->rx_ringbuf, rx_data, size);
   24ee4:	4606      	mov	r6, r0
	if (ring_buf_is_empty(dev_data->rx_ringbuf)) {
   24ee6:	691a      	ldr	r2, [r3, #16]
   24ee8:	6899      	ldr	r1, [r3, #8]
   24eea:	4291      	cmp	r1, r2
		dev_data->rx_ready = false;
   24eec:	bf04      	itt	eq
   24eee:	2200      	moveq	r2, #0
   24ef0:	f884 2049 	strbeq.w	r2, [r4, #73]	; 0x49
	if (dev_data->rx_paused == true) {
   24ef4:	f894 20a0 	ldrb.w	r2, [r4, #160]	; 0xa0
   24ef8:	b19a      	cbz	r2, 24f22 <cdc_acm_fifo_read+0x50>
	return buf->size - (buf->put_head - buf->get_tail);
   24efa:	685a      	ldr	r2, [r3, #4]
   24efc:	6959      	ldr	r1, [r3, #20]
   24efe:	69db      	ldr	r3, [r3, #28]
   24f00:	1a52      	subs	r2, r2, r1
   24f02:	1a9b      	subs	r3, r3, r2
		if (ring_buf_space_get(dev_data->rx_ringbuf) >= CDC_ACM_BUFFER_SIZE) {
   24f04:	2b3f      	cmp	r3, #63	; 0x3f
   24f06:	d90c      	bls.n	24f22 <cdc_acm_fifo_read+0x50>
			if (dev_data->configured) {
   24f08:	f894 309e 	ldrb.w	r3, [r4, #158]	; 0x9e
   24f0c:	b133      	cbz	r3, 24f1c <cdc_acm_fifo_read+0x4a>
				cdc_acm_read_cb(cfg->endpoint[ACM_OUT_EP_IDX].ep_addr, 0, dev_data);
   24f0e:	686b      	ldr	r3, [r5, #4]
   24f10:	4622      	mov	r2, r4
   24f12:	6a1b      	ldr	r3, [r3, #32]
   24f14:	2100      	movs	r1, #0
   24f16:	7b18      	ldrb	r0, [r3, #12]
   24f18:	f7f9 f91a 	bl	1e150 <cdc_acm_read_cb>
			dev_data->rx_paused = false;
   24f1c:	2300      	movs	r3, #0
   24f1e:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
}
   24f22:	4630      	mov	r0, r6
   24f24:	bd70      	pop	{r4, r5, r6, pc}

00024f26 <cdc_acm_poll_in>:
	int ret = cdc_acm_fifo_read(dev, c, 1);
   24f26:	2201      	movs	r2, #1
{
   24f28:	b508      	push	{r3, lr}
	int ret = cdc_acm_fifo_read(dev, c, 1);
   24f2a:	f7ff ffd2 	bl	24ed2 <cdc_acm_fifo_read>
}
   24f2e:	3801      	subs	r0, #1
   24f30:	bf18      	it	ne
   24f32:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   24f36:	bd08      	pop	{r3, pc}

00024f38 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   24f38:	f000 bdcf 	b.w	25ada <z_fatal_error>

00024f3c <z_do_kernel_oops>:
 *
 * @param esf exception frame
 * @param callee_regs Callee-saved registers (R4-R11)
 */
void z_do_kernel_oops(const z_arch_esf_t *esf, _callee_saved_t *callee_regs)
{
   24f3c:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
   24f3e:	6800      	ldr	r0, [r0, #0]
   24f40:	f000 bdcb 	b.w	25ada <z_fatal_error>

00024f44 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   24f44:	2100      	movs	r1, #0
   24f46:	2001      	movs	r0, #1
   24f48:	f7ff bff6 	b.w	24f38 <z_arm_fatal_error>

00024f4c <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
   24f4c:	b508      	push	{r3, lr}
	handler();
   24f4e:	f7f9 fa05 	bl	1e35c <z_SysNmiOnReset>
	z_arm_int_exit();
}
   24f52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   24f56:	f7f9 bacd 	b.w	1e4f4 <z_arm_exc_exit>

00024f5a <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   24f5a:	6e43      	ldr	r3, [r0, #100]	; 0x64
   24f5c:	f383 880b 	msr	PSPLIM, r3
}
   24f60:	4770      	bx	lr

00024f62 <z_arm_save_fp_context>:
		 * here though, since FPCA should have no impact on instruction
		 * fetching.
		 */
	}
#endif
}
   24f62:	4770      	bx	lr

00024f64 <z_arm_restore_fp_context>:

void z_arm_restore_fp_context(const struct fpu_ctx_full *buffer)
   24f64:	4770      	bx	lr

00024f66 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   24f66:	e840 f300 	tt	r3, r0
int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
		return addr_info.flags.mpu_region;
   24f6a:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   24f6e:	b2d8      	uxtb	r0, r3
	}

	return -EINVAL;
}
   24f70:	bf08      	it	eq
   24f72:	f06f 0015 	mvneq.w	r0, #21
   24f76:	4770      	bx	lr

00024f78 <mpu_configure_region>:
{
   24f78:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	p_attr->rbar = attr->rbar &
   24f7a:	890a      	ldrh	r2, [r1, #8]
   24f7c:	894e      	ldrh	r6, [r1, #10]
	region_conf.base = new_region->start;
   24f7e:	680b      	ldr	r3, [r1, #0]
		&new_region->attr, new_region->start, new_region->size);
   24f80:	684d      	ldr	r5, [r1, #4]
   24f82:	f002 021f 	and.w	r2, r2, #31
   24f86:	ea42 1246 	orr.w	r2, r2, r6, lsl #5
	region_conf.base = new_region->start;
   24f8a:	9300      	str	r3, [sp, #0]
   24f8c:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   24f90:	f023 031f 	bic.w	r3, r3, #31
   24f94:	1e6a      	subs	r2, r5, #1
   24f96:	4413      	add	r3, r2
   24f98:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1U)) {
   24f9c:	2807      	cmp	r0, #7
   24f9e:	9303      	str	r3, [sp, #12]
   24fa0:	d804      	bhi.n	24fac <mpu_configure_region+0x34>
	region_init(index, region_conf);
   24fa2:	4669      	mov	r1, sp
   24fa4:	f7f9 fcb4 	bl	1e910 <region_init>
}
   24fa8:	b004      	add	sp, #16
   24faa:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   24fac:	f06f 0015 	mvn.w	r0, #21
	return region_allocate_and_init(index,
   24fb0:	e7fa      	b.n	24fa8 <mpu_configure_region+0x30>

00024fb2 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   24fb2:	4603      	mov	r3, r0
	size_t n = 0;
   24fb4:	2000      	movs	r0, #0

	while (*s != '\0') {
   24fb6:	5c1a      	ldrb	r2, [r3, r0]
   24fb8:	b902      	cbnz	r2, 24fbc <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   24fba:	4770      	bx	lr
		n++;
   24fbc:	3001      	adds	r0, #1
   24fbe:	e7fa      	b.n	24fb6 <strlen+0x4>

00024fc0 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   24fc0:	4603      	mov	r3, r0
	size_t n = 0;
   24fc2:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   24fc4:	5c1a      	ldrb	r2, [r3, r0]
   24fc6:	b10a      	cbz	r2, 24fcc <strnlen+0xc>
   24fc8:	4288      	cmp	r0, r1
   24fca:	d100      	bne.n	24fce <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   24fcc:	4770      	bx	lr
		n++;
   24fce:	3001      	adds	r0, #1
   24fd0:	e7f8      	b.n	24fc4 <strnlen+0x4>

00024fd2 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
   24fd2:	b510      	push	{r4, lr}
   24fd4:	1e43      	subs	r3, r0, #1
   24fd6:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
   24fd8:	4291      	cmp	r1, r2
   24fda:	d100      	bne.n	24fde <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   24fdc:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
   24fde:	f811 4b01 	ldrb.w	r4, [r1], #1
   24fe2:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   24fe6:	e7f7      	b.n	24fd8 <memcpy+0x6>

00024fe8 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   24fe8:	4603      	mov	r3, r0
	unsigned char c_byte = (unsigned char)c;
   24fea:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
   24fec:	4402      	add	r2, r0
   24fee:	4293      	cmp	r3, r2
   24ff0:	d100      	bne.n	24ff4 <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   24ff2:	4770      	bx	lr
		*(d_byte++) = c_byte;
   24ff4:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   24ff8:	e7f9      	b.n	24fee <memset+0x6>

00024ffa <_stdout_hook_default>:
}
   24ffa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24ffe:	4770      	bx	lr

00025000 <ep_ctx_reset>:
{
   25000:	b510      	push	{r4, lr}
	ep_ctx->buf.data = ep_ctx->buf.block.data;
   25002:	6903      	ldr	r3, [r0, #16]
{
   25004:	4604      	mov	r4, r0
	ep_ctx->buf.curr = ep_ctx->buf.data;
   25006:	e9c0 3305 	strd	r3, r3, [r0, #20]
	ep_ctx->buf.len  = 0U;
   2500a:	2300      	movs	r3, #0
   2500c:	60c3      	str	r3, [r0, #12]
	if (ep_ctx->write_in_progress) {
   2500e:	7f83      	ldrb	r3, [r0, #30]
   25010:	b113      	cbz	r3, 25018 <ep_ctx_reset+0x18>
		nrfx_usbd_ep_abort(ep_addr_to_nrfx(ep_ctx->cfg.addr));
   25012:	7a40      	ldrb	r0, [r0, #9]
   25014:	f000 fd47 	bl	25aa6 <nrfx_usbd_ep_abort>
	ep_ctx->read_complete = true;
   25018:	2301      	movs	r3, #1
   2501a:	7723      	strb	r3, [r4, #28]
	ep_ctx->read_pending = false;
   2501c:	2300      	movs	r3, #0
   2501e:	7763      	strb	r3, [r4, #29]
	ep_ctx->trans_zlp = false;
   25020:	77e3      	strb	r3, [r4, #31]
	ep_ctx->write_in_progress = false;
   25022:	77a3      	strb	r3, [r4, #30]
}
   25024:	bd10      	pop	{r4, pc}

00025026 <attached_evt_delay_handler>:
	submit_dc_power_event(USBD_ATTACHED);
   25026:	2001      	movs	r0, #1
   25028:	f7f9 be58 	b.w	1ecdc <submit_dc_power_event>

0002502c <k_mutex_lock.constprop.0.isra.0>:
	return z_impl_k_mutex_lock(mutex, timeout);
   2502c:	f7fe b996 	b.w	2335c <z_impl_k_mutex_lock>

00025030 <k_mutex_unlock.isra.0>:
	return z_impl_k_mutex_unlock(mutex);
   25030:	f7fe ba0e 	b.w	23450 <z_impl_k_mutex_unlock>

00025034 <usb_dc_ep_check_cap>:
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
   25034:	7803      	ldrb	r3, [r0, #0]
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
   25036:	7901      	ldrb	r1, [r0, #4]
	uint8_t ep_idx = NRF_USBD_EP_NR_GET(ep_cfg->ep_addr);
   25038:	f003 020f 	and.w	r2, r3, #15
	if ((ep_cfg->ep_type == USB_DC_EP_CONTROL) && ep_idx) {
   2503c:	b921      	cbnz	r1, 25048 <usb_dc_ep_check_cap+0x14>
   2503e:	3a00      	subs	r2, #0
   25040:	bf18      	it	ne
   25042:	2201      	movne	r2, #1
   25044:	4250      	negs	r0, r2
   25046:	4770      	bx	lr
	if (!NRF_USBD_EP_VALIDATE(ep_cfg->ep_addr)) {
   25048:	2a08      	cmp	r2, #8
   2504a:	d806      	bhi.n	2505a <usb_dc_ep_check_cap+0x26>
	if ((ep_cfg->ep_type == USB_DC_EP_ISOCHRONOUS) &&
   2504c:	2901      	cmp	r1, #1
   2504e:	d107      	bne.n	25060 <usb_dc_ep_check_cap+0x2c>
   25050:	f083 0008 	eor.w	r0, r3, #8
   25054:	f340 00c0 	sbfx	r0, r0, #3, #1
   25058:	4770      	bx	lr
		return -1;
   2505a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2505e:	4770      	bx	lr
	return 0;
   25060:	2000      	movs	r0, #0
}
   25062:	4770      	bx	lr

00025064 <usb_dc_ep_disable>:
{
   25064:	b538      	push	{r3, r4, r5, lr}
   25066:	4604      	mov	r4, r0
	ep_ctx = endpoint_ctx(ep);
   25068:	f7f9 fdd0 	bl	1ec0c <endpoint_ctx>
	if (!ep_ctx) {
   2506c:	4605      	mov	r5, r0
   2506e:	b160      	cbz	r0, 2508a <usb_dc_ep_disable+0x26>
	if (!ep_ctx->cfg.en) {
   25070:	7a03      	ldrb	r3, [r0, #8]
   25072:	b16b      	cbz	r3, 25090 <usb_dc_ep_disable+0x2c>
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
   25074:	4620      	mov	r0, r4
	ep_ctx->write_in_progress = false;
   25076:	2400      	movs	r4, #0
	nrfx_usbd_ep_disable(ep_addr_to_nrfx(ep));
   25078:	f7fd fe0a 	bl	22c90 <nrfx_usbd_ep_disable>
	ep_ctx_reset(ep_ctx);
   2507c:	4628      	mov	r0, r5
	ep_ctx->write_in_progress = false;
   2507e:	77ac      	strb	r4, [r5, #30]
	ep_ctx_reset(ep_ctx);
   25080:	f7ff ffbe 	bl	25000 <ep_ctx_reset>
	return 0;
   25084:	4620      	mov	r0, r4
	ep_ctx->cfg.en = false;
   25086:	722c      	strb	r4, [r5, #8]
}
   25088:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   2508a:	f06f 0015 	mvn.w	r0, #21
   2508e:	e7fb      	b.n	25088 <usb_dc_ep_disable+0x24>
		return -EALREADY;
   25090:	f06f 0077 	mvn.w	r0, #119	; 0x77
   25094:	e7f8      	b.n	25088 <usb_dc_ep_disable+0x24>

00025096 <usb_dc_ep_read>:
{
   25096:	b570      	push	{r4, r5, r6, lr}
   25098:	4604      	mov	r4, r0
   2509a:	460e      	mov	r6, r1
   2509c:	4615      	mov	r5, r2
	ret = usb_dc_ep_read_wait(ep, data, max_data_len, read_bytes);
   2509e:	f7fa faa1 	bl	1f5e4 <usb_dc_ep_read_wait>
	if (ret) {
   250a2:	b930      	cbnz	r0, 250b2 <usb_dc_ep_read+0x1c>
	if (!data && !max_data_len) {
   250a4:	b906      	cbnz	r6, 250a8 <usb_dc_ep_read+0x12>
   250a6:	b125      	cbz	r5, 250b2 <usb_dc_ep_read+0x1c>
	ret = usb_dc_ep_read_continue(ep);
   250a8:	4620      	mov	r0, r4
}
   250aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = usb_dc_ep_read_continue(ep);
   250ae:	f7fa bae1 	b.w	1f674 <usb_dc_ep_read_continue>
}
   250b2:	bd70      	pop	{r4, r5, r6, pc}

000250b4 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   250b4:	220c      	movs	r2, #12
   250b6:	6903      	ldr	r3, [r0, #16]
   250b8:	b2c9      	uxtb	r1, r1
   250ba:	fb01 3302 	mla	r3, r1, r2, r3
   250be:	6f98      	ldr	r0, [r3, #120]	; 0x78
}
   250c0:	f000 0007 	and.w	r0, r0, #7
   250c4:	4770      	bx	lr

000250c6 <set_on_state>:
	__asm__ volatile(
   250c6:	f04f 0320 	mov.w	r3, #32
   250ca:	f3ef 8211 	mrs	r2, BASEPRI
   250ce:	f383 8812 	msr	BASEPRI_MAX, r3
   250d2:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   250d6:	6803      	ldr	r3, [r0, #0]
   250d8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   250dc:	f043 0302 	orr.w	r3, r3, #2
   250e0:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   250e2:	f382 8811 	msr	BASEPRI, r2
   250e6:	f3bf 8f6f 	isb	sy
}
   250ea:	4770      	bx	lr

000250ec <stop>:
{
   250ec:	b570      	push	{r4, r5, r6, lr}
   250ee:	b2c9      	uxtb	r1, r1
	struct nrf_clock_control_data *data = dev->data;
   250f0:	6903      	ldr	r3, [r0, #16]
	__asm__ volatile(
   250f2:	f04f 0420 	mov.w	r4, #32
   250f6:	f3ef 8511 	mrs	r5, BASEPRI
   250fa:	f384 8812 	msr	BASEPRI_MAX, r4
   250fe:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   25102:	260c      	movs	r6, #12
   25104:	fb06 3401 	mla	r4, r6, r1, r3
   25108:	6fa4      	ldr	r4, [r4, #120]	; 0x78
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   2510a:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
   2510e:	d008      	beq.n	25122 <stop+0x36>
   25110:	42a2      	cmp	r2, r4
   25112:	d006      	beq.n	25122 <stop+0x36>
	__asm__ volatile(
   25114:	f385 8811 	msr	BASEPRI, r5
   25118:	f3bf 8f6f 	isb	sy
		err = -EPERM;
   2511c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   25120:	bd70      	pop	{r4, r5, r6, pc}
		*flags = CLOCK_CONTROL_STATUS_OFF;
   25122:	2201      	movs	r2, #1
   25124:	fb06 3301 	mla	r3, r6, r1, r3
   25128:	679a      	str	r2, [r3, #120]	; 0x78
   2512a:	f385 8811 	msr	BASEPRI, r5
   2512e:	f3bf 8f6f 	isb	sy
	get_sub_config(dev, type)->stop();
   25132:	6843      	ldr	r3, [r0, #4]
   25134:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
   25138:	685b      	ldr	r3, [r3, #4]
   2513a:	4798      	blx	r3
	return 0;
   2513c:	2000      	movs	r0, #0
   2513e:	e7ef      	b.n	25120 <stop+0x34>

00025140 <api_stop>:
	return stop(dev, subsys, CTX_API);
   25140:	2280      	movs	r2, #128	; 0x80
   25142:	f7ff bfd3 	b.w	250ec <stop>

00025146 <async_start>:
{
   25146:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25148:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
   2514a:	6904      	ldr	r4, [r0, #16]
	return &data->subsys[type];
   2514c:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
   2514e:	f04f 0520 	mov.w	r5, #32
   25152:	f3ef 8611 	mrs	r6, BASEPRI
   25156:	f385 8812 	msr	BASEPRI_MAX, r5
   2515a:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   2515e:	250c      	movs	r5, #12
   25160:	fb05 4401 	mla	r4, r5, r1, r4
   25164:	6fa5      	ldr	r5, [r4, #120]	; 0x78
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   25166:	f005 0c07 	and.w	ip, r5, #7
   2516a:	f1bc 0f01 	cmp.w	ip, #1
   2516e:	d10c      	bne.n	2518a <async_start+0x44>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   25170:	67a7      	str	r7, [r4, #120]	; 0x78
	__asm__ volatile(
   25172:	f386 8811 	msr	BASEPRI, r6
   25176:	f3bf 8f6f 	isb	sy
	subdata->user_data = user_data;
   2517a:	e9c4 231c 	strd	r2, r3, [r4, #112]	; 0x70
	 get_sub_config(dev, type)->start();
   2517e:	6843      	ldr	r3, [r0, #4]
   25180:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
   25184:	4798      	blx	r3
	return 0;
   25186:	2000      	movs	r0, #0
}
   25188:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   2518a:	f005 05c0 	and.w	r5, r5, #192	; 0xc0
	} else if (current_ctx != ctx) {
   2518e:	42af      	cmp	r7, r5
   25190:	f386 8811 	msr	BASEPRI, r6
   25194:	f3bf 8f6f 	isb	sy
		err = -EALREADY;
   25198:	bf0c      	ite	eq
   2519a:	f06f 0077 	mvneq.w	r0, #119	; 0x77
		err = -EPERM;
   2519e:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   251a2:	e7f1      	b.n	25188 <async_start+0x42>

000251a4 <api_start>:
{
   251a4:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
   251a6:	2480      	movs	r4, #128	; 0x80
   251a8:	9400      	str	r4, [sp, #0]
   251aa:	f7ff ffcc 	bl	25146 <async_start>
}
   251ae:	b002      	add	sp, #8
   251b0:	bd10      	pop	{r4, pc}

000251b2 <onoff_started_callback>:
{
   251b2:	b410      	push	{r4}
	notify(mgr, 0);
   251b4:	241c      	movs	r4, #28
	return &data->mgr[type];
   251b6:	6900      	ldr	r0, [r0, #16]
   251b8:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   251ba:	fb03 0004 	mla	r0, r3, r4, r0
   251be:	2100      	movs	r1, #0
}
   251c0:	bc10      	pop	{r4}
	notify(mgr, 0);
   251c2:	4710      	bx	r2

000251c4 <hfclkaudio_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   251c4:	2003      	movs	r0, #3
   251c6:	f7fb bd47 	b.w	20c58 <nrfx_clock_start>

000251ca <hfclk192m_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK192M);
   251ca:	2002      	movs	r0, #2
   251cc:	f7fb bd44 	b.w	20c58 <nrfx_clock_start>

000251d0 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   251d0:	2000      	movs	r0, #0
   251d2:	f7fb bd41 	b.w	20c58 <nrfx_clock_start>

000251d6 <hfclkaudio_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   251d6:	2003      	movs	r0, #3
   251d8:	f000 bb19 	b.w	2580e <nrfx_clock_stop>

000251dc <hfclk192m_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK192M);
   251dc:	2002      	movs	r0, #2
   251de:	f000 bb16 	b.w	2580e <nrfx_clock_stop>

000251e2 <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   251e2:	2000      	movs	r0, #0
   251e4:	f000 bb13 	b.w	2580e <nrfx_clock_stop>

000251e8 <blocking_start_callback>:
{
   251e8:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
   251ea:	f7fe b9a1 	b.w	23530 <z_impl_k_sem_give>

000251ee <entropy_psa_crypto_rng_get_entropy>:
}

/* API implementation: get_entropy */
static int entropy_psa_crypto_rng_get_entropy(const struct device *dev,
					      uint8_t *buffer, uint16_t length)
{
   251ee:	4608      	mov	r0, r1
   251f0:	b508      	push	{r3, lr}
	psa_status_t status = PSA_ERROR_CORRUPTION_DETECTED;

	ARG_UNUSED(dev);

	status = psa_generate_random(buffer, length);
   251f2:	4611      	mov	r1, r2
   251f4:	f7fb fbd6 	bl	209a4 <psa_generate_random>
	if (status != PSA_SUCCESS) {
		return -EIO;
   251f8:	2800      	cmp	r0, #0
	}

	return 0;
}
   251fa:	bf18      	it	ne
   251fc:	f06f 0004 	mvnne.w	r0, #4
   25200:	bd08      	pop	{r3, pc}

00025202 <entropy_psa_crypto_rng_init>:
{
   25202:	b508      	push	{r3, lr}
	status = psa_crypto_init();
   25204:	f000 facc 	bl	257a0 <psa_crypto_init>
		return -EIO;
   25208:	2800      	cmp	r0, #0
}
   2520a:	bf18      	it	ne
   2520c:	f06f 0004 	mvnne.w	r0, #4
   25210:	bd08      	pop	{r3, pc}

00025212 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25212:	6843      	ldr	r3, [r0, #4]
}
   25214:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25216:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   25218:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   2521a:	600b      	str	r3, [r1, #0]
}
   2521c:	4770      	bx	lr

0002521e <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2521e:	6843      	ldr	r3, [r0, #4]
	const uint32_t set_mask = value & mask;
   25220:	ea02 0001 	and.w	r0, r2, r1
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25224:	685b      	ldr	r3, [r3, #4]
	const uint32_t clear_mask = (~set_mask) & mask;
   25226:	ea21 0102 	bic.w	r1, r1, r2
    p_reg->OUTSET = set_mask;
   2522a:	6098      	str	r0, [r3, #8]
}
   2522c:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   2522e:	60d9      	str	r1, [r3, #12]
   25230:	4770      	bx	lr

00025232 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25232:	6843      	ldr	r3, [r0, #4]
}
   25234:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25236:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   25238:	6099      	str	r1, [r3, #8]
}
   2523a:	4770      	bx	lr

0002523c <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   2523c:	6843      	ldr	r3, [r0, #4]
}
   2523e:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25240:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   25242:	60d9      	str	r1, [r3, #12]
}
   25244:	4770      	bx	lr

00025246 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   25246:	6843      	ldr	r3, [r0, #4]
   25248:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   2524a:	6853      	ldr	r3, [r2, #4]
	const uint32_t set_mask = value & mask;
   2524c:	ea21 0003 	bic.w	r0, r1, r3
	const uint32_t clear_mask = (~value) & mask;
   25250:	400b      	ands	r3, r1
    p_reg->OUTSET = set_mask;
   25252:	6090      	str	r0, [r2, #8]
}
   25254:	2000      	movs	r0, #0
    p_reg->OUTCLR = clr_mask;
   25256:	60d3      	str	r3, [r2, #12]
   25258:	4770      	bx	lr

0002525a <gpio_nrfx_manage_callback>:
{
   2525a:	b510      	push	{r4, lr}
	return port->data;
   2525c:	6903      	ldr	r3, [r0, #16]
	return list->head;
   2525e:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   25260:	b1f8      	cbz	r0, 252a2 <gpio_nrfx_manage_callback+0x48>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   25262:	4288      	cmp	r0, r1
   25264:	d119      	bne.n	2529a <gpio_nrfx_manage_callback+0x40>
Z_GENLIST_REMOVE(slist, snode)
   25266:	689c      	ldr	r4, [r3, #8]
	return node->next;
   25268:	6808      	ldr	r0, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   2526a:	42a1      	cmp	r1, r4
	list->head = node;
   2526c:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   2526e:	d100      	bne.n	25272 <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
   25270:	6098      	str	r0, [r3, #8]
	parent->next = child;
   25272:	2000      	movs	r0, #0
   25274:	6008      	str	r0, [r1, #0]
	if (set) {
   25276:	b12a      	cbz	r2, 25284 <gpio_nrfx_manage_callback+0x2a>
	return list->head;
   25278:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   2527a:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   2527c:	689a      	ldr	r2, [r3, #8]
	list->head = node;
   2527e:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   25280:	b902      	cbnz	r2, 25284 <gpio_nrfx_manage_callback+0x2a>
	list->tail = node;
   25282:	6099      	str	r1, [r3, #8]
	return 0;
   25284:	2000      	movs	r0, #0
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   25286:	e010      	b.n	252aa <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   25288:	4281      	cmp	r1, r0
   2528a:	d106      	bne.n	2529a <gpio_nrfx_manage_callback+0x40>
	return node->next;
   2528c:	6808      	ldr	r0, [r1, #0]
	parent->next = child;
   2528e:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   25290:	6898      	ldr	r0, [r3, #8]
   25292:	4281      	cmp	r1, r0
   25294:	d1ed      	bne.n	25272 <gpio_nrfx_manage_callback+0x18>
	list->tail = node;
   25296:	609c      	str	r4, [r3, #8]
}
   25298:	e7eb      	b.n	25272 <gpio_nrfx_manage_callback+0x18>
	return node->next;
   2529a:	4604      	mov	r4, r0
   2529c:	6800      	ldr	r0, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   2529e:	2800      	cmp	r0, #0
   252a0:	d1f2      	bne.n	25288 <gpio_nrfx_manage_callback+0x2e>
			if (!set) {
   252a2:	2a00      	cmp	r2, #0
   252a4:	d1e8      	bne.n	25278 <gpio_nrfx_manage_callback+0x1e>
				return -EINVAL;
   252a6:	f06f 0015 	mvn.w	r0, #21
}
   252aa:	bd10      	pop	{r4, pc}

000252ac <i2c_nrfx_twim_configure>:
	if (I2C_ADDR_10_BITS & i2c_config) {
   252ac:	07ca      	lsls	r2, r1, #31
	const struct i2c_nrfx_twim_config *dev_config = dev->config;
   252ae:	6843      	ldr	r3, [r0, #4]
	if (I2C_ADDR_10_BITS & i2c_config) {
   252b0:	d416      	bmi.n	252e0 <i2c_nrfx_twim_configure+0x34>
	switch (I2C_SPEED_GET(i2c_config)) {
   252b2:	f3c1 0142 	ubfx	r1, r1, #1, #3
   252b6:	2902      	cmp	r1, #2
   252b8:	d00a      	beq.n	252d0 <i2c_nrfx_twim_configure+0x24>
   252ba:	2903      	cmp	r1, #3
   252bc:	d00c      	beq.n	252d8 <i2c_nrfx_twim_configure+0x2c>
   252be:	2901      	cmp	r1, #1
   252c0:	d10e      	bne.n	252e0 <i2c_nrfx_twim_configure+0x34>
    p_reg->FREQUENCY = frequency;
   252c2:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   252c6:	681b      	ldr	r3, [r3, #0]
	return 0;
   252c8:	2000      	movs	r0, #0
   252ca:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
   252ce:	4770      	bx	lr
   252d0:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   252d4:	681b      	ldr	r3, [r3, #0]
   252d6:	e7f7      	b.n	252c8 <i2c_nrfx_twim_configure+0x1c>
   252d8:	f04f 627f 	mov.w	r2, #267386880	; 0xff00000
		nrf_twim_frequency_set(dev_config->twim.p_twim,
   252dc:	681b      	ldr	r3, [r3, #0]
   252de:	e7f3      	b.n	252c8 <i2c_nrfx_twim_configure+0x1c>
	switch (I2C_SPEED_GET(i2c_config)) {
   252e0:	f06f 0015 	mvn.w	r0, #21
}
   252e4:	4770      	bx	lr

000252e6 <irq_connect1>:
#ifdef CONFIG_I2C_0_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(0);
#endif

#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
   252e6:	2200      	movs	r2, #0
   252e8:	2101      	movs	r1, #1
   252ea:	2009      	movs	r0, #9
   252ec:	f7f9 b820 	b.w	1e330 <z_arm_irq_priority_set>

000252f0 <pinctrl_apply_state.constprop.0>:
 *
 * @retval 0 If succeeded.
 * @retval -ENOENT If given state id does not exist.
 * @retval -errno Negative errno for other failures.
 */
static inline int pinctrl_apply_state(const struct pinctrl_dev_config *config,
   252f0:	b513      	push	{r0, r1, r4, lr}
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
   252f2:	2100      	movs	r1, #0
   252f4:	aa01      	add	r2, sp, #4
static inline int pinctrl_apply_state(const struct pinctrl_dev_config *config,
   252f6:	4604      	mov	r4, r0
	ret = pinctrl_lookup_state(config, id, &state);
   252f8:	f000 f80a 	bl	25310 <pinctrl_lookup_state>
	if (ret < 0) {
   252fc:	2800      	cmp	r0, #0
   252fe:	db05      	blt.n	2530c <pinctrl_apply_state.constprop.0+0x1c>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
   25300:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   25302:	6822      	ldr	r2, [r4, #0]
   25304:	7919      	ldrb	r1, [r3, #4]
   25306:	6818      	ldr	r0, [r3, #0]
   25308:	f7fa fe4e 	bl	1ffa8 <pinctrl_configure_pins>
}
   2530c:	b002      	add	sp, #8
   2530e:	bd10      	pop	{r4, pc}

00025310 <pinctrl_lookup_state>:

#include <zephyr/drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
   25310:	b530      	push	{r4, r5, lr}
	*state = &config->states[0];
   25312:	6843      	ldr	r3, [r0, #4]
   25314:	6013      	str	r3, [r2, #0]
	while (*state < &config->states[config->state_cnt]) {
   25316:	7a05      	ldrb	r5, [r0, #8]
   25318:	6844      	ldr	r4, [r0, #4]
   2531a:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   2531e:	42a3      	cmp	r3, r4
   25320:	d302      	bcc.n	25328 <pinctrl_lookup_state+0x18>
		}

		(*state)++;
	}

	return -ENOENT;
   25322:	f06f 0001 	mvn.w	r0, #1
}
   25326:	bd30      	pop	{r4, r5, pc}
		if (id == (*state)->id) {
   25328:	795c      	ldrb	r4, [r3, #5]
   2532a:	428c      	cmp	r4, r1
   2532c:	d001      	beq.n	25332 <pinctrl_lookup_state+0x22>
		(*state)++;
   2532e:	3308      	adds	r3, #8
   25330:	e7f0      	b.n	25314 <pinctrl_lookup_state+0x4>
			return 0;
   25332:	2000      	movs	r0, #0
   25334:	e7f7      	b.n	25326 <pinctrl_lookup_state+0x16>

00025336 <regulator_common_data_init>:
 */

#include <zephyr/drivers/regulator.h>

void regulator_common_data_init(const struct device *dev)
{
   25336:	b510      	push	{r4, lr}
	struct regulator_common_data *data = dev->data;
   25338:	6904      	ldr	r4, [r0, #16]
	return z_impl_k_mutex_init(mutex);
   2533a:	4620      	mov	r0, r4
   2533c:	f000 fc45 	bl	25bca <z_impl_k_mutex_init>

	(void)k_mutex_init(&data->lock);
	data->refcnt = 0;
   25340:	2300      	movs	r3, #0
   25342:	6163      	str	r3, [r4, #20]
}
   25344:	bd10      	pop	{r4, pc}

00025346 <regulator_is_enabled>:

	return ret;
}

bool regulator_is_enabled(const struct device *dev)
{
   25346:	b538      	push	{r3, r4, r5, lr}
	const struct regulator_common_config *config = dev->config;
	struct regulator_common_data *data = dev->data;
	bool enabled;

	if ((config->flags & REGULATOR_ALWAYS_ON) != 0U) {
   25348:	6843      	ldr	r3, [r0, #4]
   2534a:	7e9b      	ldrb	r3, [r3, #26]
   2534c:	07db      	lsls	r3, r3, #31
   2534e:	d410      	bmi.n	25372 <regulator_is_enabled+0x2c>
	struct regulator_common_data *data = dev->data;
   25350:	6905      	ldr	r5, [r0, #16]
	return z_impl_k_mutex_lock(mutex, timeout);
   25352:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   25356:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2535a:	4628      	mov	r0, r5
   2535c:	f7fd fffe 	bl	2335c <z_impl_k_mutex_lock>
		enabled = true;
	} else {
		(void)k_mutex_lock(&data->lock, K_FOREVER);
		enabled = data->refcnt != 0;
   25360:	696c      	ldr	r4, [r5, #20]
   25362:	3c00      	subs	r4, #0
   25364:	bf18      	it	ne
   25366:	2401      	movne	r4, #1
	return z_impl_k_mutex_unlock(mutex);
   25368:	4628      	mov	r0, r5
   2536a:	f7fe f871 	bl	23450 <z_impl_k_mutex_unlock>
		k_mutex_unlock(&data->lock);
	}

	return enabled;
}
   2536e:	4620      	mov	r0, r4
   25370:	bd38      	pop	{r3, r4, r5, pc}
		enabled = true;
   25372:	2401      	movs	r4, #1
   25374:	e7fb      	b.n	2536e <regulator_is_enabled+0x28>

00025376 <regulator_set_voltage>:
	return false;
}

int regulator_set_voltage(const struct device *dev, int32_t min_uv,
			  int32_t max_uv)
{
   25376:	b4f0      	push	{r4, r5, r6, r7}
	const struct regulator_common_config *config = dev->config;
	const struct regulator_driver_api *api = dev->api;

	if (api->set_voltage == NULL) {
   25378:	e9d0 6301 	ldrd	r6, r3, [r0, #4]
   2537c:	691b      	ldr	r3, [r3, #16]
   2537e:	b13b      	cbz	r3, 25390 <regulator_set_voltage+0x1a>
		return -ENOSYS;
	}

	/* voltage may not be allowed, even if supported */
	if ((min_uv > config->max_uv) || (max_uv < config->min_uv)) {
   25380:	6877      	ldr	r7, [r6, #4]
   25382:	428f      	cmp	r7, r1
   25384:	db08      	blt.n	25398 <regulator_set_voltage+0x22>
   25386:	6835      	ldr	r5, [r6, #0]
   25388:	4295      	cmp	r5, r2
   2538a:	dc05      	bgt.n	25398 <regulator_set_voltage+0x22>
		return -EINVAL;
	}

	return api->set_voltage(dev, min_uv, max_uv);
}
   2538c:	bcf0      	pop	{r4, r5, r6, r7}
	return api->set_voltage(dev, min_uv, max_uv);
   2538e:	4718      	bx	r3
		return -ENOSYS;
   25390:	f06f 0057 	mvn.w	r0, #87	; 0x57
}
   25394:	bcf0      	pop	{r4, r5, r6, r7}
   25396:	4770      	bx	lr
		return -EINVAL;
   25398:	f06f 0015 	mvn.w	r0, #21
   2539c:	e7fa      	b.n	25394 <regulator_set_voltage+0x1e>

0002539e <regulator_set_mode>:

	return api->set_current_limit(dev, min_ua, max_ua);
}

int regulator_set_mode(const struct device *dev, regulator_mode_t mode)
{
   2539e:	b470      	push	{r4, r5, r6}
	const struct regulator_common_config *config = dev->config;
	const struct regulator_driver_api *api = dev->api;

	if (api->set_mode == NULL) {
   253a0:	e9d0 6201 	ldrd	r6, r2, [r0, #4]
   253a4:	6a15      	ldr	r5, [r2, #32]
{
   253a6:	4603      	mov	r3, r0
   253a8:	460c      	mov	r4, r1
	if (api->set_mode == NULL) {
   253aa:	b19d      	cbz	r5, 253d4 <regulator_set_mode+0x36>
		return -ENOSYS;
	}

	/* no mode restrictions */
	if (config->allowed_modes_cnt == 0U) {
   253ac:	7e32      	ldrb	r2, [r6, #24]
   253ae:	b912      	cbnz	r2, 253b6 <regulator_set_mode+0x18>
	}

	/* check if mode is allowed, apply if it is */
	for (uint8_t i = 0U; i < config->allowed_modes_cnt; i++) {
		if (mode == config->allowed_modes[i]) {
			return api->set_mode(dev, mode);
   253b0:	462b      	mov	r3, r5
		}
	}

	return -ENOTSUP;
}
   253b2:	bc70      	pop	{r4, r5, r6}
			return api->set_mode(dev, mode);
   253b4:	4718      	bx	r3
   253b6:	6970      	ldr	r0, [r6, #20]
   253b8:	4402      	add	r2, r0
		if (mode == config->allowed_modes[i]) {
   253ba:	f810 1b01 	ldrb.w	r1, [r0], #1
   253be:	42a1      	cmp	r1, r4
   253c0:	d102      	bne.n	253c8 <regulator_set_mode+0x2a>
			return api->set_mode(dev, mode);
   253c2:	4621      	mov	r1, r4
   253c4:	4618      	mov	r0, r3
   253c6:	e7f3      	b.n	253b0 <regulator_set_mode+0x12>
	for (uint8_t i = 0U; i < config->allowed_modes_cnt; i++) {
   253c8:	4290      	cmp	r0, r2
   253ca:	d1f6      	bne.n	253ba <regulator_set_mode+0x1c>
	return -ENOTSUP;
   253cc:	f06f 0085 	mvn.w	r0, #133	; 0x85
}
   253d0:	bc70      	pop	{r4, r5, r6}
   253d2:	4770      	bx	lr
		return -ENOSYS;
   253d4:	f06f 0057 	mvn.w	r0, #87	; 0x57
   253d8:	e7fa      	b.n	253d0 <regulator_set_mode+0x32>

000253da <regulator_common_init>:
{
   253da:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   253de:	460e      	mov	r6, r1
	const struct regulator_common_config *config = dev->config;
   253e0:	e9d0 8701 	ldrd	r8, r7, [r0, #4]
	if (config->initial_mode != REGULATOR_INITIAL_MODE_UNKNOWN) {
   253e4:	f898 1019 	ldrb.w	r1, [r8, #25]
{
   253e8:	4604      	mov	r4, r0
	if (config->initial_mode != REGULATOR_INITIAL_MODE_UNKNOWN) {
   253ea:	29ff      	cmp	r1, #255	; 0xff
	struct regulator_common_data *data = dev->data;
   253ec:	6905      	ldr	r5, [r0, #16]
	if (config->initial_mode != REGULATOR_INITIAL_MODE_UNKNOWN) {
   253ee:	d123      	bne.n	25438 <regulator_common_init+0x5e>
	if (config->init_uv > INT32_MIN) {
   253f0:	f8d8 2008 	ldr.w	r2, [r8, #8]
   253f4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   253f8:	d005      	beq.n	25406 <regulator_common_init+0x2c>
		ret = regulator_set_voltage(dev, config->init_uv, config->init_uv);
   253fa:	4611      	mov	r1, r2
   253fc:	4620      	mov	r0, r4
   253fe:	f7ff ffba 	bl	25376 <regulator_set_voltage>
		if (ret < 0) {
   25402:	2800      	cmp	r0, #0
   25404:	db1c      	blt.n	25440 <regulator_common_init+0x66>
	if ((config->min_uv > INT32_MIN) || (config->max_uv < INT32_MAX)) {
   25406:	f8d8 3000 	ldr.w	r3, [r8]
   2540a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   2540e:	d01a      	beq.n	25446 <regulator_common_init+0x6c>
					int32_t *volt_uv)
{
	const struct regulator_driver_api *api =
		(const struct regulator_driver_api *)dev->api;

	if (api->get_voltage == NULL) {
   25410:	68a3      	ldr	r3, [r4, #8]
   25412:	695b      	ldr	r3, [r3, #20]
   25414:	b38b      	cbz	r3, 2547a <regulator_common_init+0xa0>
		return -ENOSYS;
	}

	return api->get_voltage(dev, volt_uv);
   25416:	4620      	mov	r0, r4
   25418:	a901      	add	r1, sp, #4
   2541a:	4798      	blx	r3
		if (ret < 0) {
   2541c:	2800      	cmp	r0, #0
   2541e:	db0f      	blt.n	25440 <regulator_common_init+0x66>
		if (current_uv < config->min_uv) {
   25420:	f8d8 2000 	ldr.w	r2, [r8]
   25424:	9b01      	ldr	r3, [sp, #4]
   25426:	429a      	cmp	r2, r3
   25428:	dd22      	ble.n	25470 <regulator_common_init+0x96>
			ret = regulator_set_voltage(dev, config->max_uv, config->max_uv);
   2542a:	4611      	mov	r1, r2
   2542c:	4620      	mov	r0, r4
   2542e:	f7ff ffa2 	bl	25376 <regulator_set_voltage>
			if (ret < 0) {
   25432:	2800      	cmp	r0, #0
   25434:	da0d      	bge.n	25452 <regulator_common_init+0x78>
   25436:	e003      	b.n	25440 <regulator_common_init+0x66>
		ret = regulator_set_mode(dev, config->initial_mode);
   25438:	f7ff ffb1 	bl	2539e <regulator_set_mode>
		if (ret < 0) {
   2543c:	2800      	cmp	r0, #0
   2543e:	dad7      	bge.n	253f0 <regulator_common_init+0x16>
}
   25440:	b002      	add	sp, #8
   25442:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((config->min_uv > INT32_MIN) || (config->max_uv < INT32_MAX)) {
   25446:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   2544a:	f8d8 2004 	ldr.w	r2, [r8, #4]
   2544e:	429a      	cmp	r2, r3
   25450:	d1de      	bne.n	25410 <regulator_common_init+0x36>
	if (is_enabled) {
   25452:	b946      	cbnz	r6, 25466 <regulator_common_init+0x8c>
	} else if ((config->flags & REGULATOR_INIT_ENABLED) != 0U) {
   25454:	f898 301a 	ldrb.w	r3, [r8, #26]
   25458:	079b      	lsls	r3, r3, #30
   2545a:	d007      	beq.n	2546c <regulator_common_init+0x92>
		ret = api->enable(dev);
   2545c:	4620      	mov	r0, r4
   2545e:	683b      	ldr	r3, [r7, #0]
   25460:	4798      	blx	r3
		if (ret < 0) {
   25462:	2800      	cmp	r0, #0
   25464:	dbec      	blt.n	25440 <regulator_common_init+0x66>
		data->refcnt++;
   25466:	696b      	ldr	r3, [r5, #20]
   25468:	3301      	adds	r3, #1
   2546a:	616b      	str	r3, [r5, #20]
	return 0;
   2546c:	2000      	movs	r0, #0
   2546e:	e7e7      	b.n	25440 <regulator_common_init+0x66>
		} else if (current_uv > config->max_uv) {
   25470:	f8d8 2004 	ldr.w	r2, [r8, #4]
   25474:	4293      	cmp	r3, r2
   25476:	ddec      	ble.n	25452 <regulator_common_init+0x78>
   25478:	e7d7      	b.n	2542a <regulator_common_init+0x50>
		return -ENOSYS;
   2547a:	f06f 0057 	mvn.w	r0, #87	; 0x57
   2547e:	e7df      	b.n	25440 <regulator_common_init+0x66>

00025480 <gpio_pin_set>:
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   25480:	2301      	movs	r3, #1
   25482:	fa03 f101 	lsl.w	r1, r3, r1
   25486:	6903      	ldr	r3, [r0, #16]
   25488:	681b      	ldr	r3, [r3, #0]
   2548a:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   2548c:	bf18      	it	ne
   2548e:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   25492:	b112      	cbz	r2, 2549a <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   25494:	6883      	ldr	r3, [r0, #8]
   25496:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   25498:	4718      	bx	r3
   2549a:	6883      	ldr	r3, [r0, #8]
   2549c:	691b      	ldr	r3, [r3, #16]
   2549e:	e7fb      	b.n	25498 <gpio_pin_set+0x18>

000254a0 <regulator_fixed_init>:
	.enable = regulator_fixed_enable,
	.disable = regulator_fixed_disable,
};

static int regulator_fixed_init(const struct device *dev)
{
   254a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	const struct regulator_fixed_config *cfg = dev->config;
   254a2:	6844      	ldr	r4, [r0, #4]
{
   254a4:	4605      	mov	r5, r0
	int ret;

	regulator_common_data_init(dev);
   254a6:	f7ff ff46 	bl	25336 <regulator_common_data_init>

	if (!device_is_ready(cfg->enable.port)) {
   254aa:	6a60      	ldr	r0, [r4, #36]	; 0x24
   254ac:	f000 fb0a 	bl	25ac4 <z_device_is_ready>
   254b0:	b370      	cbz	r0, 25510 <regulator_fixed_init+0x70>
	return gpio_pin_configure(spec->port,
   254b2:	6a60      	ldr	r0, [r4, #36]	; 0x24
				  spec->pin,
   254b4:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
				  spec->dt_flags | extra_flags);
   254b8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254ba:	2701      	movs	r7, #1
	struct gpio_driver_data *data =
   254bc:	f8d0 c010 	ldr.w	ip, [r0, #16]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   254c0:	07da      	lsls	r2, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254c2:	f8dc 6000 	ldr.w	r6, [ip]
	return gpio_pin_configure(spec->port,
   254c6:	bf54      	ite	pl
   254c8:	f443 13b0 	orrpl.w	r3, r3, #1441792	; 0x160000
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   254cc:	f483 13d0 	eormi.w	r3, r3, #1703936	; 0x1a0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   254d0:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254d4:	408f      	lsls	r7, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   254d6:	07db      	lsls	r3, r3, #31
	const struct gpio_driver_api *api =
   254d8:	f8d0 e008 	ldr.w	lr, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
   254dc:	bf4c      	ite	mi
   254de:	433e      	orrmi	r6, r7
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   254e0:	43be      	bicpl	r6, r7
   254e2:	f8cc 6000 	str.w	r6, [ip]
	return api->pin_configure(port, pin, flags);
   254e6:	f8de 3000 	ldr.w	r3, [lr]
   254ea:	4798      	blx	r3
		LOG_ERR("GPIO port: %s not ready", cfg->enable.port->name);
		return -ENODEV;
	}

	ret = gpio_pin_configure_dt(&cfg->enable, GPIO_OUTPUT_INACTIVE);
	if (ret < 0) {
   254ec:	2800      	cmp	r0, #0
   254ee:	db0a      	blt.n	25506 <regulator_fixed_init+0x66>
		return ret;
	}

	ret = regulator_common_init(dev, false);
   254f0:	2100      	movs	r1, #0
   254f2:	4628      	mov	r0, r5
   254f4:	f7ff ff71 	bl	253da <regulator_common_init>
	if (ret < 0) {
   254f8:	2800      	cmp	r0, #0
   254fa:	db04      	blt.n	25506 <regulator_fixed_init+0x66>
		return ret;
	}

	if (regulator_is_enabled(dev)) {
   254fc:	4628      	mov	r0, r5
   254fe:	f7ff ff22 	bl	25346 <regulator_is_enabled>
   25502:	b908      	cbnz	r0, 25508 <regulator_fixed_init+0x68>
		k_busy_wait(cfg->startup_delay_us);
	}

	return 0;
   25504:	2000      	movs	r0, #0
}
   25506:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		k_busy_wait(cfg->startup_delay_us);
   25508:	69e0      	ldr	r0, [r4, #28]
	z_impl_k_busy_wait(usec_to_wait);
   2550a:	f000 fd80 	bl	2600e <z_impl_k_busy_wait>
}
   2550e:	e7f9      	b.n	25504 <regulator_fixed_init+0x64>
		return -ENODEV;
   25510:	f06f 0012 	mvn.w	r0, #18
   25514:	e7f7      	b.n	25506 <regulator_fixed_init+0x66>

00025516 <regulator_fixed_disable>:
	const struct regulator_fixed_config *cfg = dev->config;
   25516:	6843      	ldr	r3, [r0, #4]
	return gpio_pin_set(spec->port, spec->pin, value);
   25518:	2200      	movs	r2, #0
   2551a:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
   2551e:	6a58      	ldr	r0, [r3, #36]	; 0x24
   25520:	f7ff bfae 	b.w	25480 <gpio_pin_set>

00025524 <irq_connect3>:
#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(2);
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(3);
   25524:	2200      	movs	r2, #0
   25526:	2101      	movs	r1, #1
   25528:	200c      	movs	r0, #12
   2552a:	f7f8 bf01 	b.w	1e330 <z_arm_irq_priority_set>

0002552e <irq_connect4>:
#endif

#ifdef CONFIG_SPI_4_NRF_SPIM
SPI_NRFX_SPIM_DEFINE(4);
   2552e:	2200      	movs	r2, #0
   25530:	2101      	movs	r1, #1
   25532:	200a      	movs	r0, #10
   25534:	f7f8 befc 	b.w	1e330 <z_arm_irq_priority_set>

00025538 <spi_context_get_next_buf.constprop.0>:
static inline void *spi_context_get_next_buf(const struct spi_buf **current,
   25538:	b510      	push	{r4, lr}
	while (*count) {
   2553a:	680b      	ldr	r3, [r1, #0]
   2553c:	b913      	cbnz	r3, 25544 <spi_context_get_next_buf.constprop.0+0xc>
	return NULL;
   2553e:	4618      	mov	r0, r3
	*buf_len = 0;
   25540:	6013      	str	r3, [r2, #0]
	return NULL;
   25542:	e005      	b.n	25550 <spi_context_get_next_buf.constprop.0+0x18>
		if (((*current)->len / dfs) != 0) {
   25544:	6803      	ldr	r3, [r0, #0]
   25546:	685c      	ldr	r4, [r3, #4]
   25548:	b11c      	cbz	r4, 25552 <spi_context_get_next_buf.constprop.0+0x1a>
			*buf_len = (*current)->len / dfs;
   2554a:	6014      	str	r4, [r2, #0]
			return (*current)->buf;
   2554c:	6803      	ldr	r3, [r0, #0]
   2554e:	6818      	ldr	r0, [r3, #0]
}
   25550:	bd10      	pop	{r4, pc}
		++(*current);
   25552:	3308      	adds	r3, #8
   25554:	6003      	str	r3, [r0, #0]
		--(*count);
   25556:	680b      	ldr	r3, [r1, #0]
   25558:	3b01      	subs	r3, #1
   2555a:	600b      	str	r3, [r1, #0]
   2555c:	e7ed      	b.n	2553a <spi_context_get_next_buf.constprop.0+0x2>

0002555e <gpio_pin_set_dt.isra.0>:
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
   2555e:	4603      	mov	r3, r0
   25560:	460a      	mov	r2, r1
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   25562:	7919      	ldrb	r1, [r3, #4]
   25564:	2301      	movs	r3, #1
	return gpio_pin_set(spec->port, spec->pin, value);
   25566:	6800      	ldr	r0, [r0, #0]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   25568:	fa03 f101 	lsl.w	r1, r3, r1
   2556c:	6903      	ldr	r3, [r0, #16]
   2556e:	681b      	ldr	r3, [r3, #0]
   25570:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   25572:	bf18      	it	ne
   25574:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   25578:	b112      	cbz	r2, 25580 <gpio_pin_set_dt.isra.0+0x22>
	return api->port_set_bits_raw(port, pins);
   2557a:	6883      	ldr	r3, [r0, #8]
   2557c:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   2557e:	4718      	bx	r3
   25580:	6883      	ldr	r3, [r0, #8]
   25582:	691b      	ldr	r3, [r3, #16]
   25584:	e7fb      	b.n	2557e <gpio_pin_set_dt.isra.0+0x20>

00025586 <_spi_context_cs_control>:
{
   25586:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   25588:	6803      	ldr	r3, [r0, #0]
{
   2558a:	4604      	mov	r4, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
   2558c:	b1e3      	cbz	r3, 255c8 <_spi_context_cs_control+0x42>
   2558e:	6898      	ldr	r0, [r3, #8]
   25590:	b1d0      	cbz	r0, 255c8 <_spi_context_cs_control+0x42>
   25592:	6805      	ldr	r5, [r0, #0]
   25594:	b1c5      	cbz	r5, 255c8 <_spi_context_cs_control+0x42>
		if (on) {
   25596:	b149      	cbz	r1, 255ac <_spi_context_cs_control+0x26>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 1);
   25598:	2101      	movs	r1, #1
   2559a:	f7ff ffe0 	bl	2555e <gpio_pin_set_dt.isra.0>
			k_busy_wait(ctx->config->cs->delay);
   2559e:	6823      	ldr	r3, [r4, #0]
   255a0:	689b      	ldr	r3, [r3, #8]
   255a2:	6898      	ldr	r0, [r3, #8]
}
   255a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   255a8:	f000 bd31 	b.w	2600e <z_impl_k_busy_wait>
			if (!force_off &&
   255ac:	b912      	cbnz	r2, 255b4 <_spi_context_cs_control+0x2e>
   255ae:	889b      	ldrh	r3, [r3, #4]
   255b0:	04db      	lsls	r3, r3, #19
   255b2:	d409      	bmi.n	255c8 <_spi_context_cs_control+0x42>
			k_busy_wait(ctx->config->cs->delay);
   255b4:	6880      	ldr	r0, [r0, #8]
   255b6:	f000 fd2a 	bl	2600e <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   255ba:	6823      	ldr	r3, [r4, #0]
   255bc:	2100      	movs	r1, #0
   255be:	6898      	ldr	r0, [r3, #8]
}
   255c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
   255c4:	f7ff bfcb 	b.w	2555e <gpio_pin_set_dt.isra.0>
}
   255c8:	bd38      	pop	{r3, r4, r5, pc}

000255ca <spi_context_unlock_unconditionally>:
{
   255ca:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   255cc:	2201      	movs	r2, #1
   255ce:	2100      	movs	r1, #0
{
   255d0:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   255d2:	f7ff ffd8 	bl	25586 <_spi_context_cs_control>
	if (!k_sem_count_get(&ctx->lock)) {
   255d6:	69a3      	ldr	r3, [r4, #24]
   255d8:	b933      	cbnz	r3, 255e8 <spi_context_unlock_unconditionally+0x1e>
		ctx->owner = NULL;
   255da:	6063      	str	r3, [r4, #4]
	z_impl_k_sem_give(sem);
   255dc:	f104 0010 	add.w	r0, r4, #16
}
   255e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   255e4:	f7fd bfa4 	b.w	23530 <z_impl_k_sem_give>
   255e8:	bd10      	pop	{r4, pc}

000255ea <spi_nrfx_release>:
{
   255ea:	b510      	push	{r4, lr}
	struct spi_nrfx_data *dev_data = dev->data;
   255ec:	6900      	ldr	r0, [r0, #16]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   255ee:	6803      	ldr	r3, [r0, #0]
   255f0:	428b      	cmp	r3, r1
   255f2:	d106      	bne.n	25602 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   255f4:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   255f8:	b934      	cbnz	r4, 25608 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   255fa:	f7ff ffe6 	bl	255ca <spi_context_unlock_unconditionally>
	return 0;
   255fe:	4620      	mov	r0, r4
}
   25600:	bd10      	pop	{r4, pc}
		return -EINVAL;
   25602:	f06f 0015 	mvn.w	r0, #21
   25606:	e7fb      	b.n	25600 <spi_nrfx_release+0x16>
		return -EBUSY;
   25608:	f06f 000f 	mvn.w	r0, #15
   2560c:	e7f8      	b.n	25600 <spi_nrfx_release+0x16>

0002560e <spi_nrfx_init>:
{
   2560e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	const struct spi_nrfx_config *dev_config = dev->config;
   25612:	6844      	ldr	r4, [r0, #4]
	struct spi_nrfx_data *dev_data = dev->data;
   25614:	6905      	ldr	r5, [r0, #16]
	err = pinctrl_apply_state(dev_config->pcfg, PINCTRL_STATE_DEFAULT);
   25616:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
	ret = pinctrl_lookup_state(config, id, &state);
   25618:	2100      	movs	r1, #0
   2561a:	4630      	mov	r0, r6
   2561c:	aa01      	add	r2, sp, #4
   2561e:	f7ff fe77 	bl	25310 <pinctrl_lookup_state>
	if (ret < 0) {
   25622:	2800      	cmp	r0, #0
   25624:	db43      	blt.n	256ae <spi_nrfx_init+0xa0>
	return pinctrl_apply_state_direct(config, state);
   25626:	9b01      	ldr	r3, [sp, #4]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
   25628:	6832      	ldr	r2, [r6, #0]
   2562a:	7919      	ldrb	r1, [r3, #4]
   2562c:	6818      	ldr	r0, [r3, #0]
   2562e:	f7fa fcbb 	bl	1ffa8 <pinctrl_configure_pins>
	if (err < 0) {
   25632:	2800      	cmp	r0, #0
   25634:	db3b      	blt.n	256ae <spi_nrfx_init+0xa0>
		data->invert |= (gpio_port_pins_t)BIT(pin);
   25636:	2601      	movs	r6, #1
	dev_config->irq_connect();
   25638:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2563a:	4798      	blx	r3
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
   2563c:	68ac      	ldr	r4, [r5, #8]
   2563e:	3408      	adds	r4, #8
   25640:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
   25644:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   25648:	f1a4 0208 	sub.w	r2, r4, #8
   2564c:	4293      	cmp	r3, r2
   2564e:	d804      	bhi.n	2565a <spi_nrfx_init+0x4c>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   25650:	4628      	mov	r0, r5
   25652:	f7ff ffba 	bl	255ca <spi_context_unlock_unconditionally>
	return 0;
   25656:	2000      	movs	r0, #0
	return 0;
   25658:	e029      	b.n	256ae <spi_nrfx_init+0xa0>
		if (!device_is_ready(cs_gpio->port)) {
   2565a:	f854 0c08 	ldr.w	r0, [r4, #-8]
   2565e:	f000 fa31 	bl	25ac4 <z_device_is_ready>
   25662:	b338      	cbz	r0, 256b4 <spi_nrfx_init+0xa6>
	return gpio_pin_configure(spec->port,
   25664:	f854 0c08 	ldr.w	r0, [r4, #-8]
				  spec->pin,
   25668:	f814 1c04 	ldrb.w	r1, [r4, #-4]
				  spec->dt_flags | extra_flags);
   2566c:	f834 3c02 	ldrh.w	r3, [r4, #-2]
	struct gpio_driver_data *data =
   25670:	f8d0 c010 	ldr.w	ip, [r0, #16]
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
   25674:	07da      	lsls	r2, r3, #31
		data->invert |= (gpio_port_pins_t)BIT(pin);
   25676:	f8dc 7000 	ldr.w	r7, [ip]
	return gpio_pin_configure(spec->port,
   2567a:	bf54      	ite	pl
   2567c:	f443 13b0 	orrpl.w	r3, r3, #1441792	; 0x160000
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
   25680:	f483 13d0 	eormi.w	r3, r3, #1703936	; 0x1a0000
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
   25684:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
		data->invert |= (gpio_port_pins_t)BIT(pin);
   25688:	fa06 fe01 	lsl.w	lr, r6, r1
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
   2568c:	07db      	lsls	r3, r3, #31
	const struct gpio_driver_api *api =
   2568e:	f8d0 8008 	ldr.w	r8, [r0, #8]
		data->invert |= (gpio_port_pins_t)BIT(pin);
   25692:	bf4c      	ite	mi
   25694:	ea4e 0707 	orrmi.w	r7, lr, r7
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   25698:	ea27 070e 	bicpl.w	r7, r7, lr
   2569c:	f8cc 7000 	str.w	r7, [ip]
	return api->pin_configure(port, pin, flags);
   256a0:	f8d8 3000 	ldr.w	r3, [r8]
   256a4:	4798      	blx	r3
		if (ret < 0) {
   256a6:	2800      	cmp	r0, #0
   256a8:	f104 0408 	add.w	r4, r4, #8
   256ac:	dac8      	bge.n	25640 <spi_nrfx_init+0x32>
}
   256ae:	b002      	add	sp, #8
   256b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return -ENODEV;
   256b4:	f06f 0012 	mvn.w	r0, #18
	if (err < 0) {
   256b8:	e7f9      	b.n	256ae <spi_nrfx_init+0xa0>

000256ba <finish_transaction.isra.0>:
	_spi_context_cs_control(ctx, on, false);
   256ba:	2200      	movs	r2, #0
static void finish_transaction(const struct device *dev, int error)
   256bc:	b538      	push	{r3, r4, r5, lr}
   256be:	4604      	mov	r4, r0
   256c0:	460d      	mov	r5, r1
   256c2:	4611      	mov	r1, r2
   256c4:	f7ff ff5f 	bl	25586 <_spi_context_cs_control>
	ctx->sync_status = status;
   256c8:	6325      	str	r5, [r4, #48]	; 0x30
   256ca:	f104 0020 	add.w	r0, r4, #32
   256ce:	f7fd ff2f 	bl	23530 <z_impl_k_sem_give>
	dev_data->busy = false;
   256d2:	2300      	movs	r3, #0
   256d4:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
   256d8:	bd38      	pop	{r3, r4, r5, pc}

000256da <event_handler>:
{
   256da:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   256dc:	7803      	ldrb	r3, [r0, #0]
{
   256de:	460c      	mov	r4, r1
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   256e0:	2b00      	cmp	r3, #0
   256e2:	d145      	bne.n	25770 <event_handler+0x96>
		if (dev_data->chunk_len == 0) {
   256e4:	6d8d      	ldr	r5, [r1, #88]	; 0x58
   256e6:	b93d      	cbnz	r5, 256f8 <event_handler+0x1e>
			finish_transaction(dev_data->dev, -ETIMEDOUT);
   256e8:	6d4b      	ldr	r3, [r1, #84]	; 0x54
   256ea:	f06f 0173 	mvn.w	r1, #115	; 0x73
   256ee:	6918      	ldr	r0, [r3, #16]
}
   256f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			finish_transaction(dev_data->dev, -ETIMEDOUT);
   256f4:	f7ff bfe1 	b.w	256ba <finish_transaction.isra.0>
	if (!ctx->tx_len) {
   256f8:	6c8b      	ldr	r3, [r1, #72]	; 0x48
   256fa:	b193      	cbz	r3, 25722 <event_handler+0x48>
	if (len > ctx->tx_len) {
   256fc:	429d      	cmp	r5, r3
   256fe:	d810      	bhi.n	25722 <event_handler+0x48>
	ctx->tx_len -= len;
   25700:	1b5b      	subs	r3, r3, r5
   25702:	648b      	str	r3, [r1, #72]	; 0x48
	if (!ctx->tx_len) {
   25704:	bb43      	cbnz	r3, 25758 <event_handler+0x7e>
		++ctx->current_tx;
   25706:	6b4b      	ldr	r3, [r1, #52]	; 0x34
			spi_context_get_next_buf(&ctx->current_tx,
   25708:	f101 0248 	add.w	r2, r1, #72	; 0x48
		++ctx->current_tx;
   2570c:	3308      	adds	r3, #8
   2570e:	634b      	str	r3, [r1, #52]	; 0x34
		--ctx->tx_count;
   25710:	6b8b      	ldr	r3, [r1, #56]	; 0x38
			spi_context_get_next_buf(&ctx->current_tx,
   25712:	f104 0034 	add.w	r0, r4, #52	; 0x34
		--ctx->tx_count;
   25716:	3b01      	subs	r3, #1
   25718:	638b      	str	r3, [r1, #56]	; 0x38
			spi_context_get_next_buf(&ctx->current_tx,
   2571a:	3138      	adds	r1, #56	; 0x38
   2571c:	f7ff ff0c 	bl	25538 <spi_context_get_next_buf.constprop.0>
		ctx->tx_buf = (const uint8_t *)
   25720:	6460      	str	r0, [r4, #68]	; 0x44
	if (!ctx->rx_len) {
   25722:	6d23      	ldr	r3, [r4, #80]	; 0x50
   25724:	b19b      	cbz	r3, 2574e <event_handler+0x74>
	if (len > ctx->rx_len) {
   25726:	429d      	cmp	r5, r3
   25728:	d811      	bhi.n	2574e <event_handler+0x74>
	ctx->rx_len -= len;
   2572a:	1b5b      	subs	r3, r3, r5
   2572c:	6523      	str	r3, [r4, #80]	; 0x50
	if (!ctx->rx_len) {
   2572e:	b9cb      	cbnz	r3, 25764 <event_handler+0x8a>
		++ctx->current_rx;
   25730:	6be3      	ldr	r3, [r4, #60]	; 0x3c
			spi_context_get_next_buf(&ctx->current_rx,
   25732:	f104 0250 	add.w	r2, r4, #80	; 0x50
		++ctx->current_rx;
   25736:	3308      	adds	r3, #8
   25738:	63e3      	str	r3, [r4, #60]	; 0x3c
		--ctx->rx_count;
   2573a:	6c23      	ldr	r3, [r4, #64]	; 0x40
			spi_context_get_next_buf(&ctx->current_rx,
   2573c:	f104 0140 	add.w	r1, r4, #64	; 0x40
		--ctx->rx_count;
   25740:	3b01      	subs	r3, #1
   25742:	6423      	str	r3, [r4, #64]	; 0x40
			spi_context_get_next_buf(&ctx->current_rx,
   25744:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   25748:	f7ff fef6 	bl	25538 <spi_context_get_next_buf.constprop.0>
		ctx->rx_buf = (uint8_t *)
   2574c:	64e0      	str	r0, [r4, #76]	; 0x4c
		transfer_next_chunk(dev_data->dev);
   2574e:	6d60      	ldr	r0, [r4, #84]	; 0x54
}
   25750:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev_data->dev);
   25754:	f7fa bcfe 	b.w	20154 <transfer_next_chunk>
	} else if (ctx->tx_buf) {
   25758:	6c4b      	ldr	r3, [r1, #68]	; 0x44
   2575a:	2b00      	cmp	r3, #0
   2575c:	d0e1      	beq.n	25722 <event_handler+0x48>
		ctx->tx_buf += dfs * len;
   2575e:	442b      	add	r3, r5
   25760:	644b      	str	r3, [r1, #68]	; 0x44
   25762:	e7de      	b.n	25722 <event_handler+0x48>
	} else if (ctx->rx_buf) {
   25764:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   25766:	2b00      	cmp	r3, #0
   25768:	d0f1      	beq.n	2574e <event_handler+0x74>
		ctx->rx_buf += dfs * len;
   2576a:	442b      	add	r3, r5
   2576c:	64e3      	str	r3, [r4, #76]	; 0x4c
   2576e:	e7ee      	b.n	2574e <event_handler+0x74>
}
   25770:	bd38      	pop	{r3, r4, r5, pc}

00025772 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
   25772:	4770      	bx	lr

00025774 <event_clear>:
   25774:	2200      	movs	r2, #0
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
   25776:	f100 0350 	add.w	r3, r0, #80	; 0x50
   2577a:	009b      	lsls	r3, r3, #2
   2577c:	b29b      	uxth	r3, r3
   2577e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   25782:	f503 33a8 	add.w	r3, r3, #86016	; 0x15000
   25786:	601a      	str	r2, [r3, #0]
   25788:	681b      	ldr	r3, [r3, #0]
}
   2578a:	4770      	bx	lr

0002578c <sys_clock_cycle_get_32>:
{
   2578c:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
   2578e:	f7fa ff1b 	bl	205c8 <z_nrf_rtc_timer_read>
}
   25792:	bd08      	pop	{r3, pc}

00025794 <k_sys_fatal_error_handler>:

	LOG_PANIC();

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
		sys_arch_reboot(0);
   25794:	2000      	movs	r0, #0
{
   25796:	b508      	push	{r3, lr}
		sys_arch_reboot(0);
   25798:	f7f9 f83e 	bl	1e818 <sys_arch_reboot>

0002579c <ns_interface_init>:

	__ASSERT(tfm_ns_interface_init() == TFM_SUCCESS,
		"TF-M NS interface init failed");

	return 0;
}
   2579c:	2000      	movs	r0, #0
   2579e:	4770      	bx	lr

000257a0 <psa_crypto_init>:
}
   257a0:	2000      	movs	r0, #0
   257a2:	4770      	bx	lr

000257a4 <tfm_platform_mem_read>:
#include <tfm_platform_api.h>
#include <tfm_ioctl_core_api.h>

enum tfm_platform_err_t tfm_platform_mem_read(void *destination, uint32_t addr,
					      size_t len, uint32_t *result)
{
   257a4:	b510      	push	{r4, lr}
   257a6:	b088      	sub	sp, #32
   257a8:	461c      	mov	r4, r3
	psa_invec in_vec;
	psa_outvec out_vec;
	struct tfm_read_service_args_t args;
	struct tfm_read_service_out_t out;

	in_vec.base = (const void *)&args;
   257aa:	ab05      	add	r3, sp, #20
   257ac:	9301      	str	r3, [sp, #4]
	in_vec.len = sizeof(args);
   257ae:	230c      	movs	r3, #12
   257b0:	9302      	str	r3, [sp, #8]

	out_vec.base = (void *)&out;
	out_vec.len = sizeof(out);
   257b2:	2304      	movs	r3, #4

	args.destination = destination;
	args.addr = addr;
	args.len = len;
   257b4:	e9cd 1206 	strd	r1, r2, [sp, #24]
	args.destination = destination;
   257b8:	e9cd 3004 	strd	r3, r0, [sp, #16]

	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_READ_SERVICE, &in_vec,
   257bc:	eb0d 0103 	add.w	r1, sp, r3
   257c0:	aa03      	add	r2, sp, #12
   257c2:	2000      	movs	r0, #0
	out_vec.base = (void *)&out;
   257c4:	f8cd d00c 	str.w	sp, [sp, #12]
	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_READ_SERVICE, &in_vec,
   257c8:	f7fb f8c6 	bl	20958 <tfm_platform_ioctl>
				 &out_vec);

	*result = out.result;
   257cc:	9b00      	ldr	r3, [sp, #0]
   257ce:	6023      	str	r3, [r4, #0]

	return ret;
}
   257d0:	b008      	add	sp, #32
   257d2:	bd10      	pop	{r4, pc}

000257d4 <tfm_platform_gpio_pin_mcu_select>:
	psa_invec in_vec;
	psa_outvec out_vec;
	struct tfm_gpio_service_args args;
	struct tfm_gpio_service_out out;

	args.type = TFM_GPIO_SERVICE_TYPE_PIN_MCU_SELECT;
   257d4:	2300      	movs	r3, #0
{
   257d6:	b510      	push	{r4, lr}
   257d8:	b088      	sub	sp, #32
	args.mcu_select.pin_number = pin_number;
   257da:	e9cd 3005 	strd	r3, r0, [sp, #20]
	args.mcu_select.mcu = mcu;

	in_vec.base = (const void *)&args;
   257de:	ab05      	add	r3, sp, #20
   257e0:	9301      	str	r3, [sp, #4]
	in_vec.len = sizeof(args);
   257e2:	230c      	movs	r3, #12
   257e4:	9302      	str	r3, [sp, #8]

	out_vec.base = (void *)&out;
	out_vec.len = sizeof(out);
   257e6:	2304      	movs	r3, #4
{
   257e8:	4614      	mov	r4, r2
	args.mcu_select.mcu = mcu;
   257ea:	9107      	str	r1, [sp, #28]

	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_GPIO_SERVICE, &in_vec,
   257ec:	aa03      	add	r2, sp, #12
   257ee:	eb0d 0103 	add.w	r1, sp, r3
   257f2:	2001      	movs	r0, #1
	out_vec.len = sizeof(out);
   257f4:	9304      	str	r3, [sp, #16]
	out_vec.base = (void *)&out;
   257f6:	f8cd d00c 	str.w	sp, [sp, #12]
	ret = tfm_platform_ioctl(TFM_PLATFORM_IOCTL_GPIO_SERVICE, &in_vec,
   257fa:	f7fb f8ad 	bl	20958 <tfm_platform_ioctl>
				 &out_vec);

	*result = out.result;
   257fe:	9b00      	ldr	r3, [sp, #0]
   25800:	6023      	str	r3, [r4, #0]

	return ret;
#else
	return TFM_PLATFORM_ERR_NOT_SUPPORTED;
#endif
}
   25802:	b008      	add	sp, #32
   25804:	bd10      	pop	{r4, pc}

00025806 <SystemInit>:
    #if (__FPU_USED == 1)
        SCB->CPACR |= (3UL << 20) | (3UL << 22);
        __DSB();
        __ISB();
    #endif
}
   25806:	4770      	bx	lr

00025808 <nrfx_isr>:
#include <zephyr/kernel.h>
#include <soc/nrfx_coredep.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   25808:	4700      	bx	r0

0002580a <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   2580a:	f000 bc00 	b.w	2600e <z_impl_k_busy_wait>

0002580e <nrfx_clock_stop>:
    clock_stop(domain);
   2580e:	f7fb b93d 	b.w	20a8c <clock_stop>

00025812 <nrf_gpio_reconfigure>:
{
   25812:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   25814:	4616      	mov	r6, r2
   25816:	e9dd 4708 	ldrd	r4, r7, [sp, #32]
   2581a:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2581c:	a801      	add	r0, sp, #4
{
   2581e:	461d      	mov	r5, r3
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25820:	f7fb facc 	bl	20dbc <nrf_gpio_pin_port_decode>
    uint32_t cnf = reg->PIN_CNF[pin_number];
   25824:	9b01      	ldr	r3, [sp, #4]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   25826:	f1b6 0c00 	subs.w	ip, r6, #0
   2582a:	bf18      	it	ne
   2582c:	f04f 0c01 	movne.w	ip, #1
   25830:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   25834:	1e0b      	subs	r3, r1, #0
   25836:	bf18      	it	ne
   25838:	2301      	movne	r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   2583a:	2d00      	cmp	r5, #0
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   2583c:	ea43 034c 	orr.w	r3, r3, ip, lsl #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   25840:	bf14      	ite	ne
   25842:	f04f 0c0c 	movne.w	ip, #12
   25846:	f04f 0c00 	moveq.w	ip, #0
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   2584a:	2c00      	cmp	r4, #0
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
   2584c:	ea43 030c 	orr.w	r3, r3, ip
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
   25850:	bf14      	ite	ne
   25852:	f44f 6c70 	movne.w	ip, #3840	; 0xf00
   25856:	f04f 0c00 	moveq.w	ip, #0
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   2585a:	2f00      	cmp	r7, #0
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
   2585c:	ea43 030c 	orr.w	r3, r3, ip
                         (p_sense ? GPIO_PIN_CNF_SENSE_Msk : 0);
   25860:	bf14      	ite	ne
   25862:	f44f 3c40 	movne.w	ip, #196608	; 0x30000
   25866:	f04f 0c00 	moveq.w	ip, #0
    uint32_t cnf = reg->PIN_CNF[pin_number];
   2586a:	f8d0 2200 	ldr.w	r2, [r0, #512]	; 0x200
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
   2586e:	ea43 030c 	orr.w	r3, r3, ip
    cnf &= ~to_update;
   25872:	ea22 0303 	bic.w	r3, r2, r3
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   25876:	b101      	cbz	r1, 2587a <nrf_gpio_reconfigure+0x68>
   25878:	7809      	ldrb	r1, [r1, #0]
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
   2587a:	b10e      	cbz	r6, 25880 <nrf_gpio_reconfigure+0x6e>
   2587c:	7836      	ldrb	r6, [r6, #0]
   2587e:	0076      	lsls	r6, r6, #1
   25880:	4319      	orrs	r1, r3
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
   25882:	b10d      	cbz	r5, 25888 <nrf_gpio_reconfigure+0x76>
   25884:	782d      	ldrb	r5, [r5, #0]
   25886:	00ad      	lsls	r5, r5, #2
   25888:	4331      	orrs	r1, r6
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
   2588a:	b10c      	cbz	r4, 25890 <nrf_gpio_reconfigure+0x7e>
   2588c:	7824      	ldrb	r4, [r4, #0]
   2588e:	0224      	lsls	r4, r4, #8
   25890:	4329      	orrs	r1, r5
           ((uint32_t)(p_sense ? *p_sense : 0)<< GPIO_PIN_CNF_SENSE_Pos);
   25892:	b10f      	cbz	r7, 25898 <nrf_gpio_reconfigure+0x86>
   25894:	783f      	ldrb	r7, [r7, #0]
   25896:	043f      	lsls	r7, r7, #16
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
   25898:	430c      	orrs	r4, r1
   2589a:	433c      	orrs	r4, r7
    reg->PIN_CNF[pin_number] = cnf;
   2589c:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
}
   258a0:	b003      	add	sp, #12
   258a2:	bdf0      	pop	{r4, r5, r6, r7, pc}

000258a4 <nrf_gpio_cfg_sense_set>:
{
   258a4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   258a6:	f10d 030f 	add.w	r3, sp, #15
   258aa:	9301      	str	r3, [sp, #4]
   258ac:	2300      	movs	r3, #0
{
   258ae:	f88d 100f 	strb.w	r1, [sp, #15]
    nrf_gpio_reconfigure(pin_number, NULL, NULL, NULL, NULL, &sense_config);
   258b2:	461a      	mov	r2, r3
   258b4:	4619      	mov	r1, r3
   258b6:	9300      	str	r3, [sp, #0]
   258b8:	f7ff ffab 	bl	25812 <nrf_gpio_reconfigure>
}
   258bc:	b005      	add	sp, #20
   258be:	f85d fb04 	ldr.w	pc, [sp], #4

000258c2 <nrfx_power_clock_irq_handler>:
 * a library with nrfx is created. In such case, forcing a linker to use this
 * function instead of another one defined as weak will require additional
 * actions, and might be even impossible.
 */
void nrfx_power_clock_irq_handler(void)
{
   258c2:	b508      	push	{r3, lr}
    nrfx_power_irq_handler();
   258c4:	f7fb fe08 	bl	214d8 <nrfx_power_irq_handler>
    nrfx_clock_irq_handler();
}
   258c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_irq_handler();
   258cc:	f7fb ba20 	b.w	20d10 <nrfx_clock_irq_handler>

000258d0 <spim_pin_uninit>:
    if (pin == NRF_SPIM_PIN_NOT_CONNECTED)
   258d0:	1c43      	adds	r3, r0, #1
{
   258d2:	b507      	push	{r0, r1, r2, lr}
    if (pin == NRF_SPIM_PIN_NOT_CONNECTED)
   258d4:	d005      	beq.n	258e2 <spim_pin_uninit+0x12>
    nrf_gpio_cfg(
   258d6:	2300      	movs	r3, #0
   258d8:	2201      	movs	r2, #1
   258da:	4619      	mov	r1, r3
   258dc:	9300      	str	r3, [sp, #0]
   258de:	f7fb fe43 	bl	21568 <nrf_gpio_cfg.constprop.0>
}
   258e2:	b003      	add	sp, #12
   258e4:	f85d fb04 	ldr.w	pc, [sp], #4

000258e8 <set_ss_pin_state>:
    if (p_cb->use_hw_ss)
   258e8:	7f83      	ldrb	r3, [r0, #30]
   258ea:	075a      	lsls	r2, r3, #29
   258ec:	d40b      	bmi.n	25906 <set_ss_pin_state+0x1e>
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   258ee:	7fc0      	ldrb	r0, [r0, #31]
   258f0:	28ff      	cmp	r0, #255	; 0xff
   258f2:	d008      	beq.n	25906 <set_ss_pin_state+0x1e>
        nrf_gpio_pin_write(p_cb->ss_pin,
   258f4:	079b      	lsls	r3, r3, #30
   258f6:	bf58      	it	pl
   258f8:	f081 0101 	eorpl.w	r1, r1, #1
    if (value == 0)
   258fc:	b909      	cbnz	r1, 25902 <set_ss_pin_state+0x1a>
        nrf_gpio_pin_clear(pin_number);
   258fe:	f7fb be23 	b.w	21548 <nrf_gpio_pin_clear>
        nrf_gpio_pin_set(pin_number);
   25902:	f7fb be51 	b.w	215a8 <nrf_gpio_pin_set>
}
   25906:	4770      	bx	lr

00025908 <finish_transfer>:
{
   25908:	b510      	push	{r4, lr}
   2590a:	4604      	mov	r4, r0
    set_ss_pin_state(p_cb, false);
   2590c:	2100      	movs	r1, #0
   2590e:	f7ff ffeb 	bl	258e8 <set_ss_pin_state>
    p_cb->transfer_in_progress = false;
   25912:	2300      	movs	r3, #0
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   25914:	4620      	mov	r0, r4
    p_cb->transfer_in_progress = false;
   25916:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   25918:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2591a:	6861      	ldr	r1, [r4, #4]
   2591c:	f850 3b08 	ldr.w	r3, [r0], #8
}
   25920:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   25924:	4718      	bx	r3

00025926 <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   25926:	7b0a      	ldrb	r2, [r1, #12]
{
   25928:	4603      	mov	r3, r0
    switch (p_cb->xfer_desc.type)
   2592a:	2a03      	cmp	r2, #3
   2592c:	d829      	bhi.n	25982 <xfer_completeness_check+0x5c>
   2592e:	e8df f002 	tbb	[pc, r2]
   25932:	2521      	.short	0x2521
   25934:	0219      	.short	0x0219
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   25936:	688a      	ldr	r2, [r1, #8]
   25938:	0350      	lsls	r0, r2, #13
   2593a:	d504      	bpl.n	25946 <xfer_completeness_check+0x20>
    return p_reg->TXD.AMOUNT;
   2593c:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
   25940:	6908      	ldr	r0, [r1, #16]
   25942:	4290      	cmp	r0, r2
   25944:	d107      	bne.n	25956 <xfer_completeness_check+0x30>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   25946:	688a      	ldr	r2, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   25948:	0352      	lsls	r2, r2, #13
   2594a:	d41a      	bmi.n	25982 <xfer_completeness_check+0x5c>
   2594c:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   25950:	6949      	ldr	r1, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   25952:	4291      	cmp	r1, r2
   25954:	d015      	beq.n	25982 <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   25956:	2000      	movs	r0, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   25958:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   2595a:	f8c3 0500 	str.w	r0, [r3, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   2595e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
   25962:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   25964:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   25968:	6908      	ldr	r0, [r1, #16]
   2596a:	4290      	cmp	r0, r2
   2596c:	d1f3      	bne.n	25956 <xfer_completeness_check+0x30>
    return p_reg->RXD.AMOUNT;
   2596e:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   25972:	e7ed      	b.n	25950 <xfer_completeness_check+0x2a>
    return p_reg->TXD.AMOUNT;
   25974:	f8d3 254c 	ldr.w	r2, [r3, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   25978:	6909      	ldr	r1, [r1, #16]
   2597a:	e7ea      	b.n	25952 <xfer_completeness_check+0x2c>
    return p_reg->RXD.AMOUNT;
   2597c:	f8d3 253c 	ldr.w	r2, [r3, #1340]	; 0x53c
   25980:	e7fa      	b.n	25978 <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   25982:	2001      	movs	r0, #1
}
   25984:	4770      	bx	lr

00025986 <nrfx_usbd_consumer>:
{
   25986:	b530      	push	{r4, r5, lr}
    size_t size = p_transfer->size;
   25988:	684c      	ldr	r4, [r1, #4]
    if (size < data_size)
   2598a:	429c      	cmp	r4, r3
   2598c:	d209      	bcs.n	259a2 <nrfx_usbd_consumer+0x1c>
        p_next->size = 0;
   2598e:	2500      	movs	r5, #0
   25990:	6045      	str	r5, [r0, #4]
        p_next->p_data = p_transfer->p_data;
   25992:	6809      	ldr	r1, [r1, #0]
   25994:	6001      	str	r1, [r0, #0]
    return (ep_size == data_size) && (size != 0);
   25996:	429a      	cmp	r2, r3
   25998:	d10c      	bne.n	259b4 <nrfx_usbd_consumer+0x2e>
   2599a:	1e20      	subs	r0, r4, #0
   2599c:	bf18      	it	ne
   2599e:	2001      	movne	r0, #1
}
   259a0:	bd30      	pop	{r4, r5, pc}
        p_next->size = data_size;
   259a2:	6043      	str	r3, [r0, #4]
        p_next->p_data = p_transfer->p_data;
   259a4:	680d      	ldr	r5, [r1, #0]
        size -= data_size;
   259a6:	1ae4      	subs	r4, r4, r3
        p_next->p_data = p_transfer->p_data;
   259a8:	6005      	str	r5, [r0, #0]
        p_transfer->p_data.addr += data_size;
   259aa:	6808      	ldr	r0, [r1, #0]
        p_transfer->size = size;
   259ac:	604c      	str	r4, [r1, #4]
        p_transfer->p_data.addr += data_size;
   259ae:	4418      	add	r0, r3
   259b0:	6008      	str	r0, [r1, #0]
   259b2:	e7f0      	b.n	25996 <nrfx_usbd_consumer+0x10>
    return (ep_size == data_size) && (size != 0);
   259b4:	2000      	movs	r0, #0
   259b6:	e7f3      	b.n	259a0 <nrfx_usbd_consumer+0x1a>

000259b8 <nrfx_usbd_feeder_ram>:
    if (tx_size > ep_size)
   259b8:	684b      	ldr	r3, [r1, #4]
   259ba:	429a      	cmp	r2, r3
   259bc:	bf28      	it	cs
   259be:	461a      	movcs	r2, r3
    p_next->p_data = p_transfer->p_data;
   259c0:	680b      	ldr	r3, [r1, #0]
    p_next->size = tx_size;
   259c2:	e9c0 3200 	strd	r3, r2, [r0]
    p_transfer->size -= tx_size;
   259c6:	6848      	ldr	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   259c8:	680b      	ldr	r3, [r1, #0]
    p_transfer->size -= tx_size;
   259ca:	1a80      	subs	r0, r0, r2
   259cc:	6048      	str	r0, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   259ce:	4413      	add	r3, r2
}
   259d0:	3800      	subs	r0, #0
   259d2:	bf18      	it	ne
   259d4:	2001      	movne	r0, #1
    p_transfer->p_data.addr += tx_size;
   259d6:	600b      	str	r3, [r1, #0]
}
   259d8:	4770      	bx	lr

000259da <nrfx_usbd_feeder_ram_zlp>:
    if (tx_size > ep_size)
   259da:	684b      	ldr	r3, [r1, #4]
   259dc:	429a      	cmp	r2, r3
   259de:	bf28      	it	cs
   259e0:	461a      	movcs	r2, r3
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
   259e2:	b16a      	cbz	r2, 25a00 <nrfx_usbd_feeder_ram_zlp+0x26>
   259e4:	680b      	ldr	r3, [r1, #0]
    p_next->size = tx_size;
   259e6:	e9c0 3200 	strd	r3, r2, [r0]
    p_transfer->size -= tx_size;
   259ea:	684b      	ldr	r3, [r1, #4]
}
   259ec:	1e10      	subs	r0, r2, #0
    p_transfer->size -= tx_size;
   259ee:	eba3 0302 	sub.w	r3, r3, r2
   259f2:	604b      	str	r3, [r1, #4]
    p_transfer->p_data.addr += tx_size;
   259f4:	680b      	ldr	r3, [r1, #0]
}
   259f6:	bf18      	it	ne
   259f8:	2001      	movne	r0, #1
    p_transfer->p_data.addr += tx_size;
   259fa:	4413      	add	r3, r2
   259fc:	600b      	str	r3, [r1, #0]
}
   259fe:	4770      	bx	lr
    p_next->p_data.tx = (tx_size == 0) ? NULL : p_transfer->p_data.tx;
   25a00:	4613      	mov	r3, r2
   25a02:	e7f0      	b.n	259e6 <nrfx_usbd_feeder_ram_zlp+0xc>

00025a04 <ep2bit>:
    return NRFX_USBD_EP_BITPOS(ep);
   25a04:	43c3      	mvns	r3, r0
   25a06:	f000 000f 	and.w	r0, r0, #15
   25a0a:	f3c3 13c0 	ubfx	r3, r3, #7, #1
}
   25a0e:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   25a12:	4770      	bx	lr

00025a14 <ev_started_handler>:
}
   25a14:	4770      	bx	lr

00025a16 <ev_dma_epin7_handler>:
static void ev_dma_epin7_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN7 ); }
   25a16:	2087      	movs	r0, #135	; 0x87
   25a18:	f7fc bbe2 	b.w	221e0 <nrf_usbd_epin_dma_handler>

00025a1c <ev_dma_epin6_handler>:
static void ev_dma_epin6_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN6 ); }
   25a1c:	2086      	movs	r0, #134	; 0x86
   25a1e:	f7fc bbdf 	b.w	221e0 <nrf_usbd_epin_dma_handler>

00025a22 <ev_dma_epin5_handler>:
static void ev_dma_epin5_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN5 ); }
   25a22:	2085      	movs	r0, #133	; 0x85
   25a24:	f7fc bbdc 	b.w	221e0 <nrf_usbd_epin_dma_handler>

00025a28 <ev_dma_epin4_handler>:
static void ev_dma_epin4_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN4 ); }
   25a28:	2084      	movs	r0, #132	; 0x84
   25a2a:	f7fc bbd9 	b.w	221e0 <nrf_usbd_epin_dma_handler>

00025a2e <ev_dma_epin3_handler>:
static void ev_dma_epin3_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN3 ); }
   25a2e:	2083      	movs	r0, #131	; 0x83
   25a30:	f7fc bbd6 	b.w	221e0 <nrf_usbd_epin_dma_handler>

00025a34 <ev_dma_epin2_handler>:
static void ev_dma_epin2_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN2 ); }
   25a34:	2082      	movs	r0, #130	; 0x82
   25a36:	f7fc bbd3 	b.w	221e0 <nrf_usbd_epin_dma_handler>

00025a3a <ev_dma_epin1_handler>:
static void ev_dma_epin1_handler(void)  { nrf_usbd_epin_dma_handler(NRFX_USBD_EPIN1 ); }
   25a3a:	2081      	movs	r0, #129	; 0x81
   25a3c:	f7fc bbd0 	b.w	221e0 <nrf_usbd_epin_dma_handler>

00025a40 <ev_dma_epin0_handler>:
static void ev_dma_epin0_handler(void)  { nrf_usbd_ep0in_dma_handler(); }
   25a40:	f7fc bbea 	b.w	22218 <nrf_usbd_ep0in_dma_handler>

00025a44 <nrfx_usbd_ep_max_packet_size_set>:
{
   25a44:	b508      	push	{r3, lr}
    usbd_ep_state_t * p_state = ep_state_access(ep);
   25a46:	f7fc fb03 	bl	22050 <ep_state_access>
    p_state->max_packet_size = size;
   25a4a:	8181      	strh	r1, [r0, #12]
}
   25a4c:	bd08      	pop	{r3, pc}

00025a4e <nrfx_usbd_ep_status_get>:
{
   25a4e:	b508      	push	{r3, lr}
    usbd_ep_state_t const * p_state = ep_state_access(ep);
   25a50:	f7fc fafe 	bl	22050 <ep_state_access>
	__asm__ volatile(
   25a54:	f04f 0220 	mov.w	r2, #32
   25a58:	f3ef 8311 	mrs	r3, BASEPRI
   25a5c:	f382 8812 	msr	BASEPRI_MAX, r2
   25a60:	f3bf 8f6f 	isb	sy
    *p_size = p_state->transfer_cnt;
   25a64:	6882      	ldr	r2, [r0, #8]
   25a66:	600a      	str	r2, [r1, #0]
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   25a68:	6802      	ldr	r2, [r0, #0]
   25a6a:	b92a      	cbnz	r2, 25a78 <nrfx_usbd_ep_status_get+0x2a>
   25a6c:	7b80      	ldrb	r0, [r0, #14]
	__asm__ volatile(
   25a6e:	f383 8811 	msr	BASEPRI, r3
   25a72:	f3bf 8f6f 	isb	sy
}
   25a76:	bd08      	pop	{r3, pc}
    ret = (p_state->handler.consumer == NULL) ? p_state->status : NRFX_USBD_EP_BUSY;
   25a78:	2004      	movs	r0, #4
   25a7a:	e7f8      	b.n	25a6e <nrfx_usbd_ep_status_get+0x20>

00025a7c <ev_dma_epout7_handler>:
static void ev_dma_epout7_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT7); }
   25a7c:	2007      	movs	r0, #7
   25a7e:	f7fc bec5 	b.w	2280c <nrf_usbd_epout_dma_handler>

00025a82 <ev_dma_epout6_handler>:
static void ev_dma_epout6_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT6); }
   25a82:	2006      	movs	r0, #6
   25a84:	f7fc bec2 	b.w	2280c <nrf_usbd_epout_dma_handler>

00025a88 <ev_dma_epout5_handler>:
static void ev_dma_epout5_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT5); }
   25a88:	2005      	movs	r0, #5
   25a8a:	f7fc bebf 	b.w	2280c <nrf_usbd_epout_dma_handler>

00025a8e <ev_dma_epout4_handler>:
static void ev_dma_epout4_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT4); }
   25a8e:	2004      	movs	r0, #4
   25a90:	f7fc bebc 	b.w	2280c <nrf_usbd_epout_dma_handler>

00025a94 <ev_dma_epout3_handler>:
static void ev_dma_epout3_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT3); }
   25a94:	2003      	movs	r0, #3
   25a96:	f7fc beb9 	b.w	2280c <nrf_usbd_epout_dma_handler>

00025a9a <ev_dma_epout2_handler>:
static void ev_dma_epout2_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT2); }
   25a9a:	2002      	movs	r0, #2
   25a9c:	f7fc beb6 	b.w	2280c <nrf_usbd_epout_dma_handler>

00025aa0 <ev_dma_epout1_handler>:
static void ev_dma_epout1_handler(void) { nrf_usbd_epout_dma_handler(NRFX_USBD_EPOUT1); }
   25aa0:	2001      	movs	r0, #1
   25aa2:	f7fc beb3 	b.w	2280c <nrf_usbd_epout_dma_handler>

00025aa6 <nrfx_usbd_ep_abort>:
    usbd_ep_abort(ep);
   25aa6:	f7fc bfad 	b.w	22a04 <usbd_ep_abort>

00025aaa <nrf_gpio_pin_set>:
{
   25aaa:	b507      	push	{r0, r1, r2, lr}
   25aac:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   25aae:	a801      	add	r0, sp, #4
   25ab0:	f7fd f9da 	bl	22e68 <nrf_gpio_pin_port_decode>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   25ab4:	2301      	movs	r3, #1
   25ab6:	9a01      	ldr	r2, [sp, #4]
   25ab8:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
   25aba:	6083      	str	r3, [r0, #8]
}
   25abc:	b003      	add	sp, #12
   25abe:	f85d fb04 	ldr.w	pc, [sp], #4

00025ac2 <z_device_state_init>:

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
   25ac2:	4770      	bx	lr

00025ac4 <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
   25ac4:	b140      	cbz	r0, 25ad8 <z_device_is_ready+0x14>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
   25ac6:	68c3      	ldr	r3, [r0, #12]
   25ac8:	7858      	ldrb	r0, [r3, #1]
   25aca:	f010 0001 	ands.w	r0, r0, #1
   25ace:	bf1e      	ittt	ne
   25ad0:	7818      	ldrbne	r0, [r3, #0]
   25ad2:	fab0 f080 	clzne	r0, r0
   25ad6:	0940      	lsrne	r0, r0, #5
}
   25ad8:	4770      	bx	lr

00025ada <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   25ada:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25adc:	4605      	mov	r5, r0
   25ade:	460e      	mov	r6, r1
	__asm__ volatile(
   25ae0:	f04f 0320 	mov.w	r3, #32
   25ae4:	f3ef 8711 	mrs	r7, BASEPRI
   25ae8:	f383 8812 	msr	BASEPRI_MAX, r3
   25aec:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
   25af0:	f7fe f9d2 	bl	23e98 <z_impl_z_current_get>

#ifndef CONFIG_XTENSA
	coredump(reason, esf, thread);
#endif

	k_sys_fatal_error_handler(reason, esf);
   25af4:	4631      	mov	r1, r6
   25af6:	4604      	mov	r4, r0
   25af8:	4628      	mov	r0, r5
   25afa:	f7ff fe4b 	bl	25794 <k_sys_fatal_error_handler>
	__asm__ volatile(
   25afe:	f387 8811 	msr	BASEPRI, r7
   25b02:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   25b06:	4620      	mov	r0, r4
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
   25b08:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   25b0c:	f7f8 bece 	b.w	1e8ac <z_impl_k_thread_abort>

00025b10 <z_early_memset>:
	(void) memset(dst, c, n);
   25b10:	f7ff ba6a 	b.w	24fe8 <memset>

00025b14 <z_early_memcpy>:
	(void) memcpy(dst, src, n);
   25b14:	f7ff ba5d 	b.w	24fd2 <memcpy>

00025b18 <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   25b18:	e9d0 3203 	ldrd	r3, r2, [r0, #12]
   25b1c:	4313      	orrs	r3, r2
   25b1e:	f013 0303 	ands.w	r3, r3, #3
   25b22:	d10c      	bne.n	25b3e <create_free_list+0x26>
	slab->free_list = NULL;
   25b24:	6143      	str	r3, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   25b26:	6881      	ldr	r1, [r0, #8]
   25b28:	4299      	cmp	r1, r3
   25b2a:	d801      	bhi.n	25b30 <create_free_list+0x18>
	return 0;
   25b2c:	2000      	movs	r0, #0
   25b2e:	4770      	bx	lr
		*(char **)p = slab->free_list;
   25b30:	6941      	ldr	r1, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   25b32:	3301      	adds	r3, #1
		*(char **)p = slab->free_list;
   25b34:	6011      	str	r1, [r2, #0]
		p += slab->block_size;
   25b36:	68c1      	ldr	r1, [r0, #12]
		slab->free_list = p;
   25b38:	6142      	str	r2, [r0, #20]
		p += slab->block_size;
   25b3a:	440a      	add	r2, r1
	for (j = 0U; j < slab->num_blocks; j++) {
   25b3c:	e7f3      	b.n	25b26 <create_free_list+0xe>
		return -EINVAL;
   25b3e:	f06f 0015 	mvn.w	r0, #21
}
   25b42:	4770      	bx	lr

00025b44 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   25b44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   25b46:	4604      	mov	r4, r0
   25b48:	460d      	mov	r5, r1
	__asm__ volatile(
   25b4a:	f04f 0320 	mov.w	r3, #32
   25b4e:	f3ef 8611 	mrs	r6, BASEPRI
   25b52:	f383 8812 	msr	BASEPRI_MAX, r3
   25b56:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
   25b5a:	6947      	ldr	r7, [r0, #20]
   25b5c:	b977      	cbnz	r7, 25b7c <k_mem_slab_free+0x38>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   25b5e:	f000 f9ad 	bl	25ebc <z_unpend_first_thread>

		if (pending_thread != NULL) {
   25b62:	b158      	cbz	r0, 25b7c <k_mem_slab_free+0x38>
			SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   25b64:	682a      	ldr	r2, [r5, #0]
   25b66:	6787      	str	r7, [r0, #120]	; 0x78
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   25b68:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
   25b6a:	f000 f95f 	bl	25e2c <z_ready_thread>
			z_reschedule(&slab->lock, key);
   25b6e:	4631      	mov	r1, r6
   25b70:	f104 0008 	add.w	r0, r4, #8
	slab->num_used--;

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
   25b74:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&slab->lock, key);
   25b78:	f7fe b83e 	b.w	23bf8 <z_reschedule>
	**(char ***) mem = slab->free_list;
   25b7c:	682b      	ldr	r3, [r5, #0]
   25b7e:	6962      	ldr	r2, [r4, #20]
   25b80:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
   25b82:	682b      	ldr	r3, [r5, #0]
   25b84:	6163      	str	r3, [r4, #20]
	slab->num_used--;
   25b86:	69a3      	ldr	r3, [r4, #24]
   25b88:	3b01      	subs	r3, #1
   25b8a:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   25b8c:	f386 8811 	msr	BASEPRI, r6
   25b90:	f3bf 8f6f 	isb	sy
}
   25b94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00025b96 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   25b96:	f3ef 8005 	mrs	r0, IPSR
}
   25b9a:	3800      	subs	r0, #0
   25b9c:	bf18      	it	ne
   25b9e:	2001      	movne	r0, #1
   25ba0:	4770      	bx	lr

00025ba2 <z_impl_k_thread_name_set>:
}
   25ba2:	f06f 0057 	mvn.w	r0, #87	; 0x57
   25ba6:	4770      	bx	lr

00025ba8 <z_impl_k_thread_start>:
	z_sched_start(thread);
   25ba8:	f7fe b838 	b.w	23c1c <z_sched_start>

00025bac <z_pm_save_idle_exit>:
{
   25bac:	b508      	push	{r3, lr}
	pm_system_resume();
   25bae:	f7f7 f9d1 	bl	1cf54 <pm_system_resume>
}
   25bb2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	sys_clock_idle_exit();
   25bb6:	f7ff bddc 	b.w	25772 <sys_clock_idle_exit>

00025bba <adjust_owner_prio.isra.0>:
	if (mutex->owner->base.prio != new_prio) {
   25bba:	f990 300e 	ldrsb.w	r3, [r0, #14]
   25bbe:	428b      	cmp	r3, r1
   25bc0:	d001      	beq.n	25bc6 <adjust_owner_prio.isra.0+0xc>
		return z_set_prio(mutex->owner, new_prio);
   25bc2:	f7fd bfd3 	b.w	23b6c <z_set_prio>
}
   25bc6:	2000      	movs	r0, #0
   25bc8:	4770      	bx	lr

00025bca <z_impl_k_mutex_init>:
{
   25bca:	4603      	mov	r3, r0
	mutex->owner = NULL;
   25bcc:	2000      	movs	r0, #0
	list->tail = (sys_dnode_t *)list;
   25bce:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   25bd2:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   25bd6:	4770      	bx	lr

00025bd8 <queue_insert>:
{
   25bd8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   25bdc:	4699      	mov	r9, r3
   25bde:	4604      	mov	r4, r0
   25be0:	460d      	mov	r5, r1
   25be2:	4690      	mov	r8, r2
   25be4:	f89d 3020 	ldrb.w	r3, [sp, #32]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   25be8:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   25bec:	f04f 0220 	mov.w	r2, #32
   25bf0:	f3ef 8711 	mrs	r7, BASEPRI
   25bf4:	f382 8812 	msr	BASEPRI_MAX, r2
   25bf8:	f3bf 8f6f 	isb	sy
	if (is_append) {
   25bfc:	b103      	cbz	r3, 25c00 <queue_insert+0x28>
	return list->tail;
   25bfe:	6845      	ldr	r5, [r0, #4]
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   25c00:	4630      	mov	r0, r6
   25c02:	f000 f95b 	bl	25ebc <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   25c06:	b158      	cbz	r0, 25c20 <queue_insert+0x48>
   25c08:	2300      	movs	r3, #0
   25c0a:	f8c0 8014 	str.w	r8, [r0, #20]
   25c0e:	6783      	str	r3, [r0, #120]	; 0x78
	z_ready_thread(thread);
   25c10:	f000 f90c 	bl	25e2c <z_ready_thread>
	z_reschedule(&queue->lock, key);
   25c14:	4630      	mov	r0, r6
   25c16:	4639      	mov	r1, r7
   25c18:	f7fd ffee 	bl	23bf8 <z_reschedule>
		return 0;
   25c1c:	2000      	movs	r0, #0
   25c1e:	e00c      	b.n	25c3a <queue_insert+0x62>
	if (alloc) {
   25c20:	f1b9 0f00 	cmp.w	r9, #0
   25c24:	d01c      	beq.n	25c60 <queue_insert+0x88>
	return z_thread_aligned_alloc(0, size);
   25c26:	2108      	movs	r1, #8
   25c28:	f7fe fbaa 	bl	24380 <z_thread_aligned_alloc>
		if (anode == NULL) {
   25c2c:	b938      	cbnz	r0, 25c3e <queue_insert+0x66>
	__asm__ volatile(
   25c2e:	f387 8811 	msr	BASEPRI, r7
   25c32:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   25c36:	f06f 000b 	mvn.w	r0, #11
}
   25c3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   25c3e:	2201      	movs	r2, #1
		anode->data = data;
   25c40:	f8c0 8004 	str.w	r8, [r0, #4]
   25c44:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25c46:	6801      	ldr	r1, [r0, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c48:	f001 0103 	and.w	r1, r1, #3
Z_GENLIST_INSERT(sflist, sfnode)
   25c4c:	b965      	cbnz	r5, 25c68 <queue_insert+0x90>
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c4e:	6822      	ldr	r2, [r4, #0]
   25c50:	430a      	orrs	r2, r1
   25c52:	6002      	str	r2, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   25c54:	6862      	ldr	r2, [r4, #4]
	list->head = node;
   25c56:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   25c58:	2a00      	cmp	r2, #0
   25c5a:	d1db      	bne.n	25c14 <queue_insert+0x3c>
	list->tail = node;
   25c5c:	6060      	str	r0, [r4, #4]
}
   25c5e:	e7d9      	b.n	25c14 <queue_insert+0x3c>
}
   25c60:	4640      	mov	r0, r8
	node->next_and_flags = flags;
   25c62:	f8c8 9000 	str.w	r9, [r8]
}
   25c66:	e7ee      	b.n	25c46 <queue_insert+0x6e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   25c68:	682a      	ldr	r2, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   25c6a:	2a03      	cmp	r2, #3
   25c6c:	d80b      	bhi.n	25c86 <queue_insert+0xae>
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c6e:	6001      	str	r1, [r0, #0]
	return list->tail;
   25c70:	6861      	ldr	r1, [r4, #4]
Z_GENLIST_APPEND(sflist, sfnode)
   25c72:	b911      	cbnz	r1, 25c7a <queue_insert+0xa2>
	list->head = node;
   25c74:	e9c4 0000 	strd	r0, r0, [r4]
}
   25c78:	e7cc      	b.n	25c14 <queue_insert+0x3c>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25c7a:	680a      	ldr	r2, [r1, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c7c:	f002 0203 	and.w	r2, r2, #3
   25c80:	4302      	orrs	r2, r0
   25c82:	600a      	str	r2, [r1, #0]
   25c84:	e7ea      	b.n	25c5c <queue_insert+0x84>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   25c86:	f022 0203 	bic.w	r2, r2, #3
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c8a:	430a      	orrs	r2, r1
   25c8c:	6002      	str	r2, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25c8e:	682a      	ldr	r2, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   25c90:	f002 0203 	and.w	r2, r2, #3
   25c94:	ea40 0302 	orr.w	r3, r0, r2
   25c98:	602b      	str	r3, [r5, #0]
}
   25c9a:	e7bb      	b.n	25c14 <queue_insert+0x3c>

00025c9c <z_queue_node_peek>:
{
   25c9c:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (uint8_t)0)) {
   25c9e:	4604      	mov	r4, r0
   25ca0:	b130      	cbz	r0, 25cb0 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   25ca2:	6802      	ldr	r2, [r0, #0]
   25ca4:	0793      	lsls	r3, r2, #30
   25ca6:	d003      	beq.n	25cb0 <z_queue_node_peek+0x14>
		ret = anode->data;
   25ca8:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   25caa:	b109      	cbz	r1, 25cb0 <z_queue_node_peek+0x14>
			k_free(anode);
   25cac:	f000 f9d5 	bl	2605a <k_free>
}
   25cb0:	4620      	mov	r0, r4
   25cb2:	bd10      	pop	{r4, pc}

00025cb4 <k_queue_append>:
	(void)queue_insert(queue, NULL, data, false, true);
   25cb4:	2301      	movs	r3, #1
{
   25cb6:	b507      	push	{r0, r1, r2, lr}
	(void)queue_insert(queue, NULL, data, false, true);
   25cb8:	9300      	str	r3, [sp, #0]
   25cba:	2300      	movs	r3, #0
{
   25cbc:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false, true);
   25cbe:	4619      	mov	r1, r3
   25cc0:	f7ff ff8a 	bl	25bd8 <queue_insert>
}
   25cc4:	b003      	add	sp, #12
   25cc6:	f85d fb04 	ldr.w	pc, [sp], #4

00025cca <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || limit > K_SEM_MAX_LIMIT || initial_count > limit) {
   25cca:	b13a      	cbz	r2, 25cdc <z_impl_k_sem_init+0x12>
   25ccc:	428a      	cmp	r2, r1
   25cce:	d305      	bcc.n	25cdc <z_impl_k_sem_init+0x12>
	sem->limit = limit;
   25cd0:	e9c0 1202 	strd	r1, r2, [r0, #8]
   25cd4:	e9c0 0000 	strd	r0, r0, [r0]
	return 0;
   25cd8:	2000      	movs	r0, #0
   25cda:	4770      	bx	lr
		return -EINVAL;
   25cdc:	f06f 0015 	mvn.w	r0, #21
}
   25ce0:	4770      	bx	lr

00025ce2 <flag_test_and_clear>:
	*flagp &= ~BIT(bit);
   25ce2:	2301      	movs	r3, #1
	return (*flagp & BIT(bit)) != 0U;
   25ce4:	6802      	ldr	r2, [r0, #0]
	*flagp &= ~BIT(bit);
   25ce6:	408b      	lsls	r3, r1
   25ce8:	ea22 0303 	bic.w	r3, r2, r3
   25cec:	6003      	str	r3, [r0, #0]
	return (*flagp & BIT(bit)) != 0U;
   25cee:	fa22 f001 	lsr.w	r0, r2, r1
}
   25cf2:	f000 0001 	and.w	r0, r0, #1
   25cf6:	4770      	bx	lr

00025cf8 <notify_queue_locked.isra.0>:
	if (queue != NULL) {
   25cf8:	b120      	cbz	r0, 25d04 <notify_queue_locked.isra.0+0xc>
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
   25cfa:	2200      	movs	r2, #0
   25cfc:	3088      	adds	r0, #136	; 0x88
   25cfe:	4611      	mov	r1, r2
   25d00:	f000 b936 	b.w	25f70 <z_sched_wake>
}
   25d04:	4770      	bx	lr

00025d06 <work_timeout>:
{
   25d06:	b573      	push	{r0, r1, r4, r5, r6, lr}
   25d08:	4604      	mov	r4, r0
	__asm__ volatile(
   25d0a:	f04f 0320 	mov.w	r3, #32
   25d0e:	f3ef 8511 	mrs	r5, BASEPRI
   25d12:	f383 8812 	msr	BASEPRI_MAX, r3
   25d16:	f3bf 8f6f 	isb	sy
	struct k_work_q *queue = NULL;
   25d1a:	2300      	movs	r3, #0
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   25d1c:	f1a0 0610 	sub.w	r6, r0, #16
   25d20:	2103      	movs	r1, #3
   25d22:	3804      	subs	r0, #4
	struct k_work_q *queue = NULL;
   25d24:	9301      	str	r3, [sp, #4]
	if (flag_test_and_clear(&wp->flags, K_WORK_DELAYED_BIT)) {
   25d26:	f7ff ffdc 	bl	25ce2 <flag_test_and_clear>
   25d2a:	b128      	cbz	r0, 25d38 <work_timeout+0x32>
		queue = dw->queue;
   25d2c:	69a3      	ldr	r3, [r4, #24]
		(void)submit_to_queue_locked(wp, &queue);
   25d2e:	4630      	mov	r0, r6
   25d30:	a901      	add	r1, sp, #4
		queue = dw->queue;
   25d32:	9301      	str	r3, [sp, #4]
		(void)submit_to_queue_locked(wp, &queue);
   25d34:	f7fd fcfe 	bl	23734 <submit_to_queue_locked>
	__asm__ volatile(
   25d38:	f385 8811 	msr	BASEPRI, r5
   25d3c:	f3bf 8f6f 	isb	sy
}
   25d40:	b002      	add	sp, #8
   25d42:	bd70      	pop	{r4, r5, r6, pc}

00025d44 <k_work_init>:
{
   25d44:	b538      	push	{r3, r4, r5, lr}
   25d46:	4604      	mov	r4, r0
   25d48:	460d      	mov	r5, r1
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   25d4a:	2210      	movs	r2, #16
   25d4c:	2100      	movs	r1, #0
   25d4e:	f7ff f94b 	bl	24fe8 <memset>
   25d52:	6065      	str	r5, [r4, #4]
}
   25d54:	bd38      	pop	{r3, r4, r5, pc}

00025d56 <z_work_submit_to_queue>:
{
   25d56:	b513      	push	{r0, r1, r4, lr}
   25d58:	9001      	str	r0, [sp, #4]
   25d5a:	4608      	mov	r0, r1
	__asm__ volatile(
   25d5c:	f04f 0320 	mov.w	r3, #32
   25d60:	f3ef 8411 	mrs	r4, BASEPRI
   25d64:	f383 8812 	msr	BASEPRI_MAX, r3
   25d68:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
   25d6c:	a901      	add	r1, sp, #4
   25d6e:	f7fd fce1 	bl	23734 <submit_to_queue_locked>
	__asm__ volatile(
   25d72:	f384 8811 	msr	BASEPRI, r4
   25d76:	f3bf 8f6f 	isb	sy
}
   25d7a:	b002      	add	sp, #8
   25d7c:	bd10      	pop	{r4, pc}

00025d7e <k_work_submit_to_queue>:
{
   25d7e:	b510      	push	{r4, lr}
	int ret = z_work_submit_to_queue(queue, work);
   25d80:	f7ff ffe9 	bl	25d56 <z_work_submit_to_queue>
	if (ret > 0) {
   25d84:	1e04      	subs	r4, r0, #0
   25d86:	dd09      	ble.n	25d9c <k_work_submit_to_queue+0x1e>
	__asm__ volatile(
   25d88:	f04f 0320 	mov.w	r3, #32
   25d8c:	f3ef 8011 	mrs	r0, BASEPRI
   25d90:	f383 8812 	msr	BASEPRI_MAX, r3
   25d94:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   25d98:	f000 f8c4 	bl	25f24 <z_reschedule_irqlock>
}
   25d9c:	4620      	mov	r0, r4
   25d9e:	bd10      	pop	{r4, pc}

00025da0 <k_work_init_delayable>:
{
   25da0:	b538      	push	{r3, r4, r5, lr}
	*dwork = (struct k_work_delayable){
   25da2:	2230      	movs	r2, #48	; 0x30
{
   25da4:	460d      	mov	r5, r1
	*dwork = (struct k_work_delayable){
   25da6:	2100      	movs	r1, #0
{
   25da8:	4604      	mov	r4, r0
	*dwork = (struct k_work_delayable){
   25daa:	f7ff f91d 	bl	24fe8 <memset>
   25dae:	f44f 7380 	mov.w	r3, #256	; 0x100
   25db2:	6065      	str	r5, [r4, #4]
   25db4:	60e3      	str	r3, [r4, #12]
}
   25db6:	bd38      	pop	{r3, r4, r5, pc}

00025db8 <sys_dlist_remove>:
	sys_dnode_t *const next = node->next;
   25db8:	e9d0 3200 	ldrd	r3, r2, [r0]
	prev->next = next;
   25dbc:	6013      	str	r3, [r2, #0]
	next->prev = prev;
   25dbe:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   25dc0:	2300      	movs	r3, #0
	node->prev = NULL;
   25dc2:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dnode_init(node);
}
   25dc6:	4770      	bx	lr

00025dc8 <unpend_thread_no_timeout>:
{
   25dc8:	b508      	push	{r3, lr}
	sys_dlist_remove(&thread->base.qnode_dlist);
   25dca:	f7ff fff5 	bl	25db8 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   25dce:	7b43      	ldrb	r3, [r0, #13]
   25dd0:	f023 0302 	bic.w	r3, r3, #2
   25dd4:	7343      	strb	r3, [r0, #13]
	thread->base.pended_on = NULL;
   25dd6:	2300      	movs	r3, #0
   25dd8:	6083      	str	r3, [r0, #8]
}
   25dda:	bd08      	pop	{r3, pc}

00025ddc <add_to_waitq_locked>:
{
   25ddc:	b538      	push	{r3, r4, r5, lr}
   25dde:	4604      	mov	r4, r0
   25de0:	460d      	mov	r5, r1
	unready_thread(thread);
   25de2:	f7fd fe45 	bl	23a70 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   25de6:	7b63      	ldrb	r3, [r4, #13]
   25de8:	f043 0302 	orr.w	r3, r3, #2
   25dec:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   25dee:	b1e5      	cbz	r5, 25e2a <add_to_waitq_locked+0x4e>
		thread->base.pended_on = wait_q;
   25df0:	60a5      	str	r5, [r4, #8]
	return list->head == list;
   25df2:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25df4:	429d      	cmp	r5, r3
   25df6:	d109      	bne.n	25e0c <add_to_waitq_locked+0x30>
	sys_dnode_t *const tail = list->tail;
   25df8:	686b      	ldr	r3, [r5, #4]
	node->prev = tail;
   25dfa:	e9c4 5300 	strd	r5, r3, [r4]
	tail->next = node;
   25dfe:	601c      	str	r4, [r3, #0]
	list->tail = node;
   25e00:	606c      	str	r4, [r5, #4]
}
   25e02:	e012      	b.n	25e2a <add_to_waitq_locked+0x4e>
	return (node == list->tail) ? NULL : node->next;
   25e04:	686a      	ldr	r2, [r5, #4]
   25e06:	4293      	cmp	r3, r2
   25e08:	d0f6      	beq.n	25df8 <add_to_waitq_locked+0x1c>
   25e0a:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   25e0c:	2b00      	cmp	r3, #0
   25e0e:	d0f3      	beq.n	25df8 <add_to_waitq_locked+0x1c>
	int32_t b1 = thread_1->base.prio;
   25e10:	f994 200e 	ldrsb.w	r2, [r4, #14]
	int32_t b2 = thread_2->base.prio;
   25e14:	f993 100e 	ldrsb.w	r1, [r3, #14]
	if (b1 != b2) {
   25e18:	428a      	cmp	r2, r1
   25e1a:	d0f3      	beq.n	25e04 <add_to_waitq_locked+0x28>
		if (z_sched_prio_cmp(thread, t) > 0) {
   25e1c:	4291      	cmp	r1, r2
   25e1e:	ddf1      	ble.n	25e04 <add_to_waitq_locked+0x28>
	sys_dnode_t *const prev = successor->prev;
   25e20:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   25e22:	e9c4 3200 	strd	r3, r2, [r4]
	prev->next = node;
   25e26:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   25e28:	605c      	str	r4, [r3, #4]
}
   25e2a:	bd38      	pop	{r3, r4, r5, pc}

00025e2c <z_ready_thread>:
{
   25e2c:	b510      	push	{r4, lr}
   25e2e:	f04f 0320 	mov.w	r3, #32
   25e32:	f3ef 8411 	mrs	r4, BASEPRI
   25e36:	f383 8812 	msr	BASEPRI_MAX, r3
   25e3a:	f3bf 8f6f 	isb	sy
			ready_thread(thread);
   25e3e:	f7fd fde3 	bl	23a08 <ready_thread>
	__asm__ volatile(
   25e42:	f384 8811 	msr	BASEPRI, r4
   25e46:	f3bf 8f6f 	isb	sy
}
   25e4a:	bd10      	pop	{r4, pc}

00025e4c <z_unpend_thread_no_timeout>:
{
   25e4c:	b508      	push	{r3, lr}
	__asm__ volatile(
   25e4e:	f04f 0220 	mov.w	r2, #32
   25e52:	f3ef 8111 	mrs	r1, BASEPRI
   25e56:	f382 8812 	msr	BASEPRI_MAX, r2
   25e5a:	f3bf 8f6f 	isb	sy
		if (thread->base.pended_on != NULL) {
   25e5e:	6883      	ldr	r3, [r0, #8]
   25e60:	b10b      	cbz	r3, 25e66 <z_unpend_thread_no_timeout+0x1a>
			unpend_thread_no_timeout(thread);
   25e62:	f7ff ffb1 	bl	25dc8 <unpend_thread_no_timeout>
	__asm__ volatile(
   25e66:	f381 8811 	msr	BASEPRI, r1
   25e6a:	f3bf 8f6f 	isb	sy
}
   25e6e:	bd08      	pop	{r3, pc}

00025e70 <z_sched_wake_thread>:
{
   25e70:	b538      	push	{r3, r4, r5, lr}
   25e72:	4604      	mov	r4, r0
	__asm__ volatile(
   25e74:	f04f 0320 	mov.w	r3, #32
   25e78:	f3ef 8511 	mrs	r5, BASEPRI
   25e7c:	f383 8812 	msr	BASEPRI_MAX, r3
   25e80:	f3bf 8f6f 	isb	sy
		if (!killed) {
   25e84:	7b43      	ldrb	r3, [r0, #13]
   25e86:	f013 0f28 	tst.w	r3, #40	; 0x28
   25e8a:	d10b      	bne.n	25ea4 <z_sched_wake_thread+0x34>
			if (thread->base.pended_on != NULL) {
   25e8c:	6883      	ldr	r3, [r0, #8]
   25e8e:	b10b      	cbz	r3, 25e94 <z_sched_wake_thread+0x24>
				unpend_thread_no_timeout(thread);
   25e90:	f7ff ff9a 	bl	25dc8 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_PRESTART;
   25e94:	7b63      	ldrb	r3, [r4, #13]
			if (is_timeout) {
   25e96:	b951      	cbnz	r1, 25eae <z_sched_wake_thread+0x3e>
   25e98:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
			ready_thread(thread);
   25e9c:	4620      	mov	r0, r4
   25e9e:	7363      	strb	r3, [r4, #13]
   25ea0:	f7fd fdb2 	bl	23a08 <ready_thread>
	__asm__ volatile(
   25ea4:	f385 8811 	msr	BASEPRI, r5
   25ea8:	f3bf 8f6f 	isb	sy
}
   25eac:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   25eae:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
}
   25eb2:	e7f3      	b.n	25e9c <z_sched_wake_thread+0x2c>

00025eb4 <z_thread_timeout>:
	z_sched_wake_thread(thread, true);
   25eb4:	2101      	movs	r1, #1
   25eb6:	3818      	subs	r0, #24
   25eb8:	f7ff bfda 	b.w	25e70 <z_sched_wake_thread>

00025ebc <z_unpend_first_thread>:
{
   25ebc:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   25ebe:	f04f 0320 	mov.w	r3, #32
   25ec2:	f3ef 8511 	mrs	r5, BASEPRI
   25ec6:	f383 8812 	msr	BASEPRI_MAX, r3
   25eca:	f3bf 8f6f 	isb	sy
	return list->head == list;
   25ece:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25ed0:	42a0      	cmp	r0, r4
   25ed2:	d00d      	beq.n	25ef0 <z_unpend_first_thread+0x34>
		if (thread != NULL) {
   25ed4:	b134      	cbz	r4, 25ee4 <z_unpend_first_thread+0x28>
			unpend_thread_no_timeout(thread);
   25ed6:	4620      	mov	r0, r4
   25ed8:	f7ff ff76 	bl	25dc8 <unpend_thread_no_timeout>
   25edc:	f104 0018 	add.w	r0, r4, #24
   25ee0:	f000 f869 	bl	25fb6 <z_abort_timeout>
	__asm__ volatile(
   25ee4:	f385 8811 	msr	BASEPRI, r5
   25ee8:	f3bf 8f6f 	isb	sy
}
   25eec:	4620      	mov	r0, r4
   25eee:	bd38      	pop	{r3, r4, r5, pc}
   25ef0:	2400      	movs	r4, #0
   25ef2:	e7f7      	b.n	25ee4 <z_unpend_first_thread+0x28>

00025ef4 <z_unpend_thread>:
{
   25ef4:	4601      	mov	r1, r0
   25ef6:	b510      	push	{r4, lr}
	__asm__ volatile(
   25ef8:	f04f 0320 	mov.w	r3, #32
   25efc:	f3ef 8411 	mrs	r4, BASEPRI
   25f00:	f383 8812 	msr	BASEPRI_MAX, r3
   25f04:	f3bf 8f6f 	isb	sy
		if (thread->base.pended_on != NULL) {
   25f08:	6883      	ldr	r3, [r0, #8]
   25f0a:	b10b      	cbz	r3, 25f10 <z_unpend_thread+0x1c>
			unpend_thread_no_timeout(thread);
   25f0c:	f7ff ff5c 	bl	25dc8 <unpend_thread_no_timeout>
	__asm__ volatile(
   25f10:	f384 8811 	msr	BASEPRI, r4
   25f14:	f3bf 8f6f 	isb	sy
}
   25f18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   25f1c:	f101 0018 	add.w	r0, r1, #24
   25f20:	f000 b849 	b.w	25fb6 <z_abort_timeout>

00025f24 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   25f24:	4603      	mov	r3, r0
   25f26:	b920      	cbnz	r0, 25f32 <z_reschedule_irqlock+0xe>
   25f28:	f3ef 8205 	mrs	r2, IPSR
   25f2c:	b90a      	cbnz	r2, 25f32 <z_reschedule_irqlock+0xe>
	ret = arch_swap(key);
   25f2e:	f7f8 ba35 	b.w	1e39c <arch_swap>
   25f32:	f383 8811 	msr	BASEPRI, r3
   25f36:	f3bf 8f6f 	isb	sy
}
   25f3a:	4770      	bx	lr

00025f3c <z_reschedule_unlocked>:
	__asm__ volatile(
   25f3c:	f04f 0320 	mov.w	r3, #32
   25f40:	f3ef 8011 	mrs	r0, BASEPRI
   25f44:	f383 8812 	msr	BASEPRI_MAX, r3
   25f48:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   25f4c:	f7ff bfea 	b.w	25f24 <z_reschedule_irqlock>

00025f50 <z_unpend_all>:
{
   25f50:	b538      	push	{r3, r4, r5, lr}
   25f52:	4605      	mov	r5, r0
	int need_sched = 0;
   25f54:	2000      	movs	r0, #0
	return list->head == list;
   25f56:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25f58:	42a5      	cmp	r5, r4
   25f5a:	d000      	beq.n	25f5e <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   25f5c:	b904      	cbnz	r4, 25f60 <z_unpend_all+0x10>
}
   25f5e:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   25f60:	4620      	mov	r0, r4
   25f62:	f7ff ffc7 	bl	25ef4 <z_unpend_thread>
		z_ready_thread(thread);
   25f66:	4620      	mov	r0, r4
   25f68:	f7ff ff60 	bl	25e2c <z_ready_thread>
		need_sched = 1;
   25f6c:	2001      	movs	r0, #1
   25f6e:	e7f2      	b.n	25f56 <z_unpend_all+0x6>

00025f70 <z_sched_wake>:
{
   25f70:	b538      	push	{r3, r4, r5, lr}
   25f72:	f04f 0320 	mov.w	r3, #32
   25f76:	f3ef 8511 	mrs	r5, BASEPRI
   25f7a:	f383 8812 	msr	BASEPRI_MAX, r3
   25f7e:	f3bf 8f6f 	isb	sy
	return list->head == list;
   25f82:	6804      	ldr	r4, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   25f84:	42a0      	cmp	r0, r4
   25f86:	d012      	beq.n	25fae <z_sched_wake+0x3e>
		if (thread != NULL) {
   25f88:	b19c      	cbz	r4, 25fb2 <z_sched_wake+0x42>
   25f8a:	67a1      	str	r1, [r4, #120]	; 0x78
	thread->base.swap_data = data;
   25f8c:	6162      	str	r2, [r4, #20]
			unpend_thread_no_timeout(thread);
   25f8e:	4620      	mov	r0, r4
   25f90:	f7ff ff1a 	bl	25dc8 <unpend_thread_no_timeout>
   25f94:	f104 0018 	add.w	r0, r4, #24
   25f98:	f000 f80d 	bl	25fb6 <z_abort_timeout>
			ready_thread(thread);
   25f9c:	4620      	mov	r0, r4
   25f9e:	f7fd fd33 	bl	23a08 <ready_thread>
			ret = true;
   25fa2:	2001      	movs	r0, #1
	__asm__ volatile(
   25fa4:	f385 8811 	msr	BASEPRI, r5
   25fa8:	f3bf 8f6f 	isb	sy
}
   25fac:	bd38      	pop	{r3, r4, r5, pc}
	bool ret = false;
   25fae:	2000      	movs	r0, #0
   25fb0:	e7f8      	b.n	25fa4 <z_sched_wake+0x34>
   25fb2:	4620      	mov	r0, r4
   25fb4:	e7f6      	b.n	25fa4 <z_sched_wake+0x34>

00025fb6 <z_abort_timeout>:
{
   25fb6:	b510      	push	{r4, lr}
	__asm__ volatile(
   25fb8:	f04f 0220 	mov.w	r2, #32
   25fbc:	f3ef 8411 	mrs	r4, BASEPRI
   25fc0:	f382 8812 	msr	BASEPRI_MAX, r2
   25fc4:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   25fc8:	6803      	ldr	r3, [r0, #0]
   25fca:	b13b      	cbz	r3, 25fdc <z_abort_timeout+0x26>
			remove_timeout(to);
   25fcc:	f7fe f820 	bl	24010 <remove_timeout>
			ret = 0;
   25fd0:	2000      	movs	r0, #0
	__asm__ volatile(
   25fd2:	f384 8811 	msr	BASEPRI, r4
   25fd6:	f3bf 8f6f 	isb	sy
}
   25fda:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   25fdc:	f06f 0015 	mvn.w	r0, #21
   25fe0:	e7f7      	b.n	25fd2 <z_abort_timeout+0x1c>

00025fe2 <z_get_next_timeout_expiry>:
{
   25fe2:	b510      	push	{r4, lr}
	__asm__ volatile(
   25fe4:	f04f 0320 	mov.w	r3, #32
   25fe8:	f3ef 8411 	mrs	r4, BASEPRI
   25fec:	f383 8812 	msr	BASEPRI_MAX, r3
   25ff0:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   25ff4:	f7fd ffec 	bl	23fd0 <next_timeout>
	__asm__ volatile(
   25ff8:	f384 8811 	msr	BASEPRI, r4
   25ffc:	f3bf 8f6f 	isb	sy
}
   26000:	bd10      	pop	{r4, pc}

00026002 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
   26002:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
   26004:	f7fe f900 	bl	24208 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   26008:	bd08      	pop	{r3, pc}

0002600a <z_impl_k_uptime_ticks>:

int64_t z_impl_k_uptime_ticks(void)
{
	return sys_clock_tick_get();
   2600a:	f7fe b8fd 	b.w	24208 <sys_clock_tick_get>

0002600e <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
   2600e:	b108      	cbz	r0, 26014 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
   26010:	f7f6 bf5e 	b.w	1ced0 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
   26014:	4770      	bx	lr

00026016 <sys_clock_timeout_end_calc>:
 */
uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)
{
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   26016:	f1b1 3fff 	cmp.w	r1, #4294967295	; 0xffffffff
   2601a:	bf08      	it	eq
   2601c:	f1b0 3fff 	cmpeq.w	r0, #4294967295	; 0xffffffff
{
   26020:	b538      	push	{r3, r4, r5, lr}
   26022:	460c      	mov	r4, r1
   26024:	4605      	mov	r5, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   26026:	d014      	beq.n	26052 <sys_clock_timeout_end_calc+0x3c>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   26028:	4308      	orrs	r0, r1
   2602a:	d103      	bne.n	26034 <sys_clock_timeout_end_calc+0x1e>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
			return Z_TICK_ABS(dt);
		}
		return sys_clock_tick_get() + MAX(1, dt);
	}
}
   2602c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return sys_clock_tick_get();
   26030:	f7fe b8ea 	b.w	24208 <sys_clock_tick_get>
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   26034:	f06f 0001 	mvn.w	r0, #1
   26038:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2603c:	1b40      	subs	r0, r0, r5
   2603e:	eb63 0101 	sbc.w	r1, r3, r1
   26042:	2900      	cmp	r1, #0
   26044:	da04      	bge.n	26050 <sys_clock_timeout_end_calc+0x3a>
		return sys_clock_tick_get() + MAX(1, dt);
   26046:	f7fe f8df 	bl	24208 <sys_clock_tick_get>
   2604a:	1940      	adds	r0, r0, r5
   2604c:	eb41 0104 	adc.w	r1, r1, r4
}
   26050:	bd38      	pop	{r3, r4, r5, pc}
		return UINT64_MAX;
   26052:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26056:	4601      	mov	r1, r0
   26058:	e7fa      	b.n	26050 <sys_clock_timeout_end_calc+0x3a>

0002605a <k_free>:
	if (ptr != NULL) {
   2605a:	b120      	cbz	r0, 26066 <k_free+0xc>
		k_heap_free(*heap_ref, ptr);
   2605c:	1f01      	subs	r1, r0, #4
   2605e:	f850 0c04 	ldr.w	r0, [r0, #-4]
   26062:	f000 b856 	b.w	26112 <k_heap_free>
}
   26066:	4770      	bx	lr

00026068 <k_heap_init>:
{
   26068:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   2606a:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   2606e:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   26072:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   26074:	f7fe bb9b 	b.w	247ae <sys_heap_init>

00026078 <k_heap_aligned_alloc>:
SYS_INIT_NAMED(statics_init_post, statics_init, POST_KERNEL, 0);
#endif /* CONFIG_DEMAND_PAGING && !CONFIG_LINKER_GENERIC_SECTIONS_PRESENT_AT_BOOT */

void *k_heap_aligned_alloc(struct k_heap *h, size_t align, size_t bytes,
			k_timeout_t timeout)
{
   26078:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2607c:	b085      	sub	sp, #20
   2607e:	e9dd a40e 	ldrd	sl, r4, [sp, #56]	; 0x38
   26082:	4607      	mov	r7, r0
   26084:	4688      	mov	r8, r1
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   26086:	4650      	mov	r0, sl
   26088:	4621      	mov	r1, r4
{
   2608a:	4691      	mov	r9, r2
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   2608c:	f7ff ffc3 	bl	26016 <sys_clock_timeout_end_calc>
	void *ret = NULL;

	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
   26090:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
   26094:	bf08      	it	eq
   26096:	f1ba 3fff 	cmpeq.w	sl, #4294967295	; 0xffffffff
	int64_t now, end = sys_clock_timeout_end_calc(timeout);
   2609a:	4605      	mov	r5, r0
   2609c:	460e      	mov	r6, r1
	end = K_TIMEOUT_EQ(timeout, K_FOREVER) ? INT64_MAX : end;
   2609e:	bf04      	itt	eq
   260a0:	f04f 35ff 	moveq.w	r5, #4294967295	; 0xffffffff
   260a4:	f06f 4600 	mvneq.w	r6, #2147483648	; 0x80000000

	k_spinlock_key_t key = k_spin_lock(&h->lock);
   260a8:	f107 0a14 	add.w	sl, r7, #20
	__asm__ volatile(
   260ac:	f04f 0320 	mov.w	r3, #32
   260b0:	f3ef 8411 	mrs	r4, BASEPRI
   260b4:	f383 8812 	msr	BASEPRI_MAX, r3
   260b8:	f3bf 8f6f 	isb	sy
			/**
			 * @todo	Trace attempt to avoid empty trace segments
			 */
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   260bc:	f107 0b0c 	add.w	fp, r7, #12
		ret = sys_heap_aligned_alloc(&h->heap, align, bytes);
   260c0:	464a      	mov	r2, r9
   260c2:	4641      	mov	r1, r8
   260c4:	4638      	mov	r0, r7
   260c6:	f7fe fb0b 	bl	246e0 <sys_heap_aligned_alloc>
   260ca:	9003      	str	r0, [sp, #12]
		now = sys_clock_tick_get();
   260cc:	f7fe f89c 	bl	24208 <sys_clock_tick_get>
		if (!IS_ENABLED(CONFIG_MULTITHREADING) ||
   260d0:	9b03      	ldr	r3, [sp, #12]
   260d2:	b13b      	cbz	r3, 260e4 <k_heap_aligned_alloc+0x6c>
	__asm__ volatile(
   260d4:	f384 8811 	msr	BASEPRI, r4
   260d8:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_heap, aligned_alloc, h, timeout, ret);

	k_spin_unlock(&h->lock, key);
	return ret;
}
   260dc:	4618      	mov	r0, r3
   260de:	b005      	add	sp, #20
   260e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    (ret != NULL) || ((end - now) <= 0)) {
   260e4:	1a28      	subs	r0, r5, r0
   260e6:	eb66 0101 	sbc.w	r1, r6, r1
   260ea:	2801      	cmp	r0, #1
   260ec:	f171 0200 	sbcs.w	r2, r1, #0
   260f0:	dbf0      	blt.n	260d4 <k_heap_aligned_alloc+0x5c>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   260f2:	e9cd 0100 	strd	r0, r1, [sp]
   260f6:	465a      	mov	r2, fp
   260f8:	4621      	mov	r1, r4
   260fa:	4650      	mov	r0, sl
   260fc:	f7fd fd18 	bl	23b30 <z_pend_curr>
	__asm__ volatile(
   26100:	f04f 0320 	mov.w	r3, #32
   26104:	f3ef 8411 	mrs	r4, BASEPRI
   26108:	f383 8812 	msr	BASEPRI_MAX, r3
   2610c:	f3bf 8f6f 	isb	sy
	return k;
   26110:	e7d6      	b.n	260c0 <k_heap_aligned_alloc+0x48>

00026112 <k_heap_free>:

	return ret;
}

void k_heap_free(struct k_heap *h, void *mem)
{
   26112:	b538      	push	{r3, r4, r5, lr}
   26114:	4604      	mov	r4, r0
   26116:	f04f 0320 	mov.w	r3, #32
   2611a:	f3ef 8511 	mrs	r5, BASEPRI
   2611e:	f383 8812 	msr	BASEPRI_MAX, r3
   26122:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   26126:	f7fe faa3 	bl	24670 <sys_heap_free>

	SYS_PORT_TRACING_OBJ_FUNC(k_heap, free, h);
	if (IS_ENABLED(CONFIG_MULTITHREADING) && z_unpend_all(&h->wait_q) != 0) {
   2612a:	f104 000c 	add.w	r0, r4, #12
   2612e:	f7ff ff0f 	bl	25f50 <z_unpend_all>
   26132:	b130      	cbz	r0, 26142 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   26134:	4629      	mov	r1, r5
   26136:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   2613a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   2613e:	f7fd bd5b 	b.w	23bf8 <z_reschedule>
	__asm__ volatile(
   26142:	f385 8811 	msr	BASEPRI, r5
   26146:	f3bf 8f6f 	isb	sy
}
   2614a:	bd38      	pop	{r3, r4, r5, pc}

0002614c <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
   2614c:	4770      	bx	lr
	...
